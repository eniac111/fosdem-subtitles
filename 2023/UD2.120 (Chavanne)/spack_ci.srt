1
0:00:00.000 --> 0:00:11.960
So, the next speaker is Todd Gamblin, and as I think a lot of people here know, I'm

2
0:00:11.960 --> 0:00:17.400
very much involved in the EasyBuild project, which was actually the excuse we used to start

3
0:00:17.400 --> 0:00:21.920
the HPC Dev Room, but we're also very open to other projects which are very similar to

4
0:00:21.920 --> 0:00:24.000
what we work on every day.

5
0:00:24.000 --> 0:00:28.560
So, in some sense, back as our mortal enemy, but we do allow them to give talks in the

6
0:00:28.560 --> 0:00:30.440
Dev Room as well.

7
0:00:30.440 --> 0:00:31.440
Yeah, thanks.

8
0:00:31.440 --> 0:00:34.440
Okay, who's heard of SPAC?

9
0:00:34.440 --> 0:00:36.720
Okay, cool.

10
0:00:36.720 --> 0:00:37.720
People have heard of SPAC.

11
0:00:37.720 --> 0:00:42.520
We don't need to do too many introductions for this talk.

12
0:00:42.520 --> 0:00:46.520
This is less of a talk about SPAC and more of a talk about the CI that we've started

13
0:00:46.520 --> 0:00:49.480
doing since introducing binary packages in SPAC.

14
0:00:49.480 --> 0:00:54.080
I don't think I need to tell people why they need SPAC for HPC.

15
0:00:54.080 --> 0:00:58.160
I think lots of folks have talked about that already today.

16
0:00:58.160 --> 0:01:01.400
Someone said that, so I was supposed to talk a little bit about deployment.

17
0:01:01.400 --> 0:01:04.560
To deploy SPAC, if you want to try it on a new system, just clone it from the Git repo

18
0:01:04.560 --> 0:01:05.560
and run it.

19
0:01:05.560 --> 0:01:09.440
Like, all you need is Python and a few other tools on your system to do that.

20
0:01:09.440 --> 0:01:12.560
So you can just run it straight out of the repo if you want to play around with it and

21
0:01:12.560 --> 0:01:15.320
build stuff right there.

22
0:01:15.320 --> 0:01:20.240
SPAC is designed to install lots of different versions of things, like others have said.

23
0:01:20.240 --> 0:01:23.400
This is sort of a snapshot of the syntax, some of the things that you can add.

24
0:01:23.400 --> 0:01:25.720
You can install HDF5 at lots of different versions.

25
0:01:25.720 --> 0:01:27.200
You can inject flags in the build.

26
0:01:27.200 --> 0:01:28.680
You can pick a compiler.

27
0:01:28.680 --> 0:01:32.160
You can do all that on the fly and it will build you a custom version of that software

28
0:01:32.160 --> 0:01:33.840
and let you use it.

29
0:01:33.840 --> 0:01:36.920
You can get it into your environment a lot of different ways.

30
0:01:36.920 --> 0:01:40.840
What we're trying to do with SPAC is provide the ease of use of mainstream tools that people

31
0:01:40.840 --> 0:01:45.760
are used to, but with the flexibility for HPC, whether we fully accomplish that is a

32
0:01:45.760 --> 0:01:49.480
whole other question because there's a lot of complexity still in this because it is

33
0:01:49.480 --> 0:01:53.040
intended for HPC.

34
0:01:53.040 --> 0:01:56.320
Originally it was designed to build from source because it was trying to automate people's

35
0:01:56.320 --> 0:02:00.800
common workflow.

36
0:02:00.800 --> 0:02:05.280
Actually the Fermi lab and CERN folks added a first implementation of binary packaging

37
0:02:05.280 --> 0:02:11.880
to SPAC and I talked about some of that in a past FOSM.

38
0:02:11.880 --> 0:02:16.400
Since then we've actually started relying on the build caches a lot more.

39
0:02:16.400 --> 0:02:21.400
SPAC has relocatable build caches that you can build in either a build farm or you can

40
0:02:21.400 --> 0:02:25.080
make one right out of your SPAC build.

41
0:02:25.080 --> 0:02:29.000
You may not want to do one yourself that way because then you won't have padding on the

42
0:02:29.000 --> 0:02:33.360
path and like you said, patch off relocation is dangerous.

43
0:02:33.360 --> 0:02:39.160
Generally if we build binaries for wide use we pad the paths pretty extensively so that

44
0:02:39.160 --> 0:02:43.280
we can just poke values in instead of having to do all the patch off stuff.

45
0:02:43.280 --> 0:02:48.360
But anyway you can install SPAC binaries from a build cache in S3 to your home directory.

46
0:02:48.360 --> 0:02:50.960
You can make a common build cache in the file system.

47
0:02:50.960 --> 0:02:57.120
You can use a build cache to accelerate SCI and it's very handy because it eliminates

48
0:02:57.120 --> 0:03:03.320
the need to rebuild lots of stuff all the time.

49
0:03:03.320 --> 0:03:09.560
So if you look at the SPAC project as a whole, I think people know most of this.

50
0:03:09.560 --> 0:03:13.400
There's a community, we maintain the core tool, there's package recipes but the part

51
0:03:13.400 --> 0:03:18.720
that you don't see is all the infrastructure behind the scenes that keeps the thing working.

52
0:03:18.720 --> 0:03:24.720
And originally we did not have CI for SPAC or at least not for the package builds.

53
0:03:24.720 --> 0:03:29.160
We've always had CI for the tool itself and we've done unit tests and checked a bunch

54
0:03:29.160 --> 0:03:31.680
of things about concretization and so on.

55
0:03:31.680 --> 0:03:35.440
But we weren't building all the packages and we're still not building all the packages

56
0:03:35.440 --> 0:03:38.000
but we're building quite a few of them.

57
0:03:38.000 --> 0:03:41.620
With the infrastructure that we have, we have a system where essentially you can build lots

58
0:03:41.620 --> 0:03:43.200
of software stacks on top of SPAC.

59
0:03:43.200 --> 0:03:46.080
You can write a YAML description of what you want in the software stack.

60
0:03:46.080 --> 0:03:51.280
You can have E4S, AWS, Sysstack, Livermore, Mathstack.

61
0:03:51.280 --> 0:03:56.000
There's a Viz SDK within the Exascale Computing Project and really every application is its

62
0:03:56.000 --> 0:03:57.520
own software stack these days.

63
0:03:57.520 --> 0:04:03.200
So our production codes have upwards of 100 dependencies that they are using for multiphysics

64
0:04:03.200 --> 0:04:08.040
and so each of them is essentially maintaining their own little private software distribution

65
0:04:08.040 --> 0:04:10.560
in some sense or another.

66
0:04:10.560 --> 0:04:15.160
And so we'd like to be able to build all of this stuff and ensure that these things keep

67
0:04:15.160 --> 0:04:16.640
working.

68
0:04:16.640 --> 0:04:21.120
That's hard to do given that the GitHub for SPAC is a pretty busy place.

69
0:04:21.120 --> 0:04:24.200
There's almost 7,000 packages in SPAC now.

70
0:04:24.200 --> 0:04:29.440
Over the whole life of the project there's been over 1,100 contributors and you can see

71
0:04:29.440 --> 0:04:36.640
down there this month there's been 122 people active on the GitHub repo and that's like

72
0:04:36.640 --> 0:04:42.520
over 400 commits and 300 to 500 PRs per month that we have to merge.

73
0:04:42.520 --> 0:04:47.400
And so ensuring that everything stays working with that many changes is pretty hard and

74
0:04:47.400 --> 0:04:52.160
you'd be sort of nuts to do it without CI.

75
0:04:52.160 --> 0:04:56.400
One of the problems that we have though is that CI for HPC is hard.

76
0:04:56.400 --> 0:05:02.000
If you want to test in the HPC environments that you actually care about you can't just

77
0:05:02.000 --> 0:05:06.560
take an HPC node and hook it up to random pull requests on GitHub.

78
0:05:06.560 --> 0:05:09.880
They don't like that when the machine might have export controlled software on it because

79
0:05:09.880 --> 0:05:16.120
you're effectively allowing someone, some random person in a pull request to run software

80
0:05:16.120 --> 0:05:18.000
on your HPC machine.

81
0:05:18.000 --> 0:05:20.520
And so this is the model for SPAC.

82
0:05:20.520 --> 0:05:23.840
We have a bunch of external contributors on GitHub constantly contributing to this develop

83
0:05:23.840 --> 0:05:26.040
branch.

84
0:05:26.040 --> 0:05:31.160
We have sort of stable release branches where we freeze the packages to reduce the churn

85
0:05:31.160 --> 0:05:32.520
that some people rely on.

86
0:05:32.520 --> 0:05:36.920
Most users are actually on develop at least according to our surveys which is a little

87
0:05:36.920 --> 0:05:40.560
surprising to me but that's where we are.

88
0:05:40.560 --> 0:05:45.160
And then off of the release branches there is a software distribution within the XSEL

89
0:05:45.160 --> 0:05:48.920
project in the US called E4S and there's a few others that sort of freeze a commit from

90
0:05:48.920 --> 0:05:52.460
SPAC and do their own integration after that.

91
0:05:52.460 --> 0:05:56.120
And that's really supposed to be the deployment mechanism for the 100 or so packages and it's

92
0:05:56.120 --> 0:06:00.400
like 600 with dependencies that are in ECP.

93
0:06:00.400 --> 0:06:06.160
And what happens with this is that that gets deployed to the facilities and the E4S team

94
0:06:06.160 --> 0:06:12.600
goes and ensures that everything works but we're not able to run on these systems on

95
0:06:12.600 --> 0:06:15.200
pull requests in CI and it's very frustrating.

96
0:06:15.200 --> 0:06:19.080
And so essentially this is a bunch of downstream work that we would really like to get rid

97
0:06:19.080 --> 0:06:20.080
of.

98
0:06:20.080 --> 0:06:23.840
Moreover, like the applications are also doing downstream integration.

99
0:06:23.840 --> 0:06:26.680
They may have their own CI which may be good.

100
0:06:26.680 --> 0:06:28.240
They're essentially pulling from all these places.

101
0:06:28.240 --> 0:06:30.000
They may pull a facility deployment.

102
0:06:30.000 --> 0:06:31.040
They may pull from develop.

103
0:06:31.040 --> 0:06:32.520
They may pull from a release.

104
0:06:32.520 --> 0:06:35.220
They're essentially integrating from all these places and so there's a lot of downstream

105
0:06:35.220 --> 0:06:36.440
importing there.

106
0:06:36.440 --> 0:06:41.200
What we would ultimately like to do in SPAC is take all of that work that's going on downstream

107
0:06:41.200 --> 0:06:46.720
and move it upstream so that we're actually doing CI testing on develop along with everything

108
0:06:46.720 --> 0:06:47.720
else.

109
0:06:47.720 --> 0:06:49.880
And so this is progress towards that but we're not doing that yet.

110
0:06:49.880 --> 0:06:55.240
Essentially the main obstacle for us to build stuff that looks like the HPC environments

111
0:06:55.240 --> 0:07:01.400
right now is a licensing issue which is that we can't take the create PE container and

112
0:07:01.400 --> 0:07:06.280
run it in the cloud because that's just not something you can do with HPE's license.

113
0:07:06.280 --> 0:07:09.920
We are pushing them real hard on this and trying to get an exception for us to build

114
0:07:09.920 --> 0:07:15.600
things, in which case we would be able to do work upstream and ideally deploy it the

115
0:07:15.600 --> 0:07:19.960
facilities from the binary cache which I think would be way more stable and less error prone

116
0:07:19.960 --> 0:07:23.460
than what we do right now.

117
0:07:23.460 --> 0:07:29.120
And so we set out to make this CI system to enable this with a bunch of different goals.

118
0:07:29.120 --> 0:07:32.600
One of the goals is that we want to be sustainable.

119
0:07:32.600 --> 0:07:36.600
We don't want to change the maintainer workflow and we already have a few enough maintainers

120
0:07:36.600 --> 0:07:39.880
for the amount of work that there is.

121
0:07:39.880 --> 0:07:41.380
We don't want to change what they have to do.

122
0:07:41.380 --> 0:07:46.600
They're used to going out on GitHub and approving PRs, getting them merged, working with them,

123
0:07:46.600 --> 0:07:49.200
checking if they build and so on.

124
0:07:49.200 --> 0:07:51.000
And we don't want them to have to do something different.

125
0:07:51.000 --> 0:07:55.040
So we don't want them to both have to maintain PRs and think about how the integration branch

126
0:07:55.040 --> 0:07:57.600
is doing like some distros do.

127
0:07:57.600 --> 0:07:59.360
We'd like that to just happen.

128
0:07:59.360 --> 0:08:03.400
And so in that vein we want a rolling release where on develop we're constantly building

129
0:08:03.400 --> 0:08:09.680
binaries for the develop branch and that we basically snapshot and develop for every release

130
0:08:09.680 --> 0:08:11.480
that we do and say okay, it's stable.

131
0:08:11.480 --> 0:08:12.480
Everything built.

132
0:08:12.480 --> 0:08:13.480
We are ready to do the release.

133
0:08:13.480 --> 0:08:17.560
We'll just cut one and then we will backport bug fixes to this back tool on that release

134
0:08:17.560 --> 0:08:19.520
if we need to.

135
0:08:19.520 --> 0:08:21.760
We want it to eventually support all 6900 packages.

136
0:08:21.760 --> 0:08:23.640
It's not something we're doing now.

137
0:08:23.640 --> 0:08:27.880
And we want source builds to still work with these binaries effectively once it's done.

138
0:08:27.880 --> 0:08:31.680
So we want to make sure that the recipes are still versatile enough to do all those combinations

139
0:08:31.680 --> 0:08:34.360
of builds that I showed on the first slide.

140
0:08:34.360 --> 0:08:38.840
And then finally, and this is a big one, we wanted to ensure that the binaries that we

141
0:08:38.840 --> 0:08:41.320
have in SPAC are just as trustworthy as the sources.

142
0:08:41.320 --> 0:08:45.840
So if you feel like you can trust our maintainers and rely on the sources that are in SPAC packages

143
0:08:45.840 --> 0:08:49.520
with checksums that you feel just as comfortable with the binaries that we're putting in the

144
0:08:49.520 --> 0:08:52.540
build cache for you.

145
0:08:52.540 --> 0:08:57.560
And so if you think about how this works, if you look at traditional package managers

146
0:08:57.560 --> 0:09:02.800
like say APT or YUM, you have a recipe per package configuration that's getting thrown

147
0:09:02.800 --> 0:09:06.240
into a build farm for each of those package configurations.

148
0:09:06.240 --> 0:09:10.600
Think like easy configs if EasyBuild had binaries.

149
0:09:10.600 --> 0:09:15.000
Throw that into a build farm and then you get these portable unoptimized binaries for

150
0:09:15.000 --> 0:09:19.120
theoretical binary having EasyBuild where there's one of those per package configuration

151
0:09:19.120 --> 0:09:21.240
or per spec file or whatever.

152
0:09:21.240 --> 0:09:25.680
And then, and this is more like an APT or whatever, you're managing one software stack

153
0:09:25.680 --> 0:09:29.640
that's meant to be upgraded over time and there's a consistent ABI across the distribution

154
0:09:29.640 --> 0:09:32.280
so that you can sort of swap one package in for another.

155
0:09:32.280 --> 0:09:35.680
And the solver in those distributions really operates on the binaries.

156
0:09:35.680 --> 0:09:40.880
In SPAC you have parameterized package recipes that we are designing to be portable and we

157
0:09:40.880 --> 0:09:43.880
want the maintainers to work on them together so that they remain portable so you can use

158
0:09:43.880 --> 0:09:45.600
them in different environments.

159
0:09:45.600 --> 0:09:49.280
Throw those into the build farm and effectively test the parameterized package recipe in lots

160
0:09:49.280 --> 0:09:52.880
of different configurations and spit out different stacks.

161
0:09:52.880 --> 0:09:56.960
Lots of different stacks optimized for different environments from the same portable recipes

162
0:09:56.960 --> 0:10:00.440
for different systems, OSs, compilers and MPIs and so on.

163
0:10:00.440 --> 0:10:03.960
And then we also want at any time for you to be able to choose to build something from

164
0:10:03.960 --> 0:10:09.720
source along with that if you want to customize some aspect of the pipeline.

165
0:10:09.720 --> 0:10:13.040
So to enable that we came up with this architecture.

166
0:10:13.040 --> 0:10:20.360
We have a bunch of AWS resources because AWS has been nice enough to donate some cycles

167
0:10:20.360 --> 0:10:22.080
to the project.

168
0:10:22.080 --> 0:10:25.800
They are interested in using SPAC in their parallel cluster product and so that's the

169
0:10:25.800 --> 0:10:28.360
motivation for them is they want binaries ready to go.

170
0:10:28.360 --> 0:10:31.700
If someone spins up a cluster in the cloud they don't want to spin up a cluster and have

171
0:10:31.700 --> 0:10:35.920
it sit there and build software for hours and then run after having charged a bunch

172
0:10:35.920 --> 0:10:39.760
of money which is nice to them right because they would make a lot of money.

173
0:10:39.760 --> 0:10:41.840
But then no one would use their service.

174
0:10:41.840 --> 0:10:44.360
So they want binaries.

175
0:10:44.360 --> 0:10:49.440
And in there we use S3 and CloudFront to distribute the binaries around the world.

176
0:10:49.440 --> 0:10:51.560
And EC2 is really the main build resource.

177
0:10:51.560 --> 0:10:55.160
RDS is in there but it's not that important.

178
0:10:55.160 --> 0:10:58.960
We've got a Kubernetes cluster in there that we have auto scaling runners in and so we're

179
0:10:58.960 --> 0:11:03.520
building mostly in containers inside of kube and there's a GitLab instance in there too.

180
0:11:03.520 --> 0:11:06.420
So we have a high availability GitLab instance.

181
0:11:06.420 --> 0:11:10.600
We chose GitLab because the HPC centers actually have GitLab CI themselves.

182
0:11:10.600 --> 0:11:16.080
And so the same CI logic that you can run or that we run in the cloud, you could take

183
0:11:16.080 --> 0:11:20.240
that and run it internally and have these pipelines generated for you at your own site

184
0:11:20.240 --> 0:11:21.240
too.

185
0:11:21.240 --> 0:11:25.600
You could slap another back end on this and have it generate buildgrass for some other

186
0:11:25.600 --> 0:11:28.560
system but that's the one that we're using.

187
0:11:28.560 --> 0:11:32.160
We're using runner pools with something called carpenter to basically get just in time instances

188
0:11:32.160 --> 0:11:35.300
and allocate the containers on them efficiently.

189
0:11:35.300 --> 0:11:39.440
And then we have some bare metal runners at the University of Oregon with some fairly

190
0:11:39.440 --> 0:11:40.920
exotic architectures on them.

191
0:11:40.920 --> 0:11:47.880
So if we need to build or if we need to specifically run on something that has an AMD GPU or A64

192
0:11:47.880 --> 0:11:50.000
effects and so on, we can do that.

193
0:11:50.000 --> 0:11:52.600
And we could add more runners to this eventually.

194
0:11:52.600 --> 0:11:55.280
And there's a bot that sort of coordinates all this work.

195
0:11:55.280 --> 0:11:56.280
So it's a lot of stuff.

196
0:11:56.280 --> 0:12:03.960
It's actually, every time I look at this I am amazed at how complicated CI is and how

197
0:12:03.960 --> 0:12:08.760
it's one of those things that seems like it should just work but there is a lot to maintaining

198
0:12:08.760 --> 0:12:11.400
a reliable service for doing this many builds.

199
0:12:11.400 --> 0:12:15.000
And I suspect other distro maintainers have realized that too and I'm just late to the

200
0:12:15.000 --> 0:12:17.600
game.

201
0:12:17.600 --> 0:12:23.040
The way that contributing a stack in SPAC works is we have this directory in the repo

202
0:12:23.040 --> 0:12:25.920
that has all of the cloud pipelines in it.

203
0:12:25.920 --> 0:12:30.440
And so you can see some of them are for AWS, some of them are different variations on E4S.

204
0:12:30.440 --> 0:12:35.160
Each of those directories contains just a SPAC diagonal that defines the stuff that

205
0:12:35.160 --> 0:12:36.520
is to be built.

206
0:12:36.520 --> 0:12:41.240
And so if you look inside of there, it's basically just a list of packages.

207
0:12:41.240 --> 0:12:48.400
So here's the ML CUDA one that has the build of I think PyTorch and TensorFlow, Keras,

208
0:12:48.400 --> 0:12:51.720
Jax and Friends for CUDA.

209
0:12:51.720 --> 0:12:55.640
It's just a list of packages plus there's a target up there, a target setting for all

210
0:12:55.640 --> 0:12:56.640
the packages.

211
0:12:56.640 --> 0:12:59.160
You could have a matrix of targets if you wanted.

212
0:12:59.160 --> 0:13:03.400
And then there's disable Rockum and enable CUDA on everything except for LLVM because

213
0:13:03.400 --> 0:13:05.040
there's that bug that's linked there.

214
0:13:05.040 --> 0:13:08.840
And I'm not entirely sure about the specifics of that.

215
0:13:08.840 --> 0:13:13.840
But this is the configuration part is up here and it's fairly minimal for the stack.

216
0:13:13.840 --> 0:13:17.720
There's currently if you look at these a bunch of other boilerplate stuff for things like

217
0:13:17.720 --> 0:13:18.720
mapping runners.

218
0:13:18.720 --> 0:13:19.880
I'll get to that in a minute.

219
0:13:19.880 --> 0:13:23.880
But this is, there's a PR that's going to go in where this is basically all that's going

220
0:13:23.880 --> 0:13:25.240
to be in your stack.

221
0:13:25.240 --> 0:13:27.880
And you might include some stuff from elsewhere.

222
0:13:27.880 --> 0:13:30.480
But this is essentially a stack definition.

223
0:13:30.480 --> 0:13:38.080
And we take that and this makes it very easy to change low level parameters in the stack.

224
0:13:38.080 --> 0:13:45.200
So we had a working E4S stack with something like six or seven hundred packages building.

225
0:13:45.200 --> 0:13:50.400
We wanted to get better testing for one API because that's what they're going to use on

226
0:13:50.400 --> 0:13:51.440
Aurora.

227
0:13:51.440 --> 0:13:53.920
And so we wanted to use the one API compilers.

228
0:13:53.920 --> 0:13:57.160
We added some compiler config and we said everything should use one API.

229
0:13:57.160 --> 0:14:02.440
And then at the very least we got a pipeline generated with some errors for one API.

230
0:14:02.440 --> 0:14:06.940
And it made it really easy to iterate on this with Intel where we would basically say, okay,

231
0:14:06.940 --> 0:14:07.940
this package is broken.

232
0:14:07.940 --> 0:14:08.940
Here's the bug.

233
0:14:08.940 --> 0:14:09.940
Go fix it.

234
0:14:09.940 --> 0:14:12.360
And then they'd come back with another version of one API and we would iterate with them

235
0:14:12.360 --> 0:14:13.560
until it was done.

236
0:14:13.560 --> 0:14:20.000
I think this is probably more open source than anyone has recently run through a vendor

237
0:14:20.000 --> 0:14:21.000
compiler.

238
0:14:21.000 --> 0:14:25.200
And so just being able to do this I think is big because it might make those compilers

239
0:14:25.200 --> 0:14:30.240
like actually viable things to use for real programs that have lots of dependencies.

240
0:14:30.240 --> 0:14:33.720
At the moment you have to sort of piece your program together and build parts of it with

241
0:14:33.720 --> 0:14:38.080
like, I don't know, PGI was the infamous one that broke on everything.

242
0:14:38.080 --> 0:14:42.340
But I think this could help with the vendor compilers being a viable second option.

243
0:14:42.340 --> 0:14:46.440
And maybe instill some competition among the vendors if they can do this frequently and

244
0:14:46.440 --> 0:14:49.520
show benchmarks against these packages.

245
0:14:49.520 --> 0:14:51.200
So this was I think a win.

246
0:14:51.200 --> 0:14:54.100
Yeah, thank you.

247
0:14:54.100 --> 0:14:56.440
Each of those stacks gets concretized.

248
0:14:56.440 --> 0:15:00.600
And so people know in SPAC you take that abstract description of the things that you want to

249
0:15:00.600 --> 0:15:02.780
install which is basically the requirements.

250
0:15:02.780 --> 0:15:05.160
You run it through our dependency solver.

251
0:15:05.160 --> 0:15:08.600
You get essentially a concrete description of what you're going to build which is the

252
0:15:08.600 --> 0:15:10.660
whole concrete graph.

253
0:15:10.660 --> 0:15:16.360
And then we generate a GitLab CI YAML from that that describes the jobs that need to

254
0:15:16.360 --> 0:15:18.380
be run to build the whole thing.

255
0:15:18.380 --> 0:15:20.520
This is the part that we could swap out for something else.

256
0:15:20.520 --> 0:15:22.440
So like we've looked at like Tekton pipelines.

257
0:15:22.440 --> 0:15:24.640
We've looked at other options.

258
0:15:24.640 --> 0:15:26.560
I don't know, some people use Jenkins.

259
0:15:26.560 --> 0:15:31.280
There's all sorts of things out there that you could potentially map the jobs to.

260
0:15:31.280 --> 0:15:34.120
And I think we could generate a description like that from the representation that we

261
0:15:34.120 --> 0:15:36.120
have.

262
0:15:36.120 --> 0:15:44.560
For mapping those jobs, we have a section in the CI YAML right now or in the SPAC.YAML

263
0:15:44.560 --> 0:15:49.360
that basically tells you how to generate the GitLab piece.

264
0:15:49.360 --> 0:15:52.720
And so you see this mapping section here.

265
0:15:52.720 --> 0:15:54.680
There's a match section.

266
0:15:54.680 --> 0:15:58.440
If you match any of those specs there and the first three are just a couple, just some

267
0:15:58.440 --> 0:16:03.400
names, then we have special tags that we put on the runners that say, you know, get me

268
0:16:03.400 --> 0:16:04.880
a special resource for these things.

269
0:16:04.880 --> 0:16:10.440
And so that first block is basically so that I don't run out of memory building LLVM, TensorFlow

270
0:16:10.440 --> 0:16:11.840
or Torch.

271
0:16:11.840 --> 0:16:15.720
Get me something with a lot of memory and a big CPU to build that one.

272
0:16:15.720 --> 0:16:17.440
It has to run on a big instance.

273
0:16:17.440 --> 0:16:21.280
Because those are sort of the long poles in our tent in CI.

274
0:16:21.280 --> 0:16:25.440
And then down at the bottom, there's just a mapping from everything else gets something

275
0:16:25.440 --> 0:16:28.880
that supports x86, x64, v4.

276
0:16:28.880 --> 0:16:33.300
And it's a little smaller than the other one for builds.

277
0:16:33.300 --> 0:16:37.520
And you could do this for lots of different architecture combinations and so on.

278
0:16:37.520 --> 0:16:42.160
And you can ask for images and things like that.

279
0:16:42.160 --> 0:16:47.880
I said that we needed to ensure that the source is as reliable, that the binaries are as reliable

280
0:16:47.880 --> 0:16:49.220
as the source.

281
0:16:49.220 --> 0:16:52.840
And so we sat down and we asked ourselves, you know, what is it that people trust about

282
0:16:52.840 --> 0:16:54.200
the SPAC project?

283
0:16:54.200 --> 0:16:55.980
And it's really the maintainers.

284
0:16:55.980 --> 0:17:00.300
If you use any open source project, you're trusting the maintainers or you really shouldn't

285
0:17:00.300 --> 0:17:01.840
be using that open source project.

286
0:17:01.840 --> 0:17:04.960
And so I don't see where we can do better than that.

287
0:17:04.960 --> 0:17:09.360
And so what we've done is we've said, you know, the place where bad things could get

288
0:17:09.360 --> 0:17:14.000
into a build from, at least from SPAC is in the build environment.

289
0:17:14.000 --> 0:17:18.880
And so if you give people control of the PR environment where they're submitting things

290
0:17:18.880 --> 0:17:23.400
there, they could push a commit that puts something in a binary that gets cached.

291
0:17:23.400 --> 0:17:28.220
And then, you know, somehow, I don't know, they could do bad things and end up caching

292
0:17:28.220 --> 0:17:29.220
a binary.

293
0:17:29.220 --> 0:17:32.920
And if we took that binary and stuck it out there for anyone to use, you know, there could

294
0:17:32.920 --> 0:17:34.040
be bad things in it.

295
0:17:34.040 --> 0:17:41.080
And so we have this separate set of untrusted S3 buckets where we only build PR things.

296
0:17:41.080 --> 0:17:43.520
Each PR gets its own build cache.

297
0:17:43.520 --> 0:17:46.120
That enables the maintainers to see if things work.

298
0:17:46.120 --> 0:17:48.320
And then they come along and review the code.

299
0:17:48.320 --> 0:17:52.200
And then once things are actually merged to develop, we don't trust any of the binaries

300
0:17:52.200 --> 0:17:53.560
that we built on PRs.

301
0:17:53.560 --> 0:17:58.320
And we go and rebuild everything and sign specifically from the, you know, the sources

302
0:17:58.320 --> 0:17:59.320
that got approved.

303
0:17:59.320 --> 0:18:03.880
Just, you know, so that we know that we didn't cache anything from that environment.

304
0:18:03.880 --> 0:18:07.240
So that's where the develop and the release caches are coming from.

305
0:18:07.240 --> 0:18:10.800
They're entirely separate from the PR environment.

306
0:18:10.800 --> 0:18:13.200
And the signature here is, you know, it's ephemeral.

307
0:18:13.200 --> 0:18:16.280
They have like a signing key locked up somewhere in a secret server.

308
0:18:16.280 --> 0:18:20.040
And we generate, you know, we have subkeys and then we generate ephemeral keys for the

309
0:18:20.040 --> 0:18:22.380
signing in the pipelines.

310
0:18:22.380 --> 0:18:26.200
So whatever it is that you got signed with, it doesn't actually exist anymore by the time

311
0:18:26.200 --> 0:18:28.160
the user consumes the binary.

312
0:18:28.160 --> 0:18:29.560
We could look at SigStore for this.

313
0:18:29.560 --> 0:18:32.680
It wasn't quite ready for arbitrary binary signing when we did this.

314
0:18:32.680 --> 0:18:39.840
But that's an option to reduce some of the custom GPG stuff we had to do here.

315
0:18:39.840 --> 0:18:45.080
So the pull request integration, I think, makes it easy for at least for most of the

316
0:18:45.080 --> 0:18:46.080
contributors.

317
0:18:46.080 --> 0:18:48.480
They get status updates on PRs.

318
0:18:48.480 --> 0:18:51.660
And it's fairly easy for users because they can just add one of these binary mirrors and

319
0:18:51.660 --> 0:18:54.240
then start using the build cache.

320
0:18:54.240 --> 0:18:56.680
And I'm not going to get into the details here.

321
0:18:56.680 --> 0:19:02.240
But in SPAC for a very long time, it was easy to get a lot of cache misses.

322
0:19:02.240 --> 0:19:04.240
Like we would just look up hashes.

323
0:19:04.240 --> 0:19:07.400
And I have another presentation about our reusing concretizer.

324
0:19:07.400 --> 0:19:11.320
The summary is if you add one of these build caches and you have those binaries available,

325
0:19:11.320 --> 0:19:13.040
SPAC will prefer to use them.

326
0:19:13.040 --> 0:19:15.840
And so before it tries to rebuild something.

327
0:19:15.840 --> 0:19:21.060
And so with the reusing concretizer, this is actually quite powerful.

328
0:19:21.060 --> 0:19:23.360
And so, yeah, what could go wrong?

329
0:19:23.360 --> 0:19:27.800
Well, there is a burden to doing this.

330
0:19:27.800 --> 0:19:32.360
And a build cache distribution like SPAC nix or geeks is different from an RPM distribution

331
0:19:32.360 --> 0:19:35.440
because every node has a hash.

332
0:19:35.440 --> 0:19:39.600
And the deployment model is really that you have to deploy with what you built with.

333
0:19:39.600 --> 0:19:43.080
And so you can't just swap in a new version of Zlib in a stack.

334
0:19:43.080 --> 0:19:46.200
If something has a particular hash, that implies all of its dependencies has hashes.

335
0:19:46.200 --> 0:19:50.200
And so you need to deploy the build cache with everything that it was built with.

336
0:19:50.200 --> 0:19:55.960
So if, for example, you modify XZ, right?

337
0:19:55.960 --> 0:19:59.200
And then you're going to need to rebuild all of these things too.

338
0:19:59.200 --> 0:20:02.240
And you're going to need to do that all the way up to the roots of your environment every

339
0:20:02.240 --> 0:20:06.800
once in a while so that there's a consistent build cache for people to deploy.

340
0:20:06.800 --> 0:20:08.740
And that can be bad if your stack is this big.

341
0:20:08.740 --> 0:20:10.480
This is E4S, right?

342
0:20:10.480 --> 0:20:16.000
And someone comes in and submits a PR, which you can do, by the way, that, you know, modifies

343
0:20:16.000 --> 0:20:17.440
package conf.

344
0:20:17.440 --> 0:20:21.520
And then all of a sudden, you know, this is what happens to your CI system, right?

345
0:20:21.520 --> 0:20:23.080
Your whole graph is rebuilding again.

346
0:20:23.080 --> 0:20:28.120
And it can take a long time for develop to catch up with a change like this.

347
0:20:28.120 --> 0:20:31.640
And right now we are rebuilding all that stuff on PRs.

348
0:20:31.640 --> 0:20:33.320
So your pipelines can get long.

349
0:20:33.320 --> 0:20:35.880
You dig in there and you see that, like, Visit is still building.

350
0:20:35.880 --> 0:20:37.960
And you're like, this is the fifth time I've built Visit today.

351
0:20:37.960 --> 0:20:44.040
I think Harmon once commented that he was worried that SPAC would eventually cause the

352
0:20:44.040 --> 0:20:46.920
heat death of the universe because of ParaView builds.

353
0:20:46.920 --> 0:20:53.720
Or no, the ParaView builds would eventually bring on climate change in the U.S.

354
0:20:53.720 --> 0:20:55.200
So we worry about that.

355
0:20:55.200 --> 0:20:57.480
We don't want to do that all the time.

356
0:20:57.480 --> 0:21:05.040
The other thing that can happen is there's a delicate balance between redundant builds

357
0:21:05.040 --> 0:21:07.400
and holding back PRs.

358
0:21:07.400 --> 0:21:10.800
I didn't think about this before we really got into CI.

359
0:21:10.800 --> 0:21:16.900
But it matters what commit you picked to merge with when you're doing a build cache build.

360
0:21:16.900 --> 0:21:21.600
And so if you have a pipeline like this where you've built B and develop is now picked up

361
0:21:21.600 --> 0:21:28.040
on D, and that one's building up there, and you get a PR like this, so PR1 comes in, you

362
0:21:28.040 --> 0:21:35.560
can merge that with B and get a lot of reuse there and get a pretty good testing on PR1.

363
0:21:35.560 --> 0:21:42.040
If instead you get a PR up here that is based beyond your last develop build and you try

364
0:21:42.040 --> 0:21:46.720
to merge that with B or even C, I guess it's already based on C, so you can't really merge

365
0:21:46.720 --> 0:21:50.280
that with C. But if you merge that with D, you're going to be duplicating the work that's

366
0:21:50.280 --> 0:21:51.860
already being done on develop.

367
0:21:51.860 --> 0:21:56.580
And so if you get a bunch of PRs like this at the same time, you can get a whole bunch

368
0:21:56.580 --> 0:22:01.560
of builds at the same time that are effectively already being done on develop.

369
0:22:01.560 --> 0:22:05.320
And so this is a difficulty of navigating these PR-based CI systems.

370
0:22:05.320 --> 0:22:10.160
If you had a server that had served that one patch was built all the time once, then you

371
0:22:10.160 --> 0:22:11.160
could get around this.

372
0:22:11.160 --> 0:22:16.680
So you have to be picky about this hold up PR2 until the next thing is built and then

373
0:22:16.680 --> 0:22:22.240
merge with that commit and send it to GitLab to be merged, or to be built.

374
0:22:22.240 --> 0:22:25.480
And this can annoy contributors because they have to wait for that to happen for their

375
0:22:25.480 --> 0:22:29.920
PR in order to keep the CI system sane.

376
0:22:29.920 --> 0:22:35.240
We actually did bring down GitLab once with a bunch of PRs like this.

377
0:22:35.240 --> 0:22:38.360
Essentially something got broken in develop, develop got held up, people started submitting

378
0:22:38.360 --> 0:22:41.840
a bunch of PRs, they were all doing redundant builds and GitLab fell over.

379
0:22:41.840 --> 0:22:45.400
So that was fun.

380
0:22:45.400 --> 0:22:47.160
CI does keep things stable.

381
0:22:47.160 --> 0:22:51.840
And so we have had, at least anecdotally, that our package maintainers at the lab are

382
0:22:51.840 --> 0:22:57.400
much more happy with how reliable their builds are for packages on the machines since we've

383
0:22:57.400 --> 0:22:59.000
had CI.

384
0:22:59.000 --> 0:23:02.460
But like I said, the committers get frustrated.

385
0:23:02.460 --> 0:23:05.520
And the other thing that happens here if you're doing so many builds on PRs is that if your

386
0:23:05.520 --> 0:23:10.560
CI system has occasional system errors, if you're building a thousand things on a PR

387
0:23:10.560 --> 0:23:13.560
pipeline, it's very likely that you're going to get a system error on there.

388
0:23:13.560 --> 0:23:18.360
And so what ends up happening is that you end up having to babysit PRs a bit.

389
0:23:18.360 --> 0:23:21.580
And that can be painful.

390
0:23:21.580 --> 0:23:24.460
The other thing that happens is it's hard to stay correct.

391
0:23:24.460 --> 0:23:28.120
So testing on PRs doesn't really ensure that you have a working develop branch.

392
0:23:28.120 --> 0:23:33.120
If you have a setup like this with an initial package state, you get a pull request that

393
0:23:33.120 --> 0:23:38.600
updates B. You get another pull request in there that updates C. You test both of those

394
0:23:38.600 --> 0:23:41.480
configurations on your PRs and they work.

395
0:23:41.480 --> 0:23:42.840
And you merge them.

396
0:23:42.840 --> 0:23:47.200
The thing that you now have in develop is actually updated B and updated C. And you

397
0:23:47.200 --> 0:23:48.800
never tested that.

398
0:23:48.800 --> 0:23:52.720
And so keeping that state consistent is rather difficult.

399
0:23:52.720 --> 0:23:56.840
And we're thinking we're going to – we didn't – you know, before we had CI, I think we

400
0:23:56.840 --> 0:23:59.120
just didn't see these kinds of issues.

401
0:23:59.120 --> 0:24:02.240
They would just get manifest on users, which is not great.

402
0:24:02.240 --> 0:24:06.060
But now we run into them in CI because we can see that things are broken on develop.

403
0:24:06.060 --> 0:24:08.960
So we're looking into using merge queues, which actually solved this problem, and a

404
0:24:08.960 --> 0:24:11.700
couple others that we have pretty effectively.

405
0:24:11.700 --> 0:24:15.520
So you can do faster iteration on PRs with merge queues because you're merging in sequence,

406
0:24:15.520 --> 0:24:16.520
testing in parallel.

407
0:24:16.520 --> 0:24:18.680
I'll describe what that looks like in a minute.

408
0:24:18.680 --> 0:24:22.640
It's a good balance of CI versus responsiveness because you can do sort of sparse tests on

409
0:24:22.640 --> 0:24:25.960
the PRs and queue them and then do the heavy tests.

410
0:24:25.960 --> 0:24:29.360
And it actually does preserve the security model because anything queued in a merge queue

411
0:24:29.360 --> 0:24:31.760
is actually approved by maintainers.

412
0:24:31.760 --> 0:24:34.440
And you can take the builds and move them straight into develop.

413
0:24:34.440 --> 0:24:40.080
And so what that looks like is this, where you might have the same initial package state.

414
0:24:40.080 --> 0:24:41.720
You get two pull requests.

415
0:24:41.720 --> 0:24:44.140
You do some small testing on the pull request.

416
0:24:44.140 --> 0:24:48.400
And then you set up this merge queue where effectively you're doing heavy testing on

417
0:24:48.400 --> 0:24:54.240
things that are basically staged exactly as they will be merged if they are successful.

418
0:24:54.240 --> 0:24:55.640
So that gets committed.

419
0:24:55.640 --> 0:24:56.640
That gets committed.

420
0:24:56.640 --> 0:24:58.940
And now you've tested the final configuration on develop.

421
0:24:58.940 --> 0:25:02.000
And you're not in an inconsistent state.

422
0:25:02.000 --> 0:25:06.640
So we're going to stage the work that we do in CI.

423
0:25:06.640 --> 0:25:10.040
On PRs, we're probably going to build just the package or just the package and its dependence,

424
0:25:10.040 --> 0:25:12.520
which is similar to what Nix does.

425
0:25:12.520 --> 0:25:15.100
On most merge queue pipelines, we may build a bit more than that.

426
0:25:15.100 --> 0:25:17.320
And then every once in a while, we'll build everything on develop.

427
0:25:17.320 --> 0:25:18.320
And we'll see how it goes.

428
0:25:18.320 --> 0:25:20.880
We can probe what the balance is here.

429
0:25:20.880 --> 0:25:23.880
So that's where we're at.

430
0:25:23.880 --> 0:25:24.880
Thanks.

431
0:25:24.880 --> 0:25:25.880
Okay.

432
0:25:25.880 --> 0:25:32.220
I think we have time for one or two questions.

433
0:25:32.220 --> 0:25:34.360
Any questions for Tom?

434
0:25:34.360 --> 0:25:44.360
And off to the whole question, we have first MS software bill of materials, Devroom.

435
0:25:44.360 --> 0:25:48.360
You mentioned export controlled software and also being able to trust binaries.

436
0:25:48.360 --> 0:25:52.400
I work with classified customers who have isolated networks.

437
0:25:52.400 --> 0:25:56.280
Probably be shot by MI6 if I told you who they were.

438
0:25:56.280 --> 0:26:01.440
But could SPAC help with providing the offer, they're now asking for what software is running

439
0:26:01.440 --> 0:26:02.440
on these systems?

440
0:26:02.440 --> 0:26:05.720
I mean, what does that question mean, really?

441
0:26:05.720 --> 0:26:10.360
Can you help with producing a report on exactly what software is?

442
0:26:10.360 --> 0:26:15.600
We have a PR right now for so that every SPAC build would produce an S-bomb in some standard

443
0:26:15.600 --> 0:26:16.600
format.

444
0:26:16.600 --> 0:26:21.080
There's a whole Devroom on S-bombs today, which gets into that.

445
0:26:21.080 --> 0:26:25.000
And so I think, yeah, we know everything in the graph and so do Nix and Geeks and the

446
0:26:25.000 --> 0:26:26.920
other systems that do this.

447
0:26:26.920 --> 0:26:30.840
We don't expose it in a standard format that auditing systems can scan right now, but that's

448
0:26:30.840 --> 0:26:34.040
what we'd like to do.

449
0:26:34.040 --> 0:26:38.640
So very briefly, Debian a while ago did something on reproducible builds, which were much more

450
0:26:38.640 --> 0:26:39.640
difficult.

451
0:26:39.640 --> 0:26:44.120
So if you haven't worked with it, that might be interesting for you.

452
0:26:44.120 --> 0:26:49.680
Yeah, so we would like to have fully reproducible builds.

453
0:26:49.680 --> 0:26:51.160
It's a lot of upstream patching, right?

454
0:26:51.160 --> 0:26:54.480
And even Debian isn't fully reproducible right now.

455
0:26:54.480 --> 0:27:00.720
I think that would be something we could consider after we get down to libc even, because at

456
0:27:00.720 --> 0:27:04.640
the moment, because we have to run on things like craze where there's so much dependent

457
0:27:04.640 --> 0:27:09.440
on the module environment, we have to include the external environment to get some of these

458
0:27:09.440 --> 0:27:10.800
builds done.

459
0:27:10.800 --> 0:27:15.000
But yeah, I would like to have a much more isolated build environment.

460
0:27:15.000 --> 0:27:16.000
It's a good practice.

461
0:27:16.000 --> 0:27:21.200
Okay, one more question here and then you need to switch.

462
0:27:21.200 --> 0:27:26.720
Hi, so you were talking about Paddy, your head of files for relative pathing.

463
0:27:26.720 --> 0:27:27.720
Yeah.

464
0:27:27.720 --> 0:27:32.640
I'm wondering if you don't have a static path or a predefined destination as in FHS type

465
0:27:32.640 --> 0:27:33.640
locations.

466
0:27:33.640 --> 0:27:38.840
Are you in serious danger of running out of space in that header?

467
0:27:38.840 --> 0:27:40.120
Well, we're not building in a static path.

468
0:27:40.120 --> 0:27:42.080
We might be building in a home directory, right?

469
0:27:42.080 --> 0:27:47.960
And so you can put padding in your install tree prefix, it's like the next store, and

470
0:27:47.960 --> 0:27:51.160
you can say build with 256 long paths.

471
0:27:51.160 --> 0:27:54.920
And you wouldn't want to have a user actually deploy in a path like that.

472
0:27:54.920 --> 0:27:58.280
You can build that way, create the binary and then redeploy in a short path.

473
0:27:58.280 --> 0:28:04.440
You've got potentially a space where there's, where you can have an arbitrary length path

474
0:28:04.440 --> 0:28:05.440
as your...

475
0:28:05.440 --> 0:28:08.080
A lot of stuff doesn't build with overly long paths.

476
0:28:08.080 --> 0:28:12.000
So like if you get to 512, auto tools starts breaking down and not supporting that length

477
0:28:12.000 --> 0:28:13.320
of a path.

478
0:28:13.320 --> 0:28:15.200
And like the packages actually don't support it.

479
0:28:15.200 --> 0:28:17.480
And so like the sweet spot seems to be like 256.

480
0:28:17.480 --> 0:28:18.480
Seems to be.

481
0:28:18.480 --> 0:28:25.480
Okay, thanks.

