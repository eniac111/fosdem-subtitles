WEBVTT

00:00.000 --> 00:11.960
So, the next speaker is Todd Gamblin, and as I think a lot of people here know, I'm

00:11.960 --> 00:17.400
very much involved in the EasyBuild project, which was actually the excuse we used to start

00:17.400 --> 00:21.920
the HPC Dev Room, but we're also very open to other projects which are very similar to

00:21.920 --> 00:24.000
what we work on every day.

00:24.000 --> 00:28.560
So, in some sense, back as our mortal enemy, but we do allow them to give talks in the

00:28.560 --> 00:30.440
Dev Room as well.

00:30.440 --> 00:31.440
Yeah, thanks.

00:31.440 --> 00:34.440
Okay, who's heard of SPAC?

00:34.440 --> 00:36.720
Okay, cool.

00:36.720 --> 00:37.720
People have heard of SPAC.

00:37.720 --> 00:42.520
We don't need to do too many introductions for this talk.

00:42.520 --> 00:46.520
This is less of a talk about SPAC and more of a talk about the CI that we've started

00:46.520 --> 00:49.480
doing since introducing binary packages in SPAC.

00:49.480 --> 00:54.080
I don't think I need to tell people why they need SPAC for HPC.

00:54.080 --> 00:58.160
I think lots of folks have talked about that already today.

00:58.160 --> 01:01.400
Someone said that, so I was supposed to talk a little bit about deployment.

01:01.400 --> 01:04.560
To deploy SPAC, if you want to try it on a new system, just clone it from the Git repo

01:04.560 --> 01:05.560
and run it.

01:05.560 --> 01:09.440
Like, all you need is Python and a few other tools on your system to do that.

01:09.440 --> 01:12.560
So you can just run it straight out of the repo if you want to play around with it and

01:12.560 --> 01:15.320
build stuff right there.

01:15.320 --> 01:20.240
SPAC is designed to install lots of different versions of things, like others have said.

01:20.240 --> 01:23.400
This is sort of a snapshot of the syntax, some of the things that you can add.

01:23.400 --> 01:25.720
You can install HDF5 at lots of different versions.

01:25.720 --> 01:27.200
You can inject flags in the build.

01:27.200 --> 01:28.680
You can pick a compiler.

01:28.680 --> 01:32.160
You can do all that on the fly and it will build you a custom version of that software

01:32.160 --> 01:33.840
and let you use it.

01:33.840 --> 01:36.920
You can get it into your environment a lot of different ways.

01:36.920 --> 01:40.840
What we're trying to do with SPAC is provide the ease of use of mainstream tools that people

01:40.840 --> 01:45.760
are used to, but with the flexibility for HPC, whether we fully accomplish that is a

01:45.760 --> 01:49.480
whole other question because there's a lot of complexity still in this because it is

01:49.480 --> 01:53.040
intended for HPC.

01:53.040 --> 01:56.320
Originally it was designed to build from source because it was trying to automate people's

01:56.320 --> 02:00.800
common workflow.

02:00.800 --> 02:05.280
Actually the Fermi lab and CERN folks added a first implementation of binary packaging

02:05.280 --> 02:11.880
to SPAC and I talked about some of that in a past FOSM.

02:11.880 --> 02:16.400
Since then we've actually started relying on the build caches a lot more.

02:16.400 --> 02:21.400
SPAC has relocatable build caches that you can build in either a build farm or you can

02:21.400 --> 02:25.080
make one right out of your SPAC build.

02:25.080 --> 02:29.000
You may not want to do one yourself that way because then you won't have padding on the

02:29.000 --> 02:33.360
path and like you said, patch off relocation is dangerous.

02:33.360 --> 02:39.160
Generally if we build binaries for wide use we pad the paths pretty extensively so that

02:39.160 --> 02:43.280
we can just poke values in instead of having to do all the patch off stuff.

02:43.280 --> 02:48.360
But anyway you can install SPAC binaries from a build cache in S3 to your home directory.

02:48.360 --> 02:50.960
You can make a common build cache in the file system.

02:50.960 --> 02:57.120
You can use a build cache to accelerate SCI and it's very handy because it eliminates

02:57.120 --> 03:03.320
the need to rebuild lots of stuff all the time.

03:03.320 --> 03:09.560
So if you look at the SPAC project as a whole, I think people know most of this.

03:09.560 --> 03:13.400
There's a community, we maintain the core tool, there's package recipes but the part

03:13.400 --> 03:18.720
that you don't see is all the infrastructure behind the scenes that keeps the thing working.

03:18.720 --> 03:24.720
And originally we did not have CI for SPAC or at least not for the package builds.

03:24.720 --> 03:29.160
We've always had CI for the tool itself and we've done unit tests and checked a bunch

03:29.160 --> 03:31.680
of things about concretization and so on.

03:31.680 --> 03:35.440
But we weren't building all the packages and we're still not building all the packages

03:35.440 --> 03:38.000
but we're building quite a few of them.

03:38.000 --> 03:41.620
With the infrastructure that we have, we have a system where essentially you can build lots

03:41.620 --> 03:43.200
of software stacks on top of SPAC.

03:43.200 --> 03:46.080
You can write a YAML description of what you want in the software stack.

03:46.080 --> 03:51.280
You can have E4S, AWS, Sysstack, Livermore, Mathstack.

03:51.280 --> 03:56.000
There's a Viz SDK within the Exascale Computing Project and really every application is its

03:56.000 --> 03:57.520
own software stack these days.

03:57.520 --> 04:03.200
So our production codes have upwards of 100 dependencies that they are using for multiphysics

04:03.200 --> 04:08.040
and so each of them is essentially maintaining their own little private software distribution

04:08.040 --> 04:10.560
in some sense or another.

04:10.560 --> 04:15.160
And so we'd like to be able to build all of this stuff and ensure that these things keep

04:15.160 --> 04:16.640
working.

04:16.640 --> 04:21.120
That's hard to do given that the GitHub for SPAC is a pretty busy place.

04:21.120 --> 04:24.200
There's almost 7,000 packages in SPAC now.

04:24.200 --> 04:29.440
Over the whole life of the project there's been over 1,100 contributors and you can see

04:29.440 --> 04:36.640
down there this month there's been 122 people active on the GitHub repo and that's like

04:36.640 --> 04:42.520
over 400 commits and 300 to 500 PRs per month that we have to merge.

04:42.520 --> 04:47.400
And so ensuring that everything stays working with that many changes is pretty hard and

04:47.400 --> 04:52.160
you'd be sort of nuts to do it without CI.

04:52.160 --> 04:56.400
One of the problems that we have though is that CI for HPC is hard.

04:56.400 --> 05:02.000
If you want to test in the HPC environments that you actually care about you can't just

05:02.000 --> 05:06.560
take an HPC node and hook it up to random pull requests on GitHub.

05:06.560 --> 05:09.880
They don't like that when the machine might have export controlled software on it because

05:09.880 --> 05:16.120
you're effectively allowing someone, some random person in a pull request to run software

05:16.120 --> 05:18.000
on your HPC machine.

05:18.000 --> 05:20.520
And so this is the model for SPAC.

05:20.520 --> 05:23.840
We have a bunch of external contributors on GitHub constantly contributing to this develop

05:23.840 --> 05:26.040
branch.

05:26.040 --> 05:31.160
We have sort of stable release branches where we freeze the packages to reduce the churn

05:31.160 --> 05:32.520
that some people rely on.

05:32.520 --> 05:36.920
Most users are actually on develop at least according to our surveys which is a little

05:36.920 --> 05:40.560
surprising to me but that's where we are.

05:40.560 --> 05:45.160
And then off of the release branches there is a software distribution within the XSEL

05:45.160 --> 05:48.920
project in the US called E4S and there's a few others that sort of freeze a commit from

05:48.920 --> 05:52.460
SPAC and do their own integration after that.

05:52.460 --> 05:56.120
And that's really supposed to be the deployment mechanism for the 100 or so packages and it's

05:56.120 --> 06:00.400
like 600 with dependencies that are in ECP.

06:00.400 --> 06:06.160
And what happens with this is that that gets deployed to the facilities and the E4S team

06:06.160 --> 06:12.600
goes and ensures that everything works but we're not able to run on these systems on

06:12.600 --> 06:15.200
pull requests in CI and it's very frustrating.

06:15.200 --> 06:19.080
And so essentially this is a bunch of downstream work that we would really like to get rid

06:19.080 --> 06:20.080
of.

06:20.080 --> 06:23.840
Moreover, like the applications are also doing downstream integration.

06:23.840 --> 06:26.680
They may have their own CI which may be good.

06:26.680 --> 06:28.240
They're essentially pulling from all these places.

06:28.240 --> 06:30.000
They may pull a facility deployment.

06:30.000 --> 06:31.040
They may pull from develop.

06:31.040 --> 06:32.520
They may pull from a release.

06:32.520 --> 06:35.220
They're essentially integrating from all these places and so there's a lot of downstream

06:35.220 --> 06:36.440
importing there.

06:36.440 --> 06:41.200
What we would ultimately like to do in SPAC is take all of that work that's going on downstream

06:41.200 --> 06:46.720
and move it upstream so that we're actually doing CI testing on develop along with everything

06:46.720 --> 06:47.720
else.

06:47.720 --> 06:49.880
And so this is progress towards that but we're not doing that yet.

06:49.880 --> 06:55.240
Essentially the main obstacle for us to build stuff that looks like the HPC environments

06:55.240 --> 07:01.400
right now is a licensing issue which is that we can't take the create PE container and

07:01.400 --> 07:06.280
run it in the cloud because that's just not something you can do with HPE's license.

07:06.280 --> 07:09.920
We are pushing them real hard on this and trying to get an exception for us to build

07:09.920 --> 07:15.600
things, in which case we would be able to do work upstream and ideally deploy it the

07:15.600 --> 07:19.960
facilities from the binary cache which I think would be way more stable and less error prone

07:19.960 --> 07:23.460
than what we do right now.

07:23.460 --> 07:29.120
And so we set out to make this CI system to enable this with a bunch of different goals.

07:29.120 --> 07:32.600
One of the goals is that we want to be sustainable.

07:32.600 --> 07:36.600
We don't want to change the maintainer workflow and we already have a few enough maintainers

07:36.600 --> 07:39.880
for the amount of work that there is.

07:39.880 --> 07:41.380
We don't want to change what they have to do.

07:41.380 --> 07:46.600
They're used to going out on GitHub and approving PRs, getting them merged, working with them,

07:46.600 --> 07:49.200
checking if they build and so on.

07:49.200 --> 07:51.000
And we don't want them to have to do something different.

07:51.000 --> 07:55.040
So we don't want them to both have to maintain PRs and think about how the integration branch

07:55.040 --> 07:57.600
is doing like some distros do.

07:57.600 --> 07:59.360
We'd like that to just happen.

07:59.360 --> 08:03.400
And so in that vein we want a rolling release where on develop we're constantly building

08:03.400 --> 08:09.680
binaries for the develop branch and that we basically snapshot and develop for every release

08:09.680 --> 08:11.480
that we do and say okay, it's stable.

08:11.480 --> 08:12.480
Everything built.

08:12.480 --> 08:13.480
We are ready to do the release.

08:13.480 --> 08:17.560
We'll just cut one and then we will backport bug fixes to this back tool on that release

08:17.560 --> 08:19.520
if we need to.

08:19.520 --> 08:21.760
We want it to eventually support all 6900 packages.

08:21.760 --> 08:23.640
It's not something we're doing now.

08:23.640 --> 08:27.880
And we want source builds to still work with these binaries effectively once it's done.

08:27.880 --> 08:31.680
So we want to make sure that the recipes are still versatile enough to do all those combinations

08:31.680 --> 08:34.360
of builds that I showed on the first slide.

08:34.360 --> 08:38.840
And then finally, and this is a big one, we wanted to ensure that the binaries that we

08:38.840 --> 08:41.320
have in SPAC are just as trustworthy as the sources.

08:41.320 --> 08:45.840
So if you feel like you can trust our maintainers and rely on the sources that are in SPAC packages

08:45.840 --> 08:49.520
with checksums that you feel just as comfortable with the binaries that we're putting in the

08:49.520 --> 08:52.540
build cache for you.

08:52.540 --> 08:57.560
And so if you think about how this works, if you look at traditional package managers

08:57.560 --> 09:02.800
like say APT or YUM, you have a recipe per package configuration that's getting thrown

09:02.800 --> 09:06.240
into a build farm for each of those package configurations.

09:06.240 --> 09:10.600
Think like easy configs if EasyBuild had binaries.

09:10.600 --> 09:15.000
Throw that into a build farm and then you get these portable unoptimized binaries for

09:15.000 --> 09:19.120
theoretical binary having EasyBuild where there's one of those per package configuration

09:19.120 --> 09:21.240
or per spec file or whatever.

09:21.240 --> 09:25.680
And then, and this is more like an APT or whatever, you're managing one software stack

09:25.680 --> 09:29.640
that's meant to be upgraded over time and there's a consistent ABI across the distribution

09:29.640 --> 09:32.280
so that you can sort of swap one package in for another.

09:32.280 --> 09:35.680
And the solver in those distributions really operates on the binaries.

09:35.680 --> 09:40.880
In SPAC you have parameterized package recipes that we are designing to be portable and we

09:40.880 --> 09:43.880
want the maintainers to work on them together so that they remain portable so you can use

09:43.880 --> 09:45.600
them in different environments.

09:45.600 --> 09:49.280
Throw those into the build farm and effectively test the parameterized package recipe in lots

09:49.280 --> 09:52.880
of different configurations and spit out different stacks.

09:52.880 --> 09:56.960
Lots of different stacks optimized for different environments from the same portable recipes

09:56.960 --> 10:00.440
for different systems, OSs, compilers and MPIs and so on.

10:00.440 --> 10:03.960
And then we also want at any time for you to be able to choose to build something from

10:03.960 --> 10:09.720
source along with that if you want to customize some aspect of the pipeline.

10:09.720 --> 10:13.040
So to enable that we came up with this architecture.

10:13.040 --> 10:20.360
We have a bunch of AWS resources because AWS has been nice enough to donate some cycles

10:20.360 --> 10:22.080
to the project.

10:22.080 --> 10:25.800
They are interested in using SPAC in their parallel cluster product and so that's the

10:25.800 --> 10:28.360
motivation for them is they want binaries ready to go.

10:28.360 --> 10:31.700
If someone spins up a cluster in the cloud they don't want to spin up a cluster and have

10:31.700 --> 10:35.920
it sit there and build software for hours and then run after having charged a bunch

10:35.920 --> 10:39.760
of money which is nice to them right because they would make a lot of money.

10:39.760 --> 10:41.840
But then no one would use their service.

10:41.840 --> 10:44.360
So they want binaries.

10:44.360 --> 10:49.440
And in there we use S3 and CloudFront to distribute the binaries around the world.

10:49.440 --> 10:51.560
And EC2 is really the main build resource.

10:51.560 --> 10:55.160
RDS is in there but it's not that important.

10:55.160 --> 10:58.960
We've got a Kubernetes cluster in there that we have auto scaling runners in and so we're

10:58.960 --> 11:03.520
building mostly in containers inside of kube and there's a GitLab instance in there too.

11:03.520 --> 11:06.420
So we have a high availability GitLab instance.

11:06.420 --> 11:10.600
We chose GitLab because the HPC centers actually have GitLab CI themselves.

11:10.600 --> 11:16.080
And so the same CI logic that you can run or that we run in the cloud, you could take

11:16.080 --> 11:20.240
that and run it internally and have these pipelines generated for you at your own site

11:20.240 --> 11:21.240
too.

11:21.240 --> 11:25.600
You could slap another back end on this and have it generate buildgrass for some other

11:25.600 --> 11:28.560
system but that's the one that we're using.

11:28.560 --> 11:32.160
We're using runner pools with something called carpenter to basically get just in time instances

11:32.160 --> 11:35.300
and allocate the containers on them efficiently.

11:35.300 --> 11:39.440
And then we have some bare metal runners at the University of Oregon with some fairly

11:39.440 --> 11:40.920
exotic architectures on them.

11:40.920 --> 11:47.880
So if we need to build or if we need to specifically run on something that has an AMD GPU or A64

11:47.880 --> 11:50.000
effects and so on, we can do that.

11:50.000 --> 11:52.600
And we could add more runners to this eventually.

11:52.600 --> 11:55.280
And there's a bot that sort of coordinates all this work.

11:55.280 --> 11:56.280
So it's a lot of stuff.

11:56.280 --> 12:03.960
It's actually, every time I look at this I am amazed at how complicated CI is and how

12:03.960 --> 12:08.760
it's one of those things that seems like it should just work but there is a lot to maintaining

12:08.760 --> 12:11.400
a reliable service for doing this many builds.

12:11.400 --> 12:15.000
And I suspect other distro maintainers have realized that too and I'm just late to the

12:15.000 --> 12:17.600
game.

12:17.600 --> 12:23.040
The way that contributing a stack in SPAC works is we have this directory in the repo

12:23.040 --> 12:25.920
that has all of the cloud pipelines in it.

12:25.920 --> 12:30.440
And so you can see some of them are for AWS, some of them are different variations on E4S.

12:30.440 --> 12:35.160
Each of those directories contains just a SPAC diagonal that defines the stuff that

12:35.160 --> 12:36.520
is to be built.

12:36.520 --> 12:41.240
And so if you look inside of there, it's basically just a list of packages.

12:41.240 --> 12:48.400
So here's the ML CUDA one that has the build of I think PyTorch and TensorFlow, Keras,

12:48.400 --> 12:51.720
Jax and Friends for CUDA.

12:51.720 --> 12:55.640
It's just a list of packages plus there's a target up there, a target setting for all

12:55.640 --> 12:56.640
the packages.

12:56.640 --> 12:59.160
You could have a matrix of targets if you wanted.

12:59.160 --> 13:03.400
And then there's disable Rockum and enable CUDA on everything except for LLVM because

13:03.400 --> 13:05.040
there's that bug that's linked there.

13:05.040 --> 13:08.840
And I'm not entirely sure about the specifics of that.

13:08.840 --> 13:13.840
But this is the configuration part is up here and it's fairly minimal for the stack.

13:13.840 --> 13:17.720
There's currently if you look at these a bunch of other boilerplate stuff for things like

13:17.720 --> 13:18.720
mapping runners.

13:18.720 --> 13:19.880
I'll get to that in a minute.

13:19.880 --> 13:23.880
But this is, there's a PR that's going to go in where this is basically all that's going

13:23.880 --> 13:25.240
to be in your stack.

13:25.240 --> 13:27.880
And you might include some stuff from elsewhere.

13:27.880 --> 13:30.480
But this is essentially a stack definition.

13:30.480 --> 13:38.080
And we take that and this makes it very easy to change low level parameters in the stack.

13:38.080 --> 13:45.200
So we had a working E4S stack with something like six or seven hundred packages building.

13:45.200 --> 13:50.400
We wanted to get better testing for one API because that's what they're going to use on

13:50.400 --> 13:51.440
Aurora.

13:51.440 --> 13:53.920
And so we wanted to use the one API compilers.

13:53.920 --> 13:57.160
We added some compiler config and we said everything should use one API.

13:57.160 --> 14:02.440
And then at the very least we got a pipeline generated with some errors for one API.

14:02.440 --> 14:06.940
And it made it really easy to iterate on this with Intel where we would basically say, okay,

14:06.940 --> 14:07.940
this package is broken.

14:07.940 --> 14:08.940
Here's the bug.

14:08.940 --> 14:09.940
Go fix it.

14:09.940 --> 14:12.360
And then they'd come back with another version of one API and we would iterate with them

14:12.360 --> 14:13.560
until it was done.

14:13.560 --> 14:20.000
I think this is probably more open source than anyone has recently run through a vendor

14:20.000 --> 14:21.000
compiler.

14:21.000 --> 14:25.200
And so just being able to do this I think is big because it might make those compilers

14:25.200 --> 14:30.240
like actually viable things to use for real programs that have lots of dependencies.

14:30.240 --> 14:33.720
At the moment you have to sort of piece your program together and build parts of it with

14:33.720 --> 14:38.080
like, I don't know, PGI was the infamous one that broke on everything.

14:38.080 --> 14:42.340
But I think this could help with the vendor compilers being a viable second option.

14:42.340 --> 14:46.440
And maybe instill some competition among the vendors if they can do this frequently and

14:46.440 --> 14:49.520
show benchmarks against these packages.

14:49.520 --> 14:51.200
So this was I think a win.

14:51.200 --> 14:54.100
Yeah, thank you.

14:54.100 --> 14:56.440
Each of those stacks gets concretized.

14:56.440 --> 15:00.600
And so people know in SPAC you take that abstract description of the things that you want to

15:00.600 --> 15:02.780
install which is basically the requirements.

15:02.780 --> 15:05.160
You run it through our dependency solver.

15:05.160 --> 15:08.600
You get essentially a concrete description of what you're going to build which is the

15:08.600 --> 15:10.660
whole concrete graph.

15:10.660 --> 15:16.360
And then we generate a GitLab CI YAML from that that describes the jobs that need to

15:16.360 --> 15:18.380
be run to build the whole thing.

15:18.380 --> 15:20.520
This is the part that we could swap out for something else.

15:20.520 --> 15:22.440
So like we've looked at like Tekton pipelines.

15:22.440 --> 15:24.640
We've looked at other options.

15:24.640 --> 15:26.560
I don't know, some people use Jenkins.

15:26.560 --> 15:31.280
There's all sorts of things out there that you could potentially map the jobs to.

15:31.280 --> 15:34.120
And I think we could generate a description like that from the representation that we

15:34.120 --> 15:36.120
have.

15:36.120 --> 15:44.560
For mapping those jobs, we have a section in the CI YAML right now or in the SPAC.YAML

15:44.560 --> 15:49.360
that basically tells you how to generate the GitLab piece.

15:49.360 --> 15:52.720
And so you see this mapping section here.

15:52.720 --> 15:54.680
There's a match section.

15:54.680 --> 15:58.440
If you match any of those specs there and the first three are just a couple, just some

15:58.440 --> 16:03.400
names, then we have special tags that we put on the runners that say, you know, get me

16:03.400 --> 16:04.880
a special resource for these things.

16:04.880 --> 16:10.440
And so that first block is basically so that I don't run out of memory building LLVM, TensorFlow

16:10.440 --> 16:11.840
or Torch.

16:11.840 --> 16:15.720
Get me something with a lot of memory and a big CPU to build that one.

16:15.720 --> 16:17.440
It has to run on a big instance.

16:17.440 --> 16:21.280
Because those are sort of the long poles in our tent in CI.

16:21.280 --> 16:25.440
And then down at the bottom, there's just a mapping from everything else gets something

16:25.440 --> 16:28.880
that supports x86, x64, v4.

16:28.880 --> 16:33.300
And it's a little smaller than the other one for builds.

16:33.300 --> 16:37.520
And you could do this for lots of different architecture combinations and so on.

16:37.520 --> 16:42.160
And you can ask for images and things like that.

16:42.160 --> 16:47.880
I said that we needed to ensure that the source is as reliable, that the binaries are as reliable

16:47.880 --> 16:49.220
as the source.

16:49.220 --> 16:52.840
And so we sat down and we asked ourselves, you know, what is it that people trust about

16:52.840 --> 16:54.200
the SPAC project?

16:54.200 --> 16:55.980
And it's really the maintainers.

16:55.980 --> 17:00.300
If you use any open source project, you're trusting the maintainers or you really shouldn't

17:00.300 --> 17:01.840
be using that open source project.

17:01.840 --> 17:04.960
And so I don't see where we can do better than that.

17:04.960 --> 17:09.360
And so what we've done is we've said, you know, the place where bad things could get

17:09.360 --> 17:14.000
into a build from, at least from SPAC is in the build environment.

17:14.000 --> 17:18.880
And so if you give people control of the PR environment where they're submitting things

17:18.880 --> 17:23.400
there, they could push a commit that puts something in a binary that gets cached.

17:23.400 --> 17:28.220
And then, you know, somehow, I don't know, they could do bad things and end up caching

17:28.220 --> 17:29.220
a binary.

17:29.220 --> 17:32.920
And if we took that binary and stuck it out there for anyone to use, you know, there could

17:32.920 --> 17:34.040
be bad things in it.

17:34.040 --> 17:41.080
And so we have this separate set of untrusted S3 buckets where we only build PR things.

17:41.080 --> 17:43.520
Each PR gets its own build cache.

17:43.520 --> 17:46.120
That enables the maintainers to see if things work.

17:46.120 --> 17:48.320
And then they come along and review the code.

17:48.320 --> 17:52.200
And then once things are actually merged to develop, we don't trust any of the binaries

17:52.200 --> 17:53.560
that we built on PRs.

17:53.560 --> 17:58.320
And we go and rebuild everything and sign specifically from the, you know, the sources

17:58.320 --> 17:59.320
that got approved.

17:59.320 --> 18:03.880
Just, you know, so that we know that we didn't cache anything from that environment.

18:03.880 --> 18:07.240
So that's where the develop and the release caches are coming from.

18:07.240 --> 18:10.800
They're entirely separate from the PR environment.

18:10.800 --> 18:13.200
And the signature here is, you know, it's ephemeral.

18:13.200 --> 18:16.280
They have like a signing key locked up somewhere in a secret server.

18:16.280 --> 18:20.040
And we generate, you know, we have subkeys and then we generate ephemeral keys for the

18:20.040 --> 18:22.380
signing in the pipelines.

18:22.380 --> 18:26.200
So whatever it is that you got signed with, it doesn't actually exist anymore by the time

18:26.200 --> 18:28.160
the user consumes the binary.

18:28.160 --> 18:29.560
We could look at SigStore for this.

18:29.560 --> 18:32.680
It wasn't quite ready for arbitrary binary signing when we did this.

18:32.680 --> 18:39.840
But that's an option to reduce some of the custom GPG stuff we had to do here.

18:39.840 --> 18:45.080
So the pull request integration, I think, makes it easy for at least for most of the

18:45.080 --> 18:46.080
contributors.

18:46.080 --> 18:48.480
They get status updates on PRs.

18:48.480 --> 18:51.660
And it's fairly easy for users because they can just add one of these binary mirrors and

18:51.660 --> 18:54.240
then start using the build cache.

18:54.240 --> 18:56.680
And I'm not going to get into the details here.

18:56.680 --> 19:02.240
But in SPAC for a very long time, it was easy to get a lot of cache misses.

19:02.240 --> 19:04.240
Like we would just look up hashes.

19:04.240 --> 19:07.400
And I have another presentation about our reusing concretizer.

19:07.400 --> 19:11.320
The summary is if you add one of these build caches and you have those binaries available,

19:11.320 --> 19:13.040
SPAC will prefer to use them.

19:13.040 --> 19:15.840
And so before it tries to rebuild something.

19:15.840 --> 19:21.060
And so with the reusing concretizer, this is actually quite powerful.

19:21.060 --> 19:23.360
And so, yeah, what could go wrong?

19:23.360 --> 19:27.800
Well, there is a burden to doing this.

19:27.800 --> 19:32.360
And a build cache distribution like SPAC nix or geeks is different from an RPM distribution

19:32.360 --> 19:35.440
because every node has a hash.

19:35.440 --> 19:39.600
And the deployment model is really that you have to deploy with what you built with.

19:39.600 --> 19:43.080
And so you can't just swap in a new version of Zlib in a stack.

19:43.080 --> 19:46.200
If something has a particular hash, that implies all of its dependencies has hashes.

19:46.200 --> 19:50.200
And so you need to deploy the build cache with everything that it was built with.

19:50.200 --> 19:55.960
So if, for example, you modify XZ, right?

19:55.960 --> 19:59.200
And then you're going to need to rebuild all of these things too.

19:59.200 --> 20:02.240
And you're going to need to do that all the way up to the roots of your environment every

20:02.240 --> 20:06.800
once in a while so that there's a consistent build cache for people to deploy.

20:06.800 --> 20:08.740
And that can be bad if your stack is this big.

20:08.740 --> 20:10.480
This is E4S, right?

20:10.480 --> 20:16.000
And someone comes in and submits a PR, which you can do, by the way, that, you know, modifies

20:16.000 --> 20:17.440
package conf.

20:17.440 --> 20:21.520
And then all of a sudden, you know, this is what happens to your CI system, right?

20:21.520 --> 20:23.080
Your whole graph is rebuilding again.

20:23.080 --> 20:28.120
And it can take a long time for develop to catch up with a change like this.

20:28.120 --> 20:31.640
And right now we are rebuilding all that stuff on PRs.

20:31.640 --> 20:33.320
So your pipelines can get long.

20:33.320 --> 20:35.880
You dig in there and you see that, like, Visit is still building.

20:35.880 --> 20:37.960
And you're like, this is the fifth time I've built Visit today.

20:37.960 --> 20:44.040
I think Harmon once commented that he was worried that SPAC would eventually cause the

20:44.040 --> 20:46.920
heat death of the universe because of ParaView builds.

20:46.920 --> 20:53.720
Or no, the ParaView builds would eventually bring on climate change in the U.S.

20:53.720 --> 20:55.200
So we worry about that.

20:55.200 --> 20:57.480
We don't want to do that all the time.

20:57.480 --> 21:05.040
The other thing that can happen is there's a delicate balance between redundant builds

21:05.040 --> 21:07.400
and holding back PRs.

21:07.400 --> 21:10.800
I didn't think about this before we really got into CI.

21:10.800 --> 21:16.900
But it matters what commit you picked to merge with when you're doing a build cache build.

21:16.900 --> 21:21.600
And so if you have a pipeline like this where you've built B and develop is now picked up

21:21.600 --> 21:28.040
on D, and that one's building up there, and you get a PR like this, so PR1 comes in, you

21:28.040 --> 21:35.560
can merge that with B and get a lot of reuse there and get a pretty good testing on PR1.

21:35.560 --> 21:42.040
If instead you get a PR up here that is based beyond your last develop build and you try

21:42.040 --> 21:46.720
to merge that with B or even C, I guess it's already based on C, so you can't really merge

21:46.720 --> 21:50.280
that with C. But if you merge that with D, you're going to be duplicating the work that's

21:50.280 --> 21:51.860
already being done on develop.

21:51.860 --> 21:56.580
And so if you get a bunch of PRs like this at the same time, you can get a whole bunch

21:56.580 --> 22:01.560
of builds at the same time that are effectively already being done on develop.

22:01.560 --> 22:05.320
And so this is a difficulty of navigating these PR-based CI systems.

22:05.320 --> 22:10.160
If you had a server that had served that one patch was built all the time once, then you

22:10.160 --> 22:11.160
could get around this.

22:11.160 --> 22:16.680
So you have to be picky about this hold up PR2 until the next thing is built and then

22:16.680 --> 22:22.240
merge with that commit and send it to GitLab to be merged, or to be built.

22:22.240 --> 22:25.480
And this can annoy contributors because they have to wait for that to happen for their

22:25.480 --> 22:29.920
PR in order to keep the CI system sane.

22:29.920 --> 22:35.240
We actually did bring down GitLab once with a bunch of PRs like this.

22:35.240 --> 22:38.360
Essentially something got broken in develop, develop got held up, people started submitting

22:38.360 --> 22:41.840
a bunch of PRs, they were all doing redundant builds and GitLab fell over.

22:41.840 --> 22:45.400
So that was fun.

22:45.400 --> 22:47.160
CI does keep things stable.

22:47.160 --> 22:51.840
And so we have had, at least anecdotally, that our package maintainers at the lab are

22:51.840 --> 22:57.400
much more happy with how reliable their builds are for packages on the machines since we've

22:57.400 --> 22:59.000
had CI.

22:59.000 --> 23:02.460
But like I said, the committers get frustrated.

23:02.460 --> 23:05.520
And the other thing that happens here if you're doing so many builds on PRs is that if your

23:05.520 --> 23:10.560
CI system has occasional system errors, if you're building a thousand things on a PR

23:10.560 --> 23:13.560
pipeline, it's very likely that you're going to get a system error on there.

23:13.560 --> 23:18.360
And so what ends up happening is that you end up having to babysit PRs a bit.

23:18.360 --> 23:21.580
And that can be painful.

23:21.580 --> 23:24.460
The other thing that happens is it's hard to stay correct.

23:24.460 --> 23:28.120
So testing on PRs doesn't really ensure that you have a working develop branch.

23:28.120 --> 23:33.120
If you have a setup like this with an initial package state, you get a pull request that

23:33.120 --> 23:38.600
updates B. You get another pull request in there that updates C. You test both of those

23:38.600 --> 23:41.480
configurations on your PRs and they work.

23:41.480 --> 23:42.840
And you merge them.

23:42.840 --> 23:47.200
The thing that you now have in develop is actually updated B and updated C. And you

23:47.200 --> 23:48.800
never tested that.

23:48.800 --> 23:52.720
And so keeping that state consistent is rather difficult.

23:52.720 --> 23:56.840
And we're thinking we're going to – we didn't – you know, before we had CI, I think we

23:56.840 --> 23:59.120
just didn't see these kinds of issues.

23:59.120 --> 24:02.240
They would just get manifest on users, which is not great.

24:02.240 --> 24:06.060
But now we run into them in CI because we can see that things are broken on develop.

24:06.060 --> 24:08.960
So we're looking into using merge queues, which actually solved this problem, and a

24:08.960 --> 24:11.700
couple others that we have pretty effectively.

24:11.700 --> 24:15.520
So you can do faster iteration on PRs with merge queues because you're merging in sequence,

24:15.520 --> 24:16.520
testing in parallel.

24:16.520 --> 24:18.680
I'll describe what that looks like in a minute.

24:18.680 --> 24:22.640
It's a good balance of CI versus responsiveness because you can do sort of sparse tests on

24:22.640 --> 24:25.960
the PRs and queue them and then do the heavy tests.

24:25.960 --> 24:29.360
And it actually does preserve the security model because anything queued in a merge queue

24:29.360 --> 24:31.760
is actually approved by maintainers.

24:31.760 --> 24:34.440
And you can take the builds and move them straight into develop.

24:34.440 --> 24:40.080
And so what that looks like is this, where you might have the same initial package state.

24:40.080 --> 24:41.720
You get two pull requests.

24:41.720 --> 24:44.140
You do some small testing on the pull request.

24:44.140 --> 24:48.400
And then you set up this merge queue where effectively you're doing heavy testing on

24:48.400 --> 24:54.240
things that are basically staged exactly as they will be merged if they are successful.

24:54.240 --> 24:55.640
So that gets committed.

24:55.640 --> 24:56.640
That gets committed.

24:56.640 --> 24:58.940
And now you've tested the final configuration on develop.

24:58.940 --> 25:02.000
And you're not in an inconsistent state.

25:02.000 --> 25:06.640
So we're going to stage the work that we do in CI.

25:06.640 --> 25:10.040
On PRs, we're probably going to build just the package or just the package and its dependence,

25:10.040 --> 25:12.520
which is similar to what Nix does.

25:12.520 --> 25:15.100
On most merge queue pipelines, we may build a bit more than that.

25:15.100 --> 25:17.320
And then every once in a while, we'll build everything on develop.

25:17.320 --> 25:18.320
And we'll see how it goes.

25:18.320 --> 25:20.880
We can probe what the balance is here.

25:20.880 --> 25:23.880
So that's where we're at.

25:23.880 --> 25:24.880
Thanks.

25:24.880 --> 25:25.880
Okay.

25:25.880 --> 25:32.220
I think we have time for one or two questions.

25:32.220 --> 25:34.360
Any questions for Tom?

25:34.360 --> 25:44.360
And off to the whole question, we have first MS software bill of materials, Devroom.

25:44.360 --> 25:48.360
You mentioned export controlled software and also being able to trust binaries.

25:48.360 --> 25:52.400
I work with classified customers who have isolated networks.

25:52.400 --> 25:56.280
Probably be shot by MI6 if I told you who they were.

25:56.280 --> 26:01.440
But could SPAC help with providing the offer, they're now asking for what software is running

26:01.440 --> 26:02.440
on these systems?

26:02.440 --> 26:05.720
I mean, what does that question mean, really?

26:05.720 --> 26:10.360
Can you help with producing a report on exactly what software is?

26:10.360 --> 26:15.600
We have a PR right now for so that every SPAC build would produce an S-bomb in some standard

26:15.600 --> 26:16.600
format.

26:16.600 --> 26:21.080
There's a whole Devroom on S-bombs today, which gets into that.

26:21.080 --> 26:25.000
And so I think, yeah, we know everything in the graph and so do Nix and Geeks and the

26:25.000 --> 26:26.920
other systems that do this.

26:26.920 --> 26:30.840
We don't expose it in a standard format that auditing systems can scan right now, but that's

26:30.840 --> 26:34.040
what we'd like to do.

26:34.040 --> 26:38.640
So very briefly, Debian a while ago did something on reproducible builds, which were much more

26:38.640 --> 26:39.640
difficult.

26:39.640 --> 26:44.120
So if you haven't worked with it, that might be interesting for you.

26:44.120 --> 26:49.680
Yeah, so we would like to have fully reproducible builds.

26:49.680 --> 26:51.160
It's a lot of upstream patching, right?

26:51.160 --> 26:54.480
And even Debian isn't fully reproducible right now.

26:54.480 --> 27:00.720
I think that would be something we could consider after we get down to libc even, because at

27:00.720 --> 27:04.640
the moment, because we have to run on things like craze where there's so much dependent

27:04.640 --> 27:09.440
on the module environment, we have to include the external environment to get some of these

27:09.440 --> 27:10.800
builds done.

27:10.800 --> 27:15.000
But yeah, I would like to have a much more isolated build environment.

27:15.000 --> 27:16.000
It's a good practice.

27:16.000 --> 27:21.200
Okay, one more question here and then you need to switch.

27:21.200 --> 27:26.720
Hi, so you were talking about Paddy, your head of files for relative pathing.

27:26.720 --> 27:27.720
Yeah.

27:27.720 --> 27:32.640
I'm wondering if you don't have a static path or a predefined destination as in FHS type

27:32.640 --> 27:33.640
locations.

27:33.640 --> 27:38.840
Are you in serious danger of running out of space in that header?

27:38.840 --> 27:40.120
Well, we're not building in a static path.

27:40.120 --> 27:42.080
We might be building in a home directory, right?

27:42.080 --> 27:47.960
And so you can put padding in your install tree prefix, it's like the next store, and

27:47.960 --> 27:51.160
you can say build with 256 long paths.

27:51.160 --> 27:54.920
And you wouldn't want to have a user actually deploy in a path like that.

27:54.920 --> 27:58.280
You can build that way, create the binary and then redeploy in a short path.

27:58.280 --> 28:04.440
You've got potentially a space where there's, where you can have an arbitrary length path

28:04.440 --> 28:05.440
as your...

28:05.440 --> 28:08.080
A lot of stuff doesn't build with overly long paths.

28:08.080 --> 28:12.000
So like if you get to 512, auto tools starts breaking down and not supporting that length

28:12.000 --> 28:13.320
of a path.

28:13.320 --> 28:15.200
And like the packages actually don't support it.

28:15.200 --> 28:17.480
And so like the sweet spot seems to be like 256.

28:17.480 --> 28:18.480
Seems to be.

28:18.480 --> 28:25.480
Okay, thanks.
