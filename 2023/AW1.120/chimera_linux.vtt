WEBVTT

00:00.000 --> 00:14.140
All right, looks like we can begin, so welcome.

00:14.140 --> 00:19.680
And I will tell you about my project which is called Chimera Linux.

00:19.680 --> 00:22.920
But first let me introduce myself a bit.

00:22.920 --> 00:25.520
I'm a software developer from the Czech Republic.

00:25.520 --> 00:29.760
I've been contributing to open source software since 2007.

00:29.760 --> 00:36.320
And currently I'm on a break from work, so I'm kind of working on the distro full time.

00:36.320 --> 00:41.680
When I'm not on a break for work, I work in the WebKit team in Iglia.

00:41.680 --> 00:46.360
Previously I also used to work for Samsung in the open source group where I worked on

00:46.360 --> 00:51.580
the Enlightenment Foundation libraries and the Window Manager.

00:51.580 --> 00:58.560
Since 2009 I've been using FreeBSD, also on desktop for about ten years.

00:58.560 --> 01:05.720
But I've not been using that on desktop since about 2018 because I've been mostly using

01:05.720 --> 01:10.640
power architecture computers these days which FreeBSD doesn't have the greatest support

01:10.640 --> 01:11.640
for.

01:11.640 --> 01:14.720
So for example, my GPU wouldn't work.

01:14.720 --> 01:20.880
I'm also a former developer of the Void Linux distribution which has served as a huge inspiration

01:20.880 --> 01:26.800
for this project, especially in the design of the packaging system.

01:26.800 --> 01:32.000
And I sort of do all sorts of things besides distribution development.

01:32.000 --> 01:37.280
I also do, for example, game development, compiler stuff.

01:37.280 --> 01:41.200
I did some kernel bits as well.

01:41.200 --> 01:43.240
But now what's Chimera Linux?

01:43.240 --> 01:47.320
It's a new Linux distribution which I started in 2021.

01:47.320 --> 01:51.360
And it's a general purpose distribution created from scratch.

01:51.360 --> 01:59.200
It utilizes core tools from FreeBSD which is one of the big differences from standard

01:59.200 --> 02:03.460
distributions which is GNU tools for this or Busybox for example.

02:03.460 --> 02:07.200
It uses the LLVM toolchain to compile all the packages.

02:07.200 --> 02:14.120
As a matter of fact, there's currently no GCC in the distribution other than for some

02:14.120 --> 02:18.560
variants of U-Boot for specific ARM devices.

02:18.560 --> 02:24.040
It uses the muscle Lipsi and it's a rolling release distribution so there are no releases.

02:24.040 --> 02:26.920
It sort of updates continuously.

02:26.920 --> 02:29.640
And it's also highly portable to many architectures.

02:29.640 --> 02:37.600
Right now we are supporting Arch 64, Power, Little Indian, soon there will be PowerBigIndian,

02:37.600 --> 02:45.920
X8664 as well as complete full support for RISC-5 64-bit.

02:45.920 --> 02:53.160
I started this project in early mid-2021 and it started with C-Build which is sort of a

02:53.160 --> 02:55.960
meta-build system for packages.

02:55.960 --> 03:01.920
You create your packaging templates and these basically describe the package and how to

03:01.920 --> 03:05.280
build it and C-Build builds it.

03:05.280 --> 03:10.280
I also void Linux developer at this time and I started C-Build as a way to investigate

03:10.280 --> 03:16.320
if I can fix many of the shortcomings of void Linux's Xbps SRC system.

03:16.320 --> 03:21.360
So I've created a quick distribution around C-Build which consisted of GCC and GNU user

03:21.360 --> 03:26.120
runs as well as the Xbps package manager which you avoid to use this.

03:26.120 --> 03:29.120
At this point it was only about 50 packaging templates.

03:29.120 --> 03:30.120
So it was very tiny.

03:30.120 --> 03:37.360
It couldn't boot definitely because it had no kernel and no bootloader or init system

03:37.360 --> 03:39.000
even or anything.

03:39.000 --> 03:44.080
So it was just like a little container which was capable of building itself when hosted

03:44.080 --> 03:46.200
on another distribution.

03:46.200 --> 03:51.900
And as I said I was trying to fix many of the issues and main focuses of C-Build have

03:51.900 --> 03:56.360
been performance as well as correctness.

03:56.360 --> 04:04.480
This was when I first managed to make Kaimira boot in VM.

04:04.480 --> 04:11.120
Shortly after those 50 packages switched to LLVM and removal of GCC followed as well as

04:11.120 --> 04:17.520
the switch to FreeBSD tools, removal of the GNU stuff and so on and as well as gradual

04:17.520 --> 04:19.880
expansion of all the packages.

04:19.880 --> 04:25.880
I've been sort of iteratively enhancing the distribution ever since and until it got to

04:25.880 --> 04:27.280
the current state.

04:27.280 --> 04:34.280
In late 2021 it was possible to boot the system and it's capable of bootstrapping itself.

04:34.280 --> 04:40.280
In early 2022 there was a full GNOME desktop already.

04:40.280 --> 04:45.140
This was when I got a Wayland Compositor running and of course everything needs to be able

04:45.140 --> 04:52.320
to run Doom so we got Doom working as a terminal and some other basic stuff but this was I

04:52.320 --> 04:57.240
believe around late 2021.

04:57.240 --> 05:06.000
I had a talk about the distro at FOSDAM 2022 and many things happened during 2022 so last

05:06.000 --> 05:11.000
year I did the talk as a sort of chronological thing.

05:11.000 --> 05:14.400
I'm not going to do that this year because there have been too many things and I couldn't

05:14.400 --> 05:18.200
fit it into a 50 minute slot.

05:18.200 --> 05:25.600
Which focus has been in last year on security hardening and on development of different

05:25.600 --> 05:29.080
new solutions for things which we've been missing.

05:29.080 --> 05:34.320
I'm currently aiming for an alpha release which will be sort of early adapter release

05:34.320 --> 05:37.800
where things will mostly work on desktop.

05:37.800 --> 05:46.280
In late February or early March I plan to make it coincide with one of the betas of

05:46.280 --> 05:53.800
FreeBSD 13.2 in order to be able to rebase the tooling.

05:53.800 --> 05:56.720
Now for some motivations why did I create this project?

05:56.720 --> 05:59.840
I've been unhappy with existing systems.

05:59.840 --> 06:04.760
There are many great things that existing systems have but there's always at least

06:04.760 --> 06:10.360
one thing which has been annoying me so I sort of wanted to create a thing which would

06:10.360 --> 06:13.080
actually suit me in every single way.

06:13.080 --> 06:18.960
I wanted to make a well rounded practical operating system that wouldn't be just a toy

06:18.960 --> 06:21.880
but something people could actually use.

06:21.880 --> 06:28.040
At the same time I would like to improve software in general that is mainly in terms of portability

06:28.040 --> 06:34.680
as well as security when it comes to things like usage of sanitizers and so on.

06:34.680 --> 06:42.120
I would like to make full use of LLVM not just to replace GCC compiler but actually

06:42.120 --> 06:48.920
utilize the unique strengths of LLVM which includes great sanitizer infrastructure, things

06:48.920 --> 06:53.600
like finLTO which GCC still doesn't have and so on.

06:53.600 --> 07:00.240
Of course proving Linux is an under-gnew Linux is also a major thing.

07:00.240 --> 07:04.520
While doing all this I wanted to have some fun and some people on the internet said I

07:04.520 --> 07:09.400
couldn't do this so of course it's important to prove them wrong.

07:09.400 --> 07:15.680
I wanted to build a nice community which would be fun to hang around with and make a good

07:15.680 --> 07:20.720
system for both myself and for other people.

07:20.720 --> 07:24.320
Now for some general principles of the project.

07:24.320 --> 07:31.040
I strongly believe that projects which basically are centered around a single goal are eventually

07:31.040 --> 07:36.520
doomed to fail because once you reach this goal you have nothing else to do but at the

07:36.520 --> 07:49.680
same time it creates dogmatic things which you are not allowed to cross and it really

07:49.680 --> 07:53.240
restricts you with the development.

07:53.240 --> 07:58.920
On the other side of the problem there's scope creep if you have too many things to do and

07:58.920 --> 08:03.640
you keep expanding on it eventually you get to the point where you never get anything

08:03.640 --> 08:04.640
done.

08:04.640 --> 08:07.040
It's important to balance these things.

08:07.040 --> 08:13.520
I think opinion development is overall a good thing because it gives you a sense of direction

08:13.520 --> 08:16.280
which is always nice to have.

08:16.280 --> 08:21.480
I think obviously quality of the code matters but quality of the community matters even

08:21.480 --> 08:23.960
more so.

08:23.960 --> 08:30.600
I think fun is good so I would like to try to keep it that way and not to get too technical

08:30.600 --> 08:32.200
in the process.

08:32.200 --> 08:38.240
I think free and open source software projects are social spaces and that's why if you let

08:38.240 --> 08:45.320
toxic people into your community it's eventually going to become a job for everybody else.

08:45.320 --> 08:51.640
So I try hard to keep them out but at the same time I try to make sure it does not get

08:51.640 --> 08:57.720
overly elitist because it should be an open inclusive project for everybody.

08:57.720 --> 09:03.360
As for technical principles I try to make sure things are strict by default and try

09:03.360 --> 09:07.840
to avoid technical debt at all costs.

09:07.840 --> 09:12.920
There should usually be just one way to do things.

09:12.920 --> 09:17.280
That doesn't mean there only has to be one way but more like a good default that people

09:17.280 --> 09:23.280
are supposed to follow and that's sort of intuitive and easy to follow.

09:23.280 --> 09:27.560
This should remain as simple as possible but not too simple.

09:27.560 --> 09:34.840
There are many people who overly focus on things like minimalist systems and in the

09:34.840 --> 09:38.560
process they end up forgetting what's actually practical.

09:38.560 --> 09:44.000
I think security and hardening is also very important and in many Linux distributions

09:44.000 --> 09:49.160
it's sort of overlooked so that's another thing.

09:49.160 --> 09:53.640
And I think portability is also extremely important.

09:53.640 --> 09:57.400
There are many kinds of hardware and people like using many different kinds of hardware.

09:57.400 --> 10:02.200
Of course most people have their x86 computers but there's more of it than you may think

10:02.200 --> 10:08.080
and things like RISC-V are taking off and there's of course power workstations and there's

10:08.080 --> 10:14.320
ARM and so on so it's good to have all these things.

10:14.320 --> 10:21.560
Now good tooling is also very important and related to that is self-sustainability.

10:21.560 --> 10:26.840
That basically means whatever infrastructure you have should be self-contained and easy

10:26.840 --> 10:32.400
to get going and easy to replicate on any new computer.

10:32.400 --> 10:36.840
Related to that is being able to bootstrap the system from a source code.

10:36.840 --> 10:43.040
I think that's sort of a double-edged sword because some people don't care about bootstrapability

10:43.040 --> 10:48.320
at all and things are massive binaries downloaded from the internet.

10:48.320 --> 10:54.600
On the other side of the coin there's people who insist on complete bootstrapability from

10:54.600 --> 11:02.680
source code for everything even if it involves doing completely cursed things such as ever

11:02.680 --> 11:08.800
seen how to bootstrap the Haskell compiler from a source completely.

11:08.800 --> 11:13.720
It's like if you want to do it and you have to go through an ancient unmaintained Haskell

11:13.720 --> 11:20.280
compiler which only targets 32-bit x86 computers and compile some stuff on NAND and it's from

11:20.280 --> 11:25.120
2004 and then you have to iterate through newer versions.

11:25.120 --> 11:30.520
Eventually you get to GHC and then you can cross-compile a partial distribution for architecture

11:30.520 --> 11:36.440
and then go from that and eventually you reach your goal.

11:36.440 --> 11:44.960
I think it's a means to an end and it's important but not that important.

11:44.960 --> 11:50.200
Another thing is that I've seen over the years many things and I think it's something is

11:50.200 --> 11:54.440
written in shell and it's a complicated program and it probably shouldn't be.

11:54.440 --> 12:00.240
It should be easy to do the right thing but tooling should also make it difficult to do

12:00.240 --> 12:07.600
the bad thing, kind of steer people towards doing what's right and doing so out of the

12:07.600 --> 12:08.600
box.

12:08.600 --> 12:13.960
Documentation is obviously also important and many people avoid writing documentation.

12:13.960 --> 12:19.680
I understand them because I'm also guilty of this in many cases but yeah we should strive

12:19.680 --> 12:21.800
for a good documentation.

12:21.800 --> 12:24.560
There's also the question of systemd.

12:24.560 --> 12:30.600
I believe systemd is in many aspects not great but also it brought necessary change

12:30.600 --> 12:36.640
to Linux and there are basically many people and distributions who just stick their head

12:36.640 --> 12:45.120
into the sand and just avoid even considering that systemd might have brought some useful

12:45.120 --> 12:51.960
things and that it might kind of be also their fault that it has become so widely adopted.

12:51.960 --> 12:58.800
So we should develop good solutions to counter whatever systemd has come up with and basically

12:58.800 --> 13:02.000
always try to improve.

13:02.000 --> 13:05.920
Now let's take a look at how a bsd system is developed.

13:05.920 --> 13:11.280
Usually you have your entire system in a single tree and a single repository typically sbn

13:11.280 --> 13:16.360
and so on and you have lots of different components in this repository.

13:16.360 --> 13:21.600
It's a complete system capable of boot so if you invoke the central makefile and compile

13:21.600 --> 13:26.080
the system you generally compile your kernel and compile your user lines and if you put

13:26.080 --> 13:29.360
it together you will get a system which is capable of booting.

13:29.360 --> 13:35.360
And third party software which is not required for the base system is distributed through

13:35.360 --> 13:37.120
some kind of port system.

13:37.120 --> 13:42.520
Of course this doesn't mean that there are no third party components in a base of the

13:42.520 --> 13:49.920
bsd system because I'm not aware of any bsd system which is developing a complete replacement

13:49.920 --> 13:52.640
for the toolchain for example.

13:52.640 --> 13:59.440
You have your lvm or whatever in base and usually it has its own built system integrated

13:59.440 --> 14:04.040
with the existing makefiles but it's a single tree.

14:04.040 --> 14:07.520
Now let's contrast it to a linux distribution.

14:07.520 --> 14:11.800
In a linux distribution it's a collection of software from many different parties which

14:11.800 --> 14:14.880
are separate packages.

14:14.880 --> 14:18.440
And you have linux kernel as the base layer that's always the case otherwise it wouldn't

14:18.440 --> 14:20.640
be a linux distribution.

14:20.640 --> 14:24.920
You have your user line tooling which is often supplied by GNU and you have the libc which

14:24.920 --> 14:28.560
is also often supplied by GNU glpc.

14:28.560 --> 14:33.520
And you have the toolchain to build all this so it's also from GNU because while client

14:33.520 --> 14:37.240
is used for some distributions not too many of them.

14:37.240 --> 14:42.480
And you have the service manager and also some auxiliary tooling around to the service

14:42.480 --> 14:47.160
manager so that's often system D nowadays.

14:47.160 --> 14:53.760
This is tied together with a package manager which handles installing and removing and

14:53.760 --> 14:54.760
so on.

14:54.760 --> 15:00.600
And sometimes you have some of the components always and then you can install or remove

15:00.600 --> 15:02.080
whatever you want.

15:02.080 --> 15:07.600
And linux plus gcc plus glpc plus corutals find utils if utils so on.

15:07.600 --> 15:11.720
It makes GNU linux or what is called GNU linux.

15:11.720 --> 15:18.080
This exists to make sure that all these components work together and they combine well because

15:18.080 --> 15:22.880
many different distributions combine them in different ways and they have different

15:22.880 --> 15:27.600
versions of these components and they all have to play nice.

15:27.600 --> 15:35.200
So the linux kernel has a rule of never breaking user space if a new version of linux kernel

15:35.200 --> 15:37.620
results in a binary not working.

15:37.620 --> 15:44.720
It means it's a bug in the kernel even if it was for example originally an unintended

15:44.720 --> 15:50.120
behavior so this can be kind of a pain.

15:50.120 --> 15:51.800
But let's get back to chimera.

15:51.800 --> 15:54.200
So starting out the toolchain.

15:54.200 --> 15:59.920
LLVM and linux is pretty seamless nowadays most of the time.

15:59.920 --> 16:05.280
You have it available on most linux systems but on most linux systems it's sort of a different

16:05.280 --> 16:10.320
arrangement because you do not have LLVM provide the runtime.

16:10.320 --> 16:13.440
Gcc provides this and it's called libGcc.

16:13.440 --> 16:20.680
It's mostly ABI compatible with libunwind from LLVM but it also includes some of these

16:20.680 --> 16:25.800
built ins which are provided via a separate library in LLVM.

16:25.800 --> 16:31.480
LLVM comes with its own runtime called compiler RT and this is used in chimera instead of

16:31.480 --> 16:33.960
libGcc.

16:33.960 --> 16:40.000
For the C library we use muscle because it's a proven good implementation of a C library

16:40.000 --> 16:45.480
which is used by several distributions already and you can make most software work on it

16:45.480 --> 16:53.800
just fine with maybe with a few patches but better than other libcs.

16:53.800 --> 17:00.680
When you have GNU toolchain you usually have GNU Benu tools to complement Gcc as well as

17:00.680 --> 17:04.600
Lv tools to provide lib else.

17:04.600 --> 17:09.040
Benu tools provides things like linker because Gcc does not come with its own linker.

17:09.040 --> 17:13.960
It also provides different tools which are used together with the compiler things like

17:13.960 --> 17:19.880
erkiver and read else and this kind of stuff.

17:19.880 --> 17:26.280
In chimera this is the LLD from LLVM is used as a linker and it's used everywhere.

17:26.280 --> 17:30.920
As for the other tooling which is provided by Benu tools, Lv toolchain provides this

17:30.920 --> 17:36.040
tooling and this is also used on FreeBSD to provide these tools.

17:36.040 --> 17:42.160
Lv toolchain also provides libelse implementation which replaces the one provided by Lv tools.

17:42.160 --> 17:47.640
Libelse is used in many places but for example the kernel requires it.

17:47.640 --> 17:52.280
LLVM also provides most of these tools which are provided by libutils.

17:52.280 --> 17:56.320
They have a prefix LLVM so for example LLVM read else.

17:56.320 --> 18:02.760
We do not use those in the core system most of the time.

18:02.760 --> 18:08.640
So now to sort out the core user want you have many GNU components as well as non GNU

18:08.640 --> 18:12.640
components things like core utils, find utils, defutils and so on.

18:12.640 --> 18:17.800
You have util linux also which is used by pretty much all distributions and provides sort of

18:17.800 --> 18:21.840
a mixture of tools for all sorts of stuff.

18:21.840 --> 18:29.440
In non GNU distros existing ones such as Alpine you often have Busybox which is a sort of

18:29.440 --> 18:36.320
single binary which can be configured to include many different tools which are otherwise provided

18:36.320 --> 18:39.920
by core utils and so on as well as by util linux.

18:39.920 --> 18:45.200
The main strength of Busybox is that it's a single binary so you can put it in embedded

18:45.200 --> 18:48.920
environments and we can have things mostly work.

18:48.920 --> 18:53.320
But the other side of the coin is that it's very Spartan when it comes to functionality

18:53.320 --> 18:56.440
and the code is also not very good.

18:56.440 --> 19:01.320
But the other alternatives are usually even worse in terms of available functionality.

19:01.320 --> 19:08.440
So FreeBSD tools are the answer here and that's what we've done.

19:08.440 --> 19:13.680
I found this third party port of FreeBSD's tools called BSD utils.

19:13.680 --> 19:21.440
It was a sort of incomplete experimental thing which was not quite ready for an actual system.

19:21.440 --> 19:25.280
So I helped complete it and reach parity with core utils.

19:25.280 --> 19:31.240
I fixed many bugs which were created during porting in the process.

19:31.240 --> 19:36.720
I also ported many other tools to expand coverage and the result is Karmira utils which the

19:36.720 --> 19:45.000
distro currently manages and it's sort of a single easy to build package which includes

19:45.000 --> 19:48.220
all of the tooling you want.

19:48.220 --> 19:55.720
And this replaced not just GNU tooling but also for example a portion of util linux which

19:55.720 --> 20:00.840
makes things much easier for the distribution especially in terms of bootstrapping because

20:00.840 --> 20:06.640
for example in void linux a nxb-psrc which is the build system which is similar to C

20:06.640 --> 20:11.520
build you have stripped down version of util linux in the base build container and you

20:11.520 --> 20:16.400
need this because some of these tools are necessary.

20:16.400 --> 20:23.000
But this means bootstrap problem because when you build a full version of util linux you

20:23.000 --> 20:28.240
have many dependencies which you do not want during bootstrapping of your system.

20:28.240 --> 20:33.120
For example udef or that kind of stuff which you really don't want to pull in.

20:33.120 --> 20:36.920
So it has a stripped down version of util linux for that and then it has a full version

20:36.920 --> 20:40.040
which is built separately and it's kind of a mess.

20:40.040 --> 20:45.240
If we have a single package for the user run all of this can be avoided and then only a

20:45.240 --> 20:50.960
partial build of util linux can be built if needed.

20:50.960 --> 20:57.480
Karmira tools is lean enough for better environments things like init ramfs or even embedded things.

20:57.480 --> 21:04.360
But at the same time it's fully featured enough to be used as interactive tooling so it's

21:04.360 --> 21:06.440
a nice all in one thing.

21:06.440 --> 21:12.920
And of course it helps break up the current monoculture of tooling as well as it's easy

21:12.920 --> 21:14.240
to harden.

21:14.240 --> 21:21.960
For example Karmira tool utilizes client control flow integrity hardening which can be enabled

21:21.960 --> 21:27.080
on Karmira tools very easily and it just works.

21:27.080 --> 21:29.240
Now to get the kernel sorted out.

21:29.240 --> 21:35.720
These two photos one is Karmira running on the MNT reform laptop and the other is running

21:35.720 --> 21:39.420
on Raspberry Pi 3.

21:39.420 --> 21:44.020
The kernel is mostly compatible with client these days and some patches are needed to

21:44.020 --> 21:49.000
support BSD utilities as well as the lip else from L-Toolchain.

21:49.000 --> 21:53.760
I would like to eventually upstream these things and make sure things work out of box.

21:53.760 --> 22:00.560
Until recently there was an issue with the option to use client's internal assembler.

22:00.560 --> 22:07.040
It did not work on some architectures notably 64 bit power because of some legacy debugging

22:07.040 --> 22:08.480
for nonsense.

22:08.480 --> 22:14.880
So GNU binutils was used for that until sometime but nowadays it's not a problem and the client

22:14.880 --> 22:18.120
assembler just works for every architecture.

22:18.120 --> 22:21.620
CKMS.

22:21.620 --> 22:23.480
What is CKMS?

22:23.480 --> 22:29.160
distros usually use a DKMS which stands for dynamic kernel module system to build out

22:29.160 --> 22:35.920
of three kernel modules and it's a massive 5K inline bash script and it has functionality

22:35.920 --> 22:40.640
which seemed like a good idea at the time and nobody uses it and it no longer seems

22:40.640 --> 22:42.440
like a good idea for example.

22:42.440 --> 22:47.400
DKMS can package kernel modules and you can distribute them and of course this doesn't

22:47.400 --> 22:52.040
work because every distro has its own kernel and it can result in slight differences in

22:52.040 --> 22:55.760
ABI and so on so you cannot really do that.

22:55.760 --> 23:00.760
I created CKMS which stands for chimeric kernel module system and it's kind of similar to

23:00.760 --> 23:06.960
DKMS but it's much more lightweight, more robust, it's implemented in Python.

23:06.960 --> 23:11.320
It has privilege separation so when you have your package manager build a kernel module

23:11.320 --> 23:16.120
in a hook during installation and you run your package manager through it, it will properly

23:16.120 --> 23:20.600
drop privileges so it does not run the whole compilation of the module through it which

23:20.600 --> 23:25.600
also happens with DKMS and most setups.

23:25.600 --> 23:30.240
Now for the package manager that's an important thing in a distro.

23:30.240 --> 23:37.560
I considered the FreeBSD package manager at some point but it was not in quite the shape

23:37.560 --> 23:39.480
I would like for production.

23:39.480 --> 23:46.280
I did contribute back some patches to fix a bunch of things with muscle because that

23:46.280 --> 23:52.520
was the main thing which was really problematic and I got it working but there are things

23:52.520 --> 24:02.240
such as version expressions and the version string stuff which is a work in progress and

24:02.240 --> 24:09.560
it's quite obvious that it's mainly all geared towards FreeBSD issues right now.

24:09.560 --> 24:15.840
Eventually I ended up investigating APK from Alpine Linux which ended up proving to be

24:15.840 --> 24:18.400
a great fit.

24:18.400 --> 24:23.520
For one it's lightweight but it's also fairly powerful and I really like its virtual package

24:23.520 --> 24:25.360
system.

24:25.360 --> 24:31.680
It handles things like shared libraries very seamlessly where shared libraries in packages

24:31.680 --> 24:38.680
are provided basically as virtual packages and this makes it easily searchable, easy

24:38.680 --> 24:40.840
for the solver and so on.

24:40.840 --> 24:46.400
I eventually transitioned to APK tools version 3 which is the next generation of APK which

24:46.400 --> 24:53.520
is currently not used by Alpine and it does not have a stable roof yet but it works great.

24:53.520 --> 24:58.280
The main difference in APK 3 is that it no longer uses starballs as packages.

24:58.280 --> 25:07.720
It has a new custom sort of structured format which should help with avoiding vulnerabilities

25:07.720 --> 25:10.520
in the package manager.

25:10.520 --> 25:17.640
By summer 2021 it was fully integrated in C-built and it just worked.

25:17.640 --> 25:22.520
Service management is another big thing you need to boot Linux distribution.

25:22.520 --> 25:28.360
Many options were evaluated in the process for example Runit which is used by Void Linux,

25:28.360 --> 25:37.400
S6 which is a new kid on the block, OpenRC which is classic and built on the same principles

25:37.400 --> 25:39.600
as classic RC systems.

25:39.600 --> 25:45.880
In the end I ended up choosing Dynit which is a new service manager.

25:45.880 --> 25:51.240
I chose it because it's both powerful and lean.

25:51.240 --> 26:00.280
It's implemented in modern C++ so it's also safer than most other service managers.

26:00.280 --> 26:06.720
Most importantly it took me about one afternoon to get it fully working and get the system

26:06.720 --> 26:11.680
from not booting at all to having it completely booting.

26:11.680 --> 26:20.040
It's supervising which means most demons are supervised by the service manager by running

26:20.040 --> 26:24.120
on the foreground and being basically child processes of the service manager.

26:24.120 --> 26:28.200
But you can have background processes as well.

26:28.200 --> 26:31.840
It's less robust so it should be avoided most of the time.

26:31.840 --> 26:38.920
It's dependency based so it can ensure that your services start in correct order.

26:38.920 --> 26:44.600
It has support for things like one shots which help immensely during early boot because most

26:44.600 --> 26:48.960
things you need to do during early boot is basically things you run once and they do

26:48.960 --> 26:51.720
not have any sort of persistent process.

26:51.720 --> 26:54.600
So the early boot process is full of one shots.

26:54.600 --> 27:02.200
For example, void Linux solves it by making these one shots a bunch of sequential shell

27:02.200 --> 27:06.680
scripts which are run before the actual services are running.

27:06.680 --> 27:10.640
It's not a great solution because it's not very flexible.

27:10.640 --> 27:14.520
In any case it's a good base for a solid service infrastructure.

27:14.520 --> 27:19.600
We have a custom suite of core services for Dynit written from scratch.

27:19.600 --> 27:23.960
It has full support for fine grained targets.

27:23.960 --> 27:32.440
Basically a target is a logical service which does not do anything by itself except act

27:32.440 --> 27:35.120
as some sort of sentinel.

27:35.120 --> 27:41.640
You can for example have networked as target and then you can have other things say I want

27:41.640 --> 27:47.720
to start before this and then you can make sure that or I want to start after this.

27:47.720 --> 27:56.000
You can make sure that your services start only after network is up for example.

27:56.000 --> 28:00.360
It also has first class support for user services which is very important and I'll get to that

28:00.360 --> 28:02.040
later.

28:02.040 --> 28:07.840
The eventual goal is to have all long running processes be services.

28:07.840 --> 28:11.640
And there's also the matter of session tracking which I'll describe in a bit.

28:11.640 --> 28:15.240
Now this is a new project that I came up with.

28:15.240 --> 28:21.840
It's called turnstile and it's an answer to the login part of system D.

28:21.840 --> 28:25.760
Let's mostly use this system D login D for session tracking.

28:25.760 --> 28:32.720
What that does is basically know when a user has logged in or when a user has logged in

28:32.720 --> 28:37.400
on another console and it also knows when the user has logged out and it can be used

28:37.400 --> 28:41.520
by say desktop environments in many different ways.

28:41.520 --> 28:46.160
This E login D which exists as a standalone version which is basically just ripped away

28:46.160 --> 28:55.800
from system D and the dependencies are stopped out and it's sort of dirty and not great.

28:55.800 --> 29:02.360
This is done by basically running a daemon which is called login D and a module in the

29:02.360 --> 29:07.320
PAM infrastructure which is obviously used for authentication.

29:07.320 --> 29:11.160
The PAM module basically lets the daemon know when a new session has started and it also

29:11.160 --> 29:15.240
lets it know when a session has ended.

29:15.240 --> 29:20.180
This plus seed management which E login D also does but this is not widely used because

29:20.180 --> 29:21.880
usually you only have one seed.

29:21.880 --> 29:27.320
This is used by desktop environments especially things like Wayland compositors.

29:27.320 --> 29:35.120
With system D most importantly also have login D also spawn a user session of system D basically

29:35.120 --> 29:40.240
which acts as just like normal service manager but it runs as your user and it runs Caesar

29:40.240 --> 29:41.240
services.

29:41.240 --> 29:49.000
E login D cannot do this because it has no idea what other init system or what user service

29:49.000 --> 29:50.280
manager you might be running.

29:50.280 --> 29:53.920
So this functionality is removed and there's no way to access it.

29:53.920 --> 29:58.640
This is one of the reasons why I developed this.

29:58.640 --> 30:05.960
It aims to eventually replace E login D and it was originally created just to manage those

30:05.960 --> 30:09.080
user instances of init.

30:09.080 --> 30:15.120
The issue with that when running this in parallel with E login D was that sometimes it needs

30:15.120 --> 30:20.800
to know something which E login D knows but sometimes E login D also needs to know something

30:20.800 --> 30:22.920
the user service manager knows.

30:22.920 --> 30:26.720
It especially affects things like lingering for example.

30:26.720 --> 30:33.700
You can enable specific user to linger which means those user services will stay up even

30:33.700 --> 30:36.720
after you have fully logged out.

30:36.720 --> 30:43.480
E login D manages your runtime directory for you which is used by many services and upon

30:43.480 --> 30:46.200
log out it removes this runtime directory.

30:46.200 --> 30:51.640
If you have still some user services running and E login D has removed your service directory

30:51.640 --> 30:54.160
then things go wrong.

30:54.160 --> 30:59.600
So it needs to be integrated and I plan to eventually fully replace login D.

30:59.600 --> 31:04.600
It turns out does not manage seats because there's already a project called libseat and

31:04.600 --> 31:07.760
CTD which can do this satisfactorily.

31:07.760 --> 31:13.680
But libseat does not do the session tracking so they can be used together and I plan to

31:13.680 --> 31:16.440
provide a library alongside the daemon.

31:16.440 --> 31:19.160
This library will provide agnostic API.

31:19.160 --> 31:22.920
This API will have multiple back ends and it will have a back end for login D, it will

31:22.920 --> 31:28.240
have a back end for turn style D as well as potentially other solutions and then things

31:28.240 --> 31:36.040
like desktops will be able to use this and be actually portable because for example right

31:36.040 --> 31:43.160
now to have GNOME for on free BSD for example it needs many patches to replace this functionality

31:43.160 --> 31:45.600
and it's just not great.

31:45.600 --> 31:50.980
Having an agnostic API which is not provided by system D would be much nicer solution.

31:50.980 --> 31:55.980
Of course I also have to convince up frames to adopt it.

31:55.980 --> 32:02.480
One thing which you do if turn style is managing the bus session, bus as a user service, this

32:02.480 --> 32:08.520
has an advantage because you have a single session bus per user just like is done when

32:08.520 --> 32:13.440
you have system D. Well why have a single session bus?

32:13.440 --> 32:16.240
This session bus has a socket.

32:16.240 --> 32:20.240
The socket is somewhere on the file system and the socket is used to identify other things

32:20.240 --> 32:22.480
on the bus.

32:22.480 --> 32:28.360
The way to locate this session bus is provided via environment variable.

32:28.360 --> 32:32.640
So if you have the environment variable in your environment then things can use this

32:32.640 --> 32:35.880
to read the path and actually locate the socket.

32:35.880 --> 32:43.240
Traditionally you had the session bus started by for example your X11 script, Xinit RC which

32:43.240 --> 32:47.240
would run something like D bus run session something.

32:47.240 --> 32:53.840
That means the session bus was only available within your single graphical DTY.

32:53.840 --> 32:57.640
This is not great because when you switch console and log in there and you want to run

32:57.640 --> 33:00.920
something which needs to access the session bus it doesn't know about it.

33:00.920 --> 33:02.080
System D solves this.

33:02.080 --> 33:07.320
We also solve this by running the session bus as a user service.

33:07.320 --> 33:10.820
So when you first log in it automatically spawns the session bus.

33:10.820 --> 33:17.840
When you last log out it stops the session bus and it's available on every single Vt.

33:17.840 --> 33:21.480
This has also limitless potential for other user services.

33:21.480 --> 33:27.240
We can do things like D bus activation without having D bus spawn the services themselves.

33:27.240 --> 33:32.360
It's currently also used for the sound server for example with pipewire.

33:32.360 --> 33:34.840
Now let's move on to C build.

33:34.840 --> 33:47.160
C build is basically a build system for seaports as I already know.

34:04.840 --> 34:11.560
This is what a template might look like.

34:11.560 --> 34:15.900
This is the template to build Doom game.

34:15.900 --> 34:18.080
As you can see it's mostly metadata.

34:18.080 --> 34:21.320
There's one hook in there which runs W

34:21.320 --> 34:24.480
which has no other way to do this.

34:24.480 --> 34:31.860
There's a build style for configure script which basically strips away all the non-decorative

34:31.860 --> 34:34.320
things you would otherwise need.

34:34.320 --> 34:39.280
How C build works is that it builds all the software in a simple container called the

34:39.280 --> 34:41.800
build root in our terminology.

34:41.800 --> 34:45.000
It's minimized chimera system.

34:45.000 --> 34:50.160
There's some packages which provide a baseline and your build dependencies which are specified

34:50.160 --> 34:53.560
by the template are also installed into this container.

34:53.560 --> 34:58.680
This container is fully unprivileged so you don't need to run anything as root and it's

34:58.680 --> 34:59.760
fully sandboxed.

34:59.760 --> 35:03.920
This is done by with Linux namespaces.

35:03.920 --> 35:09.600
The container is also read only after the build dependencies are installed which means

35:09.600 --> 35:16.320
no package built can actually change anything in the container otherwise other than in its

35:16.320 --> 35:18.400
own build directory.

35:18.400 --> 35:24.240
It also has no network access after all the fetch stage things are done.

35:24.240 --> 35:28.240
It has no access to the outside system.

35:28.240 --> 35:29.240
Templates are also declarative.

35:29.240 --> 35:34.520
As I said, ideally just metadata and it has fully transparent support for cross compiling

35:34.520 --> 35:39.160
with most build systems which means in most templates you don't need to do anything and

35:39.160 --> 35:43.280
it will be able to cross compiling without any additional effort.

35:43.280 --> 35:45.960
It has a clean handling of common build systems.

35:45.960 --> 35:51.000
This includes configure script, mass and CMake and so on.

35:51.000 --> 35:52.000
It's strict.

35:52.000 --> 35:58.720
It has mandatory linting hooks for many things and unit tests where possible will run out

35:58.720 --> 35:59.720
of box.

35:59.720 --> 36:03.920
I strongly believe that being strict by default is good because you can always make things

36:03.920 --> 36:07.840
more loose if you need it but if you have things loose by default and then you need

36:07.840 --> 36:13.080
to strengthen them and you have many hundreds to thousands of packages and you need to adjust

36:13.080 --> 36:17.600
every single one of them it becomes effort which cannot be done because it's just too

36:17.600 --> 36:19.000
much.

36:19.000 --> 36:24.680
It has support for things like bulk builds where it can properly order things in the

36:24.680 --> 36:30.600
batch to build without having dependency ordering issues.

36:30.600 --> 36:36.320
It can check upstream projects for new versions and so on.

36:36.320 --> 36:37.800
Build flags.

36:37.800 --> 36:43.680
All the basic stuff for hardening which Linux and service typically use like Fortify, position

36:43.680 --> 36:48.320
independent executables, stack entries and so on are used.

36:48.320 --> 36:52.240
On top of that we use system wide LTO for practically every package.

36:52.240 --> 36:57.920
I think there's only about 30 templates out of close to a thousand which have LTO disabled

36:57.920 --> 36:59.400
for different reasons.

36:59.400 --> 37:03.240
In some cases it could be enabled but it's not worth it.

37:03.240 --> 37:09.360
We do utilize a system wide subset of undefined behavior sanitizer.

37:09.360 --> 37:16.720
It deals with things like trapping signed integer overflows in order to avoid potential

37:16.720 --> 37:18.360
problems.

37:18.360 --> 37:23.280
Also CFI or control flow integrity is used for many packages.

37:23.280 --> 37:26.160
It cannot be used for all because it breaks on a lot of stuff.

37:26.160 --> 37:30.920
It's very strict when it comes to typing of functions but it's still used on a couple

37:30.920 --> 37:34.720
hundred packages.

37:34.720 --> 37:36.800
The allocator.

37:36.800 --> 37:44.000
We now use the scudo allocator from LLVM which is also used for example on Google Android.

37:44.000 --> 37:47.060
It replaces the allocator in muscle.

37:47.060 --> 37:52.000
This is not because of hardening because muscle allocator is already hardened but scudo is

37:52.000 --> 37:53.720
also hardened allocator.

37:53.720 --> 37:58.200
But it has significantly better multi-threaded performance because muscle malloc ng uses

37:58.200 --> 38:00.100
a single global lock.

38:00.100 --> 38:07.560
This is a trade-off but it also means that the stock allocator in muscle performs poorly

38:07.560 --> 38:13.720
in many things and it's something people commonly complain about so we now rely on scudo.

38:13.720 --> 38:19.760
This is also the advantage of being able to eventually deploy GWP asan which is sort of

38:19.760 --> 38:27.120
sampling runtime version of address sanitizers which can catch many memory errors at runtime

38:27.120 --> 38:29.520
with minimal performance overhead.

38:29.520 --> 38:34.200
This is not enabled yet but it will be at some point.

38:34.200 --> 38:35.640
Other core things for this row.

38:35.640 --> 38:37.560
Some tooling is taken from Debian.

38:37.560 --> 38:44.080
For example we use initramfs tools to generate initramfs images because other solutions were

38:44.080 --> 38:46.840
generally found to be unsatisfactory.

38:46.840 --> 38:51.640
For example requiring bash for the hooks and so on.

38:51.640 --> 38:55.940
Initramfs tools is very clean and simple and nice to work with.

38:55.940 --> 39:00.560
We also use console setup from Debian to do console and keyboard configuration as well

39:00.560 --> 39:04.880
as the script for handling encrypted drives.

39:04.880 --> 39:09.840
I also had to add some other things like the GRAP bootloader support for ZFS.

39:09.840 --> 39:15.280
We now support root on ZFS very easily and so on.

39:15.280 --> 39:19.360
This is Kaimira desktop on RISC-V.

39:19.360 --> 39:23.360
You can see it runs things like Firefox for example which it does not build out of books

39:23.360 --> 39:25.240
but I made it work.

39:25.240 --> 39:30.560
This is on the high-five unmatched board from C5.

39:30.560 --> 39:35.240
When I was starting to add to the desktop, the first thing I added was the Western Wayland

39:35.240 --> 39:37.120
Composter as well as GTK.

39:37.120 --> 39:42.480
This sort of provided a baseline set of dependencies which are also used by pretty much everything

39:42.480 --> 39:43.480
else.

39:43.480 --> 39:50.040
Then I expanded with Exodorq stack, things like the Enlightenment Window Manager as well

39:50.040 --> 39:53.560
as PEGWM for a simple X11 Window Manager.

39:53.560 --> 40:00.000
I added the multimedia stack including FFmpeg, Gstreamer, media players and so on.

40:00.000 --> 40:06.480
In Spring 2022 I added GNOME desktop which is the default choice but of course you can

40:06.480 --> 40:08.400
use anything else you want.

40:08.400 --> 40:13.680
I also added web browsers, this includes Epiphany which comes with GNOME and is built on WebKit

40:13.680 --> 40:17.000
and Firefox which is alternative choice.

40:17.000 --> 40:20.920
And of course some games.

40:20.920 --> 40:25.720
As I said before I would like to release an alpha version in late February or early March.

40:25.720 --> 40:29.600
I'm not sure if this will happen but I hope it will.

40:29.600 --> 40:33.520
Before doing this I would like to perform a complete world rebuild of all the packages

40:33.520 --> 40:39.320
because I have introduced some things in C-Bilt which I would like to propagate it into existing

40:39.320 --> 40:40.960
packages and it's not.

40:40.960 --> 40:45.600
So just to be clean I would like to build everything with LVM 15 as it is right now

40:45.600 --> 40:49.120
and basically then release the alpha.

40:49.120 --> 40:51.520
I will need to launch automatic built infrastructure.

40:51.520 --> 40:57.640
I currently have a server in Kolo in my city but it's not on public network yet so I need

40:57.640 --> 41:03.760
to set up the public network and launch things like this as well as CI.

41:03.760 --> 41:09.840
I would like to clean up the remaining fallout from the recent hardening stuff as well as

41:09.840 --> 41:13.680
update every template to its latest version.

41:13.680 --> 41:18.880
And after alpha which is the alpha cycle is expected to take about half a year to one

41:18.880 --> 41:24.620
year I would like to add libGCC compatibility shim so we can run existing binaries because

41:24.620 --> 41:29.560
right now you cannot run existing binaries because the system runtime is different.

41:29.560 --> 41:36.080
I would like to add support for the bus activation so the bus does not run demons by itself through

41:36.080 --> 41:43.240
the bus service files but instead delegate it to the service manager.

41:43.240 --> 41:49.080
I would like to investigate additional hardening things like LVM save stack and I would like

41:49.080 --> 41:50.560
to improve the documentation.

41:50.560 --> 41:56.440
Right now there's the beginning of Chimera handbook which includes some handy basic information

41:56.440 --> 42:02.760
like installation and how to set up encrypted writes and so on but it can always use more

42:02.760 --> 42:07.400
documentation and local support is also another thing I would like to expand to this is the

42:07.400 --> 42:13.180
problem in pretty much all muscle distros with the local support being sort of limited

42:13.180 --> 42:19.440
and you can have translations but things like formats and so on.

42:19.440 --> 42:25.520
So the conclusion we are currently nearing usability and it should be suitable for early

42:25.520 --> 42:27.040
adapters by March.

42:27.040 --> 42:32.520
I would like to get all the major changes done by beta and continue packaging more software

42:32.520 --> 42:38.200
as well as cooperate with upstreams including the free BSD upstream on sensing fixes and

42:38.200 --> 42:40.720
tooling and so on.

42:40.720 --> 42:44.960
In any case thank you for listening and if you have any questions you can ask them out

42:44.960 --> 42:51.960
of course we also have stickers so come pick them up.

42:51.960 --> 42:55.320
Yeah.

42:55.320 --> 43:07.960
Yeah, as I said it's supported.

43:07.960 --> 43:11.280
I recently introduced it and I recently tested it.

43:11.280 --> 43:12.280
Oh yeah.

43:12.280 --> 43:13.280
Sure.

43:13.280 --> 43:16.040
So it's only thing if ZFS on the root is supported.

43:16.040 --> 43:17.600
Yeah, it's supported.

43:17.600 --> 43:25.960
It uses the upstream scripts for any time of tools just patched to support the user

43:25.960 --> 43:30.280
and because we don't use busy box and it just works.

43:30.280 --> 43:37.200
We also provide ZFS packages with precompiled binary modules so it's not necessarily compiled

43:37.200 --> 43:40.120
from source during installation.

43:40.120 --> 43:45.800
And CKMS can handle things in a non-conflicting way so if you have the package installed for

43:45.800 --> 43:51.560
the stock kernel which provides the binary ZFS modules, CKMS will not try to build the

43:51.560 --> 43:53.560
modules again.

43:53.560 --> 43:54.560
Yeah.

43:54.560 --> 43:57.560
What are the target user segments for this distribution?

43:57.560 --> 44:04.720
For example at home I use gel, I have to use Ubuntu and...

44:04.720 --> 44:05.720
Okay.

44:05.720 --> 44:09.280
Well, the question was if...

44:09.280 --> 44:11.760
What's the target audience basically?

44:11.760 --> 44:17.240
Well, I would say the primary audience is basically the same people who would use things

44:17.240 --> 44:18.920
like Gen 2 and so on.

44:18.920 --> 44:24.280
Basically power users who can find their way around things because there's no insistence

44:24.280 --> 44:29.800
on providing graphical clickable stuff for everything because it just wouldn't be possible.

44:29.800 --> 44:33.280
I just do not have the manpower to do all this.

44:33.280 --> 44:39.760
So yeah, it's for power users who can find their way around a simple system.

44:39.760 --> 44:41.320
Yeah.

44:41.320 --> 44:47.640
Where does the name come from?

44:47.640 --> 44:51.200
He was asking where does the name come from?

44:51.200 --> 44:57.960
Well, Chimera is basically like a mythical monster made up of three different animals

44:57.960 --> 45:00.840
so it should be fairly obvious where it comes from.

45:00.840 --> 45:04.760
We have Linux kernel and FreeBSD stuff and other stuff.

45:04.760 --> 45:05.760
Yeah.

45:05.760 --> 45:12.760
How do you work with upstream in particular against FreeBSD to provide a change in path

45:12.760 --> 45:13.760
to the...

45:13.760 --> 45:14.760
Okay.

45:14.760 --> 45:16.440
...change in some way might be useful?

45:16.440 --> 45:20.640
Yeah, the question was if I'm working with FreeBSD.

45:20.640 --> 45:24.680
I know the project has taken back some of the changes.

45:24.680 --> 45:29.960
I have some patches in Chimera tools which I do believe would be useful for upstream

45:29.960 --> 45:33.400
and yes, I do want to submit to them upstream.

45:33.400 --> 45:41.560
For example, I have a fix in the sort tool which fixes a crash with control flow integrity

45:41.560 --> 45:45.160
hardening so this would be nice to include for example.

45:45.160 --> 45:46.160
Yeah.

45:46.160 --> 45:47.160
Turns out the...

45:47.160 --> 45:48.160
How did you solve the problem of the PAM service program?

45:48.160 --> 45:49.160
The problem was the PAM service crashing before it can run the...

45:49.160 --> 45:50.160
Oh.

45:50.160 --> 46:00.520
...use C groups?

46:00.520 --> 46:05.360
Sorry, can you repeat?

46:05.360 --> 46:08.320
Those turnstile use C groups.

46:08.320 --> 46:10.600
Question is if turnstile uses C groups.

46:10.600 --> 46:11.680
No, it doesn't.

46:11.680 --> 46:12.680
It uses...

46:12.680 --> 46:14.760
It does the same thing as Log-in-D basically.

46:14.760 --> 46:20.760
This is a PAM module to report things and it keeps a persistent socket connection to

46:20.760 --> 46:27.280
the daemon as long as the session is active and then when the socket is closed and when

46:27.280 --> 46:32.880
the daemon receives basically a notification pulse on the socket and once it knows the

46:32.880 --> 46:36.560
connection has been closed then it closes the session inside of the daemon.

46:36.560 --> 46:37.560
Yeah.

46:37.560 --> 46:38.560
Follow up question.

46:38.560 --> 46:44.600
So you open a socket from the PAM service module?

46:44.600 --> 46:48.760
The question is if I open the socket from the PAM module.

46:48.760 --> 46:55.160
Yes, the PAM module opens a connection to the socket which is provided by the daemon

46:55.160 --> 47:00.000
and the daemon basically opens the socket in the system as a Unix domain socket and

47:00.000 --> 47:04.440
it's only accessible by root obviously so the PAM module access it.

47:04.440 --> 47:05.440
Yeah.

47:05.440 --> 47:06.440
Follow this is the last question.

47:06.440 --> 47:07.440
So if you open a socket from the PAM module that socket obviously ends up appearing as

47:07.440 --> 47:17.800
a file descriptor inside the program that ran the PAM.

47:17.800 --> 47:19.880
Does that not interfere with anything?

47:19.880 --> 47:23.600
Have you not found anything that closes for like...

47:23.600 --> 47:25.800
Because I have to try to do the same thing.

47:25.800 --> 47:31.920
The question is if the PAM module with the socket actually interferes with anything?

47:31.920 --> 47:36.960
No, I found it doesn't interfere with anything and in fact as far as I know Log-in-D does

47:36.960 --> 47:41.680
basically the same thing and other solutions for handling for example there are several

47:41.680 --> 47:49.560
solutions for handling for the runtime directory which is basically run user your UID and they

47:49.560 --> 47:56.080
basically did the same thing as far as I know but yeah as far as I can tell it works okay.

47:56.080 --> 47:57.080
Yeah.

47:57.080 --> 48:02.680
So first of all text to the job must be like really difficult to maintain all this dependence.

48:02.680 --> 48:03.680
Thank you.

48:03.680 --> 48:09.680
So my question is are you planning to integrate like in a specific SSL library like for example

48:09.680 --> 48:12.720
LibraSSL or like OpenSSL?

48:12.720 --> 48:17.320
Okay the question was about integrating SSL library.

48:17.320 --> 48:20.600
We do use OpenSSL version 3.

48:20.600 --> 48:27.440
This was actually a pretty big transition when it happened because many things do not

48:27.440 --> 48:30.120
or did not work well with OpenSSL 3.

48:30.120 --> 48:33.800
Unfortunately the amount of packages right now is not that huge.

48:33.800 --> 48:37.920
There are still some which do not work with OpenSSL 3 and which we do rely on.

48:37.920 --> 48:45.760
For example the Heimdall implementation of Kerberos which we use instead of MIT, GAR-B

48:45.760 --> 48:50.720
does not work with OpenSSL 3 yet but it has its own built-in crypto which can be used

48:50.720 --> 48:59.320
instead so we fall back on that for now.

48:59.320 --> 49:05.280
Anyone else?

49:05.280 --> 49:08.760
Looks like that's it then and thank you again.

49:08.760 --> 49:37.680
Thank you.
