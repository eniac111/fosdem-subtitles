1
0:00:00.000 --> 0:00:11.000
Next up we have Peter Smith who will talk about using LLVM to create embedded toolchains.

2
0:00:11.000 --> 0:00:16.200
Hello, my name is Peter and thank you all very much for staying up so late. It's almost

3
0:00:16.200 --> 0:00:23.320
bedtime. So I'll be here to talk about embedded toolchains using LLVM. So first thing I want

4
0:00:23.320 --> 0:00:27.720
to clarify is what do I actually mean by an embedded toolchain. Now as some of the people

5
0:00:27.720 --> 0:00:35.040
here earlier on were talking about sanitizers and we mentioned Yocto and embedded Linux.

6
0:00:35.040 --> 0:00:40.920
That's way too high level. This is basically for bare metal embedded systems. So yeah,

7
0:00:40.920 --> 0:00:45.640
so typical this is for those of you already know this, I'm sorry, but for those of you

8
0:00:45.640 --> 0:00:48.960
aren't necessarily familiar about what some of the differences are. So typically when

9
0:00:48.960 --> 0:00:55.100
you're developing on say Linux or Mac or Windows, whatever you're developing with the knowledge

10
0:00:55.100 --> 0:00:58.920
of an operating system. So when you implement your C library, you already know you can use

11
0:00:58.920 --> 0:01:02.560
system calls. You know, if you want to get some more memory, you ask the operating system,

12
0:01:02.560 --> 0:01:06.280
that type of thing. So by contrast on the embedded system, you don't have an operating

13
0:01:06.280 --> 0:01:11.080
system. You can ask for memory. So you basically have to roll part of that into the C library,

14
0:01:11.080 --> 0:01:15.320
that type of thing. So also when you're actually programming, you're programming on the device,

15
0:01:15.320 --> 0:01:19.840
you're actually running the program on embedded systems, you're cross compiling. That is one

16
0:01:19.840 --> 0:01:23.800
thing that is likely shared with Yocto and embedded Linux because quite often you're

17
0:01:23.800 --> 0:01:28.760
cross compile for speed on that one there. Typically you'll be static linking only because

18
0:01:28.760 --> 0:01:33.720
your either your your RTOS probably doesn't have a dynamic linker at that particular point.

19
0:01:33.720 --> 0:01:37.320
And your RTOS might actually just be a library that you link into your program, that type

20
0:01:37.320 --> 0:01:42.680
of thing. So yeah, so platform when you if you're on on the Linux, you might be using

21
0:01:42.680 --> 0:01:47.680
glib C that type of thing and that will be platform. And then you just use you when you

22
0:01:47.680 --> 0:01:51.200
have a tool chain, you might just need to provide a compiler and everything's there

23
0:01:51.200 --> 0:01:56.360
for you. Embedded systems, everything's just you have to do everything or yourself. I will

24
0:01:56.360 --> 0:02:00.440
mention one word there freestanding. So there is a definition in the C plus standard of

25
0:02:00.440 --> 0:02:04.520
what freestanding means. It's a little loose. It kind of says this is basically what the

26
0:02:04.520 --> 0:02:09.800
minimum you have to supply, but that's practically useless unless you want to write a full C

27
0:02:09.800 --> 0:02:15.560
plus plus stand implementation yourself. So in effect, what happens is that most embedded

28
0:02:15.560 --> 0:02:20.280
C libraries tend to roll half of an operating system into themselves, at least basically

29
0:02:20.280 --> 0:02:23.400
the minimum from there. So that's what we're sort of talking about by an embedded tool

30
0:02:23.400 --> 0:02:24.400
chain.

31
0:02:24.400 --> 0:02:30.840
OK, so this is the thing we already have embedded tool chains. What why do we need LLVM essentially

32
0:02:30.840 --> 0:02:34.200
at this particular point? So this is some of the reasons why you might actually want

33
0:02:34.200 --> 0:02:40.280
to use LLVM over say something like GCC. So first of all, clang is kind of a natural cross

34
0:02:40.280 --> 0:02:46.360
compiler. So you don't actually have to say, gather GCC for arm GCC for S5 GCC for a out

35
0:02:46.360 --> 0:02:52.320
of 64. You just have one clang. Now that is quite useful if you're a team where you don't

36
0:02:52.320 --> 0:02:56.800
want to use different compilers, different installations. That's I guess more administrative

37
0:02:56.800 --> 0:03:01.600
more than anything, but it can be a benefit on some places. So code generation can also

38
0:03:01.600 --> 0:03:07.400
be more mature. And I will say be safe of fairness, sometimes less mature than GCC,

39
0:03:07.400 --> 0:03:12.240
for example. So when my is it obviously for somebody who works for arm or my examples

40
0:03:12.240 --> 0:03:15.600
of a mom just because that's what I know. But I'm sure there are similar sort of things

41
0:03:15.600 --> 0:03:23.640
on other architectures as well. So an example here, V8.1n, which is one of arms most recent

42
0:03:23.640 --> 0:03:31.480
sort of CPUs for embedded systems, has got a vector extension. And basically, clang has

43
0:03:31.480 --> 0:03:35.760
got better support for auto vectorization for this than GCC, just simply because the

44
0:03:35.760 --> 0:03:39.160
work was done earlier, that type of thing. But that's just one of the examples where

45
0:03:39.160 --> 0:03:42.080
if you've got that particular target, you might want to use that. Whereas if you've

46
0:03:42.080 --> 0:03:47.520
got a different target, GCC might be better at the moment. Other thing is taking advantage

47
0:03:47.520 --> 0:03:51.720
of some of the tooling that clang provides. So I'm going to go into in the next few slides

48
0:03:51.720 --> 0:03:56.240
how you might be able to use some of the sanitizers. I know we kind of said in the early bit this

49
0:03:56.240 --> 0:04:01.560
morning that we were talking particularly about MSAN and ASAN, that type of thing. And

50
0:04:01.560 --> 0:04:07.200
those typically have quite a high runtime component. But there are sanitizers that you

51
0:04:07.200 --> 0:04:11.680
can use without that. And I'll just go through a few of those here. And finally, you've got

52
0:04:11.680 --> 0:04:15.440
diversity of implementation. Running more compilers is almost always good. Compilers

53
0:04:15.440 --> 0:04:19.560
find different sets of bugs. And sometimes programs find different sets of compilers.

54
0:04:19.560 --> 0:04:24.480
Sorry? Yeah. I was working recently on safety critical application for train. Yeah. You

55
0:04:24.480 --> 0:04:29.520
actually have to implement several processes doing different things. Yeah. So having two

56
0:04:29.520 --> 0:04:34.040
different compilers is a good thing in that application. Yes, definitely. Yes. And certainly

57
0:04:34.040 --> 0:04:37.840
you can different programs find different compiler bugs as well. That sort of thing.

58
0:04:37.840 --> 0:04:43.320
So yeah. OK. So do you think sanitizers are embedded systems? So we kind of run through

59
0:04:43.320 --> 0:04:48.640
some of this earlier on today. So the main restriction of sanitizers is that it's not

60
0:04:48.640 --> 0:04:53.080
actually the code generation. It's actually the run times. So if you look at the runtime

61
0:04:53.080 --> 0:05:00.480
for ASAN, it's basically using a dynamic shared object to intercept the C library. It's got

62
0:05:00.480 --> 0:05:05.360
all sorts of bits that are kind of operating system dependent. But of course, in embedded,

63
0:05:05.360 --> 0:05:08.840
you don't have an operating system. So it's very hard as a tool chain vendor to provide

64
0:05:08.840 --> 0:05:14.680
a kind of bare metal thing that doesn't depend on one very specific example. But some of

65
0:05:14.680 --> 0:05:18.520
the sanitizers have a very minimal runtime. And some of these things you can use here.

66
0:05:18.520 --> 0:05:23.080
So I'm just going to go through some of these here right now. So the first one to use is

67
0:05:23.080 --> 0:05:28.320
the undefined behavior sanitizer. So by default, that does have a runtime. But all that runtime

68
0:05:28.320 --> 0:05:32.960
effectively doing is pretty printing a nice error. But if you don't care about pretty

69
0:05:32.960 --> 0:05:37.720
printing a nice error, you might not even have a printer. So at this particular case,

70
0:05:37.720 --> 0:05:43.320
then you can just say, OK, well, if there's undefined behavior in my program and someone's

71
0:05:43.320 --> 0:05:48.080
trying to attack me, maybe that's a bad thing. So maybe I just want to abort, say, for example,

72
0:05:48.080 --> 0:05:53.640
if I've gotten an out of range runtime. This particular example is just using a very standard

73
0:05:53.640 --> 0:05:59.240
integer overflow detection. And basically, look on there, all it's really doing is just

74
0:05:59.240 --> 0:06:04.320
saying check for overflow. If I overflow, branch to an undefined instruction that just

75
0:06:04.320 --> 0:06:09.080
happens to cause an abort on the processor, that type of thing. So yes, crash your program.

76
0:06:09.080 --> 0:06:13.560
There's also a minimal runtime. So there is a default implementation to the minimal runtime

77
0:06:13.560 --> 0:06:18.960
in compiler RT. You can't use that directly on an embedded system. But you can basically

78
0:06:18.960 --> 0:06:24.320
write your own. So instead of actually calling, well, going branching to an undefined instruction,

79
0:06:24.320 --> 0:06:28.440
it just calls a user defined function. And you can basically make that do whatever you

80
0:06:28.440 --> 0:06:34.280
want. There are ones for log and continue, and there's ones for log and terminate, that

81
0:06:34.280 --> 0:06:38.720
type of thing. But basically, the choice is yours. But those functions have got extremely

82
0:06:38.720 --> 0:06:43.920
trivial implementations that you can make work for an embedded system.

83
0:06:43.920 --> 0:06:49.240
Next one here is the kernel control flow integrity. And it's called KFCI. And I keep calling it

84
0:06:49.240 --> 0:06:53.840
KFC. I've even got this to write right around it. And it's actually, I think I've even got

85
0:06:53.840 --> 0:06:58.840
it wrong on the slide, which is embarrassing. I should actually be KCFI at that particular

86
0:06:58.840 --> 0:07:04.680
point. So there is a control flow sanitizer that can work with embedded systems right

87
0:07:04.680 --> 0:07:11.960
now. That's the sort of the full facts. I'll call it sanitizer. But that requires link

88
0:07:11.960 --> 0:07:17.440
time optimization. So the advantage of the kernel control flow integrity sanitizer is

89
0:07:17.440 --> 0:07:22.840
it doesn't need LTO, which makes which if anyone's tried to use LTO on embedded systems,

90
0:07:22.840 --> 0:07:26.920
it works until you've got a linker script. Certainly, we're a linker script that depends

91
0:07:26.920 --> 0:07:32.320
on placing things in different places. So yeah, so here's just a very trivial example

92
0:07:32.320 --> 0:07:35.360
of something that's just calling a floating point. And this just shows some of the code

93
0:07:35.360 --> 0:07:41.440
that's generated. So what we essentially have is this function pointer has a type. And you

94
0:07:41.440 --> 0:07:46.360
can basically make that into a signature. So what happens is we prefix at the top of

95
0:07:46.360 --> 0:07:51.320
the function with the signature. And then we basically load when we're sort of saying,

96
0:07:51.320 --> 0:07:55.600
well, let's load from this arbitrary function pointer. Well, let's check its signature.

97
0:07:55.600 --> 0:08:01.240
And then we'll check to see if it matches what we want. And if it doesn't, boom. So

98
0:08:01.240 --> 0:08:05.760
this doesn't, as far as I know, work on C++ tables at the moment. Obviously, this is implemented

99
0:08:05.760 --> 0:08:10.840
for the Linux kernel. So they don't care about C++. But if you're using C with function

100
0:08:10.840 --> 0:08:18.080
pointers, this is a relatively low cost way to get control flow integrity checking. So

101
0:08:18.080 --> 0:08:21.680
this is just some of the things that the components have embedded toolchain. I'm kind of jumping

102
0:08:21.680 --> 0:08:28.280
around here at the moment. So these are sort of things you would expect in a GCC embedded

103
0:08:28.280 --> 0:08:33.040
toolchain. And as you can see, Clang's actually, well, LLVM project. We've got pretty much

104
0:08:33.040 --> 0:08:38.520
all that we need in one place. We're only really missing a C library at the moment.

105
0:08:38.520 --> 0:08:41.600
So yeah, as we can go through some of the, I won't go through each individual thing in

106
0:08:41.600 --> 0:08:47.320
those titles, but you've got Clang, the compiler, you've got LLD, the linker, you've got implementations

107
0:08:47.320 --> 0:08:53.720
of Obsdump, read-elf, you've got implementations of the C++ runtime library. Yes, say what

108
0:08:53.720 --> 0:09:00.840
we're missing is a C library. So technically, GCC doesn't have a C library either. But there

109
0:09:00.840 --> 0:09:06.320
are hooks in the build system to basically build new lib in sort of multi-lib configurations

110
0:09:06.320 --> 0:09:12.520
at that point. LLVM is developing a C library. I would say at the moment, currently, it's

111
0:09:12.520 --> 0:09:17.000
sort of focused on what you would probably call desktop use cases. But they are planning

112
0:09:17.000 --> 0:09:20.880
to have sort of scalable implementations. So I think the end goal is that it will be

113
0:09:20.880 --> 0:09:25.480
able to cope with embedded systems, but I expect that to be some years down the line

114
0:09:25.480 --> 0:09:31.920
at the moment. So how would you actually assemble one of these building, basically assemble

115
0:09:31.920 --> 0:09:35.840
an LLVM toolchain from the LLVM project? And the honest answer is it's not as easy as it

116
0:09:35.840 --> 0:09:40.360
could be. Certainly when you're building a sort of a hosted toolchain, it's just, it's

117
0:09:40.360 --> 0:09:46.680
fairly easy. You just go to LLVM, CMake, Ninja, done. So actually building the tools is not

118
0:09:46.680 --> 0:09:50.440
difficult because they're all cross compilers. They're just all part of the default build.

119
0:09:50.440 --> 0:09:55.520
So if you want to get all the tools, very, very simple. Building the run times is a bit

120
0:09:55.520 --> 0:09:59.240
more difficult because you've got to cross compile the run times and you've got to do

121
0:09:59.240 --> 0:10:03.080
them in a particular order. Not all of them build in all of the things. So one of the

122
0:10:03.080 --> 0:10:07.600
big problems if you say try and buy a compiler, sorry, if you try and compile compiler RT,

123
0:10:07.600 --> 0:10:12.520
it'll fail because you've not got all of the, you know, it's kind of, if you try, it'll

124
0:10:12.520 --> 0:10:17.280
end up building the sanitizers and the sanitizers obviously have got dependencies on POSIX operating

125
0:10:17.280 --> 0:10:22.040
systems, which of course won't work. But you can say, for example, build the built-ins,

126
0:10:22.040 --> 0:10:28.280
which are kind of like the libGCC equivalent. So what we've done at Arm is to put together

127
0:10:28.280 --> 0:10:33.240
an embedded toolchain for Cortex-M, which is the sort of Arm's microcontroller range.

128
0:10:33.240 --> 0:10:38.800
And this is essentially a set of build scripts. It's all open source. And we're using the

129
0:10:38.800 --> 0:10:44.360
Pico libc at the moment as our C library. We did start with new lib, but we sort of moved

130
0:10:44.360 --> 0:10:50.880
on to Pico lib at that point, but you can make it work with new lib if you want to.

131
0:10:50.880 --> 0:10:55.960
So we've got, it's primarily just build scripts. It's not like got an LLVM project embedded

132
0:10:55.960 --> 0:11:02.480
on that. It will just go fetch LLVM from the actual source code. And yes, it's got a few

133
0:11:02.480 --> 0:11:10.160
samples for building some programs, that type of thing. So as I say, it's by Arm for Arm,

134
0:11:10.160 --> 0:11:14.120
but I'm sure if anybody wanted to apply it to a different microprocessor, they pretty

135
0:11:14.120 --> 0:11:20.720
much could, because it's essentially just a bit of CMake that you can adapt.

136
0:11:20.720 --> 0:11:26.400
So what's the usability of an LLVM toolchain like next to, say, the GNU-embedded toolchain,

137
0:11:26.400 --> 0:11:31.040
that type of thing? So one of the main things we're missing at the moment is multi-lib support.

138
0:11:31.040 --> 0:11:35.560
Now there are some multi-lib support for certain targets. So for example, I think there are

139
0:11:35.560 --> 0:11:40.880
some RISC-V multi-libs that are already in the bare metal driver, but that's not the

140
0:11:40.880 --> 0:11:45.280
case for Arm at the moment. I'll go on to what we're doing about that in a few slides

141
0:11:45.280 --> 0:11:53.360
time. Clang also doesn't have a direct equivalent of GCC specs files. So specs files are basically

142
0:11:53.360 --> 0:11:57.560
just fragments of command line, but they're not just raw command lines. They have got

143
0:11:57.560 --> 0:12:02.600
some intelligence and they can talk to each other and override defaults. So as an example

144
0:12:02.600 --> 0:12:08.360
here, that nano.spec and rdimon.spec, that says, give me newlib nano, which is the really

145
0:12:08.360 --> 0:12:12.680
small version of newlib. And rdimon is the semi-hosted version, which is easier to run

146
0:12:12.680 --> 0:12:19.920
on emulators, that type of thing. So for the LLVM-embedded toolchain, we basically, because

147
0:12:19.920 --> 0:12:25.640
we don't have the information for the specs file to say, ah, someone has someone added

148
0:12:25.640 --> 0:12:30.960
this other specs file, so I'm going to modify my behaviors. We have to basically have multiple

149
0:12:30.960 --> 0:12:35.560
config files that just blow up for all of the possible combinations. So as you see there,

150
0:12:35.560 --> 0:12:43.040
we've got an Arm V6M, which ideally would be handled by multi-lib in DMD semi-host version.

151
0:12:43.040 --> 0:12:48.280
And yeah, there's just more configuration files than you really ought to have. And I

152
0:12:48.280 --> 0:12:52.440
would say there's probably a small, well, there's a long tail of small incompatibilities.

153
0:12:52.440 --> 0:13:00.440
You might find that LLD doesn't do orphan placement exactly the same way as GNU-LD does,

154
0:13:00.440 --> 0:13:04.200
that type of thing. But normally these sort of small incompatibilities, you can kind of

155
0:13:04.200 --> 0:13:09.680
code around it. There's normally a way you can make it work. So that's what we found

156
0:13:09.680 --> 0:13:16.520
so far anyway. So this is just, again, another jumping around, just showing you how Clang

157
0:13:16.520 --> 0:13:21.160
might do some of this sort of stuff. So if any of you have played around with Clang drivers,

158
0:13:21.160 --> 0:13:24.440
whenever you give them the target triple, so normally if you're using Clang on your

159
0:13:24.440 --> 0:13:31.040
Linux, your target triple is native, I guess, at this particular point. Or you're using

160
0:13:31.040 --> 0:13:35.320
the default triple that's there. But if you're doing cross compilation, you have to give

161
0:13:35.320 --> 0:13:42.520
it a sort of architecture environment. So you've got the Linux-GnU there. So this is

162
0:13:42.520 --> 0:13:46.840
actually one if you were targeting something like the Octo, that type of thing. And that

163
0:13:46.840 --> 0:13:51.800
will, Clang driver will then tell you where all of your header files are, what your target

164
0:13:51.800 --> 0:13:57.400
features are. So it's like a much low level using sort of private command line options

165
0:13:57.400 --> 0:14:04.240
at that particular one. So for what we find for embedded systems is that Clang has added

166
0:14:04.240 --> 0:14:09.000
something probably a few years ago, but it's sort of only recently sort of getting a bit

167
0:14:09.000 --> 0:14:14.000
more development onto it. In particular, the multi-lib support for RISC-V came in fairly

168
0:14:14.000 --> 0:14:23.240
recently. And that's when you have a target that the bare metal handles. So far, that's

169
0:14:23.240 --> 0:14:29.000
only ARM-A out 64 and RISC-V at the moment. But this, in theory, could be added for any

170
0:14:29.000 --> 0:14:34.600
other target, that type of thing. If you happen to be doing bare metal development on an X86

171
0:14:34.600 --> 0:14:38.840
and you don't match, say, a Linux operating system or BSD or whatever, you end up getting

172
0:14:38.840 --> 0:14:43.160
forwarded to the generic GCC driver, which basically throws everything at GCC, which

173
0:14:43.160 --> 0:14:48.360
generally knows what to do about things. So as long as you've got a GCC toolchain, if

174
0:14:48.360 --> 0:14:53.360
you give an object file to GCC, GCC will say, oh, I'll just fire that at the linker, that

175
0:14:53.360 --> 0:14:59.720
type of thing. So it will work itself out. OK, yeah. So I've just basically repeated

176
0:14:59.720 --> 0:15:06.240
what I've just said there. It will default to the LLVM tools at that particular point.

177
0:15:06.240 --> 0:15:10.320
So as for the last part of the talk, I just want to go to some of the ongoing work that's

178
0:15:10.320 --> 0:15:15.040
happening in Clang and some of the community involvement that's going on here. So one of

179
0:15:15.040 --> 0:15:19.200
the first and probably the major bit of work that we're doing at the moment is what I'm

180
0:15:19.200 --> 0:15:22.880
going to call data-driven multi-lib at the moment. So currently, multi-lib support in

181
0:15:22.880 --> 0:15:27.640
Clang is hard-coded. It's basically a C++ class where you basically describe what the

182
0:15:27.640 --> 0:15:33.240
multi-lib will do for that. Now, that works pretty well if you're doing things like 32

183
0:15:33.240 --> 0:15:43.000
or 64-bit x86 in, say, Debian or Red Hat, because the structures are well-known at that particular

184
0:15:43.000 --> 0:15:48.120
point and they are stable. Whereas there's no way every possible embedded toolchain with

185
0:15:48.120 --> 0:15:52.960
every possible library variant that you might want to do could get that hard-coded in upstream

186
0:15:52.960 --> 0:15:57.920
Clang. So typically what you find is that every toolchain based on LLVM has its own

187
0:15:57.920 --> 0:16:05.200
downstream patch if it wants to support multi-lib. So GCC allows you to set this up at configure

188
0:16:05.200 --> 0:16:13.880
time and the GCC way basically maps command line options onto directories. So for Clang,

189
0:16:13.880 --> 0:16:18.880
we can do a bit better because the Clang driver has a bit more scope to, say, do things like

190
0:16:18.880 --> 0:16:24.640
target parser and find out more about what the CPU can do. So at the moment, we're kind

191
0:16:24.640 --> 0:16:30.760
of proposing that you kind of have a stacked tower of multi-libs where you can kind of

192
0:16:30.760 --> 0:16:35.040
– almost like a Docker container file where you get each sort of can override the next

193
0:16:35.040 --> 0:16:40.160
so that you can basically describe what your multi-lib configuration is and then Clang will

194
0:16:40.160 --> 0:16:47.600
be able to take this configuration file. So it will basically allow people to have multi-lib

195
0:16:47.600 --> 0:16:51.880
toolchains without having to hard-code them in downstream patches, that type of thing.

196
0:16:51.880 --> 0:16:57.960
So this is still in active development. There's an RFC that went up probably a few weeks ago.

197
0:16:57.960 --> 0:17:01.840
Recently there's some links to the patches and that sort of thing. So please do, if you're

198
0:17:01.840 --> 0:17:05.600
interested in data-driven multi-lib and how it develops, please do comment on those patches

199
0:17:05.600 --> 0:17:09.920
and the RFC.

200
0:17:09.920 --> 0:17:16.280
So future work. So we'd ideally like to get some upstream build bots for some of the compiler

201
0:17:16.280 --> 0:17:24.440
RT runtimes. So whilst there are build bots for AART64 and ARM Linux, we haven't got

202
0:17:24.440 --> 0:17:31.400
build bots for, say, the built-ins for, say, the V6M, V7M, the very low-level embedded

203
0:17:31.400 --> 0:17:35.320
sort of targets. And we think that would be good to – well, obviously more build bots

204
0:17:35.320 --> 0:17:41.320
the better, I think, at that particular point. There is some work going on at TI, and that

205
0:17:41.320 --> 0:17:49.640
link to YouTube is to a presentation from the – at the last LLVM developer meeting,

206
0:17:49.640 --> 0:17:54.840
basically adding attributes from the linker script so that you can tell – you can basically

207
0:17:54.840 --> 0:18:01.120
say things like, this section must go in this place, this output section, this one must

208
0:18:01.120 --> 0:18:05.760
go in this other one. Please do not cross module inline across these boundaries because

209
0:18:05.760 --> 0:18:09.880
these things might not be in memory at the same time, that type of thing. So – and

210
0:18:09.880 --> 0:18:14.280
also I need this section to have this particular name, so please don't give it a different

211
0:18:14.280 --> 0:18:19.160
name or merge it, that type of thing. So that should be able to make LTO much more usable

212
0:18:19.160 --> 0:18:24.240
with linker scripts. And what we tend to find with Clang is that if you get it right, LTO

213
0:18:24.240 --> 0:18:29.520
is very aggressive at removing code that's not needed. So that's actually very good

214
0:18:29.520 --> 0:18:33.600
for code size if you can make it work. Certainly we've seen – you know, for benchmarks,

215
0:18:33.600 --> 0:18:38.480
LTO is great, but then we say to customers, hey, use LTO, and he goes, ah, but we can't

216
0:18:38.480 --> 0:18:43.640
because of the linker script, that type of thing. Next one is not strictly embedded,

217
0:18:43.640 --> 0:18:48.840
but it is very important for the safety critical industry, which often is, you know, by definition

218
0:18:48.840 --> 0:18:52.680
embedded because you're controlling some kind of hardware. And this is something called

219
0:18:52.680 --> 0:19:01.080
MCDC code coverage. And that is kind of a special form of code coverage where you're

220
0:19:01.080 --> 0:19:06.400
kind of – if you can imagine something like IF and then A, B, C, D, E, E, it's a way

221
0:19:06.400 --> 0:19:12.520
of sort of deriving test cases so that – so it's not quite exhaustive, but it covers

222
0:19:12.520 --> 0:19:16.520
more than just did this branch go this way or this way. It's like did it go this way

223
0:19:16.520 --> 0:19:22.080
because this condition held that type of thing. Hopefully that's not going to show up too

224
0:19:22.080 --> 0:19:27.680
much there. And, yes, so there's a patch in for generating that in the code coverage

225
0:19:27.680 --> 0:19:34.120
thing. And obviously, LRVM libc developing, and we would like that to support embedded

226
0:19:34.120 --> 0:19:38.320
systems. Okay. I'll skip through this very quickly. There's some patches up for big

227
0:19:38.320 --> 0:19:42.280
endian support. If anyone actually uses big endian, I don't know. I'll be rude there.

228
0:19:42.280 --> 0:19:46.160
There's an armed person in the way. Almost all arms a little endian. And then there's

229
0:19:46.160 --> 0:19:52.000
the Cortex-M security extensions, which are, you know, that's very useful if you're trying

230
0:19:52.000 --> 0:19:56.600
to sort of have secure state and non-secure state. So that supports an LLD. Again, if

231
0:19:56.600 --> 0:20:02.520
anyone wants to comment on those patches, please do. Okay. Okay. So finally, if you

232
0:20:02.520 --> 0:20:06.320
do want to contribute to this, and this is not just as a developer, we're perfectly happy

233
0:20:06.320 --> 0:20:10.320
to have contributions from users as well, or just in some ways just telling us what's

234
0:20:10.320 --> 0:20:16.560
important. So Clang has pretty much come out of what I call the hosted community. You know,

235
0:20:16.560 --> 0:20:22.840
it's generally, at least as now, I would say there's a lot fewer people in the embedded

236
0:20:22.840 --> 0:20:27.680
system, embedded systems area than there is on GCC. So if you, you know, there are certain

237
0:20:27.680 --> 0:20:33.320
features that are useful in embedded tool chains, but not necessarily in say, say, hosted

238
0:20:33.320 --> 0:20:37.720
tool chains. So just telling the community that you need these features is often helpful

239
0:20:37.720 --> 0:20:41.080
because quite often it will say, why do we need all this complexity for this thing? No

240
0:20:41.080 --> 0:20:45.400
one's going to use it. And it's like, well, and you can only get people who only get used

241
0:20:45.400 --> 0:20:48.960
to features if they're there, but then you can't get them in, you know, chicken and egg

242
0:20:48.960 --> 0:20:55.720
situation there. So yeah, so there is a full weekly call that goes on, unfortunately, at

243
0:20:55.720 --> 0:21:00.440
a time slot that's not great for Europeans, but this is the only sort of time slot you

244
0:21:00.440 --> 0:21:06.920
can kind of get across US and Europe together at that particular point. So that's probably

245
0:21:06.920 --> 0:21:11.720
about I'd say about 20 people turn up. And that's really just about the various people

246
0:21:11.720 --> 0:21:15.480
are working on embedded systems. And if they want to sort of highlight patches that want

247
0:21:15.480 --> 0:21:21.680
to be reviewed, discuss new features. Last time we were talking about how we might improve

248
0:21:21.680 --> 0:21:28.120
LLDs and observability of diagnostics, that type of thing. Obviously bug reports welcome

249
0:21:28.120 --> 0:21:33.880
those links. And obviously, if you attend the developer meetings, there's often a round

250
0:21:33.880 --> 0:21:38.560
table on embed systems at that point. And with that, that's my last slide. So hopefully

251
0:21:38.560 --> 0:21:41.880
we've got a few minutes for questions.

252
0:21:41.880 --> 0:21:53.520
I'm trying to understand something I know of some people who say that they're using

253
0:21:53.520 --> 0:21:55.520
LLVM for embedded already. Yeah.

254
0:21:55.520 --> 0:21:59.000
Does this mean that they're using the other definition of embedded?

255
0:21:59.000 --> 0:22:04.800
So there's two, well, you can do it. There'll be three ways they can do it. One of them

256
0:22:04.800 --> 0:22:09.440
is they're kind of using an LLVM based tool chain from a vendor. So that vendor will have

257
0:22:09.440 --> 0:22:15.840
done all of that packaging up. Or it will be, like for example, Arm will sell you a commercial

258
0:22:15.840 --> 0:22:22.200
tool chain that is a derivative of Clang. That type of thing. That's one way of doing

259
0:22:22.200 --> 0:22:26.160
it, that sort of thing. Or they might be using embedded Linux. That type of thing. Yeah.

260
0:22:26.160 --> 0:22:29.400
The question was, sorry, I've been holding up a picture all day saying, please repeat

261
0:22:29.400 --> 0:22:34.960
the question. I didn't. And that's the question was that some people say they're already using

262
0:22:34.960 --> 0:22:41.040
LLVM. Does that mean they were using a hosted system or not? Okay. Yes. Sorry. Go to the

263
0:22:41.040 --> 0:22:47.120
back. Yes. So one of the things I noticed is LLVM ships, it's on the Sember. Yeah. We've

264
0:22:47.120 --> 0:22:51.720
noticed for some embedded projects that they have trouble with some of the newer Sember

265
0:22:51.720 --> 0:22:56.560
macros. So we have to use, have to fall back to the inter-tool changes for some targets.

266
0:22:56.560 --> 0:23:01.480
Is there some plans for work on this?

267
0:23:01.480 --> 0:23:08.480
So there was, with the latest LLVM, I know, sorry, repeat the question. Yeah. So the question

268
0:23:08.480 --> 0:23:15.760
was the LLVM has an integrated Sember, GNU has GNU AS. And there are some directives

269
0:23:15.760 --> 0:23:24.400
or macro support that might be in the GNU Sember but not LLVM. So I think it's generally

270
0:23:24.400 --> 0:23:29.960
done on demand. So there was a big effort to get the Linux kernel compiled with Clang.

271
0:23:29.960 --> 0:23:34.080
And that added quite a lot of features that were basically needed for the Linux kernel.

272
0:23:34.080 --> 0:23:38.600
So the best thing to do is have a really important project that's a big company, wants to get

273
0:23:38.600 --> 0:23:45.720
compiled with the integrated Sember. Yes. And then, yes. That is a very good way of

274
0:23:45.720 --> 0:23:46.720
doing it.

275
0:23:46.720 --> 0:23:52.720
As macros were in the Linux kernel and they asked us to support them and say, no, screw

276
0:23:52.720 --> 0:23:56.080
this, the kernel changed away from macros. And they changed away from macros.

277
0:23:56.080 --> 0:24:00.480
Yeah. But there certainly was support. I think there is a directive where you can switch

278
0:24:00.480 --> 0:24:05.560
the GNU Sember into advanced macro mode or something like that. I can't remember.

279
0:24:05.560 --> 0:24:11.360
No, that's not that. That's an inline assembly thing. There is an, yes, there is a highness

280
0:24:11.360 --> 0:24:20.120
GNU extensions option. But no, there was a patch that probably landed a few years ago.

281
0:24:20.120 --> 0:24:27.360
So depending on how long ago you tried, then there was some support done for more macros.

282
0:24:27.360 --> 0:24:29.960
But whether it's got all of it or not, I don't know.

283
0:24:29.960 --> 0:24:32.640
Well, I forgot what the problem was a while ago.

284
0:24:32.640 --> 0:24:38.080
Right. So you may find that someone has already fixed that already. Yes. Thank you.

285
0:24:38.080 --> 0:24:43.760
Yeah. So my question is about like we, for example, try to deploy machine learning models

286
0:24:43.760 --> 0:24:45.760
on tiny bare metal devices.

287
0:24:45.760 --> 0:24:46.760
Yeah.

288
0:24:46.760 --> 0:24:51.640
And then there we are also looking into, for example, TVM as a tool chain, but also MLIR

289
0:24:51.640 --> 0:24:54.120
now, like the EV project from Google.

290
0:24:54.120 --> 0:24:55.120
Yeah.

291
0:24:55.120 --> 0:24:58.000
And they're basically what they do is they use this entire tool chain and then they use

292
0:24:58.000 --> 0:25:01.800
the MHC dialect, for example, in EV to MHC code again.

293
0:25:01.800 --> 0:25:02.800
Okay.

294
0:25:02.800 --> 0:25:07.400
To then put it into an embedded tool chain to actually do the final compilation stuff.

295
0:25:07.400 --> 0:25:14.080
Do you think that there is, or what is basically needed to omit this last going back to C

296
0:25:14.080 --> 0:25:16.120
or is this a good idea or not?

297
0:25:16.120 --> 0:25:24.440
Oh, well, I mean, I suppose I'm just trying to think, think how, not very familiar.

298
0:25:24.440 --> 0:25:29.840
The question was about people deploying machine learning models on small devices and they're

299
0:25:29.840 --> 0:25:37.760
currently outputting to a C back end and then recompiling that C back end.

300
0:25:37.760 --> 0:25:40.480
And do I think this is a good idea or not?

301
0:25:40.480 --> 0:25:45.280
I mean, I guess the C back ends are often the how do I get this up and running as quickly

302
0:25:45.280 --> 0:25:46.840
as possible.

303
0:25:46.840 --> 0:25:53.360
I do know that there are, I guess, machine learning compilers that have got, I guess,

304
0:25:53.360 --> 0:25:54.360
code generation out.

305
0:25:54.360 --> 0:26:00.480
I mean, I guess if you're using LLVM itself, it's probably not too difficult to just lower

306
0:26:00.480 --> 0:26:05.240
to LLVM and get most, and you then get the code generation for free.

307
0:26:05.240 --> 0:26:11.960
I guess the bit that you might not get is, have you got all of the, the runtime and intrinsics

308
0:26:11.960 --> 0:26:16.080
that you might have that the C compiler might insert, but you might find someone else in

309
0:26:16.080 --> 0:26:17.080
this way.

310
0:26:17.080 --> 0:26:21.600
So maybe just in addition, it does not compile the whole machine learning models to C, so

311
0:26:21.600 --> 0:26:26.200
they are still a static library linked in which is generated via LLVM.

312
0:26:26.200 --> 0:26:28.120
It's just some parts around.

313
0:26:28.120 --> 0:26:32.240
So it's not that there is a pure C in the end.

314
0:26:32.240 --> 0:26:34.240
That's not done in the approach.

315
0:26:34.240 --> 0:26:35.240
Okay.

316
0:26:35.240 --> 0:26:36.240
Yes.

317
0:26:36.240 --> 0:26:42.600
I was one of those unfortunate uses of a big ambient arm.

318
0:26:42.600 --> 0:26:47.320
We were running several compilers in the safety critical application.

319
0:26:47.320 --> 0:26:50.320
Everyone had a problem with one thing, and that's the linker.

320
0:26:50.320 --> 0:26:53.080
We're trying to generate the header.

321
0:26:53.080 --> 0:26:56.560
And the linker, you called insert the text string in the linker.

322
0:26:56.560 --> 0:26:59.560
It's very difficult to insert static data.

323
0:26:59.560 --> 0:27:03.680
We want to insert information about how large is the section.

324
0:27:03.680 --> 0:27:11.400
Right.

325
0:27:11.400 --> 0:27:18.200
With great difficulty, I think, I think there isn't really a, there isn't, I think the,

326
0:27:18.200 --> 0:27:25.360
yeah, I think Christophe has nailed it in that what I would probably do myself is reserve

327
0:27:25.360 --> 0:27:32.720
some space in the binary, name a section out of it, and then use objdump to poke it in

328
0:27:32.720 --> 0:27:33.720
that particular part.

329
0:27:33.720 --> 0:27:34.720
Yes.

330
0:27:34.720 --> 0:27:35.720
No, but.

331
0:27:35.720 --> 0:27:36.720
You see my problem?

332
0:27:36.720 --> 0:27:37.720
No.

333
0:27:37.720 --> 0:27:38.720
Yes.

334
0:27:38.720 --> 0:27:39.720
I mean, there are some.

335
0:27:39.720 --> 0:27:40.720
Putting a string in the linker command file.

336
0:27:40.720 --> 0:27:45.360
Well, it's a bit, well, it's a bit more difficult.

337
0:27:45.360 --> 0:27:47.680
It's the, I think the linker needs to know the lengths.

338
0:27:47.680 --> 0:27:51.280
I mean, I suppose you could do it with horrifying things.

339
0:27:51.280 --> 0:27:54.200
You could use data statements in the linker script.

340
0:27:54.200 --> 0:27:56.320
But that sounds, it's really what you would want it.

341
0:27:56.320 --> 0:27:57.320
You really.

342
0:27:57.320 --> 0:27:58.320
Yes.

343
0:27:58.320 --> 0:27:59.920
I really, I think, yeah, because you get a number.

344
0:27:59.920 --> 0:28:05.480
But really, yeah, I suppose, yeah, found an extension request of a linker script.

345
0:28:05.480 --> 0:28:06.480
Yeah.

346
0:28:06.480 --> 0:28:11.560
I think we do have the problem.

347
0:28:11.560 --> 0:28:13.480
We do have a problem with things like build ID.

348
0:28:13.480 --> 0:28:17.680
I think at that particular point where you're generating the build ID string, which, which

349
0:28:17.680 --> 0:28:19.320
it needs to know everything all at once.

350
0:28:19.320 --> 0:28:22.800
But yeah, I get, I, yeah, unfortunately there's nothing in the LLD linker.

351
0:28:22.800 --> 0:28:27.800
I think someone should try to generate the header for a binary, put in the interesting

352
0:28:27.800 --> 0:28:28.800
information.

353
0:28:28.800 --> 0:28:30.800
But you quickly realize all the problems.

354
0:28:30.800 --> 0:28:31.800
Oh, yeah, sure.

355
0:28:31.800 --> 0:28:34.800
But no assembler has the ink bin.

356
0:28:34.800 --> 0:28:36.000
Yes, it does.

357
0:28:36.000 --> 0:28:40.320
The assembler does have ink bin, but I think the idea is for the header, you want the linker

358
0:28:40.320 --> 0:28:44.200
to generate something based on the properties of something.

359
0:28:44.200 --> 0:28:48.320
You want to generate the information about the link time, not when you assembled it

360
0:28:48.320 --> 0:28:49.320
two weeks ago.

361
0:28:49.320 --> 0:28:56.320
You can, you can assemble just before the link step, assemble something that's generated.

362
0:28:56.320 --> 0:29:02.120
It's an, it's an double file and then link that in using a link script.

363
0:29:02.120 --> 0:29:06.800
I know there are workarounds, but a good workaround would have to have a good link.

364
0:29:06.800 --> 0:29:07.800
Yeah.

365
0:29:07.800 --> 0:29:11.200
I mean, I think, I think, I mean, there's a lot of times with linkers, it's the, because

366
0:29:11.200 --> 0:29:14.960
one of the, one of the perennial things you get asked is how do I embed some kind of custom

367
0:29:14.960 --> 0:29:18.280
checksum that I've written at link time, you know, that type of thing.

368
0:29:18.280 --> 0:29:24.280
And it's just which one and do you then have a linker Python script extension or plugin?

369
0:29:24.280 --> 0:29:27.040
It just tends to build.

370
0:29:27.040 --> 0:29:28.040
Yeah.

371
0:29:28.040 --> 0:29:29.040
Check some afterwards.

372
0:29:29.040 --> 0:29:31.040
And that's also something that should be supported in linker.

373
0:29:31.040 --> 0:29:32.040
Yeah.

374
0:29:32.040 --> 0:29:37.560
And it could be done just say, run this application afterwards on the section.

375
0:29:37.560 --> 0:29:38.560
Yeah.

376
0:29:38.560 --> 0:29:39.560
So, so it's.

377
0:29:39.560 --> 0:29:40.560
I mean, I guess.

378
0:29:40.560 --> 0:29:49.800
I mean, I guess it's, I mean, to, I mean, to paraphrase, I guess it's the tools are

379
0:29:49.800 --> 0:29:52.760
supposed to make users life easier, I suppose, at that particular point.

380
0:29:52.760 --> 0:29:56.560
So if it's a common enough thing to do, then it should be, they should be able to find

381
0:29:56.560 --> 0:29:57.560
a way of doing it.

382
0:29:57.560 --> 0:30:00.560
And if this is security, then you don't want to generate the checksum in one process and

383
0:30:00.560 --> 0:30:01.560
then use it the other process.

384
0:30:01.560 --> 0:30:02.560
You want to use all in one because I know who generated this.

385
0:30:02.560 --> 0:30:03.560
They didn't come from outside.

386
0:30:03.560 --> 0:30:04.560
We actually have to have two different programs in this application.

387
0:30:04.560 --> 0:30:05.560
Yeah.

388
0:30:05.560 --> 0:30:06.560
So, I wait, so I better go for.

389
0:30:06.560 --> 0:30:07.560
Yeah.

390
0:30:07.560 --> 0:30:08.560
So, I, I'm not in all the other.

391
0:30:08.560 --> 0:30:09.560
Yeah.

392
0:30:09.560 --> 0:30:10.560
I deal with a lot of built-in stuff.

393
0:30:10.560 --> 0:30:23.360
Is anyone working on stuff to make things better?

394
0:30:23.360 --> 0:30:35.360
Essentially, like, you're talking about communicating between the mild stage and the line stage,

395
0:30:35.360 --> 0:30:36.360
and introducing dependencies to what you've accomplished, and then you have to link with

396
0:30:36.360 --> 0:30:37.360
that to that stage.

397
0:30:37.360 --> 0:30:38.360
Right.

398
0:30:38.360 --> 0:30:39.360
And now, like, it seems like you need like a schema, a data format, and a dependency

399
0:30:39.360 --> 0:30:40.360
specification for that.

400
0:30:40.360 --> 0:30:41.360
And then, you have to use it and spare the users who have to deal with all this crap.

401
0:30:41.360 --> 0:30:42.360
Nice.

402
0:30:42.360 --> 0:30:43.360
The, the incentive.

403
0:30:43.360 --> 0:30:54.720
I mean, I, I, I think the, the, the, the, the, I say it's mostly a, what I would call

404
0:30:54.720 --> 0:30:58.920
almost a coordination problem between getting the right people on board at that particular

405
0:30:58.920 --> 0:31:01.920
point and it's, so it's quite.

406
0:31:01.920 --> 0:31:02.920
I need the question.

407
0:31:02.920 --> 0:31:03.920
Sorry.

408
0:31:03.920 --> 0:31:04.920
Yes.

409
0:31:04.920 --> 0:31:05.920
Okay.

410
0:31:05.920 --> 0:31:10.080
So, the question, question was about, is anybody working on build systems?

411
0:31:10.080 --> 0:31:15.200
And things that able to be able to communicate the, of the linker to be able to communicate

412
0:31:15.200 --> 0:31:18.560
to the build system and automate things like the checksum sort of handling and that type

413
0:31:18.560 --> 0:31:19.560
of thing.

414
0:31:19.560 --> 0:31:26.080
I mean, I think the, the major difficulty is just, LLVM's an open source project and

415
0:31:26.080 --> 0:31:30.240
there's often, as soon as you open something like that up, it ends up in lots and lots

416
0:31:30.240 --> 0:31:34.440
of discussions about what the right way, and you can easily find a way that works for one,

417
0:31:34.440 --> 0:31:38.120
a small number of people, but completely doesn't work for someone else.

418
0:31:38.120 --> 0:31:39.880
So it's one of those.

419
0:31:39.880 --> 0:31:43.440
It first of all needs someone brave enough to actually try it rather than just implementing

420
0:31:43.440 --> 0:31:44.600
it downstream.

421
0:31:44.600 --> 0:31:51.000
So I think it's, what it really needs in this case is, because this is sort of things that,

422
0:31:51.000 --> 0:31:55.360
this is not, it really needs people to go on the LLVM mailing list and say, yes, we

423
0:31:55.360 --> 0:31:56.560
really need this.

424
0:31:56.560 --> 0:32:00.240
Because typically this sort of thing is to silent people who say, oh, this stuff's all

425
0:32:00.240 --> 0:32:03.080
rubbish, but we don't, as developers, we don't get to hear about it.

426
0:32:03.080 --> 0:32:07.320
Or at least we don't get to hear it, hear about it loud enough for the people who pay

427
0:32:07.320 --> 0:32:09.720
our wages to say, go and work on it.

428
0:32:09.720 --> 0:32:10.720
Yeah.

429
0:32:10.720 --> 0:32:11.720
Right.

430
0:32:11.720 --> 0:32:12.720
Yeah.

431
0:32:12.720 --> 0:32:13.720
Okay.

432
0:32:13.720 --> 0:32:23.520
I probably ought to hold it there to let everyone go.

433
0:32:23.520 --> 0:32:24.520
Thank you very much for staying.

434
0:32:24.520 --> 0:32:25.520
I'll tell you after.

435
0:32:25.520 --> 0:32:41.640
Thank you very much.

