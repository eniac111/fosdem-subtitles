1
0:00:00.000 --> 0:00:07.520
a tool called Parkoach and how they've been using

2
0:00:07.520 --> 0:00:12.440
a logarithm for one time and they've kept it well.

3
0:00:12.440 --> 0:00:13.440
I think.

4
0:00:13.440 --> 0:00:15.800
Yeah. We'll see.

5
0:00:15.800 --> 0:00:17.160
All right. Up to you, Philippe.

6
0:00:17.160 --> 0:00:18.600
Thank you very much. So yes,

7
0:00:18.600 --> 0:00:20.820
my name is Philippe. I work at Tenerife in France.

8
0:00:20.820 --> 0:00:25.160
And so the talk today is not so much about Parkoach itself.

9
0:00:25.160 --> 0:00:26.480
I'm sorry for the wrong title,

10
0:00:26.480 --> 0:00:27.640
but naming is hard,

11
0:00:27.640 --> 0:00:29.600
so I had to put something.

12
0:00:29.600 --> 0:00:32.720
But today I want to talk to you about

13
0:00:32.720 --> 0:00:35.000
my experience with dealing with out of

14
0:00:35.000 --> 0:00:37.400
three plug-in and tools for LLVM.

15
0:00:37.400 --> 0:00:41.640
Parkoach is just one example and I will give some others.

16
0:00:41.640 --> 0:00:46.440
So first of all, I will try to explain you why and for whom

17
0:00:46.440 --> 0:00:49.680
am I doing this talk so that you know the audience.

18
0:00:49.680 --> 0:00:52.080
I'm going to talk about three different things.

19
0:00:52.080 --> 0:00:54.040
The first one is keeping up with LLVM.

20
0:00:54.040 --> 0:00:55.400
So we will see some code,

21
0:00:55.400 --> 0:00:57.600
CMake, C++ and stuff.

22
0:00:57.600 --> 0:01:00.280
The other point, the second point is usability,

23
0:01:00.280 --> 0:01:04.560
both from a developer to developer point of view and the user point of view.

24
0:01:04.560 --> 0:01:07.040
And the final point will be dealing with

25
0:01:07.040 --> 0:01:11.720
packaging when you're actually targeting some system.

26
0:01:11.720 --> 0:01:14.640
So why am I doing this talk?

27
0:01:14.640 --> 0:01:17.800
First of all, it's to provide some feedback

28
0:01:17.800 --> 0:01:23.200
and maybe provide you with some stuff I wish I knew beforehand,

29
0:01:23.200 --> 0:01:28.040
before coming into this.

30
0:01:28.040 --> 0:01:31.640
I'm doing this also because I've learned a couple of out of three projects

31
0:01:31.640 --> 0:01:33.560
and I faced the same issues.

32
0:01:33.560 --> 0:01:37.200
So maybe you've faced them too and it will be helpful.

33
0:01:37.200 --> 0:01:40.880
So it's not so much about the tool Parkoach itself,

34
0:01:40.880 --> 0:01:43.040
it's rather about the approach.

35
0:01:43.040 --> 0:01:47.400
And for whom it's basically anyone with a vote or who is involved in

36
0:01:47.400 --> 0:01:50.280
an out of three project for LLVM.

37
0:01:50.280 --> 0:01:53.840
This is my own point of view on this topic.

38
0:01:53.840 --> 0:01:55.480
If you have IDs, comments,

39
0:01:55.480 --> 0:01:59.960
improvements that you think may be helpful to me, don't hesitate.

40
0:01:59.960 --> 0:02:02.040
I will welcome them.

41
0:02:02.040 --> 0:02:06.680
So Parkoach is a tool for HPC application.

42
0:02:06.680 --> 0:02:10.760
It's basically an instrumentation analysis and instrumentation tool

43
0:02:10.760 --> 0:02:13.240
for OpenMP and MPI application.

44
0:02:13.240 --> 0:02:16.280
Basically checks that the user is using

45
0:02:16.280 --> 0:02:21.160
the APIs appropriately that there are no deadlock or data racism.

46
0:02:21.160 --> 0:02:23.880
The developers, this is where it gets interesting

47
0:02:23.880 --> 0:02:25.840
because they are not LLVM engineers, right?

48
0:02:25.840 --> 0:02:30.480
They are interns, students, PhD students, researchers.

49
0:02:30.480 --> 0:02:35.120
They have a whole job which is not LLVM.

50
0:02:35.120 --> 0:02:37.080
The users of the tool,

51
0:02:37.080 --> 0:02:39.000
they are scientific application developers.

52
0:02:39.000 --> 0:02:42.360
So you cannot ask them to compile LLVM from source.

53
0:02:42.360 --> 0:02:45.640
It's not going to work. They are not going to use your tool.

54
0:02:45.640 --> 0:02:49.600
The last part which is interesting with this project,

55
0:02:49.600 --> 0:02:53.640
it started like a long time ago when it was LLVM 3.7,

56
0:02:53.640 --> 0:02:55.840
and now it's based on LLVM 15.

57
0:02:55.840 --> 0:02:59.080
So there has been a lot of history in the tool.

58
0:02:59.080 --> 0:03:00.920
I'm working on it right now.

59
0:03:00.920 --> 0:03:04.360
It's my main job. So they have an LLVM engineer now,

60
0:03:04.360 --> 0:03:05.960
and I can do stuff.

61
0:03:05.960 --> 0:03:09.040
I provided the link for reference if you want to take a look.

62
0:03:09.040 --> 0:03:12.360
There are two other motivating projects that I can talk about.

63
0:03:12.360 --> 0:03:14.280
One, I'm actually not going to talk about

64
0:03:14.280 --> 0:03:15.920
much because it's not free.

65
0:03:15.920 --> 0:03:19.200
It's a commercial compiler which is based on LLVM,

66
0:03:19.200 --> 0:03:23.160
and basically the developers are LLVM engineers.

67
0:03:23.160 --> 0:03:27.120
So we have more flexibility when doing developments,

68
0:03:27.120 --> 0:03:29.560
and the users are clients who are paying for the compiler.

69
0:03:29.560 --> 0:03:33.920
So we needed to provide something good.

70
0:03:34.760 --> 0:03:38.800
The other point is a student LLVM exercises.

71
0:03:38.800 --> 0:03:43.080
I do LLVM courses for security students,

72
0:03:43.080 --> 0:03:45.040
and I want them to be able to do

73
0:03:45.040 --> 0:03:47.160
some code transformation with LLVM.

74
0:03:47.160 --> 0:03:49.840
So the developers are just a friend of mine and me,

75
0:03:49.840 --> 0:03:52.280
and the users are students.

76
0:03:52.280 --> 0:03:55.480
We are expecting them to code into the project.

77
0:03:55.480 --> 0:03:58.760
So we need to make it easy for them to get into,

78
0:03:58.760 --> 0:04:03.280
and we have 16 hours to this project,

79
0:04:03.280 --> 0:04:06.880
and they cannot spend two hours installing LLVM.

80
0:04:06.880 --> 0:04:08.800
It's not going to work either.

81
0:04:09.000 --> 0:04:11.520
So in all this projects,

82
0:04:11.520 --> 0:04:13.320
I'm going to talk pretty much the same issues.

83
0:04:13.320 --> 0:04:15.040
So I'm going to talk about them now.

84
0:04:15.040 --> 0:04:17.480
The first one is keeping up with LLVM.

85
0:04:17.480 --> 0:04:19.680
So I'm not sure if it was intentional in the schedule,

86
0:04:19.680 --> 0:04:22.800
but having a talk for you about CMake and stuff,

87
0:04:22.800 --> 0:04:24.440
it's quite helpful because I don't have to

88
0:04:24.440 --> 0:04:26.200
go too deep in the details.

89
0:04:26.200 --> 0:04:27.640
You already know them.

90
0:04:27.640 --> 0:04:33.720
So let's go back like maybe eight years ago.

91
0:04:33.720 --> 0:04:36.320
You wanted to do some LLVM tools,

92
0:04:36.320 --> 0:04:38.200
as there was no CMake integration.

93
0:04:38.200 --> 0:04:41.160
The first approach that you had as a developer was

94
0:04:41.160 --> 0:04:43.640
either do stuff manually,

95
0:04:43.640 --> 0:04:45.920
maybe using LLVM config to get

96
0:04:45.920 --> 0:04:48.600
the flags and the libraries and so on.

97
0:04:48.600 --> 0:04:50.320
But basically, you had no easy way to

98
0:04:50.320 --> 0:04:52.560
integrate with LLVM. It was quite manual.

99
0:04:52.560 --> 0:04:56.520
Then came CMake, and you could use

100
0:04:56.520 --> 0:04:59.600
the standard add library, target link libraries,

101
0:04:59.600 --> 0:05:04.120
but you had to know what to feed these macros with.

102
0:05:04.880 --> 0:05:08.760
Some stuff I've encountered in this project is

103
0:05:08.760 --> 0:05:13.960
some people who were developing this project,

104
0:05:13.960 --> 0:05:16.720
were not comfortable with CMake,

105
0:05:16.720 --> 0:05:19.560
and they would perform some changes where they would

106
0:05:19.560 --> 0:05:21.920
actually do CMake integration with

107
0:05:21.920 --> 0:05:25.800
our coded passes in the CMake, so it would be a quad.

108
0:05:26.080 --> 0:05:28.840
Basically, now it's, I think,

109
0:05:28.840 --> 0:05:34.040
at least from the examples we have, it's way better.

110
0:05:34.040 --> 0:05:37.000
So using the LLVM CMake integration

111
0:05:37.000 --> 0:05:38.720
simplifies a lot of stuff.

112
0:05:38.720 --> 0:05:43.320
You just have basically to know which component of LLVM you want to use,

113
0:05:43.320 --> 0:05:45.720
how you want to build your library,

114
0:05:45.720 --> 0:05:47.880
like is it static or shared basically,

115
0:05:47.880 --> 0:05:50.760
and you have dedicated macros to just construct

116
0:05:50.760 --> 0:05:55.000
whatever stuff you want to construct for LLVM.

117
0:05:55.000 --> 0:05:57.400
So let's take an example code.

118
0:05:57.400 --> 0:05:59.440
So you don't have to understand everything.

119
0:05:59.440 --> 0:06:02.640
It's just to give an example of how it works.

120
0:06:02.640 --> 0:06:04.440
You basically say, okay,

121
0:06:04.440 --> 0:06:08.800
I want to find LLVM, provide a version, sometimes,

122
0:06:08.800 --> 0:06:11.960
include the LLVM CMake helper,

123
0:06:11.960 --> 0:06:14.200
and include some definition,

124
0:06:14.200 --> 0:06:17.200
and then this is interesting part because you can say, okay,

125
0:06:17.200 --> 0:06:20.080
I want these components in my tool.

126
0:06:20.080 --> 0:06:26.440
Call the CMake helper with your plugin source, and that's it.

127
0:06:26.440 --> 0:06:30.800
I mean, the CMake helper will take care of saying, okay,

128
0:06:30.800 --> 0:06:33.240
depending on how LLVM is installed,

129
0:06:33.240 --> 0:06:38.560
like is it just the big dial-up or are there individual libraries?

130
0:06:38.560 --> 0:06:41.360
It will set up the target link libraries

131
0:06:41.360 --> 0:06:43.360
appropriately and you don't have to think about it.

132
0:06:43.360 --> 0:06:45.320
It's just automatic.

133
0:06:45.320 --> 0:06:49.240
If you want to do some tools or pass plugin,

134
0:06:49.240 --> 0:06:51.440
there are macros to do these two.

135
0:06:51.440 --> 0:06:55.360
So basically, you just have to figure out which kind of build you want,

136
0:06:55.360 --> 0:06:59.680
and CMake LLVM will configure everything for you.

137
0:06:59.680 --> 0:07:02.240
There are some useful examples.

138
0:07:02.240 --> 0:07:05.320
For pass plugins, there is a by example,

139
0:07:05.320 --> 0:07:07.360
which is basically a new pass plugin,

140
0:07:07.360 --> 0:07:09.840
very simple, it's a kind of a hello world.

141
0:07:09.840 --> 0:07:14.440
LLVM tutorials are some out of three passes to get you started with,

142
0:07:14.440 --> 0:07:18.560
and actually quite helpful if you are looking into this.

143
0:07:22.320 --> 0:07:25.840
Now, let's talk about some code.

144
0:07:25.840 --> 0:07:28.640
So let's say you're new to LLVM,

145
0:07:28.640 --> 0:07:30.680
pretty new to C++.

146
0:07:30.680 --> 0:07:32.840
Your students, for instance,

147
0:07:32.840 --> 0:07:36.560
and you want to perform some LLVM transformation.

148
0:07:36.560 --> 0:07:42.000
So you go on your search engine and you look for,

149
0:07:42.000 --> 0:07:46.880
how do I iterate over instructions of LLVM function?

150
0:07:46.880 --> 0:07:50.600
Pretty much all of your resources like StackOverflow or even

151
0:07:50.600 --> 0:07:53.960
some presentations that will give you the code on the left.

152
0:07:53.960 --> 0:07:56.440
So it's fine, it works. I mean, you are iterating over

153
0:07:56.440 --> 0:07:59.080
all the iteration instruction of the function.

154
0:07:59.080 --> 0:08:01.400
But if you know a bit better C++,

155
0:08:01.400 --> 0:08:04.400
you know that you can put runge instead of row iterators.

156
0:08:04.400 --> 0:08:08.440
If you know the instruction iterators from LLVM,

157
0:08:08.440 --> 0:08:12.720
you know that you can use instruction of F to just get all the instruction of F.

158
0:08:12.720 --> 0:08:15.840
All the code works, but arguably,

159
0:08:15.840 --> 0:08:20.320
the codes on the right are easier to read and in the end,

160
0:08:20.320 --> 0:08:24.720
easier to maintain especially if you consider that there are a lot of examples like this in the code.

161
0:08:24.720 --> 0:08:30.280
It adds up and so simplifying stuff is nice sometimes.

162
0:08:30.280 --> 0:08:34.640
So it's not a problem of StackOverflow or anything.

163
0:08:34.640 --> 0:08:40.600
It's just that the answer in StackOverflow on the slides are old like from 2015.

164
0:08:40.600 --> 0:08:43.840
Like if you would update the answer,

165
0:08:43.840 --> 0:08:47.760
it would just be the option on the right.

166
0:08:47.760 --> 0:08:53.640
Another thing I want to talk about and that I've seen a lot in

167
0:08:53.640 --> 0:08:56.680
Parkout is iterating over something,

168
0:08:56.680 --> 0:08:59.600
but putting a predicate like I want to iterate through this stuff,

169
0:08:59.600 --> 0:09:03.440
but only if this stuff is true for some predicate.

170
0:09:03.440 --> 0:09:05.280
So you can do stuff like that,

171
0:09:05.280 --> 0:09:08.400
early continues or nested if.

172
0:09:08.400 --> 0:09:12.320
But if you know the STL extra from LLVM,

173
0:09:12.320 --> 0:09:17.240
you know that you can create filtered range for any range actually.

174
0:09:17.240 --> 0:09:18.840
So you pass a range,

175
0:09:18.840 --> 0:09:21.240
you pass a predicate and inside the loop,

176
0:09:21.240 --> 0:09:25.280
you just get the object you're looking for.

177
0:09:25.280 --> 0:09:27.920
Again, it's a simple predicate,

178
0:09:27.920 --> 0:09:29.480
so it doesn't matter much as is,

179
0:09:29.480 --> 0:09:31.640
but if you add some more stuff,

180
0:09:31.640 --> 0:09:35.680
it starts growing up and maintenance became a bit harder,

181
0:09:35.680 --> 0:09:37.800
readability is impacted too.

182
0:09:37.800 --> 0:09:40.520
So this is something to consider.

183
0:09:40.520 --> 0:09:43.520
Now, something more like a critical,

184
0:09:43.520 --> 0:09:45.840
it's advanced data types.

185
0:09:45.840 --> 0:09:47.880
There are a lot of data types in LLVM.

186
0:09:47.880 --> 0:09:50.480
If you are not familiar with LLVM,

187
0:09:50.480 --> 0:09:52.000
and I've seen a lot of color exists,

188
0:09:52.000 --> 0:09:57.880
you will just use whatever data types is available in the STL,

189
0:09:57.880 --> 0:10:00.000
and you will get a map for instance,

190
0:10:00.000 --> 0:10:04.800
use some helper, and the actual issue starts when input,

191
0:10:04.800 --> 0:10:06.320
the map of instruction,

192
0:10:06.320 --> 0:10:09.000
you want to map an instruction to something.

193
0:10:09.000 --> 0:10:13.200
If you go through the input and

194
0:10:13.200 --> 0:10:16.300
change an instruction like if you delete it,

195
0:10:16.300 --> 0:10:19.200
or if you replace all the uses with some other value,

196
0:10:19.200 --> 0:10:21.800
what happens to the instruction in the map?

197
0:10:21.800 --> 0:10:25.960
So with row map from the STL,

198
0:10:25.960 --> 0:10:28.080
there is no mechanism,

199
0:10:28.080 --> 0:10:30.480
so nothing happened and you end up iterating

200
0:10:30.480 --> 0:10:34.080
of trying to find something which is not valid anymore.

201
0:10:34.080 --> 0:10:38.720
Whereas if you are aware of the data types from LLVM,

202
0:10:38.720 --> 0:10:41.740
you are able to use some kind of value map which has

203
0:10:41.740 --> 0:10:44.240
specific handle to remove the value or

204
0:10:44.240 --> 0:10:49.760
update the value if it is changed during the life of the value.

205
0:10:49.760 --> 0:10:54.720
So some other helpers that are quite nice,

206
0:10:54.720 --> 0:10:56.640
I mean it's not a big deal,

207
0:10:56.640 --> 0:10:59.440
but for instance, instead of using std-fanif,

208
0:10:59.440 --> 0:11:01.680
you can use LLVM-fanif and just put a range

209
0:11:01.680 --> 0:11:04.680
instead of just the individual character.

210
0:11:04.680 --> 0:11:06.920
In this case, it's not a big deal,

211
0:11:06.920 --> 0:11:08.960
but it's actually quite nice.

212
0:11:08.960 --> 0:11:11.400
But basically, every stuff like that,

213
0:11:11.400 --> 0:11:15.800
I've encountered this for a lot of code where

214
0:11:15.800 --> 0:11:20.040
you would be able to replace most of

215
0:11:20.040 --> 0:11:22.640
the occurrences with any vector from

216
0:11:22.640 --> 0:11:28.600
the LLVM advanced data types or a array for string graph.

217
0:11:28.600 --> 0:11:32.160
There are a lot of stuff in LLVM that you may not be aware of,

218
0:11:32.160 --> 0:11:37.040
and that makes your code quite nicer if you use them.

219
0:11:37.040 --> 0:11:41.960
So yeah, dealing with it.

220
0:11:41.960 --> 0:11:43.280
So you may think, okay,

221
0:11:43.280 --> 0:11:44.720
this guy is just being picky with

222
0:11:44.720 --> 0:11:47.640
people who are writing the code. It may be true.

223
0:11:47.640 --> 0:11:49.280
I would argue that it depends on

224
0:11:49.280 --> 0:11:51.720
actually who makes the contribution because you cannot

225
0:11:51.720 --> 0:11:53.720
expect the same level of contribution from

226
0:11:53.720 --> 0:11:56.880
a student or from an LLVM engineer.

227
0:11:56.880 --> 0:11:59.200
Especially when you're a PhD student,

228
0:11:59.200 --> 0:12:00.600
you have a, I don't know, a deadline,

229
0:12:00.600 --> 0:12:02.880
you just want a tool who does something.

230
0:12:02.880 --> 0:12:07.880
You're not going to spend times and times on how you do stuff,

231
0:12:07.880 --> 0:12:09.280
as long as it works.

232
0:12:09.280 --> 0:12:13.400
At least that's my experience dealing with that.

233
0:12:13.400 --> 0:12:17.040
But in my opinion, the accumulation of small details matters,

234
0:12:17.040 --> 0:12:20.840
and it was very explicit in the case of

235
0:12:20.840 --> 0:12:24.080
Barcoach because I came after maybe five,

236
0:12:24.080 --> 0:12:29.200
six years where the accumulation of researchers and PhD students

237
0:12:29.200 --> 0:12:33.640
led to a lot of technical depth.

238
0:12:35.080 --> 0:12:40.320
If there was some advice that were given

239
0:12:40.320 --> 0:12:43.960
to the PhD students or the researcher,

240
0:12:43.960 --> 0:12:47.640
it would have been a way nicer code to read or to maintain.

241
0:12:49.640 --> 0:12:53.680
It's quite obvious, but doing code reviews helps a lot.

242
0:12:53.680 --> 0:12:56.880
Sometimes you cannot do them if there is no one

243
0:12:56.880 --> 0:13:00.440
able to actually provide some useful feedback on this.

244
0:13:00.440 --> 0:13:03.440
Like in the case when people don't know LLVM,

245
0:13:03.440 --> 0:13:05.320
you cannot expect them to review code and

246
0:13:05.320 --> 0:13:08.080
provide some a lot of feedback.

247
0:13:08.080 --> 0:13:11.480
But what I do know is I

248
0:13:11.480 --> 0:13:14.400
redirect every time to the LLVM programmers manual.

249
0:13:14.400 --> 0:13:16.320
It's not like the first thing you do.

250
0:13:16.320 --> 0:13:19.560
Usually, you just go to a search engine and search for what you want.

251
0:13:19.560 --> 0:13:21.360
But I will argue that actually reading

252
0:13:21.360 --> 0:13:25.480
the programmer manual is more helpful in that specific case.

253
0:13:25.480 --> 0:13:27.840
Some things that I know people don't want to

254
0:13:27.840 --> 0:13:29.800
do when they are starting LLVM is just

255
0:13:29.800 --> 0:13:31.600
read the code from the past using LLVM.

256
0:13:31.600 --> 0:13:33.800
There are a lot of good stuff in there.

257
0:13:33.800 --> 0:13:37.240
Obviously, if you're not familiar with C++ and LLVM,

258
0:13:37.240 --> 0:13:39.120
it's not the easiest,

259
0:13:39.120 --> 0:13:41.760
but I think it's still worth it.

260
0:13:42.800 --> 0:13:48.320
So the next topic is updating the LLVM versions.

261
0:13:48.720 --> 0:13:52.740
So far when I've developed out of two tools,

262
0:13:52.740 --> 0:13:56.520
I've always set the version to one specific number.

263
0:13:56.520 --> 0:13:58.600
Let's say LLVM 9.

264
0:13:58.600 --> 0:14:01.480
Then when LLVM 10 comes out,

265
0:14:01.480 --> 0:14:06.560
you rebase your plugin and check if any API broke.

266
0:14:06.560 --> 0:14:09.120
Either was some changes in the IR.

267
0:14:09.120 --> 0:14:12.040
Most recently, I am thinking about Opac pointers.

268
0:14:12.040 --> 0:14:18.200
It was quite a big change when updating the LLVM version.

269
0:14:18.200 --> 0:14:22.000
Something to consider when doing this is that it may be time consuming.

270
0:14:22.000 --> 0:14:24.520
A lot of time can be spent in,

271
0:14:24.520 --> 0:14:29.280
it may be just a day if there were no changes in the API.

272
0:14:29.280 --> 0:14:31.360
But it could also be very time consuming.

273
0:14:31.360 --> 0:14:34.160
For instance, if you have to change all your passes because it's been

274
0:14:34.160 --> 0:14:38.320
three years that the new pass manager was out and you still didn't do the migration,

275
0:14:38.320 --> 0:14:40.760
and now suddenly it's deprecated and it's going to be removed.

276
0:14:40.760 --> 0:14:42.760
So you need to migrate your passes.

277
0:14:42.760 --> 0:14:44.640
So you have to do it.

278
0:14:44.640 --> 0:14:46.840
In my experience, it's quite obvious too,

279
0:14:46.840 --> 0:14:50.200
but skipping versions makes it worse.

280
0:14:50.200 --> 0:14:54.600
Sorry. Something that I've seen,

281
0:14:54.600 --> 0:14:57.120
and I know sometimes it cannot be avoided,

282
0:14:57.120 --> 0:15:01.360
but in that case it was avoidable.

283
0:15:01.360 --> 0:15:05.400
But basically trying to support multiple LLVM versions at once.

284
0:15:05.400 --> 0:15:08.040
Like say support from LLVM 9 through 12,

285
0:15:08.040 --> 0:15:10.280
it's actually what was done.

286
0:15:10.280 --> 0:15:13.200
Don't do it. If you can, just don't do it.

287
0:15:13.200 --> 0:15:16.520
It's a pick a version and stay like this because otherwise,

288
0:15:16.520 --> 0:15:18.960
it's just multiple if-def and everyone

289
0:15:18.960 --> 0:15:22.880
is going to code and it's a unmaintainable, I think.

290
0:15:23.920 --> 0:15:27.680
So now, let's talk about passes.

291
0:15:27.680 --> 0:15:33.560
If you look for a Hello World pass on the Internet,

292
0:15:33.560 --> 0:15:36.880
you will get a Hello World pass which is a transformation pass.

293
0:15:36.880 --> 0:15:39.800
So in LLVM, you have two kinds of passes.

294
0:15:39.800 --> 0:15:43.240
One was the first kind is analysis,

295
0:15:43.240 --> 0:15:45.520
and basically they don't touch the IR.

296
0:15:45.520 --> 0:15:49.160
You just look at the IR and maybe provide some result,

297
0:15:49.160 --> 0:15:51.280
which is a result of the analysis and that can be

298
0:15:51.280 --> 0:15:54.920
used by transformation passes or other analysis.

299
0:15:54.920 --> 0:15:57.000
There are the transformation passes

300
0:15:57.000 --> 0:15:59.920
which may or may not change the IR.

301
0:16:00.520 --> 0:16:03.520
Obviously, when you get your Hello World pass,

302
0:16:03.520 --> 0:16:05.760
you want to do everything in it.

303
0:16:05.840 --> 0:16:08.920
I'm not talking about LLVM developers,

304
0:16:08.920 --> 0:16:11.240
but I'm talking about students and researchers that have

305
0:16:11.240 --> 0:16:13.440
the pass and they put everything in it.

306
0:16:13.440 --> 0:16:18.000
So it's fine when it's just

307
0:16:18.000 --> 0:16:20.160
one shot or something like that,

308
0:16:20.160 --> 0:16:22.720
but in the time at some point,

309
0:16:22.720 --> 0:16:25.160
both the analysis and the transformations

310
0:16:25.160 --> 0:16:29.200
are semantically different and LLVM has some mechanism

311
0:16:29.200 --> 0:16:31.920
to make it easy for you to have

312
0:16:31.920 --> 0:16:34.800
the analysis run only when it's needed.

313
0:16:34.800 --> 0:16:36.520
There is a caching mechanism.

314
0:16:36.520 --> 0:16:39.800
You can say, okay, I want this analysis for this object,

315
0:16:39.800 --> 0:16:43.560
and if it exists, it will give it back to you.

316
0:16:43.560 --> 0:16:48.080
Also, it avoids the passing structure around

317
0:16:48.080 --> 0:16:50.000
because when you are in a transformation pass,

318
0:16:50.000 --> 0:16:52.120
you can request any analysis from basically anywhere

319
0:16:52.120 --> 0:16:54.960
as long as you have the analysis manager.

320
0:16:55.240 --> 0:17:01.200
So this is something that have cost me quite some time,

321
0:17:01.200 --> 0:17:05.200
like just untangling the analysis code from the transformation code,

322
0:17:05.200 --> 0:17:09.080
and overall, it's improved the performances

323
0:17:09.080 --> 0:17:14.720
because some analysis were requested more than once for the same object.

324
0:17:17.560 --> 0:17:20.120
So yes, it leads me to

325
0:17:20.120 --> 0:17:24.240
investigating performance issues because it was something too.

326
0:17:24.560 --> 0:17:28.880
So what happens when you don't know LLVM and you want to debug your code?

327
0:17:28.880 --> 0:17:31.760
You put LLVM errors everywhere and you

328
0:17:31.760 --> 0:17:33.920
come on them out when your code is ready.

329
0:17:33.920 --> 0:17:35.840
Okay. So it's a nightmare.

330
0:17:35.840 --> 0:17:40.840
I mean, it works, but you're not supposed to do it like this.

331
0:17:41.800 --> 0:17:49.040
So specifically for like a printf-like debug stuff,

332
0:17:49.040 --> 0:17:50.560
you have some LLVM helper.

333
0:17:50.560 --> 0:17:51.600
It's actually quite handy.

334
0:17:51.600 --> 0:17:54.840
You just put a debug type somewhere and you dot CPP.

335
0:17:54.840 --> 0:18:00.040
You wrap everything in LLVM debug because it does all the thing for you.

336
0:18:00.040 --> 0:18:02.640
If you don't include the debug information,

337
0:18:02.640 --> 0:18:05.080
it doesn't even appear in the binary.

338
0:18:05.080 --> 0:18:07.600
When you're running your path with ops,

339
0:18:07.600 --> 0:18:09.600
you can say, okay, I want to show

340
0:18:09.600 --> 0:18:12.200
the big information for this kind of path.

341
0:18:12.200 --> 0:18:17.640
Basically, provide the same feature and you don't have to come out LLVM errors.

342
0:18:17.640 --> 0:18:21.880
The other thing is timing your code,

343
0:18:21.880 --> 0:18:23.080
being able to tell, okay,

344
0:18:23.080 --> 0:18:26.360
this part of the transformation is costing me time.

345
0:18:26.360 --> 0:18:31.240
So what I've seen was some manual attempt to do timers,

346
0:18:31.240 --> 0:18:33.200
and basically, you declare all the timers,

347
0:18:33.200 --> 0:18:37.040
you start them manually and it start being a mess really quick.

348
0:18:37.040 --> 0:18:40.520
Hopefully, now we have a time trace scope.

349
0:18:40.520 --> 0:18:46.640
It was, I think it's what's used when you use F-time trace when starting Clang.

350
0:18:46.640 --> 0:18:48.320
So basically, it's just one line.

351
0:18:48.320 --> 0:18:52.040
You put one variable and when it's constructed,

352
0:18:52.040 --> 0:18:55.320
it starts a scope and it starts a timer and when it's disrupted,

353
0:18:55.320 --> 0:18:58.160
it stops the timer.

354
0:18:58.160 --> 0:19:03.840
LLVM has a whole system for this and it emits a GZON.

355
0:19:03.840 --> 0:19:08.040
If you put this GZON in a speed scope,

356
0:19:08.040 --> 0:19:09.240
you get something like that.

357
0:19:09.240 --> 0:19:14.440
You can see basically everything in your code without having to do anything.

358
0:19:14.440 --> 0:19:16.720
You get the entry points,

359
0:19:16.720 --> 0:19:21.440
you get the analysis, and here it was quite obvious for us,

360
0:19:21.440 --> 0:19:23.480
was the changes, what the changes were,

361
0:19:23.480 --> 0:19:27.760
because this analysis for instance was called multiple times.

362
0:19:27.760 --> 0:19:29.480
But it was for the same objects.

363
0:19:29.480 --> 0:19:32.160
So for instance, it would appear here too.

364
0:19:32.160 --> 0:19:34.880
But because of the caching mechanism and the untangling,

365
0:19:34.880 --> 0:19:37.920
it basically just was just called once.

366
0:19:37.920 --> 0:19:41.600
So this is something nice that you get basically for free.

367
0:19:41.600 --> 0:19:47.640
So now, some conclusion on the tool developments.

368
0:19:47.640 --> 0:19:50.640
So it's a fairly basic conclusion.

369
0:19:50.640 --> 0:19:52.240
Try to invest in maintenance.

370
0:19:52.240 --> 0:19:53.760
I know it's not always possible,

371
0:19:53.760 --> 0:20:00.720
especially in a scientific project, but it's worth it.

372
0:20:00.720 --> 0:20:03.640
Don't remember the wheel. If you want to do something in LLVM,

373
0:20:03.640 --> 0:20:07.960
it likely has already something in LLVM for this.

374
0:20:07.960 --> 0:20:09.560
Keep the dish minimal.

375
0:20:09.560 --> 0:20:12.160
One of the main weakness of Power Coach right now is that we

376
0:20:12.160 --> 0:20:16.440
use some passes which exist already in LLVM.

377
0:20:16.440 --> 0:20:18.680
I'm thinking about memory SSA, for instance,

378
0:20:18.680 --> 0:20:22.720
we use some copy of this and from a maintenance point of view,

379
0:20:22.720 --> 0:20:25.880
it's not quite nice so we need to migrate this away.

380
0:20:25.880 --> 0:20:28.680
If your passes can be useful to others,

381
0:20:28.680 --> 0:20:30.480
just try to upstream them.

382
0:20:30.480 --> 0:20:34.560
If you don't use them, you don't have to pay for them.

383
0:20:34.560 --> 0:20:37.760
Then let's talk a bit about usability,

384
0:20:37.760 --> 0:20:40.160
because it's quite a big deal for a tool,

385
0:20:40.160 --> 0:20:42.120
because you want it to be usable.

386
0:20:42.120 --> 0:20:44.760
So first, from a developer point of view,

387
0:20:44.760 --> 0:20:50.240
if your developers are going to be non-LVM folks,

388
0:20:50.240 --> 0:20:53.720
you don't want them to go into the LLVM install and stuff.

389
0:20:53.720 --> 0:20:57.840
So I've had good experience with using Docker

390
0:20:57.840 --> 0:21:01.440
and basically provide a Docker image with

391
0:21:01.440 --> 0:21:04.160
the LLVM compiled install somewhere

392
0:21:04.160 --> 0:21:08.440
or just install using the app repositories.

393
0:21:09.720 --> 0:21:13.280
Have some clear CI like how to build your tool,

394
0:21:13.280 --> 0:21:16.680
like just looking at the CI should be enough to know how to

395
0:21:16.680 --> 0:21:18.960
build your tool from a developer point of view.

396
0:21:18.960 --> 0:21:22.240
The other great thing is when you use LLVM,

397
0:21:22.240 --> 0:21:24.240
you get LLVM tools with it.

398
0:21:24.240 --> 0:21:26.200
So you get the lead and fight check.

399
0:21:26.200 --> 0:21:30.080
So instead of going through some manual testing and stuff,

400
0:21:30.080 --> 0:21:33.520
you can just use them and it's actually quite nice.

401
0:21:33.520 --> 0:21:37.280
Yes, of course, I could talk about coding standards,

402
0:21:37.280 --> 0:21:40.640
but basically since you're making a plug-in or a tool for LLVM,

403
0:21:40.640 --> 0:21:42.600
it makes sense to follow the same standard and you have

404
0:21:42.600 --> 0:21:46.680
already clung format and clung tidy configuration for this.

405
0:21:46.680 --> 0:21:49.520
Now as a user,

406
0:21:49.520 --> 0:21:51.840
you obviously don't want

407
0:21:51.840 --> 0:21:56.200
scientific application developer to compile your code from source.

408
0:21:56.200 --> 0:22:01.720
You want them to just have the plug-in and use it or have the tool and use it.

409
0:22:01.720 --> 0:22:05.080
If you look at Hello World passes,

410
0:22:05.080 --> 0:22:08.320
you see a lot of times that you have to first get the IR.

411
0:22:08.320 --> 0:22:11.640
So in our case, it's either from clung or from flung.

412
0:22:13.040 --> 0:22:15.080
You have to call up,

413
0:22:15.080 --> 0:22:18.360
load the path manually and call the path manually.

414
0:22:18.360 --> 0:22:27.000
So I would argue this is not nice enough for researchers and students.

415
0:22:27.000 --> 0:22:30.320
Since Barcoach is a verification tool,

416
0:22:30.320 --> 0:22:34.920
we cannot expect users to call it on every single file.

417
0:22:34.920 --> 0:22:40.600
So we actually had to do some more tooling to create some wrapper,

418
0:22:40.600 --> 0:22:44.520
which takes original compiler invocation,

419
0:22:44.520 --> 0:22:46.880
runs the original compiler invocation,

420
0:22:46.880 --> 0:22:50.120
generates a temporary IR and then runs a tool over it.

421
0:22:50.120 --> 0:22:56.280
It makes it much more easy for the users to just integrate with the other tools or to make.

422
0:22:57.640 --> 0:23:03.720
So that makes the tool more user friendly than I would say is unusual.

423
0:23:03.720 --> 0:23:07.000
The other part is how do you get the tool?

424
0:23:07.000 --> 0:23:12.080
So again, I've had good experience with Docker,

425
0:23:12.080 --> 0:23:17.200
especially for students because it's easy for them.

426
0:23:17.520 --> 0:23:24.000
Sometimes, obviously, we also provide some package for major distributions,

427
0:23:24.000 --> 0:23:29.280
but you actually have to worry about how is LLVM packaged on the target system,

428
0:23:29.280 --> 0:23:31.360
because depending on what is available,

429
0:23:31.360 --> 0:23:34.720
how easy chair libraries, dialyman stuff,

430
0:23:34.720 --> 0:23:37.680
it's not the same thing.

431
0:23:37.680 --> 0:23:42.880
And yeah, Docker, it's not something you can quite use on shared HPC clusters.

432
0:23:42.880 --> 0:23:44.960
You're more looking at stuff like Geeks,

433
0:23:44.960 --> 0:23:49.280
for instance, when targeting such platforms.

434
0:23:49.280 --> 0:23:53.080
So for this, you need some packaging.

435
0:23:53.080 --> 0:23:56.600
And packaging is my last pointer.

436
0:23:56.600 --> 0:24:03.040
So obviously, we used to do it yourself approach,

437
0:24:03.040 --> 0:24:06.000
basically just create a shared library and hope for the best.

438
0:24:06.000 --> 0:24:11.920
It doesn't work because you depend on how opt is installed and compiled,

439
0:24:11.920 --> 0:24:14.400
because you're loading dynamically a library into opt.

440
0:24:14.400 --> 0:24:17.840
So if you have not used the same like C++ libraries,

441
0:24:17.840 --> 0:24:19.440
you're going to run into issues.

442
0:24:19.440 --> 0:24:23.280
You don't know for sure which path manager is enabled by default in opt.

443
0:24:23.280 --> 0:24:24.880
So there's also this.

444
0:24:26.160 --> 0:24:32.080
So we've moved to doing some proper packages for APT,

445
0:24:32.080 --> 0:24:36.080
the dev and for Geeks and for Red Hat too,

446
0:24:36.080 --> 0:24:39.840
because we have some users using some custom version of Red Hat.

447
0:24:41.840 --> 0:24:44.240
And for this, we actually have quite an interesting issue,

448
0:24:44.240 --> 0:24:51.920
because we are sure that the LL version in their image is not available.

449
0:24:51.920 --> 0:24:57.600
So we made the choice of shipping just one single static tool.

450
0:24:57.600 --> 0:25:04.240
And for this, it was actually quite easy, because as I said when I talked about CMake,

451
0:25:04.240 --> 0:25:10.320
you just say, okay, I want this to be statically or as a shared library and

452
0:25:10.320 --> 0:25:14.160
the LLVM CMake handles it for you.

453
0:25:14.160 --> 0:25:17.760
And it was quite a nice experience for us to package for so

454
0:25:17.760 --> 0:25:21.760
many distribution without having to worry too much about CMake option and stuff.

455
0:25:21.760 --> 0:25:26.560
So some takeaways for the whole talk.

456
0:25:27.440 --> 0:25:31.520
In my opinion, the LLVM integration has evolved a lot and in a good direction.

457
0:25:31.520 --> 0:25:35.760
It's way easier to integrate with LLVM now than it was 10 years ago.

458
0:25:35.760 --> 0:25:42.400
It's nice, but it's nice to say it because when nice stuff happens, you have to say it too.

459
0:25:43.440 --> 0:25:44.480
Be prepared for maintenance.

460
0:25:44.480 --> 0:25:52.080
If you want to create a note of tool, you have to invest in maintenance both for LLVM rebases,

461
0:25:52.080 --> 0:25:55.920
basically reviews and make sure that your contributors,

462
0:25:56.720 --> 0:26:01.360
if you are able to provide some LLVM guidance to your contributors, do it and it's worth it.

463
0:26:03.600 --> 0:26:05.840
Investing in CI is worth it, obviously.

464
0:26:05.840 --> 0:26:11.760
And LLVM documentation, I would definitely every day recommend

465
0:26:11.760 --> 0:26:17.920
going to the LLVM documentation rather than Google for understanding what is available in LLVM.

466
0:26:20.640 --> 0:26:27.200
And yeah, I'm encouraged by students to read the LLVM source code, but it's sometimes a bit hard.

467
0:26:28.880 --> 0:26:34.240
So if you have questions or comments, feel free and I will be happy to answer them.

468
0:26:35.280 --> 0:26:35.780
Yeah.

469
0:26:35.780 --> 0:26:39.780
Yes.

470
0:26:52.580 --> 0:26:58.660
So the question is for the wrapper we created, what do we use to create this wrapper, right?

471
0:26:58.660 --> 0:27:05.540
So basically it's a very, very small LLVM tool.

472
0:27:05.540 --> 0:27:07.780
Maybe you are familiar with not in LLVM.

473
0:27:07.780 --> 0:27:14.020
There is a very small utility in LLVM which just does not on the return of a program.

474
0:27:14.020 --> 0:27:16.580
And it's a very small LLVM tool based on LLVM.

475
0:27:17.220 --> 0:27:19.860
And we use a similar approach.

476
0:27:20.420 --> 0:27:27.460
Basically we say, okay, I created basically an empty main where I just use the LLVM support

477
0:27:27.460 --> 0:27:32.500
library to get the benefit from like argument parsing and the data types and so on.

478
0:27:33.060 --> 0:27:42.100
And I just pass the command line and call successfully clone the original compiler line.

479
0:27:42.100 --> 0:27:50.660
And then I just generate the intermediate representation for it by adding the appropriate

480
0:27:50.660 --> 0:27:54.580
flag and filtering out the other object generation flags.

481
0:27:54.580 --> 0:27:56.900
And then I just run the tool over it.

482
0:27:59.780 --> 0:28:00.580
Yes.

483
0:28:00.580 --> 0:28:07.140
Yes, because you can just, for instance, with CMake you can use the CMake C launcher.

484
0:28:07.140 --> 0:28:11.540
Basically just like C cache work for LLVM, you just change the launcher and you can use

485
0:28:11.540 --> 0:28:13.460
the tool to launch the compiler.

486
0:28:13.460 --> 0:28:19.060
And for all two tools you can actually, actually in our project we use MPICC,

487
0:28:19.060 --> 0:28:25.060
but we are able to change the compiler used for MPICC and say, okay, use instead of

488
0:28:25.060 --> 0:28:26.900
a package clone instead of GDC, for instance.

489
0:28:27.540 --> 0:28:30.100
And the first point was,

490
0:28:41.540 --> 0:28:46.020
so the question is, when you ship your tool, do you link statically or dynamically?

491
0:28:46.020 --> 0:28:49.140
Basically, yeah. So both, actually both.

492
0:28:50.100 --> 0:28:56.260
When shipping for Radatz, because we don't have a control over what package are in their custom

493
0:28:56.820 --> 0:29:00.900
image, we ship statically because we are not sure which LLVM we are going to have.

494
0:29:00.900 --> 0:29:04.980
So we just, the binary is 100 megabytes, but we don't have a much choice.

495
0:29:04.980 --> 0:29:15.540
And when shipping for system like Ubuntu or Debian, we just ship that with the dependence on the shared libraries.

496
0:29:15.540 --> 0:29:36.980
Yes?

497
0:29:36.980 --> 0:29:42.900
So the question is, when we're basing the tool from one LL version to the next one,

498
0:29:42.900 --> 0:29:47.700
do you use the change log developers put their love into?

499
0:29:47.700 --> 0:29:50.740
And if yes, is it helpful?

500
0:29:52.340 --> 0:29:54.100
Unfortunately, the answer is no.

501
0:29:56.580 --> 0:30:02.900
But that's because I look at the LLVM weakles, so I kind of know what happens.

502
0:30:02.900 --> 0:30:04.820
This is just my way of doing stuff.

503
0:30:04.820 --> 0:30:13.300
Yeah, so no, but if I would look into the change log, I would find helpful information, I'm sure.

504
0:30:24.980 --> 0:30:31.380
So the question is, am I trying to rebase as LLVM progresses,

505
0:30:31.380 --> 0:30:36.580
or am I just rebasing every version when it's released? And it's only when a release

506
0:30:37.620 --> 0:30:44.420
comes out, I do the rebase. It's easier because otherwise, you know, some, yeah, I mean,

507
0:30:44.420 --> 0:30:50.180
you know the stuff, depending on what kind of target you ship for, it's hard.

508
0:30:51.060 --> 0:30:56.580
And it's just simpler to say, okay, we know and then, like, we know we need to rebase a version, and it's fine.

509
0:30:56.580 --> 0:31:01.620
Thank you.

