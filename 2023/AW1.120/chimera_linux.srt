1
0:00:00.000 --> 0:00:14.140
All right, looks like we can begin, so welcome.

2
0:00:14.140 --> 0:00:19.680
And I will tell you about my project which is called Chimera Linux.

3
0:00:19.680 --> 0:00:22.920
But first let me introduce myself a bit.

4
0:00:22.920 --> 0:00:25.520
I'm a software developer from the Czech Republic.

5
0:00:25.520 --> 0:00:29.760
I've been contributing to open source software since 2007.

6
0:00:29.760 --> 0:00:36.320
And currently I'm on a break from work, so I'm kind of working on the distro full time.

7
0:00:36.320 --> 0:00:41.680
When I'm not on a break for work, I work in the WebKit team in Iglia.

8
0:00:41.680 --> 0:00:46.360
Previously I also used to work for Samsung in the open source group where I worked on

9
0:00:46.360 --> 0:00:51.580
the Enlightenment Foundation libraries and the Window Manager.

10
0:00:51.580 --> 0:00:58.560
Since 2009 I've been using FreeBSD, also on desktop for about ten years.

11
0:00:58.560 --> 0:01:05.720
But I've not been using that on desktop since about 2018 because I've been mostly using

12
0:01:05.720 --> 0:01:10.640
power architecture computers these days which FreeBSD doesn't have the greatest support

13
0:01:10.640 --> 0:01:11.640
for.

14
0:01:11.640 --> 0:01:14.720
So for example, my GPU wouldn't work.

15
0:01:14.720 --> 0:01:20.880
I'm also a former developer of the Void Linux distribution which has served as a huge inspiration

16
0:01:20.880 --> 0:01:26.800
for this project, especially in the design of the packaging system.

17
0:01:26.800 --> 0:01:32.000
And I sort of do all sorts of things besides distribution development.

18
0:01:32.000 --> 0:01:37.280
I also do, for example, game development, compiler stuff.

19
0:01:37.280 --> 0:01:41.200
I did some kernel bits as well.

20
0:01:41.200 --> 0:01:43.240
But now what's Chimera Linux?

21
0:01:43.240 --> 0:01:47.320
It's a new Linux distribution which I started in 2021.

22
0:01:47.320 --> 0:01:51.360
And it's a general purpose distribution created from scratch.

23
0:01:51.360 --> 0:01:59.200
It utilizes core tools from FreeBSD which is one of the big differences from standard

24
0:01:59.200 --> 0:02:03.460
distributions which is GNU tools for this or Busybox for example.

25
0:02:03.460 --> 0:02:07.200
It uses the LLVM toolchain to compile all the packages.

26
0:02:07.200 --> 0:02:14.120
As a matter of fact, there's currently no GCC in the distribution other than for some

27
0:02:14.120 --> 0:02:18.560
variants of U-Boot for specific ARM devices.

28
0:02:18.560 --> 0:02:24.040
It uses the muscle Lipsi and it's a rolling release distribution so there are no releases.

29
0:02:24.040 --> 0:02:26.920
It sort of updates continuously.

30
0:02:26.920 --> 0:02:29.640
And it's also highly portable to many architectures.

31
0:02:29.640 --> 0:02:37.600
Right now we are supporting Arch 64, Power, Little Indian, soon there will be PowerBigIndian,

32
0:02:37.600 --> 0:02:45.920
X8664 as well as complete full support for RISC-5 64-bit.

33
0:02:45.920 --> 0:02:53.160
I started this project in early mid-2021 and it started with C-Build which is sort of a

34
0:02:53.160 --> 0:02:55.960
meta-build system for packages.

35
0:02:55.960 --> 0:03:01.920
You create your packaging templates and these basically describe the package and how to

36
0:03:01.920 --> 0:03:05.280
build it and C-Build builds it.

37
0:03:05.280 --> 0:03:10.280
I also void Linux developer at this time and I started C-Build as a way to investigate

38
0:03:10.280 --> 0:03:16.320
if I can fix many of the shortcomings of void Linux's Xbps SRC system.

39
0:03:16.320 --> 0:03:21.360
So I've created a quick distribution around C-Build which consisted of GCC and GNU user

40
0:03:21.360 --> 0:03:26.120
runs as well as the Xbps package manager which you avoid to use this.

41
0:03:26.120 --> 0:03:29.120
At this point it was only about 50 packaging templates.

42
0:03:29.120 --> 0:03:30.120
So it was very tiny.

43
0:03:30.120 --> 0:03:37.360
It couldn't boot definitely because it had no kernel and no bootloader or init system

44
0:03:37.360 --> 0:03:39.000
even or anything.

45
0:03:39.000 --> 0:03:44.080
So it was just like a little container which was capable of building itself when hosted

46
0:03:44.080 --> 0:03:46.200
on another distribution.

47
0:03:46.200 --> 0:03:51.900
And as I said I was trying to fix many of the issues and main focuses of C-Build have

48
0:03:51.900 --> 0:03:56.360
been performance as well as correctness.

49
0:03:56.360 --> 0:04:04.480
This was when I first managed to make Kaimira boot in VM.

50
0:04:04.480 --> 0:04:11.120
Shortly after those 50 packages switched to LLVM and removal of GCC followed as well as

51
0:04:11.120 --> 0:04:17.520
the switch to FreeBSD tools, removal of the GNU stuff and so on and as well as gradual

52
0:04:17.520 --> 0:04:19.880
expansion of all the packages.

53
0:04:19.880 --> 0:04:25.880
I've been sort of iteratively enhancing the distribution ever since and until it got to

54
0:04:25.880 --> 0:04:27.280
the current state.

55
0:04:27.280 --> 0:04:34.280
In late 2021 it was possible to boot the system and it's capable of bootstrapping itself.

56
0:04:34.280 --> 0:04:40.280
In early 2022 there was a full GNOME desktop already.

57
0:04:40.280 --> 0:04:45.140
This was when I got a Wayland Compositor running and of course everything needs to be able

58
0:04:45.140 --> 0:04:52.320
to run Doom so we got Doom working as a terminal and some other basic stuff but this was I

59
0:04:52.320 --> 0:04:57.240
believe around late 2021.

60
0:04:57.240 --> 0:05:06.000
I had a talk about the distro at FOSDAM 2022 and many things happened during 2022 so last

61
0:05:06.000 --> 0:05:11.000
year I did the talk as a sort of chronological thing.

62
0:05:11.000 --> 0:05:14.400
I'm not going to do that this year because there have been too many things and I couldn't

63
0:05:14.400 --> 0:05:18.200
fit it into a 50 minute slot.

64
0:05:18.200 --> 0:05:25.600
Which focus has been in last year on security hardening and on development of different

65
0:05:25.600 --> 0:05:29.080
new solutions for things which we've been missing.

66
0:05:29.080 --> 0:05:34.320
I'm currently aiming for an alpha release which will be sort of early adapter release

67
0:05:34.320 --> 0:05:37.800
where things will mostly work on desktop.

68
0:05:37.800 --> 0:05:46.280
In late February or early March I plan to make it coincide with one of the betas of

69
0:05:46.280 --> 0:05:53.800
FreeBSD 13.2 in order to be able to rebase the tooling.

70
0:05:53.800 --> 0:05:56.720
Now for some motivations why did I create this project?

71
0:05:56.720 --> 0:05:59.840
I've been unhappy with existing systems.

72
0:05:59.840 --> 0:06:04.760
There are many great things that existing systems have but there's always at least

73
0:06:04.760 --> 0:06:10.360
one thing which has been annoying me so I sort of wanted to create a thing which would

74
0:06:10.360 --> 0:06:13.080
actually suit me in every single way.

75
0:06:13.080 --> 0:06:18.960
I wanted to make a well rounded practical operating system that wouldn't be just a toy

76
0:06:18.960 --> 0:06:21.880
but something people could actually use.

77
0:06:21.880 --> 0:06:28.040
At the same time I would like to improve software in general that is mainly in terms of portability

78
0:06:28.040 --> 0:06:34.680
as well as security when it comes to things like usage of sanitizers and so on.

79
0:06:34.680 --> 0:06:42.120
I would like to make full use of LLVM not just to replace GCC compiler but actually

80
0:06:42.120 --> 0:06:48.920
utilize the unique strengths of LLVM which includes great sanitizer infrastructure, things

81
0:06:48.920 --> 0:06:53.600
like finLTO which GCC still doesn't have and so on.

82
0:06:53.600 --> 0:07:00.240
Of course proving Linux is an under-gnew Linux is also a major thing.

83
0:07:00.240 --> 0:07:04.520
While doing all this I wanted to have some fun and some people on the internet said I

84
0:07:04.520 --> 0:07:09.400
couldn't do this so of course it's important to prove them wrong.

85
0:07:09.400 --> 0:07:15.680
I wanted to build a nice community which would be fun to hang around with and make a good

86
0:07:15.680 --> 0:07:20.720
system for both myself and for other people.

87
0:07:20.720 --> 0:07:24.320
Now for some general principles of the project.

88
0:07:24.320 --> 0:07:31.040
I strongly believe that projects which basically are centered around a single goal are eventually

89
0:07:31.040 --> 0:07:36.520
doomed to fail because once you reach this goal you have nothing else to do but at the

90
0:07:36.520 --> 0:07:49.680
same time it creates dogmatic things which you are not allowed to cross and it really

91
0:07:49.680 --> 0:07:53.240
restricts you with the development.

92
0:07:53.240 --> 0:07:58.920
On the other side of the problem there's scope creep if you have too many things to do and

93
0:07:58.920 --> 0:08:03.640
you keep expanding on it eventually you get to the point where you never get anything

94
0:08:03.640 --> 0:08:04.640
done.

95
0:08:04.640 --> 0:08:07.040
It's important to balance these things.

96
0:08:07.040 --> 0:08:13.520
I think opinion development is overall a good thing because it gives you a sense of direction

97
0:08:13.520 --> 0:08:16.280
which is always nice to have.

98
0:08:16.280 --> 0:08:21.480
I think obviously quality of the code matters but quality of the community matters even

99
0:08:21.480 --> 0:08:23.960
more so.

100
0:08:23.960 --> 0:08:30.600
I think fun is good so I would like to try to keep it that way and not to get too technical

101
0:08:30.600 --> 0:08:32.200
in the process.

102
0:08:32.200 --> 0:08:38.240
I think free and open source software projects are social spaces and that's why if you let

103
0:08:38.240 --> 0:08:45.320
toxic people into your community it's eventually going to become a job for everybody else.

104
0:08:45.320 --> 0:08:51.640
So I try hard to keep them out but at the same time I try to make sure it does not get

105
0:08:51.640 --> 0:08:57.720
overly elitist because it should be an open inclusive project for everybody.

106
0:08:57.720 --> 0:09:03.360
As for technical principles I try to make sure things are strict by default and try

107
0:09:03.360 --> 0:09:07.840
to avoid technical debt at all costs.

108
0:09:07.840 --> 0:09:12.920
There should usually be just one way to do things.

109
0:09:12.920 --> 0:09:17.280
That doesn't mean there only has to be one way but more like a good default that people

110
0:09:17.280 --> 0:09:23.280
are supposed to follow and that's sort of intuitive and easy to follow.

111
0:09:23.280 --> 0:09:27.560
This should remain as simple as possible but not too simple.

112
0:09:27.560 --> 0:09:34.840
There are many people who overly focus on things like minimalist systems and in the

113
0:09:34.840 --> 0:09:38.560
process they end up forgetting what's actually practical.

114
0:09:38.560 --> 0:09:44.000
I think security and hardening is also very important and in many Linux distributions

115
0:09:44.000 --> 0:09:49.160
it's sort of overlooked so that's another thing.

116
0:09:49.160 --> 0:09:53.640
And I think portability is also extremely important.

117
0:09:53.640 --> 0:09:57.400
There are many kinds of hardware and people like using many different kinds of hardware.

118
0:09:57.400 --> 0:10:02.200
Of course most people have their x86 computers but there's more of it than you may think

119
0:10:02.200 --> 0:10:08.080
and things like RISC-V are taking off and there's of course power workstations and there's

120
0:10:08.080 --> 0:10:14.320
ARM and so on so it's good to have all these things.

121
0:10:14.320 --> 0:10:21.560
Now good tooling is also very important and related to that is self-sustainability.

122
0:10:21.560 --> 0:10:26.840
That basically means whatever infrastructure you have should be self-contained and easy

123
0:10:26.840 --> 0:10:32.400
to get going and easy to replicate on any new computer.

124
0:10:32.400 --> 0:10:36.840
Related to that is being able to bootstrap the system from a source code.

125
0:10:36.840 --> 0:10:43.040
I think that's sort of a double-edged sword because some people don't care about bootstrapability

126
0:10:43.040 --> 0:10:48.320
at all and things are massive binaries downloaded from the internet.

127
0:10:48.320 --> 0:10:54.600
On the other side of the coin there's people who insist on complete bootstrapability from

128
0:10:54.600 --> 0:11:02.680
source code for everything even if it involves doing completely cursed things such as ever

129
0:11:02.680 --> 0:11:08.800
seen how to bootstrap the Haskell compiler from a source completely.

130
0:11:08.800 --> 0:11:13.720
It's like if you want to do it and you have to go through an ancient unmaintained Haskell

131
0:11:13.720 --> 0:11:20.280
compiler which only targets 32-bit x86 computers and compile some stuff on NAND and it's from

132
0:11:20.280 --> 0:11:25.120
2004 and then you have to iterate through newer versions.

133
0:11:25.120 --> 0:11:30.520
Eventually you get to GHC and then you can cross-compile a partial distribution for architecture

134
0:11:30.520 --> 0:11:36.440
and then go from that and eventually you reach your goal.

135
0:11:36.440 --> 0:11:44.960
I think it's a means to an end and it's important but not that important.

136
0:11:44.960 --> 0:11:50.200
Another thing is that I've seen over the years many things and I think it's something is

137
0:11:50.200 --> 0:11:54.440
written in shell and it's a complicated program and it probably shouldn't be.

138
0:11:54.440 --> 0:12:00.240
It should be easy to do the right thing but tooling should also make it difficult to do

139
0:12:00.240 --> 0:12:07.600
the bad thing, kind of steer people towards doing what's right and doing so out of the

140
0:12:07.600 --> 0:12:08.600
box.

141
0:12:08.600 --> 0:12:13.960
Documentation is obviously also important and many people avoid writing documentation.

142
0:12:13.960 --> 0:12:19.680
I understand them because I'm also guilty of this in many cases but yeah we should strive

143
0:12:19.680 --> 0:12:21.800
for a good documentation.

144
0:12:21.800 --> 0:12:24.560
There's also the question of systemd.

145
0:12:24.560 --> 0:12:30.600
I believe systemd is in many aspects not great but also it brought necessary change

146
0:12:30.600 --> 0:12:36.640
to Linux and there are basically many people and distributions who just stick their head

147
0:12:36.640 --> 0:12:45.120
into the sand and just avoid even considering that systemd might have brought some useful

148
0:12:45.120 --> 0:12:51.960
things and that it might kind of be also their fault that it has become so widely adopted.

149
0:12:51.960 --> 0:12:58.800
So we should develop good solutions to counter whatever systemd has come up with and basically

150
0:12:58.800 --> 0:13:02.000
always try to improve.

151
0:13:02.000 --> 0:13:05.920
Now let's take a look at how a bsd system is developed.

152
0:13:05.920 --> 0:13:11.280
Usually you have your entire system in a single tree and a single repository typically sbn

153
0:13:11.280 --> 0:13:16.360
and so on and you have lots of different components in this repository.

154
0:13:16.360 --> 0:13:21.600
It's a complete system capable of boot so if you invoke the central makefile and compile

155
0:13:21.600 --> 0:13:26.080
the system you generally compile your kernel and compile your user lines and if you put

156
0:13:26.080 --> 0:13:29.360
it together you will get a system which is capable of booting.

157
0:13:29.360 --> 0:13:35.360
And third party software which is not required for the base system is distributed through

158
0:13:35.360 --> 0:13:37.120
some kind of port system.

159
0:13:37.120 --> 0:13:42.520
Of course this doesn't mean that there are no third party components in a base of the

160
0:13:42.520 --> 0:13:49.920
bsd system because I'm not aware of any bsd system which is developing a complete replacement

161
0:13:49.920 --> 0:13:52.640
for the toolchain for example.

162
0:13:52.640 --> 0:13:59.440
You have your lvm or whatever in base and usually it has its own built system integrated

163
0:13:59.440 --> 0:14:04.040
with the existing makefiles but it's a single tree.

164
0:14:04.040 --> 0:14:07.520
Now let's contrast it to a linux distribution.

165
0:14:07.520 --> 0:14:11.800
In a linux distribution it's a collection of software from many different parties which

166
0:14:11.800 --> 0:14:14.880
are separate packages.

167
0:14:14.880 --> 0:14:18.440
And you have linux kernel as the base layer that's always the case otherwise it wouldn't

168
0:14:18.440 --> 0:14:20.640
be a linux distribution.

169
0:14:20.640 --> 0:14:24.920
You have your user line tooling which is often supplied by GNU and you have the libc which

170
0:14:24.920 --> 0:14:28.560
is also often supplied by GNU glpc.

171
0:14:28.560 --> 0:14:33.520
And you have the toolchain to build all this so it's also from GNU because while client

172
0:14:33.520 --> 0:14:37.240
is used for some distributions not too many of them.

173
0:14:37.240 --> 0:14:42.480
And you have the service manager and also some auxiliary tooling around to the service

174
0:14:42.480 --> 0:14:47.160
manager so that's often system D nowadays.

175
0:14:47.160 --> 0:14:53.760
This is tied together with a package manager which handles installing and removing and

176
0:14:53.760 --> 0:14:54.760
so on.

177
0:14:54.760 --> 0:15:00.600
And sometimes you have some of the components always and then you can install or remove

178
0:15:00.600 --> 0:15:02.080
whatever you want.

179
0:15:02.080 --> 0:15:07.600
And linux plus gcc plus glpc plus corutals find utils if utils so on.

180
0:15:07.600 --> 0:15:11.720
It makes GNU linux or what is called GNU linux.

181
0:15:11.720 --> 0:15:18.080
This exists to make sure that all these components work together and they combine well because

182
0:15:18.080 --> 0:15:22.880
many different distributions combine them in different ways and they have different

183
0:15:22.880 --> 0:15:27.600
versions of these components and they all have to play nice.

184
0:15:27.600 --> 0:15:35.200
So the linux kernel has a rule of never breaking user space if a new version of linux kernel

185
0:15:35.200 --> 0:15:37.620
results in a binary not working.

186
0:15:37.620 --> 0:15:44.720
It means it's a bug in the kernel even if it was for example originally an unintended

187
0:15:44.720 --> 0:15:50.120
behavior so this can be kind of a pain.

188
0:15:50.120 --> 0:15:51.800
But let's get back to chimera.

189
0:15:51.800 --> 0:15:54.200
So starting out the toolchain.

190
0:15:54.200 --> 0:15:59.920
LLVM and linux is pretty seamless nowadays most of the time.

191
0:15:59.920 --> 0:16:05.280
You have it available on most linux systems but on most linux systems it's sort of a different

192
0:16:05.280 --> 0:16:10.320
arrangement because you do not have LLVM provide the runtime.

193
0:16:10.320 --> 0:16:13.440
Gcc provides this and it's called libGcc.

194
0:16:13.440 --> 0:16:20.680
It's mostly ABI compatible with libunwind from LLVM but it also includes some of these

195
0:16:20.680 --> 0:16:25.800
built ins which are provided via a separate library in LLVM.

196
0:16:25.800 --> 0:16:31.480
LLVM comes with its own runtime called compiler RT and this is used in chimera instead of

197
0:16:31.480 --> 0:16:33.960
libGcc.

198
0:16:33.960 --> 0:16:40.000
For the C library we use muscle because it's a proven good implementation of a C library

199
0:16:40.000 --> 0:16:45.480
which is used by several distributions already and you can make most software work on it

200
0:16:45.480 --> 0:16:53.800
just fine with maybe with a few patches but better than other libcs.

201
0:16:53.800 --> 0:17:00.680
When you have GNU toolchain you usually have GNU Benu tools to complement Gcc as well as

202
0:17:00.680 --> 0:17:04.600
Lv tools to provide lib else.

203
0:17:04.600 --> 0:17:09.040
Benu tools provides things like linker because Gcc does not come with its own linker.

204
0:17:09.040 --> 0:17:13.960
It also provides different tools which are used together with the compiler things like

205
0:17:13.960 --> 0:17:19.880
erkiver and read else and this kind of stuff.

206
0:17:19.880 --> 0:17:26.280
In chimera this is the LLD from LLVM is used as a linker and it's used everywhere.

207
0:17:26.280 --> 0:17:30.920
As for the other tooling which is provided by Benu tools, Lv toolchain provides this

208
0:17:30.920 --> 0:17:36.040
tooling and this is also used on FreeBSD to provide these tools.

209
0:17:36.040 --> 0:17:42.160
Lv toolchain also provides libelse implementation which replaces the one provided by Lv tools.

210
0:17:42.160 --> 0:17:47.640
Libelse is used in many places but for example the kernel requires it.

211
0:17:47.640 --> 0:17:52.280
LLVM also provides most of these tools which are provided by libutils.

212
0:17:52.280 --> 0:17:56.320
They have a prefix LLVM so for example LLVM read else.

213
0:17:56.320 --> 0:18:02.760
We do not use those in the core system most of the time.

214
0:18:02.760 --> 0:18:08.640
So now to sort out the core user want you have many GNU components as well as non GNU

215
0:18:08.640 --> 0:18:12.640
components things like core utils, find utils, defutils and so on.

216
0:18:12.640 --> 0:18:17.800
You have util linux also which is used by pretty much all distributions and provides sort of

217
0:18:17.800 --> 0:18:21.840
a mixture of tools for all sorts of stuff.

218
0:18:21.840 --> 0:18:29.440
In non GNU distros existing ones such as Alpine you often have Busybox which is a sort of

219
0:18:29.440 --> 0:18:36.320
single binary which can be configured to include many different tools which are otherwise provided

220
0:18:36.320 --> 0:18:39.920
by core utils and so on as well as by util linux.

221
0:18:39.920 --> 0:18:45.200
The main strength of Busybox is that it's a single binary so you can put it in embedded

222
0:18:45.200 --> 0:18:48.920
environments and we can have things mostly work.

223
0:18:48.920 --> 0:18:53.320
But the other side of the coin is that it's very Spartan when it comes to functionality

224
0:18:53.320 --> 0:18:56.440
and the code is also not very good.

225
0:18:56.440 --> 0:19:01.320
But the other alternatives are usually even worse in terms of available functionality.

226
0:19:01.320 --> 0:19:08.440
So FreeBSD tools are the answer here and that's what we've done.

227
0:19:08.440 --> 0:19:13.680
I found this third party port of FreeBSD's tools called BSD utils.

228
0:19:13.680 --> 0:19:21.440
It was a sort of incomplete experimental thing which was not quite ready for an actual system.

229
0:19:21.440 --> 0:19:25.280
So I helped complete it and reach parity with core utils.

230
0:19:25.280 --> 0:19:31.240
I fixed many bugs which were created during porting in the process.

231
0:19:31.240 --> 0:19:36.720
I also ported many other tools to expand coverage and the result is Karmira utils which the

232
0:19:36.720 --> 0:19:45.000
distro currently manages and it's sort of a single easy to build package which includes

233
0:19:45.000 --> 0:19:48.220
all of the tooling you want.

234
0:19:48.220 --> 0:19:55.720
And this replaced not just GNU tooling but also for example a portion of util linux which

235
0:19:55.720 --> 0:20:00.840
makes things much easier for the distribution especially in terms of bootstrapping because

236
0:20:00.840 --> 0:20:06.640
for example in void linux a nxb-psrc which is the build system which is similar to C

237
0:20:06.640 --> 0:20:11.520
build you have stripped down version of util linux in the base build container and you

238
0:20:11.520 --> 0:20:16.400
need this because some of these tools are necessary.

239
0:20:16.400 --> 0:20:23.000
But this means bootstrap problem because when you build a full version of util linux you

240
0:20:23.000 --> 0:20:28.240
have many dependencies which you do not want during bootstrapping of your system.

241
0:20:28.240 --> 0:20:33.120
For example udef or that kind of stuff which you really don't want to pull in.

242
0:20:33.120 --> 0:20:36.920
So it has a stripped down version of util linux for that and then it has a full version

243
0:20:36.920 --> 0:20:40.040
which is built separately and it's kind of a mess.

244
0:20:40.040 --> 0:20:45.240
If we have a single package for the user run all of this can be avoided and then only a

245
0:20:45.240 --> 0:20:50.960
partial build of util linux can be built if needed.

246
0:20:50.960 --> 0:20:57.480
Karmira tools is lean enough for better environments things like init ramfs or even embedded things.

247
0:20:57.480 --> 0:21:04.360
But at the same time it's fully featured enough to be used as interactive tooling so it's

248
0:21:04.360 --> 0:21:06.440
a nice all in one thing.

249
0:21:06.440 --> 0:21:12.920
And of course it helps break up the current monoculture of tooling as well as it's easy

250
0:21:12.920 --> 0:21:14.240
to harden.

251
0:21:14.240 --> 0:21:21.960
For example Karmira tool utilizes client control flow integrity hardening which can be enabled

252
0:21:21.960 --> 0:21:27.080
on Karmira tools very easily and it just works.

253
0:21:27.080 --> 0:21:29.240
Now to get the kernel sorted out.

254
0:21:29.240 --> 0:21:35.720
These two photos one is Karmira running on the MNT reform laptop and the other is running

255
0:21:35.720 --> 0:21:39.420
on Raspberry Pi 3.

256
0:21:39.420 --> 0:21:44.020
The kernel is mostly compatible with client these days and some patches are needed to

257
0:21:44.020 --> 0:21:49.000
support BSD utilities as well as the lip else from L-Toolchain.

258
0:21:49.000 --> 0:21:53.760
I would like to eventually upstream these things and make sure things work out of box.

259
0:21:53.760 --> 0:22:00.560
Until recently there was an issue with the option to use client's internal assembler.

260
0:22:00.560 --> 0:22:07.040
It did not work on some architectures notably 64 bit power because of some legacy debugging

261
0:22:07.040 --> 0:22:08.480
for nonsense.

262
0:22:08.480 --> 0:22:14.880
So GNU binutils was used for that until sometime but nowadays it's not a problem and the client

263
0:22:14.880 --> 0:22:18.120
assembler just works for every architecture.

264
0:22:18.120 --> 0:22:21.620
CKMS.

265
0:22:21.620 --> 0:22:23.480
What is CKMS?

266
0:22:23.480 --> 0:22:29.160
distros usually use a DKMS which stands for dynamic kernel module system to build out

267
0:22:29.160 --> 0:22:35.920
of three kernel modules and it's a massive 5K inline bash script and it has functionality

268
0:22:35.920 --> 0:22:40.640
which seemed like a good idea at the time and nobody uses it and it no longer seems

269
0:22:40.640 --> 0:22:42.440
like a good idea for example.

270
0:22:42.440 --> 0:22:47.400
DKMS can package kernel modules and you can distribute them and of course this doesn't

271
0:22:47.400 --> 0:22:52.040
work because every distro has its own kernel and it can result in slight differences in

272
0:22:52.040 --> 0:22:55.760
ABI and so on so you cannot really do that.

273
0:22:55.760 --> 0:23:00.760
I created CKMS which stands for chimeric kernel module system and it's kind of similar to

274
0:23:00.760 --> 0:23:06.960
DKMS but it's much more lightweight, more robust, it's implemented in Python.

275
0:23:06.960 --> 0:23:11.320
It has privilege separation so when you have your package manager build a kernel module

276
0:23:11.320 --> 0:23:16.120
in a hook during installation and you run your package manager through it, it will properly

277
0:23:16.120 --> 0:23:20.600
drop privileges so it does not run the whole compilation of the module through it which

278
0:23:20.600 --> 0:23:25.600
also happens with DKMS and most setups.

279
0:23:25.600 --> 0:23:30.240
Now for the package manager that's an important thing in a distro.

280
0:23:30.240 --> 0:23:37.560
I considered the FreeBSD package manager at some point but it was not in quite the shape

281
0:23:37.560 --> 0:23:39.480
I would like for production.

282
0:23:39.480 --> 0:23:46.280
I did contribute back some patches to fix a bunch of things with muscle because that

283
0:23:46.280 --> 0:23:52.520
was the main thing which was really problematic and I got it working but there are things

284
0:23:52.520 --> 0:24:02.240
such as version expressions and the version string stuff which is a work in progress and

285
0:24:02.240 --> 0:24:09.560
it's quite obvious that it's mainly all geared towards FreeBSD issues right now.

286
0:24:09.560 --> 0:24:15.840
Eventually I ended up investigating APK from Alpine Linux which ended up proving to be

287
0:24:15.840 --> 0:24:18.400
a great fit.

288
0:24:18.400 --> 0:24:23.520
For one it's lightweight but it's also fairly powerful and I really like its virtual package

289
0:24:23.520 --> 0:24:25.360
system.

290
0:24:25.360 --> 0:24:31.680
It handles things like shared libraries very seamlessly where shared libraries in packages

291
0:24:31.680 --> 0:24:38.680
are provided basically as virtual packages and this makes it easily searchable, easy

292
0:24:38.680 --> 0:24:40.840
for the solver and so on.

293
0:24:40.840 --> 0:24:46.400
I eventually transitioned to APK tools version 3 which is the next generation of APK which

294
0:24:46.400 --> 0:24:53.520
is currently not used by Alpine and it does not have a stable roof yet but it works great.

295
0:24:53.520 --> 0:24:58.280
The main difference in APK 3 is that it no longer uses starballs as packages.

296
0:24:58.280 --> 0:25:07.720
It has a new custom sort of structured format which should help with avoiding vulnerabilities

297
0:25:07.720 --> 0:25:10.520
in the package manager.

298
0:25:10.520 --> 0:25:17.640
By summer 2021 it was fully integrated in C-built and it just worked.

299
0:25:17.640 --> 0:25:22.520
Service management is another big thing you need to boot Linux distribution.

300
0:25:22.520 --> 0:25:28.360
Many options were evaluated in the process for example Runit which is used by Void Linux,

301
0:25:28.360 --> 0:25:37.400
S6 which is a new kid on the block, OpenRC which is classic and built on the same principles

302
0:25:37.400 --> 0:25:39.600
as classic RC systems.

303
0:25:39.600 --> 0:25:45.880
In the end I ended up choosing Dynit which is a new service manager.

304
0:25:45.880 --> 0:25:51.240
I chose it because it's both powerful and lean.

305
0:25:51.240 --> 0:26:00.280
It's implemented in modern C++ so it's also safer than most other service managers.

306
0:26:00.280 --> 0:26:06.720
Most importantly it took me about one afternoon to get it fully working and get the system

307
0:26:06.720 --> 0:26:11.680
from not booting at all to having it completely booting.

308
0:26:11.680 --> 0:26:20.040
It's supervising which means most demons are supervised by the service manager by running

309
0:26:20.040 --> 0:26:24.120
on the foreground and being basically child processes of the service manager.

310
0:26:24.120 --> 0:26:28.200
But you can have background processes as well.

311
0:26:28.200 --> 0:26:31.840
It's less robust so it should be avoided most of the time.

312
0:26:31.840 --> 0:26:38.920
It's dependency based so it can ensure that your services start in correct order.

313
0:26:38.920 --> 0:26:44.600
It has support for things like one shots which help immensely during early boot because most

314
0:26:44.600 --> 0:26:48.960
things you need to do during early boot is basically things you run once and they do

315
0:26:48.960 --> 0:26:51.720
not have any sort of persistent process.

316
0:26:51.720 --> 0:26:54.600
So the early boot process is full of one shots.

317
0:26:54.600 --> 0:27:02.200
For example, void Linux solves it by making these one shots a bunch of sequential shell

318
0:27:02.200 --> 0:27:06.680
scripts which are run before the actual services are running.

319
0:27:06.680 --> 0:27:10.640
It's not a great solution because it's not very flexible.

320
0:27:10.640 --> 0:27:14.520
In any case it's a good base for a solid service infrastructure.

321
0:27:14.520 --> 0:27:19.600
We have a custom suite of core services for Dynit written from scratch.

322
0:27:19.600 --> 0:27:23.960
It has full support for fine grained targets.

323
0:27:23.960 --> 0:27:32.440
Basically a target is a logical service which does not do anything by itself except act

324
0:27:32.440 --> 0:27:35.120
as some sort of sentinel.

325
0:27:35.120 --> 0:27:41.640
You can for example have networked as target and then you can have other things say I want

326
0:27:41.640 --> 0:27:47.720
to start before this and then you can make sure that or I want to start after this.

327
0:27:47.720 --> 0:27:56.000
You can make sure that your services start only after network is up for example.

328
0:27:56.000 --> 0:28:00.360
It also has first class support for user services which is very important and I'll get to that

329
0:28:00.360 --> 0:28:02.040
later.

330
0:28:02.040 --> 0:28:07.840
The eventual goal is to have all long running processes be services.

331
0:28:07.840 --> 0:28:11.640
And there's also the matter of session tracking which I'll describe in a bit.

332
0:28:11.640 --> 0:28:15.240
Now this is a new project that I came up with.

333
0:28:15.240 --> 0:28:21.840
It's called turnstile and it's an answer to the login part of system D.

334
0:28:21.840 --> 0:28:25.760
Let's mostly use this system D login D for session tracking.

335
0:28:25.760 --> 0:28:32.720
What that does is basically know when a user has logged in or when a user has logged in

336
0:28:32.720 --> 0:28:37.400
on another console and it also knows when the user has logged out and it can be used

337
0:28:37.400 --> 0:28:41.520
by say desktop environments in many different ways.

338
0:28:41.520 --> 0:28:46.160
This E login D which exists as a standalone version which is basically just ripped away

339
0:28:46.160 --> 0:28:55.800
from system D and the dependencies are stopped out and it's sort of dirty and not great.

340
0:28:55.800 --> 0:29:02.360
This is done by basically running a daemon which is called login D and a module in the

341
0:29:02.360 --> 0:29:07.320
PAM infrastructure which is obviously used for authentication.

342
0:29:07.320 --> 0:29:11.160
The PAM module basically lets the daemon know when a new session has started and it also

343
0:29:11.160 --> 0:29:15.240
lets it know when a session has ended.

344
0:29:15.240 --> 0:29:20.180
This plus seed management which E login D also does but this is not widely used because

345
0:29:20.180 --> 0:29:21.880
usually you only have one seed.

346
0:29:21.880 --> 0:29:27.320
This is used by desktop environments especially things like Wayland compositors.

347
0:29:27.320 --> 0:29:35.120
With system D most importantly also have login D also spawn a user session of system D basically

348
0:29:35.120 --> 0:29:40.240
which acts as just like normal service manager but it runs as your user and it runs Caesar

349
0:29:40.240 --> 0:29:41.240
services.

350
0:29:41.240 --> 0:29:49.000
E login D cannot do this because it has no idea what other init system or what user service

351
0:29:49.000 --> 0:29:50.280
manager you might be running.

352
0:29:50.280 --> 0:29:53.920
So this functionality is removed and there's no way to access it.

353
0:29:53.920 --> 0:29:58.640
This is one of the reasons why I developed this.

354
0:29:58.640 --> 0:30:05.960
It aims to eventually replace E login D and it was originally created just to manage those

355
0:30:05.960 --> 0:30:09.080
user instances of init.

356
0:30:09.080 --> 0:30:15.120
The issue with that when running this in parallel with E login D was that sometimes it needs

357
0:30:15.120 --> 0:30:20.800
to know something which E login D knows but sometimes E login D also needs to know something

358
0:30:20.800 --> 0:30:22.920
the user service manager knows.

359
0:30:22.920 --> 0:30:26.720
It especially affects things like lingering for example.

360
0:30:26.720 --> 0:30:33.700
You can enable specific user to linger which means those user services will stay up even

361
0:30:33.700 --> 0:30:36.720
after you have fully logged out.

362
0:30:36.720 --> 0:30:43.480
E login D manages your runtime directory for you which is used by many services and upon

363
0:30:43.480 --> 0:30:46.200
log out it removes this runtime directory.

364
0:30:46.200 --> 0:30:51.640
If you have still some user services running and E login D has removed your service directory

365
0:30:51.640 --> 0:30:54.160
then things go wrong.

366
0:30:54.160 --> 0:30:59.600
So it needs to be integrated and I plan to eventually fully replace login D.

367
0:30:59.600 --> 0:31:04.600
It turns out does not manage seats because there's already a project called libseat and

368
0:31:04.600 --> 0:31:07.760
CTD which can do this satisfactorily.

369
0:31:07.760 --> 0:31:13.680
But libseat does not do the session tracking so they can be used together and I plan to

370
0:31:13.680 --> 0:31:16.440
provide a library alongside the daemon.

371
0:31:16.440 --> 0:31:19.160
This library will provide agnostic API.

372
0:31:19.160 --> 0:31:22.920
This API will have multiple back ends and it will have a back end for login D, it will

373
0:31:22.920 --> 0:31:28.240
have a back end for turn style D as well as potentially other solutions and then things

374
0:31:28.240 --> 0:31:36.040
like desktops will be able to use this and be actually portable because for example right

375
0:31:36.040 --> 0:31:43.160
now to have GNOME for on free BSD for example it needs many patches to replace this functionality

376
0:31:43.160 --> 0:31:45.600
and it's just not great.

377
0:31:45.600 --> 0:31:50.980
Having an agnostic API which is not provided by system D would be much nicer solution.

378
0:31:50.980 --> 0:31:55.980
Of course I also have to convince up frames to adopt it.

379
0:31:55.980 --> 0:32:02.480
One thing which you do if turn style is managing the bus session, bus as a user service, this

380
0:32:02.480 --> 0:32:08.520
has an advantage because you have a single session bus per user just like is done when

381
0:32:08.520 --> 0:32:13.440
you have system D. Well why have a single session bus?

382
0:32:13.440 --> 0:32:16.240
This session bus has a socket.

383
0:32:16.240 --> 0:32:20.240
The socket is somewhere on the file system and the socket is used to identify other things

384
0:32:20.240 --> 0:32:22.480
on the bus.

385
0:32:22.480 --> 0:32:28.360
The way to locate this session bus is provided via environment variable.

386
0:32:28.360 --> 0:32:32.640
So if you have the environment variable in your environment then things can use this

387
0:32:32.640 --> 0:32:35.880
to read the path and actually locate the socket.

388
0:32:35.880 --> 0:32:43.240
Traditionally you had the session bus started by for example your X11 script, Xinit RC which

389
0:32:43.240 --> 0:32:47.240
would run something like D bus run session something.

390
0:32:47.240 --> 0:32:53.840
That means the session bus was only available within your single graphical DTY.

391
0:32:53.840 --> 0:32:57.640
This is not great because when you switch console and log in there and you want to run

392
0:32:57.640 --> 0:33:00.920
something which needs to access the session bus it doesn't know about it.

393
0:33:00.920 --> 0:33:02.080
System D solves this.

394
0:33:02.080 --> 0:33:07.320
We also solve this by running the session bus as a user service.

395
0:33:07.320 --> 0:33:10.820
So when you first log in it automatically spawns the session bus.

396
0:33:10.820 --> 0:33:17.840
When you last log out it stops the session bus and it's available on every single Vt.

397
0:33:17.840 --> 0:33:21.480
This has also limitless potential for other user services.

398
0:33:21.480 --> 0:33:27.240
We can do things like D bus activation without having D bus spawn the services themselves.

399
0:33:27.240 --> 0:33:32.360
It's currently also used for the sound server for example with pipewire.

400
0:33:32.360 --> 0:33:34.840
Now let's move on to C build.

401
0:33:34.840 --> 0:33:47.160
C build is basically a build system for seaports as I already know.

402
0:34:04.840 --> 0:34:11.560
This is what a template might look like.

403
0:34:11.560 --> 0:34:15.900
This is the template to build Doom game.

404
0:34:15.900 --> 0:34:18.080
As you can see it's mostly metadata.

405
0:34:18.080 --> 0:34:04.840
There's one hook in there which runs W

406
0:34:21.320 --> 0:34:24.480
which has no other way to do this.

407
0:34:24.480 --> 0:34:31.860
There's a build style for configure script which basically strips away all the non-decorative

408
0:34:31.860 --> 0:34:34.320
things you would otherwise need.

409
0:34:34.320 --> 0:34:39.280
How C build works is that it builds all the software in a simple container called the

410
0:34:39.280 --> 0:34:41.800
build root in our terminology.

411
0:34:41.800 --> 0:34:45.000
It's minimized chimera system.

412
0:34:45.000 --> 0:34:50.160
There's some packages which provide a baseline and your build dependencies which are specified

413
0:34:50.160 --> 0:34:53.560
by the template are also installed into this container.

414
0:34:53.560 --> 0:34:58.680
This container is fully unprivileged so you don't need to run anything as root and it's

415
0:34:58.680 --> 0:34:59.760
fully sandboxed.

416
0:34:59.760 --> 0:35:03.920
This is done by with Linux namespaces.

417
0:35:03.920 --> 0:35:09.600
The container is also read only after the build dependencies are installed which means

418
0:35:09.600 --> 0:35:16.320
no package built can actually change anything in the container otherwise other than in its

419
0:35:16.320 --> 0:35:18.400
own build directory.

420
0:35:18.400 --> 0:35:24.240
It also has no network access after all the fetch stage things are done.

421
0:35:24.240 --> 0:35:28.240
It has no access to the outside system.

422
0:35:28.240 --> 0:35:29.240
Templates are also declarative.

423
0:35:29.240 --> 0:35:34.520
As I said, ideally just metadata and it has fully transparent support for cross compiling

424
0:35:34.520 --> 0:35:39.160
with most build systems which means in most templates you don't need to do anything and

425
0:35:39.160 --> 0:35:43.280
it will be able to cross compiling without any additional effort.

426
0:35:43.280 --> 0:35:45.960
It has a clean handling of common build systems.

427
0:35:45.960 --> 0:35:51.000
This includes configure script, mass and CMake and so on.

428
0:35:51.000 --> 0:35:52.000
It's strict.

429
0:35:52.000 --> 0:35:58.720
It has mandatory linting hooks for many things and unit tests where possible will run out

430
0:35:58.720 --> 0:35:59.720
of box.

431
0:35:59.720 --> 0:36:03.920
I strongly believe that being strict by default is good because you can always make things

432
0:36:03.920 --> 0:36:07.840
more loose if you need it but if you have things loose by default and then you need

433
0:36:07.840 --> 0:36:13.080
to strengthen them and you have many hundreds to thousands of packages and you need to adjust

434
0:36:13.080 --> 0:36:17.600
every single one of them it becomes effort which cannot be done because it's just too

435
0:36:17.600 --> 0:36:19.000
much.

436
0:36:19.000 --> 0:36:24.680
It has support for things like bulk builds where it can properly order things in the

437
0:36:24.680 --> 0:36:30.600
batch to build without having dependency ordering issues.

438
0:36:30.600 --> 0:36:36.320
It can check upstream projects for new versions and so on.

439
0:36:36.320 --> 0:36:37.800
Build flags.

440
0:36:37.800 --> 0:36:43.680
All the basic stuff for hardening which Linux and service typically use like Fortify, position

441
0:36:43.680 --> 0:36:48.320
independent executables, stack entries and so on are used.

442
0:36:48.320 --> 0:36:52.240
On top of that we use system wide LTO for practically every package.

443
0:36:52.240 --> 0:36:57.920
I think there's only about 30 templates out of close to a thousand which have LTO disabled

444
0:36:57.920 --> 0:36:59.400
for different reasons.

445
0:36:59.400 --> 0:37:03.240
In some cases it could be enabled but it's not worth it.

446
0:37:03.240 --> 0:37:09.360
We do utilize a system wide subset of undefined behavior sanitizer.

447
0:37:09.360 --> 0:37:16.720
It deals with things like trapping signed integer overflows in order to avoid potential

448
0:37:16.720 --> 0:37:18.360
problems.

449
0:37:18.360 --> 0:37:23.280
Also CFI or control flow integrity is used for many packages.

450
0:37:23.280 --> 0:37:26.160
It cannot be used for all because it breaks on a lot of stuff.

451
0:37:26.160 --> 0:37:30.920
It's very strict when it comes to typing of functions but it's still used on a couple

452
0:37:30.920 --> 0:37:34.720
hundred packages.

453
0:37:34.720 --> 0:37:36.800
The allocator.

454
0:37:36.800 --> 0:37:44.000
We now use the scudo allocator from LLVM which is also used for example on Google Android.

455
0:37:44.000 --> 0:37:47.060
It replaces the allocator in muscle.

456
0:37:47.060 --> 0:37:52.000
This is not because of hardening because muscle allocator is already hardened but scudo is

457
0:37:52.000 --> 0:37:53.720
also hardened allocator.

458
0:37:53.720 --> 0:37:58.200
But it has significantly better multi-threaded performance because muscle malloc ng uses

459
0:37:58.200 --> 0:38:00.100
a single global lock.

460
0:38:00.100 --> 0:38:07.560
This is a trade-off but it also means that the stock allocator in muscle performs poorly

461
0:38:07.560 --> 0:38:13.720
in many things and it's something people commonly complain about so we now rely on scudo.

462
0:38:13.720 --> 0:38:19.760
This is also the advantage of being able to eventually deploy GWP asan which is sort of

463
0:38:19.760 --> 0:38:27.120
sampling runtime version of address sanitizers which can catch many memory errors at runtime

464
0:38:27.120 --> 0:38:29.520
with minimal performance overhead.

465
0:38:29.520 --> 0:38:34.200
This is not enabled yet but it will be at some point.

466
0:38:34.200 --> 0:38:35.640
Other core things for this row.

467
0:38:35.640 --> 0:38:37.560
Some tooling is taken from Debian.

468
0:38:37.560 --> 0:38:44.080
For example we use initramfs tools to generate initramfs images because other solutions were

469
0:38:44.080 --> 0:38:46.840
generally found to be unsatisfactory.

470
0:38:46.840 --> 0:38:51.640
For example requiring bash for the hooks and so on.

471
0:38:51.640 --> 0:38:55.940
Initramfs tools is very clean and simple and nice to work with.

472
0:38:55.940 --> 0:39:00.560
We also use console setup from Debian to do console and keyboard configuration as well

473
0:39:00.560 --> 0:39:04.880
as the script for handling encrypted drives.

474
0:39:04.880 --> 0:39:09.840
I also had to add some other things like the GRAP bootloader support for ZFS.

475
0:39:09.840 --> 0:39:15.280
We now support root on ZFS very easily and so on.

476
0:39:15.280 --> 0:39:19.360
This is Kaimira desktop on RISC-V.

477
0:39:19.360 --> 0:39:23.360
You can see it runs things like Firefox for example which it does not build out of books

478
0:39:23.360 --> 0:39:25.240
but I made it work.

479
0:39:25.240 --> 0:39:30.560
This is on the high-five unmatched board from C5.

480
0:39:30.560 --> 0:39:35.240
When I was starting to add to the desktop, the first thing I added was the Western Wayland

481
0:39:35.240 --> 0:39:37.120
Composter as well as GTK.

482
0:39:37.120 --> 0:39:42.480
This sort of provided a baseline set of dependencies which are also used by pretty much everything

483
0:39:42.480 --> 0:39:43.480
else.

484
0:39:43.480 --> 0:39:50.040
Then I expanded with Exodorq stack, things like the Enlightenment Window Manager as well

485
0:39:50.040 --> 0:39:53.560
as PEGWM for a simple X11 Window Manager.

486
0:39:53.560 --> 0:40:00.000
I added the multimedia stack including FFmpeg, Gstreamer, media players and so on.

487
0:40:00.000 --> 0:40:06.480
In Spring 2022 I added GNOME desktop which is the default choice but of course you can

488
0:40:06.480 --> 0:40:08.400
use anything else you want.

489
0:40:08.400 --> 0:40:13.680
I also added web browsers, this includes Epiphany which comes with GNOME and is built on WebKit

490
0:40:13.680 --> 0:40:17.000
and Firefox which is alternative choice.

491
0:40:17.000 --> 0:40:20.920
And of course some games.

492
0:40:20.920 --> 0:40:25.720
As I said before I would like to release an alpha version in late February or early March.

493
0:40:25.720 --> 0:40:29.600
I'm not sure if this will happen but I hope it will.

494
0:40:29.600 --> 0:40:33.520
Before doing this I would like to perform a complete world rebuild of all the packages

495
0:40:33.520 --> 0:40:39.320
because I have introduced some things in C-Bilt which I would like to propagate it into existing

496
0:40:39.320 --> 0:40:40.960
packages and it's not.

497
0:40:40.960 --> 0:40:45.600
So just to be clean I would like to build everything with LVM 15 as it is right now

498
0:40:45.600 --> 0:40:49.120
and basically then release the alpha.

499
0:40:49.120 --> 0:40:51.520
I will need to launch automatic built infrastructure.

500
0:40:51.520 --> 0:40:57.640
I currently have a server in Kolo in my city but it's not on public network yet so I need

501
0:40:57.640 --> 0:41:03.760
to set up the public network and launch things like this as well as CI.

502
0:41:03.760 --> 0:41:09.840
I would like to clean up the remaining fallout from the recent hardening stuff as well as

503
0:41:09.840 --> 0:41:13.680
update every template to its latest version.

504
0:41:13.680 --> 0:41:18.880
And after alpha which is the alpha cycle is expected to take about half a year to one

505
0:41:18.880 --> 0:41:24.620
year I would like to add libGCC compatibility shim so we can run existing binaries because

506
0:41:24.620 --> 0:41:29.560
right now you cannot run existing binaries because the system runtime is different.

507
0:41:29.560 --> 0:41:36.080
I would like to add support for the bus activation so the bus does not run demons by itself through

508
0:41:36.080 --> 0:41:43.240
the bus service files but instead delegate it to the service manager.

509
0:41:43.240 --> 0:41:49.080
I would like to investigate additional hardening things like LVM save stack and I would like

510
0:41:49.080 --> 0:41:50.560
to improve the documentation.

511
0:41:50.560 --> 0:41:56.440
Right now there's the beginning of Chimera handbook which includes some handy basic information

512
0:41:56.440 --> 0:42:02.760
like installation and how to set up encrypted writes and so on but it can always use more

513
0:42:02.760 --> 0:42:07.400
documentation and local support is also another thing I would like to expand to this is the

514
0:42:07.400 --> 0:42:13.180
problem in pretty much all muscle distros with the local support being sort of limited

515
0:42:13.180 --> 0:42:19.440
and you can have translations but things like formats and so on.

516
0:42:19.440 --> 0:42:25.520
So the conclusion we are currently nearing usability and it should be suitable for early

517
0:42:25.520 --> 0:42:27.040
adapters by March.

518
0:42:27.040 --> 0:42:32.520
I would like to get all the major changes done by beta and continue packaging more software

519
0:42:32.520 --> 0:42:38.200
as well as cooperate with upstreams including the free BSD upstream on sensing fixes and

520
0:42:38.200 --> 0:42:40.720
tooling and so on.

521
0:42:40.720 --> 0:42:44.960
In any case thank you for listening and if you have any questions you can ask them out

522
0:42:44.960 --> 0:42:51.960
of course we also have stickers so come pick them up.

523
0:42:51.960 --> 0:42:55.320
Yeah.

524
0:42:55.320 --> 0:43:07.960
Yeah, as I said it's supported.

525
0:43:07.960 --> 0:43:11.280
I recently introduced it and I recently tested it.

526
0:43:11.280 --> 0:43:12.280
Oh yeah.

527
0:43:12.280 --> 0:43:13.280
Sure.

528
0:43:13.280 --> 0:43:16.040
So it's only thing if ZFS on the root is supported.

529
0:43:16.040 --> 0:43:17.600
Yeah, it's supported.

530
0:43:17.600 --> 0:43:25.960
It uses the upstream scripts for any time of tools just patched to support the user

531
0:43:25.960 --> 0:43:30.280
and because we don't use busy box and it just works.

532
0:43:30.280 --> 0:43:37.200
We also provide ZFS packages with precompiled binary modules so it's not necessarily compiled

533
0:43:37.200 --> 0:43:40.120
from source during installation.

534
0:43:40.120 --> 0:43:45.800
And CKMS can handle things in a non-conflicting way so if you have the package installed for

535
0:43:45.800 --> 0:43:51.560
the stock kernel which provides the binary ZFS modules, CKMS will not try to build the

536
0:43:51.560 --> 0:43:53.560
modules again.

537
0:43:53.560 --> 0:43:54.560
Yeah.

538
0:43:54.560 --> 0:43:57.560
What are the target user segments for this distribution?

539
0:43:57.560 --> 0:44:04.720
For example at home I use gel, I have to use Ubuntu and...

540
0:44:04.720 --> 0:44:05.720
Okay.

541
0:44:05.720 --> 0:44:09.280
Well, the question was if...

542
0:44:09.280 --> 0:44:11.760
What's the target audience basically?

543
0:44:11.760 --> 0:44:17.240
Well, I would say the primary audience is basically the same people who would use things

544
0:44:17.240 --> 0:44:18.920
like Gen 2 and so on.

545
0:44:18.920 --> 0:44:24.280
Basically power users who can find their way around things because there's no insistence

546
0:44:24.280 --> 0:44:29.800
on providing graphical clickable stuff for everything because it just wouldn't be possible.

547
0:44:29.800 --> 0:44:33.280
I just do not have the manpower to do all this.

548
0:44:33.280 --> 0:44:39.760
So yeah, it's for power users who can find their way around a simple system.

549
0:44:39.760 --> 0:44:41.320
Yeah.

550
0:44:41.320 --> 0:44:47.640
Where does the name come from?

551
0:44:47.640 --> 0:44:51.200
He was asking where does the name come from?

552
0:44:51.200 --> 0:44:57.960
Well, Chimera is basically like a mythical monster made up of three different animals

553
0:44:57.960 --> 0:45:00.840
so it should be fairly obvious where it comes from.

554
0:45:00.840 --> 0:45:04.760
We have Linux kernel and FreeBSD stuff and other stuff.

555
0:45:04.760 --> 0:45:05.760
Yeah.

556
0:45:05.760 --> 0:45:12.760
How do you work with upstream in particular against FreeBSD to provide a change in path

557
0:45:12.760 --> 0:45:13.760
to the...

558
0:45:13.760 --> 0:45:14.760
Okay.

559
0:45:14.760 --> 0:45:16.440
...change in some way might be useful?

560
0:45:16.440 --> 0:45:20.640
Yeah, the question was if I'm working with FreeBSD.

561
0:45:20.640 --> 0:45:24.680
I know the project has taken back some of the changes.

562
0:45:24.680 --> 0:45:29.960
I have some patches in Chimera tools which I do believe would be useful for upstream

563
0:45:29.960 --> 0:45:33.400
and yes, I do want to submit to them upstream.

564
0:45:33.400 --> 0:45:41.560
For example, I have a fix in the sort tool which fixes a crash with control flow integrity

565
0:45:41.560 --> 0:45:45.160
hardening so this would be nice to include for example.

566
0:45:45.160 --> 0:45:46.160
Yeah.

567
0:45:46.160 --> 0:45:47.160
Turns out the...

568
0:45:47.160 --> 0:45:48.160
How did you solve the problem of the PAM service program?

569
0:45:48.160 --> 0:45:49.160
The problem was the PAM service crashing before it can run the...

570
0:45:49.160 --> 0:45:50.160
Oh.

571
0:45:50.160 --> 0:46:00.520
...use C groups?

572
0:46:00.520 --> 0:46:05.360
Sorry, can you repeat?

573
0:46:05.360 --> 0:46:08.320
Those turnstile use C groups.

574
0:46:08.320 --> 0:46:10.600
Question is if turnstile uses C groups.

575
0:46:10.600 --> 0:46:11.680
No, it doesn't.

576
0:46:11.680 --> 0:46:12.680
It uses...

577
0:46:12.680 --> 0:46:14.760
It does the same thing as Log-in-D basically.

578
0:46:14.760 --> 0:46:20.760
This is a PAM module to report things and it keeps a persistent socket connection to

579
0:46:20.760 --> 0:46:27.280
the daemon as long as the session is active and then when the socket is closed and when

580
0:46:27.280 --> 0:46:32.880
the daemon receives basically a notification pulse on the socket and once it knows the

581
0:46:32.880 --> 0:46:36.560
connection has been closed then it closes the session inside of the daemon.

582
0:46:36.560 --> 0:46:37.560
Yeah.

583
0:46:37.560 --> 0:46:38.560
Follow up question.

584
0:46:38.560 --> 0:46:44.600
So you open a socket from the PAM service module?

585
0:46:44.600 --> 0:46:48.760
The question is if I open the socket from the PAM module.

586
0:46:48.760 --> 0:46:55.160
Yes, the PAM module opens a connection to the socket which is provided by the daemon

587
0:46:55.160 --> 0:47:00.000
and the daemon basically opens the socket in the system as a Unix domain socket and

588
0:47:00.000 --> 0:47:04.440
it's only accessible by root obviously so the PAM module access it.

589
0:47:04.440 --> 0:47:05.440
Yeah.

590
0:47:05.440 --> 0:47:06.440
Follow this is the last question.

591
0:47:06.440 --> 0:47:07.440
So if you open a socket from the PAM module that socket obviously ends up appearing as

592
0:47:07.440 --> 0:47:17.800
a file descriptor inside the program that ran the PAM.

593
0:47:17.800 --> 0:47:19.880
Does that not interfere with anything?

594
0:47:19.880 --> 0:47:23.600
Have you not found anything that closes for like...

595
0:47:23.600 --> 0:47:25.800
Because I have to try to do the same thing.

596
0:47:25.800 --> 0:47:31.920
The question is if the PAM module with the socket actually interferes with anything?

597
0:47:31.920 --> 0:47:36.960
No, I found it doesn't interfere with anything and in fact as far as I know Log-in-D does

598
0:47:36.960 --> 0:47:41.680
basically the same thing and other solutions for handling for example there are several

599
0:47:41.680 --> 0:47:49.560
solutions for handling for the runtime directory which is basically run user your UID and they

600
0:47:49.560 --> 0:47:56.080
basically did the same thing as far as I know but yeah as far as I can tell it works okay.

601
0:47:56.080 --> 0:47:57.080
Yeah.

602
0:47:57.080 --> 0:48:02.680
So first of all text to the job must be like really difficult to maintain all this dependence.

603
0:48:02.680 --> 0:48:03.680
Thank you.

604
0:48:03.680 --> 0:48:09.680
So my question is are you planning to integrate like in a specific SSL library like for example

605
0:48:09.680 --> 0:48:12.720
LibraSSL or like OpenSSL?

606
0:48:12.720 --> 0:48:17.320
Okay the question was about integrating SSL library.

607
0:48:17.320 --> 0:48:20.600
We do use OpenSSL version 3.

608
0:48:20.600 --> 0:48:27.440
This was actually a pretty big transition when it happened because many things do not

609
0:48:27.440 --> 0:48:30.120
or did not work well with OpenSSL 3.

610
0:48:30.120 --> 0:48:33.800
Unfortunately the amount of packages right now is not that huge.

611
0:48:33.800 --> 0:48:37.920
There are still some which do not work with OpenSSL 3 and which we do rely on.

612
0:48:37.920 --> 0:48:45.760
For example the Heimdall implementation of Kerberos which we use instead of MIT, GAR-B

613
0:48:45.760 --> 0:48:50.720
does not work with OpenSSL 3 yet but it has its own built-in crypto which can be used

614
0:48:50.720 --> 0:48:59.320
instead so we fall back on that for now.

615
0:48:59.320 --> 0:49:05.280
Anyone else?

616
0:49:05.280 --> 0:49:08.760
Looks like that's it then and thank you again.

617
0:49:08.760 --> 0:49:37.680
Thank you.

