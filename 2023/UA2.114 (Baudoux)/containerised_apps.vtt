WEBVTT

00:00.000 --> 00:09.120
Good morning. Wow. I was not expecting this much of an audience at 9am on Sunday at a

00:09.120 --> 00:16.080
Fostem, so thank you all for coming. Yeah, I'm here to talk about how I was at Fostem

00:16.080 --> 00:20.480
five years ago. I told you all a whole bunch of things, and I was utterly wrong so many

00:20.480 --> 00:27.000
ways it's actually kind of amusing. But who am I? My name's Richard. I've been working

00:27.000 --> 00:33.320
on OpenSUSE since it began. I've been a customer of SUSE's, I've been a contributor, a bit

00:33.320 --> 00:39.280
of everything. QA engineer, I've been working there for 10 years now, or almost 10 years.

00:39.280 --> 00:45.320
These days I am a ridiculous advocate of rolling releases. It's what everybody should be using.

00:45.320 --> 00:50.440
I created the micro OS desktop. My day job is being one of the release engineers for

00:50.440 --> 00:58.520
tumbleweed and micro OS. I also do a bit of consulting and photography. But, yeah, a long

00:58.520 --> 01:03.720
time ago in a room actually just on the other side of this campus, I was here at Fostem

01:03.720 --> 01:11.280
telling everybody that, yeah, containerised applications, so things like Flapback, Snap,

01:11.280 --> 01:17.760
App images, the idea that graphical apps in some portable format are absolutely utterly

01:17.760 --> 01:21.640
terrible and nobody should be ever using them ever, and they were going to eat all of our

01:21.640 --> 01:28.240
users, and, yeah, it's just going to be horribly, horribly wrong. And I even started the presentation

01:28.240 --> 01:32.680
with quippy comments, like, yeah, those who don't remember the past are condemned to repeat

01:32.680 --> 01:42.240
it, and I even made really unflattering comparisons. Like, doing diagrams from Windows architecture

01:42.240 --> 01:46.320
and pointing out, you know, Windows has all these wonderful runtimes where you can have

01:46.320 --> 01:51.120
different environments and run your application on top, and, you know, it was absolutely terrible

01:51.120 --> 01:57.000
in Windows. It's going to be absolutely terrible when we do the same thing in Linux. Giving

01:57.000 --> 02:03.600
the examples of all of the security issues that you see in Windows in this kind of approach,

02:03.600 --> 02:10.960
you know, things like security relevant DLLs lurking in some folder in your Windows machine,

02:10.960 --> 02:14.000
you know, being an absolute nightmare to patch and an absolute nightmare to fix when it goes

02:14.000 --> 02:20.080
wrong, you know, all these horrible update issues, you know, how do you end up getting

02:20.080 --> 02:24.160
an update on your Windows or your Mac machine? Well, you download some EXE or some bundle

02:24.160 --> 02:30.600
and then there's some updater in it, does whatever the heck it wants on its machine.

02:30.600 --> 02:33.720
Licensing issues, especially with open source, you know, how do you mix and match all these

02:33.720 --> 02:38.600
different licenses together in one cohesive thing? And, you know, it's just going to eat

02:38.600 --> 02:46.160
up all of your disk space. And then I went back to this slide again and then started

02:46.160 --> 02:52.320
talking about the various technologies at the time, 2017, were out there doing this

02:52.320 --> 02:58.080
containerized runtime stuff and I would compare this lovely Windows diagram to this lovely

02:58.080 --> 03:03.280
canonical diagram, which looks very, very similar because actually it is. The idea is

03:03.280 --> 03:09.120
similar, the concept is similar, but as you'll see, just because the concept is similar doesn't

03:09.120 --> 03:14.800
necessarily mean the whole idea is bad, execution does matter. And it wasn't just snap, I wasn't

03:14.800 --> 03:22.760
just shifting on Ubuntu because I don't like Ubuntu. I was doing the same with Flatback.

03:22.760 --> 03:28.440
And I was, yeah, basically pointing out that this whole containerized application idea

03:28.440 --> 03:35.440
was repeating the same issue. We were going to be going down this road of security relevant

03:35.440 --> 03:41.320
libraries lurking in all of these snaps in Flatback. Back then we didn't necessarily

03:41.320 --> 03:46.080
have a good story about how are we going to update these things, how are we going to keep

03:46.080 --> 03:53.000
them maintained, who was going to look after all of these base snaps and runtimes in Flatback

03:53.000 --> 03:57.720
and the like. Who was going to look at all of the legal issues and review the possible

03:57.720 --> 04:01.760
licensing issues of bundling these things together and who was going to buy everybody

04:01.760 --> 04:09.040
bigger hard disks. And the kind of main conclusion that I left with, which despite the fact you'll

04:09.040 --> 04:15.120
see I was wrong about a lot of what I said, I still actually hold true, is at the heart

04:15.120 --> 04:20.760
of it, when distributing software, doesn't matter if you're doing it as a container or

04:20.760 --> 04:28.000
as a full blown fat OS distributor or anything in between with any kind of fancy technology,

04:28.000 --> 04:34.680
the responsibilities are the same. App image, Flatback, Snap might make it easier to be the

04:34.680 --> 04:39.840
upstream than giving out your application to the users. That's great. But the responsibilities

04:39.840 --> 04:44.160
are still the same that distributors have been doing in distributions for years. You

04:44.160 --> 04:49.240
have to worry about maintainability, you have to worry about the security, you have to worry

04:49.240 --> 04:53.520
about licensing and all this wonderful stuff. So they're going to have to borrow all of

04:53.520 --> 04:58.880
the same stuff. So five years ago I gave this presentation. There was lots of people in

04:58.880 --> 05:03.880
the audience from App Image, Snap and Flatback. Some of them said very nice things to me,

05:03.880 --> 05:12.120
some of them said very un-nice things to me. Starting with App Image, they took a lot of

05:12.120 --> 05:20.280
what I said surprisingly on board and really ran with it. I said all this stuff in February

05:20.280 --> 05:29.640
2017 and by June 2017 I was saying stuff like this on stage. This was taken at the Open

05:29.640 --> 05:37.760
SUSE conference, this was on the App Image website for, well, longer than I wish it was.

05:37.760 --> 05:44.760
But the reason it was because in that short window, App Images thought they could address

05:44.760 --> 05:51.280
most of my concerns by actually obviously running to the Open SUSE built service and

05:51.280 --> 05:56.560
working with the Open SUSE built service guys and integrating App Image really quite nicely

05:56.560 --> 06:02.840
with it at the time. So the idea being, you know, the App Image wasn't the problem, maybe

06:02.840 --> 06:09.240
the way you build App Image is the problem. If you build them in a nice auditing built

06:09.240 --> 06:13.920
system and have the whole thing tracked with dependencies in a built system and you build

06:13.920 --> 06:19.480
it reproducibly and you do all the licensing reviews there, then OBS could be the solution

06:19.480 --> 06:26.680
to all of the App Images problem. And, yeah, they worked really nicely with it and they

06:26.680 --> 06:32.480
gave all these promises. They'd be encouraging people to be using OBS as the main App Image

06:32.480 --> 06:40.240
building tool and we'd all move on happy in a nice unified way forward. And I even said

06:40.240 --> 06:45.880
things to snapping a flat back, like you're falling behind App Image at this point, saying

06:45.880 --> 06:51.720
App Image had a better build story. And they were working with other people and telling

06:51.720 --> 06:58.200
people to be more like App Image. I still was badgering on, by the way, you can tell

06:58.200 --> 07:02.840
all my old slides because they have this thing at the bottom. So you can see old me compared

07:02.840 --> 07:08.440
to new me. I was still worrying a little bit about dependencies because, as you'll see,

07:08.440 --> 07:17.320
App Image makes some really interesting assumptions. But I was, you know, June 2017 kind of hopeful

07:17.320 --> 07:21.880
that, you know, we'd get to a point where everybody would be working together and we'd

07:21.880 --> 07:28.080
have sort of maybe a new consistent run time and things could move forward. I was also

07:28.080 --> 07:33.240
hopeful that we might have sandboxing finally because, you know, Snap kind of had some with

07:33.240 --> 07:40.160
App Armor. Flatback has Bubble Wrap. You know, maybe App Armor would be the way forward.

07:40.160 --> 07:47.760
How wrong I was. So now, five years later, where are we? And I don't want to go deep

07:47.760 --> 07:53.240
down in technical issues too much because a lot of this isn't just technical. We're

07:53.240 --> 07:58.240
an open source project. Any technical issue can be fixed, right? It is a lot about what

07:58.240 --> 08:02.240
are people actually doing? What do they actually care about? Where are they actually taking

08:02.240 --> 08:08.320
things? What are we actually doing? So let's judge people by their own standards. This

08:08.320 --> 08:14.000
is a screenshot from the current App Image website. And it says, use this to make Linux

08:14.000 --> 08:21.400
apps that run everywhere. But they don't run everywhere. And they say, as a user, it should

08:21.400 --> 08:30.000
be as easy to install as it is on a Mac or Windows machine. But they're not. And they

08:30.000 --> 08:33.720
say you don't have to learn all these distributions with all these different distros doing things

08:33.720 --> 08:38.840
different ways. Technically, that's true. You just need to learn all these different

08:38.840 --> 08:42.640
distributions and doing all the different things and you have to build your own to put

08:42.640 --> 08:52.400
in your App Image. And I'm not just saying this to, you know, call shade on them. I have

08:52.400 --> 08:58.640
users on micro OS who are trying to run App Images. And they can't because App Images

08:58.640 --> 09:04.120
require Fuse 2. I'm a rolling release. I haven't shipped Fuse 2 for like a year. I've been

09:04.120 --> 09:11.240
using Fuse 3. And you can't get an App Image to work with Fuse 2. It has to be Fuse 2.

09:11.240 --> 09:15.880
The portable image format that isn't portable because it makes assumptions about stuff that's

09:15.880 --> 09:23.600
on the base OS. And not just, you know, not just weird stuff like Fuse, but even down

09:23.600 --> 09:29.280
and dirty in the kernel. If you're running Debian and you try to run an Electron app,

09:29.280 --> 09:33.960
it's not going to work properly. Because the kernel in Debian isn't built the way that App

09:33.960 --> 09:40.680
Image is expecting the kernel to be running. So this is great promise. And it's going to

09:40.680 --> 09:45.520
work in some places. But only if you're lucky enough that your distro has the same assumptions

09:45.520 --> 09:51.520
baked into it that App Image has. And this is a recurring issue. Even reading the App

09:51.520 --> 09:58.560
Image documentation for building App Images, you know, it tells you as a developer, think

09:58.560 --> 10:02.800
about all of the distros where you want your App Image to run on. So the whole promise

10:02.800 --> 10:06.520
of not worrying about distros goes away. You have to worry about more of them than you

10:06.520 --> 10:12.640
normally would. And put every single dependency which might not be fulfilled by that distro

10:12.640 --> 10:18.480
in your App Image. So, yeah, avoid distros by building a huge one and putting it in a

10:18.480 --> 10:25.400
big table. It's a lot of work. It's way too much work. I utterly respect anybody using

10:25.400 --> 10:31.360
it because they're probably doing more work than I am doing of rolling release. Especially

10:31.360 --> 10:37.800
when the recommendations for what you put in that giant App Image is the oldest, crustiest

10:37.800 --> 10:44.240
stuff you can find. They don't recommend avoiding using anything new because anything new is

10:44.240 --> 10:50.040
more likely to have compatibility issues with older distros. So literally find the oldest

10:50.040 --> 10:55.120
distro that's still supported and use that as your base for building App Image. Which,

10:55.120 --> 10:58.400
you know, also seems a bit of a problem to me because, you know, if you're always picking

10:58.400 --> 11:03.240
the oldest, the oldest is always the first one to not get maintenance updates. So you're

11:03.240 --> 11:09.080
just always going to be rebasing on some crusty old almost out of day LTS to do what you want

11:09.080 --> 11:15.680
to do with App Image. It doesn't make any sense by their own standards. And they tell

11:15.680 --> 11:22.360
everybody that it's installing just like on a Mac. You know, just download the binary,

11:22.360 --> 11:27.920
put it on your desktop, right click it, make it executable and it will run. Which, you

11:27.920 --> 11:34.440
know, 15 years ago that's true. That's how you run something on a Mac. I own a Mac now.

11:34.440 --> 11:40.240
That's not how you run stuff on a Mac. There's not a single Mac application I've ever installed

11:40.240 --> 11:45.580
that works that way. Even the Apple documentation makes it very, very clear that if you're downloading

11:45.580 --> 11:49.760
something from the Internet and you double clicking it on a Mac, it's going to run an

11:49.760 --> 11:54.480
installer. Which is a terrible thing anyway. But it needs to run an installer. When you're

11:54.480 --> 11:57.840
downloading random stuff from the Internet, there needs to be checks for dependencies.

11:57.840 --> 12:05.200
There needs to be some modification to what's on the host. So every random downloaded Mac

12:05.200 --> 12:11.840
application has an installer just like Windows. Or it's done in an App Store where Apple are

12:11.840 --> 12:17.700
controlling all that kind of things and helping that along. So, yes, I was wrong about App

12:17.700 --> 12:24.000
Image. First thing, it was terrible. Because they did try and make an effort. But then

12:24.000 --> 12:30.120
I was wrong again because it's actually even worse than I said five years ago. You know,

12:30.120 --> 12:36.200
they failed to do everything that they set out to do. They don't do anything to address

12:36.200 --> 12:43.800
the actual problems with software releasing. You know, dependency problems are just hand-waved

12:43.800 --> 12:48.880
worse than anyone else could possibly do. Licensing issues, security, maintenance, good

12:48.880 --> 12:55.480
luck. Just build a new distro and ship it again. This is worse than we do in distros

12:55.480 --> 13:01.800
with all of the faults I will admit distros have on this. So please, do not use App Images.

13:01.800 --> 13:05.680
And also they're not nice people. Because they kept publishing this for like four years

13:05.680 --> 13:10.160
after I told them to take it down and I had to threaten to sue them. So, like, they're

13:10.160 --> 13:16.920
just not nice. Now, Snap. Despite my reservations back in

13:16.920 --> 13:22.880
2017, actually Snap was at the time the one I was most optimistic about. You know, at

13:22.880 --> 13:28.600
the time, Canonical were actively collaborating with other distributions. They even invited

13:28.600 --> 13:35.040
me to a Snap workshop. Trying to get Snap supported in as many Linux distributions as

13:35.040 --> 13:39.120
possible. They had an approach of upstream first. They were promising that all of the

13:39.120 --> 13:42.920
App Armor patches and all of the enablement they had to do was going to end up in the

13:42.920 --> 13:47.880
kernel and going to end up being upstream. At the time in 2017, you could run your own

13:47.880 --> 13:55.400
Snap store. You could have your own repository for downloading Snaps. And, unlike Flatpak,

13:55.400 --> 14:01.560
where it's much more just graphical, they also had a story for non-graphical apps. It's

14:01.560 --> 14:06.440
only five years ago, but back then, everybody wasn't necessarily using containers for server

14:06.440 --> 14:13.640
stuff the way we are now. So, you know, it was interesting on all those levels. But it's

14:13.640 --> 14:22.080
five years later. And all of the promises of Snap confinement working everywhere so

14:22.080 --> 14:30.000
you can have your nice sandboxed Snap application hasn't come true. Snap does not support confinement

14:30.000 --> 14:37.320
on most non-abundant distributions and even some abundant distributions. And, you know,

14:37.320 --> 14:44.120
this was posted on their forums three years ago now. That was the case three years ago.

14:44.120 --> 14:51.000
You know, users still waiting to get any kind of proper sandboxing in security with Snaps.

14:51.000 --> 14:57.960
Still not there. And then this was posted this month. Still promising. It might happen.

14:57.960 --> 15:02.160
But it's been five years. None of the app armor stuff is in the kernel yet. None of

15:02.160 --> 15:08.440
the enablement we need is in the kernel yet. Distros can't easily or really at all, you

15:08.440 --> 15:17.440
know, keep with an upstream kernel and get Snap running in the way Snap should be running.

15:17.440 --> 15:21.880
So if you run a Snap on a non-abundant distribution, you're probably running it in an incredibly

15:21.880 --> 15:27.720
secure way. Do you trust that random software deliverable with access to everything on your

15:27.720 --> 15:36.720
machine? Probably not. At least that random software developer using Snap isn't using

15:36.720 --> 15:42.280
their own Snap store because they can't anymore. You know, 2017 you could. Then they released

15:42.280 --> 15:47.880
a new version of SnapD. So now the only version of the Snap store that works with SnapD is

15:47.880 --> 15:54.720
kimono course. So, you know, it's an open source package format. But it's a closed source

15:54.720 --> 16:00.000
delivery format. You're only going to get that software from kimono call. And if you

16:00.000 --> 16:04.880
read up on it, there's lots of examples where kimono call have done the right thing and

16:04.880 --> 16:10.240
handled snaps that were malicious and got them off quickly. But it's like, how do you

16:10.240 --> 16:14.280
know you're just trusting kimono call that they're always doing the right thing because

16:14.280 --> 16:18.120
you can't see. You can't see what they're putting on there. You can't see how they get

16:18.120 --> 16:26.800
there. You can't do it yourself. If you trust kimono call, that's fine. But I'm much more

16:26.800 --> 16:31.680
open source orientated myself. I'd rather, even if I am trusting somebody else, I'd rather

16:31.680 --> 16:35.840
be able to have a look and see what's going on in there. Maybe run my own. Maybe compare

16:35.840 --> 16:42.240
something alongside. And yes, for most developers or at least most small developers, this is

16:42.240 --> 16:50.360
free so you can build your snap and publish it to the kimono call snap store with no effort.

16:50.360 --> 16:53.880
But as soon as you start getting bigger, as soon as you start becoming a bit of an ISV

16:53.880 --> 16:58.320
or doing stuff with IoT with lots of devices, then kimono call want you to have a brand

16:58.320 --> 17:03.840
store. And this is in the documentation for snap craft where it comes to building. When

17:03.840 --> 17:09.000
you actually have a look at the price list for having a snap store, the price list is

17:09.000 --> 17:16.880
kind of dear. Do you really want to be spending at least 5000 euros just to be able to publish

17:16.880 --> 17:23.560
your application on somebody else's server under your name? But I can understand if people

17:23.560 --> 17:27.080
are buying into this, I can definitely understand why kimono call aren't in a rush to change

17:27.080 --> 17:32.840
it. It's probably making them a good bit of money. On open suited, like I said, at the

17:32.840 --> 17:41.480
time in 2017, they were working with us. Now, not going so well. Snap is the only bit of

17:41.480 --> 17:46.360
software in all of my years doing anything, police manager at open SUSE where it's failed

17:46.360 --> 17:50.960
more than one security order. It's the only bit of software I've had to project it multiple

17:50.960 --> 17:59.480
times. And there was good collaboration going on to get those issues fixed. But since 2019,

17:59.480 --> 18:07.720
it's kind of fizzled out. Haven't seen anything since. So when it comes to snap, you know,

18:07.720 --> 18:15.840
I was wrong. I was really kind of keen on snap back in 2017. And these days, I can't

18:15.840 --> 18:21.480
really say that much nice about it. The upstream first promises have all stalled. It doesn't

18:21.480 --> 18:25.880
seem to be an effort to get it really moving again and on other distributions. So, you

18:25.880 --> 18:30.920
know, it's not a portable format by any stretch of any imagination. There's no open source

18:30.920 --> 18:36.320
delivery option, you know, even if the snap store may always be the best way of doing

18:36.320 --> 18:43.840
it anyway. There's a case to be made for that, even if there was an open source way. And

18:43.840 --> 18:47.800
it's not really a viable alternative for something like flatback until, you know, unless you

18:47.800 --> 18:51.920
use Ubuntu, unless you trust canonical, unless you're willing to give them money to distribute

18:51.920 --> 19:04.440
your stuff. And so, flatback. Now, need to kind of do a little bit of a detour on this.

19:04.440 --> 19:09.000
Because when I was talking five years ago about all of this stuff, one of the things

19:09.000 --> 19:15.760
that I was kind of trying to pitch in the side thing there was this idea that, you know,

19:15.760 --> 19:19.400
well, everybody should be using rolling releases. I really, really believe that. And I still

19:19.400 --> 19:29.040
believe that now. And I really think, you know, in this modern age, to get applications

19:29.040 --> 19:35.600
in the hands of users, you know, a rolling base operating system is the absolute key.

19:35.600 --> 19:42.800
You need to have it all built together, need to have everything integrated, built consistently,

19:42.800 --> 19:47.440
tested consistently, and taking the fair share of the maintenance and security burden and

19:47.440 --> 19:50.720
then shipping it all in a way that the users don't really care that everything's churning

19:50.720 --> 19:57.620
around underneath. You know, it just works. And at SUSE, we've still been working on this.

19:57.620 --> 20:05.640
We have an operating system called OpenSUSE MicroOS. Vanilla MicroOS is much more server-orientated.

20:05.640 --> 20:11.960
It's immutable, like CoreOS and other similar immutable platforms. Can't be modified during

20:11.960 --> 20:17.800
runtime at all. It's rolling, so changing snapshots. It's actually using the same code

20:17.800 --> 20:23.800
base as tumbleweed, so every day almost. It's small, but small enough to do the job that

20:23.800 --> 20:29.880
it's meant to do. And the assumption is, you know, that server is going to do just one

20:29.880 --> 20:35.880
job in a data center, so, you know, a VM running one RPM or a VM running containers and then,

20:35.880 --> 20:40.800
you know, as many containers on top, but, you know, the job is a container from the

20:40.800 --> 20:46.200
operating system point of view. And this is working really quite well. In fact, SUSE also

20:46.200 --> 20:52.400
has commercial products based on this. SLEE Micro is based directly on OpenSUSE MicroOS.

20:52.400 --> 20:57.000
The new SUSE app you might have heard of where we're thinking of doing a whole new ecosystem

20:57.000 --> 21:05.360
of enterprise distros. That's building off what we did with SLEE Micro and OpenSUSE MicroOS.

21:05.360 --> 21:11.000
But me, you know, I'm still a desktop guy. So, you know, doing this with my day job,

21:11.000 --> 21:15.800
I found myself asking, yeah, I found myself asking, okay, so I've got this nice small

21:15.800 --> 21:24.560
OS and it can run just one thing. What if that just one thing with a desktop? And so

21:24.560 --> 21:32.000
I started the MicroOS desktop project sort of alongside regular MicroOS. And, yeah, basically

21:32.000 --> 21:38.280
it's a modern Chromebook-like, silver blue-like environment where you have a nice, minimal

21:38.280 --> 21:43.520
base system. My recommendation would be running the GNOME one after the one that's most maintained

21:43.520 --> 21:50.800
with a desktop environment on top. And the basic configuration tools are, yeah, in there,

21:50.800 --> 21:55.360
but everything else is provided by somewhere else. In fact, everything else is provided

21:55.360 --> 22:00.360
by Flatpak. So this is one of the reasons why I'm doing this presentation. I kind of

22:00.360 --> 22:04.920
have to explain how in five years I went from Flatpak is the devil to Flatpak is the only

22:04.920 --> 22:09.400
thing you should be running on your desktop. Because I talked to some of the people that

22:09.400 --> 22:16.800
I was talking to back then and this is kind of their expression. Because five years ago,

22:16.800 --> 22:23.760
when I was talking about this stuff, I was meanest about Flatpak than all the other ones.

22:23.760 --> 22:28.400
I was even invited to Guardek and I gave the meanest talk I have ever given to anybody

22:28.400 --> 22:36.840
right to the people who were actually developing the thing. And the guys from GNOME, they listened.

22:36.840 --> 22:42.800
I wasn't right. I'm not right about everything. That's the recurring theme of this presentation.

22:42.800 --> 22:51.500
But they challenged my opinions, but they accepted at least the ones that actually mattered.

22:51.500 --> 22:58.380
And Flatpak has changed. Like I was talking about earlier, responsibility is the key issue

22:58.380 --> 23:04.640
when you're talking about delivering software. No matter how you're distributing it, you

23:04.640 --> 23:10.520
need to be thinking about dependencies and licenses and maintenance and security. And

23:10.520 --> 23:15.080
one thing that Flatpak does very, very well is basically take all of that away from the

23:15.080 --> 23:21.960
distribution and make it the package's problem. Not great if you're a package, but they do

23:21.960 --> 23:26.200
it in a way that actually probably lowers the burden for everybody. So that's nice.

23:26.200 --> 23:30.600
Automation and technology is great. But really, you know, dependencies become the issue of

23:30.600 --> 23:35.920
the person making the Flatpak. Licenses become the issue there. Maintenance, security, et

23:35.920 --> 23:42.680
cetera. So distros can stop worrying about it. And Flatpak does this very well with their

23:42.680 --> 23:46.880
runtime concept where, you know, if you're building an application for GNOME, you have

23:46.880 --> 23:53.200
a GNOME runtime. If you're building an application for KDE, you have a KDE runtime. Elementary

23:53.200 --> 23:59.120
have their runtime as well. And then for everything else, there's the generic free desktop runtime,

23:59.120 --> 24:06.320
which is a little bit heavier and clunkier, but gets the job done. And back in 2017, this

24:06.320 --> 24:11.240
terrified me. Not because there was competing distributions, because I'm used to competing

24:11.240 --> 24:15.640
distributions. The question was really, you know, are these mini distributions going to

24:15.640 --> 24:20.840
be maintained anything like the one, you know, every other distro out there? Are these going

24:20.840 --> 24:28.000
to handle CVEs well? Are they going to not have horrific licensing issues? Et cetera,

24:28.000 --> 24:33.360
et cetera. Well, they've been doing this for five years now. These runtimes are very well

24:33.360 --> 24:40.080
maintained. These are snapshots from their various Git trees. They're all updating very,

24:40.080 --> 24:46.680
very quickly, keeping up with their respected upstreams of GTK and QT and what have you.

24:46.680 --> 24:52.200
Building CVEs very, very well. I'll talk more about that later. So basically, they're handling

24:52.200 --> 24:57.040
this just as well as any other distribution does. Maybe even better in some cases, because

24:57.040 --> 25:02.360
they're narrower in scope. They've actually got less work to do themselves than a full-blown

25:02.360 --> 25:09.160
distribution with tens of thousands of packages. So you've got your runtimes and you've got

25:09.160 --> 25:13.880
your Flatpak application on top of that, but what about the Flatpak client? Especially

25:13.880 --> 25:17.920
if you think about what I was just talking about with Snap earlier with all of the issues

25:17.920 --> 25:24.160
with App Armor and custom patches and what have you. Well, as a distribution guy, getting

25:24.160 --> 25:30.360
Flatpak in my distribution is really not that hard at all. You need to have the client on

25:30.360 --> 25:35.140
that, but you're not having to worry about a huge chain of dependencies and a whole bunch

25:35.140 --> 25:40.200
of plumbing to get it running. I don't need to have Fuse2 on my distro. All I need to

25:40.200 --> 25:46.720
have is Bubble Wrap, OS 3, and a couple of XDG packages. And they themselves don't really

25:46.720 --> 25:53.240
pull that much in as well. So it's small, it's simple, it's relatively easy, it's self-contained.

25:53.240 --> 25:57.680
Doesn't cause me huge build chains when I have to rebuild the whole thing in Tumbleweed.

25:57.680 --> 26:04.200
It's a really nice ecosystem to just plop on top of my distro and then all of the applications

26:04.200 --> 26:12.960
come from Flatpak. From a licensing perspective, all the Flatpaks on FlatHub are checked. They

26:12.960 --> 26:20.760
all have to have some kind of license that allows open redistribution or legal redistribution.

26:20.760 --> 26:28.080
Or they do also support proprietary stuff. You can get a Spotify Flatpak. But obviously,

26:28.080 --> 26:35.880
you can't have the source code for the Spotify binary in their get tree. So all of the proprietary

26:35.880 --> 26:43.480
stuff has to be pulled through by discrete declared links. And the Flatpak, specifically

26:43.480 --> 26:51.120
the FlatHub team, are checking that, verifying that things aren't changing there, not letting

26:51.120 --> 26:56.720
nasty things happen and binary flip around. So at the very least, you may not know exactly

26:56.720 --> 27:02.000
what horrible thing is in this sandbox, but it's sandboxed, it's not much of a threat

27:02.000 --> 27:06.360
to your machine anyway. And you know it's the one that was sent at submission time,

27:06.360 --> 27:10.080
you know it was the one that was reviewed, you know it isn't changing unexpectedly. So

27:10.080 --> 27:14.520
basically it's as good or as better as any other distribution out there with their native

27:14.520 --> 27:24.080
packages. When it comes to maintenance, basically the same story. Just like OpenSUSE, FlatHub

27:24.080 --> 27:29.120
doesn't like FlatPaks to have distro specific packages or FlatPak specific packages. They

27:29.120 --> 27:36.040
want as everything upstream as possible. They have an incredibly robust build, test, publish

27:36.040 --> 27:41.120
workflow. They're not using OBS, I wish there was. They're not using OpenQA, I wish there

27:41.120 --> 27:47.680
were. But what they're using is just as good, maybe in some ways it's better, they can actually

27:47.680 --> 27:51.400
give everyone nice test channels for testing their application, which I really think I

27:51.400 --> 27:59.080
want to copy sometime. But yeah, it's maintained, it's easy for maintainers to keep their app

27:59.080 --> 28:07.000
maintained and that is all ticking over nicely. From a security point of view, well FlatPak

28:07.000 --> 28:13.840
is the only one that works everywhere. It's the only one that those applications are sandboxed.

28:13.840 --> 28:21.280
The portal concept where you know basically holes are pegged through the sandbox to give

28:21.280 --> 28:25.400
you things like access to the file picker and other parts of the file system and the

28:25.400 --> 28:33.400
like has proven to be secure enough and expandable enough. It's not perfect, nothing ever is.

28:33.400 --> 28:36.400
But it's doing the job and it's doing the job well and these applications are working

28:36.400 --> 28:44.360
very well. And FlatPak CVEs happen very, very rarely. And when they do happen, they're

28:44.360 --> 28:49.440
not these terrifying, scary things because the thing is architected very, very well.

28:49.440 --> 28:55.640
So the last CVE that I could find was in February 2022. It was a medium score, it was fixed

28:55.640 --> 28:59.560
incredibly quickly. I think every distribution had no problem adding that because again,

28:59.560 --> 29:05.040
like I mentioned earlier, given the client is very well structured, you don't have a

29:05.040 --> 29:11.720
huge dependency chain, even the most ancient of OTSS distros can then just happily get

29:11.720 --> 29:19.000
the patch in, get the thing running. So when I started the microS desktop, I adopted FlatPak

29:19.000 --> 29:23.520
some FlatHub, actually November 2017, so if you put the timeline in there, I did change

29:23.520 --> 29:29.040
my opinion quite a bit from the beginning of February 2017 to the end. But I was using

29:29.040 --> 29:33.400
FlatPak as it was the one that I could work with. I couldn't use Snap, couldn't use App

29:33.400 --> 29:39.760
Image. And I didn't trust it that much at the time. I was thinking, like you've seen

29:39.760 --> 29:44.200
with other distributions of building my own FlatPak and using them rather than trusting

29:44.200 --> 29:48.960
FlatHub or doing like Fedora does with they build their own and then they also give FlatUp

29:48.960 --> 29:53.760
with some kind of filtering. But I didn't really want to mess with that at the beginning

29:53.760 --> 29:59.520
of my project doing all of this, so I just opted for trusting FlatHub first and then

29:59.520 --> 30:05.400
waiting for the problems to surface. And it's five years later and I'm still waiting. Like

30:05.400 --> 30:11.000
we haven't had a single issue with the microS desktop where a FlatHub application really

30:11.000 --> 30:15.120
got in the way and needed us to think, okay, you know, we can't trust these guys, we should

30:15.120 --> 30:19.480
start doing all of them. It just hasn't happened. The few times an application hasn't worked

30:19.480 --> 30:23.880
right, well, we send a patch. We work with them because that's how open source is meant

30:23.880 --> 30:32.280
to work, right? So as a distribution guy, I've realized we don't need to be building

30:32.280 --> 30:39.120
these giant humongous, huge code bases, even though that's still what we do with Tumbleweed.

30:39.120 --> 30:44.680
I don't meet myself. I'm purely a microS person now. All of my servers are microS. My desktop

30:44.680 --> 30:52.800
here is microS. I'm using a tiny 1,000 package fraction of my Tumbleweed code base. And everything

30:52.800 --> 30:57.400
else is coming from containers, some of which are built from that much bigger code base.

30:57.400 --> 31:04.680
All my graphical stuff is coming from Flour. And my life is good and I'm happy. And this

31:04.680 --> 31:11.880
presentation is LibreOffice from Flour. So my final thoughts, which I realized I'm actually

31:11.880 --> 31:16.400
finishing a little bit early, but that's good more time for Q&A. Flatpacks are ready for

31:16.400 --> 31:24.160
prime time. The other ones aren't. Don't use app image. Only use Snap if you trust Canonical.

31:24.160 --> 31:29.160
But we're here at Fostem. Flatpacks are the better way to go for people like you who are

31:29.160 --> 31:38.840
here at Fostem. And my system automatically updated in the background. Yeah. Desktop Linux

31:38.840 --> 31:42.800
distros do not need to package the whole world. If you're a distro builder, think about following

31:42.800 --> 31:47.400
the model we are doing with microS desktop. Think about if not narrowing your scope because

31:47.400 --> 31:50.920
you're building the packages and you don't want to tell maintainers to go away, then

31:50.920 --> 31:57.160
at least just start drawing your focus more on just what you need to be doing. Start testing

31:57.160 --> 32:03.360
that part more. Start telling your users that's the bit you can really, really trust and give

32:03.360 --> 32:13.960
some secondary class to the old fashioned way of doing things. Yes. So you are telling

32:13.960 --> 32:20.160
us that Flatpacks run everywhere. Is that also true for different architectures? That is

32:20.160 --> 32:25.400
true at least for ARM, for Z, probably not. But do you really have that many desktops

32:25.400 --> 32:31.120
in the mainframe? Yes, of course. Yeah. Well, then that's something I'm sure the Flathub

32:31.120 --> 32:35.080
team wouldn't mind. I'm sure we could get that working on Flatpack. If there's a need

32:35.080 --> 32:40.560
there, then... Also thinking about a risk drive, of course, and stuff like that. Yeah.

32:40.560 --> 32:46.400
But then that kind of, you know, point actually nicely draws me to my sort of finishing point,

32:46.400 --> 32:51.960
really. None of this stuff is ever going to be perfect. No technology ever is. That's

32:51.960 --> 32:58.360
why we do this stuff in the open. That's why we do this stuff open source. So when things

32:58.360 --> 33:02.240
aren't perfect and aren't the way they are, aren't covering an architecture that you want

33:02.240 --> 33:08.000
or whatever, you know, isn't it better to go to a project that is already going in that

33:08.000 --> 33:14.000
direction that is trying to be available to everybody that is open to me yelling at them

33:14.000 --> 33:20.840
for months about how terrible they are and then work with them to get it all done rather

33:20.840 --> 33:26.200
than sticking in your own tiny little sandbox, doing it all on your own and then being burdened

33:26.200 --> 33:30.960
with it for decades. Like, if you're doing graphical applications, this is the way we

33:30.960 --> 33:37.480
should be going. It's easier for package maintainers. It's easier for distros. It's easier for everyone

33:37.480 --> 33:41.880
to keep up. It's easier for users, too. Nice little web store. They click on what they

33:41.880 --> 33:46.600
want. They can have the beta version if they publish the beta version. It's a nice way

33:46.600 --> 33:53.160
of getting stuff done. So, yeah. Please, if you're doing anything with graphical apps,

33:53.160 --> 33:57.760
please get it on Flattobe. Please contribute to Flattback. Please put Flattback in your

33:57.760 --> 34:05.160
distro. And is there any other questions? Yes, right at the back there.

34:05.160 --> 34:17.960
You've addressed the outstanding question about CPU architecture, which is a great question.

34:17.960 --> 34:22.880
How do you feel about the fact, and I realize I'm asking the Linux question of a Linux distro

34:22.880 --> 34:27.360
container, but how do you feel about the fact that containers tie everyone in the world

34:27.360 --> 34:34.760
to the Linux kernel interface as their interface, shutting out other open kernel options, like

34:34.760 --> 34:42.200
the BSDs, from participating in that ecosystem? And that the overall drive towards containers

34:42.200 --> 34:49.200
is further orphaning these already minimally represented but very, very strong options

34:49.200 --> 34:59.040
in other kernels. They're strong, but I mean, I guess the recurring

34:59.040 --> 35:05.400
point I get to with all of this kind of thing is, you know, niche players are great for

35:05.400 --> 35:10.640
playing in niches. When you're talking about something that needs to have widespread adoption

35:10.640 --> 35:16.680
and or widespread contribution, some degree of centralization does make sense. It doesn't

35:16.680 --> 35:19.760
make sense for everybody to go make their own kernel. It doesn't make sense for everybody

35:19.760 --> 35:24.760
to make their own distribution. I would say it doesn't make sense for everybody to go

35:24.760 --> 35:29.960
packaging their own graphical applications 20 times over. So as hard as it is to say

35:29.960 --> 35:35.920
to somebody who's clearly passionate about other kernels and BSDs and what have you,

35:35.920 --> 35:42.240
I'm fine with containerization and these technologies dragging everybody to the Linux kernel because

35:42.240 --> 35:48.840
that's where the contributions are. So, you know, and as long as the Linux kernel is open

35:48.840 --> 35:53.280
to contributions and everybody can steer it in a good direction, I'm kind of okay with

35:53.280 --> 36:04.960
that. Thank you for your talk. I was with the presentation

36:04.960 --> 36:10.960
of 2017, so I think it's very nice that you changed the fuse. That year I also watched

36:10.960 --> 36:16.040
the presentation about atomic from Fedora. So it was funny how those things interlapped.

36:16.040 --> 36:21.320
I have a question about how you feel about the base system. You see currently there are

36:21.320 --> 36:30.120
trends like Nix and like SteamOS, which use like an immutable image as a base. How do

36:30.120 --> 36:33.680
you feel about that? So I think immutable distributions are the

36:33.680 --> 36:37.680
way to go. Like I think if you're running Linux, it should be immutable. Immutability

36:37.680 --> 36:46.680
does bring with it a bunch of extra questions. And, you know, and for us as geeks, I think

36:46.680 --> 36:51.560
I can say that without insulting anybody in the room, you know, we are keen to tinker

36:51.560 --> 36:55.600
with our machines and of course, immutability quite often can get in the way of that. If

36:55.600 --> 36:59.160
you can't change your running system, how are you going to install that one little thing

36:59.160 --> 37:08.160
that you want? I think there's a sweet spot. And I don't think some of the other distributions

37:08.160 --> 37:13.360
get it. You know, image-based deployments, you know, you've got a frozen image, you can't

37:13.360 --> 37:17.920
really modify that image, or you have to build a whole new one. That's too much work. I don't

37:17.920 --> 37:23.200
like image-based immutable systems that much. Nix has an interesting way with everything

37:23.200 --> 37:28.120
being declative, but it's a lot of hassle declaring everything. It kind of swings the

37:28.120 --> 37:36.080
other way for me, so I don't necessarily like the Nix way. OSTree has an interesting take

37:36.080 --> 37:42.560
on the whole thing, where both from a user's perspective and the fact it's immutable, it's

37:42.560 --> 37:47.120
nice but then you end up with a million different layers of OSTree and it just gets technically

37:47.120 --> 37:53.240
burdensome. Obviously, I work on microOS, I think we found that sweet spot. In our case,

37:53.240 --> 37:58.480
we're using BTRFS snapshots to do all the magic underneath the hood where your running

37:58.480 --> 38:03.360
system never gets touched, but you can still do traditional package management against

38:03.360 --> 38:06.840
a new snapshot and that becomes your next boot target. So you're never affecting the

38:06.840 --> 38:10.560
running system, but you can do whatever the heck you want with your next boot. And then

38:10.560 --> 38:15.840
if that next boot goes horribly wrong, we just throw the whole snapshot away. So it's

38:15.840 --> 38:20.160
super fast, super easy, avoids all of that. You can still tinker with it, but you're not

38:20.160 --> 38:24.680
... Unfortunately, the downside of that is I do sometimes have to tell people don't tinker

38:24.680 --> 38:28.440
too much. The more you do crazy stuff, the more likely you're going to throw that snapshot

38:28.440 --> 38:35.680
away. But I think that sweet spot is better than super lockdown images or complete freedom

38:35.680 --> 38:40.760
of having to declare everything in a config file.

38:40.760 --> 38:51.440
Okay. Thank you for the presentation. I had never heard of Flatpak. On my Ubuntu, I'm

38:51.440 --> 38:57.600
using Snap to install application. And on my Mac, I'm using Homebrew. What do you think

38:57.600 --> 39:00.800
of Homebrew on Linux?

39:00.800 --> 39:08.720
I don't see the point of Homebrew on Linux. Yeah. It's... Yeah. Why? Like I get it on

39:08.720 --> 39:13.760
my Mac, I've installed a few things on my Mac that I desperately need there. But my

39:13.760 --> 39:21.920
Mac, I use for photography. I don't do anything technical on it. So yeah. Don't see the point.

39:21.920 --> 39:29.320
Okay. Thank you.

39:29.320 --> 39:34.960
How likely is it for the files stored in the home directory, especially the user files,

39:34.960 --> 39:39.040
to be accepted if I roll back a snapshot after a failed upgrade?

39:39.040 --> 39:45.880
So yeah. That's a really like micro specific question. That's cool though. The way we do

39:45.880 --> 39:50.600
it on micro OS is when we talk about the root file system, we're not talking about the root

39:50.600 --> 39:57.360
partition because we're using BTRFS. So BTRFS, you have this concept of sub volumes. We have

39:57.360 --> 40:03.940
a sub volume for literally everything where the data should be changing. So Home, Opt,

40:03.940 --> 40:10.360
because that's third party, so it's not us. User local, because again, that's not us.

40:10.360 --> 40:14.800
Anything that isn't the distro is in a sub volume, and then the distro's root file system

40:14.800 --> 40:19.000
is just that last bit that's left. So that bit's read only. That's the bit that's managed

40:19.000 --> 40:24.880
by the package manager. All the sub volumes are freely available and read write. That

40:24.880 --> 40:28.720
does make ETC a little bit interesting, because that's like the one folder where it's both,

40:28.720 --> 40:34.360
like distro's put stuff in there and that. In micro OS we handle that with overlay FS

40:34.360 --> 40:40.000
right now, where yeah, we're basically taking copies of that, knowing what we put there,

40:40.000 --> 40:43.800
knowing what the user put there, or at least trying to, and then merging everything together

40:43.800 --> 40:51.040
so the thing works. Ideally what we would like is everybody to start using, like most

40:51.040 --> 40:58.040
people already are, user for putting in distribution convicts at USR. It should be in user lib

40:58.040 --> 41:03.600
or user ETC or whatever. Just like you see with system D, where distro's put their distro

41:03.600 --> 41:11.560
config in user lib system D, and then users put their local config in ETC system D. That

41:11.560 --> 41:16.320
way works very, very nicely, but meanwhile ETC's a bit of a mess, but a mess that we

41:16.320 --> 41:30.600
can manage. Thank you for the presentation. Why isn't

41:30.600 --> 41:40.680
flatback suitable for CLIs? Actually it is suitable for CLIs. There's actually a guide

41:40.680 --> 41:50.280
now for how to do that. I think the, so yeah, there are examples of apps where they do that,

41:50.280 --> 41:56.760
where the assumption is always probably going to be that it's graphical, but there's no

41:56.760 --> 42:02.560
reason why a graphical application can't start an X term and run a CLI app. There's actually

42:02.560 --> 42:09.520
examples in the flatback documentation of how to do that. Generally speaking, for apps

42:09.520 --> 42:18.440
that might not fit that kind of model, I think a lot of that kind of CLI or more service-based

42:18.440 --> 42:24.200
command-lining stuff, that's handled so well by OCI containers, Podman, Docker and the

42:24.200 --> 42:30.680
like. Why mess with that? You've got all those containers already out there, you've got everyone

42:30.680 --> 42:38.960
building command-line tooling and server tooling in containers. That does very, very well in

42:38.960 --> 42:44.560
that context. It just sucks on the desktop to have flatback that just handles the desktop

42:44.560 --> 42:50.840
issue. You don't necessarily have to have one thing to do everything. So I think flatback

42:50.840 --> 42:55.760
draws that line quite nicely, where it naturally starts getting painful when you head down

42:55.760 --> 43:09.720
that road. Any more questions? No? Well, hopefully I will see you in a couple of years when I'm

43:09.720 --> 43:26.160
on the game. Thank you very much.
