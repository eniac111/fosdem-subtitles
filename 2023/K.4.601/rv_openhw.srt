1
0:00:00.000 --> 0:00:12.680
Thank you all very much. Thank you for coming along.

2
0:00:12.680 --> 0:00:20.800
My name's Jeremy Bennett. I'm chief executive of Ember Cosm. But Ember Cosm is an engineering

3
0:00:20.800 --> 0:00:26.200
heavy company. We only have one full-time non-engineer in the whole company and it's

4
0:00:26.200 --> 0:00:30.960
not me. So I actually am a working engineer as well as running the company. And we develop

5
0:00:30.960 --> 0:00:37.760
open source mostly compiler tool chains but we also have some open source AI and we also

6
0:00:37.760 --> 0:00:42.080
have some open source operating system stuff. And because most of what we do is pre-silicon

7
0:00:42.080 --> 0:00:48.200
we do an awful lot of open source silicon chip modelling. But I'm also here with another

8
0:00:48.200 --> 0:00:53.720
hat on which is that I am chair of the open hardware groups software task group. So I'm

9
0:00:53.720 --> 0:00:58.320
responsible for all the software developed for the open hardware group. And I'll talk

10
0:00:58.320 --> 0:01:05.200
a bit more about them in a bit. And this talk is part technical but it's partly about the

11
0:01:05.200 --> 0:01:12.680
actual practical side of how we go about developing complex software for an open architecture like

12
0:01:12.680 --> 0:01:27.320
RISC-V. So let's tell you a bit about the open hardware group. So it's a not-for-profit.

13
0:01:27.320 --> 0:01:33.800
It's a member-driven collaboration and it's a mixture of industry companies like mine,

14
0:01:33.800 --> 0:01:41.100
some big companies that you will recognise. NXP is a member for example. It has academics

15
0:01:41.100 --> 0:01:48.320
so quite a few universities are members and part of it. And it also has individual members.

16
0:01:48.320 --> 0:01:51.480
You can contribute as an individual and we have a number of, some of the work I'm going

17
0:01:51.480 --> 0:01:58.520
to talk about has been just done by people who are individual members. And the goal is

18
0:01:58.520 --> 0:02:03.040
high quality and that high quality is the key thing, open source hardware development.

19
0:02:03.040 --> 0:02:07.640
The sort of open source hardware that you can put in a commercial chip and be confident

20
0:02:07.640 --> 0:02:13.760
you can send it off to be fabricated. So it's collaborative and it's open. It's an open

21
0:02:13.760 --> 0:02:22.120
development model. So all these things are open to all. Now the organisation's the open

22
0:02:22.120 --> 0:02:29.280
hardware group but its cores are known as core 5 or core V. So we have a huge family

23
0:02:29.280 --> 0:02:33.840
of processors. I'll talk about them. Everything from the smallest RISC-5.32 to the biggest

24
0:02:33.840 --> 0:02:43.380
RISC-5.64 designs. And these are standard RISC-5 cores but with some customer ISA extensions

25
0:02:43.380 --> 0:02:48.600
for RISC-5. The chief executive is Rick O'Connor and those of you who have been around for

26
0:02:48.600 --> 0:02:53.480
a few years will remember Rick because he was the first chief executive of RISC-5 International

27
0:02:53.480 --> 0:02:59.200
and he's moved from the open source specification world to actually delivering real silicon

28
0:02:59.200 --> 0:03:09.960
IP. Let's look at the ancestry. So open hardware group grows out of an academic industry project

29
0:03:09.960 --> 0:03:17.760
called the parallel ultra low power processor project. Pulp. And that was a collaboration

30
0:03:17.760 --> 0:03:25.080
originally between ETH Zurich, the University of Bologna and ST Microelectronics. ST Microelectronics

31
0:03:25.080 --> 0:03:31.000
no longer active in it and it predates RISC-5. The first part of pulp was done with open

32
0:03:31.000 --> 0:03:38.080
risk but for the last many years it's been a RISC-5 project. And the idea is to get very,

33
0:03:38.080 --> 0:03:44.840
very low power multi-core systems. So that's where we come from. And the cores started

34
0:03:44.840 --> 0:03:51.320
off as these academic research cores. And the point about academic research cores is

35
0:03:51.320 --> 0:03:55.760
they are designed to push the forefront of knowledge forward. They're not designed to

36
0:03:55.760 --> 0:04:00.120
be exhaustively tested for manufacturing and use in a commercial deployment. That's not

37
0:04:00.120 --> 0:04:05.840
the purpose of a university. So the natural transition is that open hardware group takes

38
0:04:05.840 --> 0:04:14.720
that as an outstanding technical base and then takes it into a robust standard. We have

39
0:04:14.720 --> 0:04:21.720
loads and loads of members. So I've copied this off the website and it's the wrong format.

40
0:04:21.720 --> 0:04:25.760
I really want a wider and flatter one. But you'll probably see some logos there. You'll

41
0:04:25.760 --> 0:04:30.920
see Ember Cosm's logos there. The astute of you will notice that Ambers and Web Services

42
0:04:30.920 --> 0:04:35.000
appears to be both a member and a partner. I think they transitioned from a partner to

43
0:04:35.000 --> 0:04:41.800
a member and the slide wasn't properly updated. So we have lots and lots of members. I think

44
0:04:41.800 --> 0:04:51.760
it's up to about 70 now. And it might be worth just saying that when you become a member,

45
0:04:51.760 --> 0:04:56.640
yes you have to pay if you're corporate you have to pay a membership fee. But that's not

46
0:04:56.640 --> 0:05:03.440
the big thing. You can only become a member if you commit resource in terms of what you're

47
0:05:03.440 --> 0:05:08.640
going to contribute. And that dwarfs any membership fee. You cannot be a member unless you're

48
0:05:08.640 --> 0:05:15.960
going to do something. We don't have sleeping members. You've got to be active members.

49
0:05:15.960 --> 0:05:21.440
In terms of an organization, it's very lightweight. And this is one of the big contrasts with

50
0:05:21.440 --> 0:05:27.320
RISC-V International. At a technical level, we only have five committees. We have an overarching

51
0:05:27.320 --> 0:05:32.320
technical working group which has the overall responsibility for the engineering direction.

52
0:05:32.320 --> 0:05:39.880
And it has two, it has co-chairs, it has Jerome Cuerre of Amont from Thales and David Lynch.

53
0:05:39.880 --> 0:05:45.160
And I can't remember where David Lynch comes from actually, but two companies joined chairs.

54
0:05:45.160 --> 0:05:50.400
And that meets every month as the final arbiter of technical stuff. And then all the work

55
0:05:50.400 --> 0:05:55.560
of this organization is handled by just four committees. The CORS group headed up by I

56
0:05:55.560 --> 0:06:05.640
am Bink from Silicon Labs. And that is responsible for the tracking the development of CORS.

57
0:06:05.640 --> 0:06:11.320
The work is done by the member companies. But these are the groups that have oversight

58
0:06:11.320 --> 0:06:17.160
and make sure the quality criterion is maintained. There's a verification task group. And verification

59
0:06:17.160 --> 0:06:22.040
is actually separated from core development, even though the two are desperately tightly

60
0:06:22.040 --> 0:06:27.800
tied in. And that's led by Simon Davidman of Imperus. There's a hardware task group.

61
0:06:27.800 --> 0:06:32.880
And this is a slightly strange name perhaps. But the point of the hardware task group is,

62
0:06:32.880 --> 0:06:41.160
though this is fundamentally a group developing Silicon IP, we do have to have reference implementations.

63
0:06:41.160 --> 0:06:46.000
And the first reference implementation should be coming out later this year, which is the

64
0:06:46.000 --> 0:06:53.200
core five MCU. And that has one of the 32-bit cores in it. And lastly, the software task

65
0:06:53.200 --> 0:06:59.240
group which I lead assisted by Yun-Hai Shang from Alibaba Teahead. And that's responsible

66
0:06:59.240 --> 0:07:03.200
for all the software projects. And again, it's oversight. It's not doing the work because

67
0:07:03.200 --> 0:07:06.760
you have to do the work. If you want to be a member, you have to do the work. We do have

68
0:07:06.760 --> 0:07:13.600
a bit of a problem there because we have mostly hardware members and not enough software members.

69
0:07:13.600 --> 0:07:22.080
In terms of the roadmap, we've got a flagship application core. That's the CV-A6. And that's

70
0:07:22.080 --> 0:07:30.640
a 64-bit full-blown RISC-V core designed to run Linux. And that comes out of the top-end

71
0:07:30.640 --> 0:07:41.960
pulp core under development. There is a smaller 32-bit core, the CV-32A5, which is designed

72
0:07:41.960 --> 0:07:49.640
for, which is designed to try and do a small Linux system. Or of course, we've got the

73
0:07:49.640 --> 0:07:56.340
issue of getting Linux running on 32-bit anyway. You probably can only just make it out. Each

74
0:07:56.340 --> 0:08:03.220
of these projects has a target technology readiness level. Are people familiar with

75
0:08:03.220 --> 0:08:08.680
technology readiness levels? A little bit. Okay. So most of these are aimed at technology

76
0:08:08.680 --> 0:08:16.160
readiness level, which is proven in the environment. CV-A5 is a bit different. It's aimed as TRL4,

77
0:08:16.160 --> 0:08:21.040
which is proven in the lab. And we've got other projects which are outside different

78
0:08:21.040 --> 0:08:28.040
levels. But mostly we're aiming at TRL5. Okay. The flagship, the first project was the CV-32E40P,

79
0:08:28.040 --> 0:08:35.800
which is a microcontroller class 32-bit RISC-V implementation. And the first version of that

80
0:08:35.800 --> 0:08:41.560
is complete. The second version is under development. And actually the work Nandni was talking about

81
0:08:41.560 --> 0:08:47.720
with built-ins is primarily focused at CV-32E40Pv2. You will see sitting there, there's something

82
0:08:47.720 --> 0:08:54.280
called the CV-32E41P. And that's a bit unusual because it's actually only going to TRL3,

83
0:08:54.280 --> 0:09:00.680
which is proof of concept. And it's being developed by Huawei under this group in order

84
0:09:00.680 --> 0:09:10.840
to test out the ZC-Star extension, the new compressed extension, and the ZF-INX, where

85
0:09:10.840 --> 0:09:15.520
you have a shared register bank for floating point and integer. So it's only a proof of

86
0:09:15.520 --> 0:09:20.320
concept chip to verify that those work. And then we have a couple of more forward-looking

87
0:09:20.320 --> 0:09:28.120
ones. CV-32E40S is a version of the original CV-32E40P aimed at security applications.

88
0:09:28.120 --> 0:09:33.320
And the really exciting one is the CV-32E40X. That's a bit further out because the X is

89
0:09:33.320 --> 0:09:38.000
a generic extension interface at the hardware level. So this is designed so you can take

90
0:09:38.000 --> 0:09:43.520
a call. It's really easy to add in a wide range of extensions. And indeed, to the extent

91
0:09:43.520 --> 0:09:48.720
you can do the floating point extension through the CV-32E40X. So that's the roadmap we're

92
0:09:48.720 --> 0:09:56.740
sitting on. So what about the software projects? Well, I'm going to focus on the tool chains.

93
0:09:56.740 --> 0:10:01.280
So the LLVM tool chain, the GNU tool chain. And because we haven't yet got silicon, I'm

94
0:10:01.280 --> 0:10:07.320
going to focus on a couple of software projects, QEMU and the Verilator model. We have other

95
0:10:07.320 --> 0:10:10.680
projects. So I'm responsible for eight projects in tool. There's the SDK, the software development

96
0:10:10.680 --> 0:10:15.440
kit that's actually joined with the hardware group. The hardware abstraction layer so that

97
0:10:15.440 --> 0:10:19.480
we can actually make our software more easily portable as we do more and more of these chips.

98
0:10:19.480 --> 0:10:25.200
Free RTOS with micro-controlling. If you're going to go for an RTOS, the obvious one to

99
0:10:25.200 --> 0:10:29.920
start with is Free RTOS. And Linux, which is really aimed at the CVA6. So we've got

100
0:10:29.920 --> 0:10:36.640
eight projects under our belt. We have a rigorous engineering process. So those of you who work

101
0:10:36.640 --> 0:10:47.280
for big engineering companies are familiar with gate-based processes. So all of the way

102
0:10:47.280 --> 0:10:53.880
we manage these projects is through a gate-based process. You have a project concept gate.

103
0:10:53.880 --> 0:10:58.360
It's where you propose a project. You want to work on this project. You explain what

104
0:10:58.360 --> 0:11:04.440
it is and why we need to do it. And the project will only go ahead if it's voted for by enough

105
0:11:04.440 --> 0:11:08.160
members. And members can't just vote and say, hey, that's a good idea. I'll say yes for

106
0:11:08.160 --> 0:11:12.920
everything. You vote for it. You're going to commit resource to it. Critical thing is

107
0:11:12.920 --> 0:11:17.640
this is a doing organization. So, OK, you're then going to explore it. And then we got

108
0:11:17.640 --> 0:11:24.560
to a project launch gate. And that stage, not only do you know what and why, but now

109
0:11:24.560 --> 0:11:30.560
you know how you're going to do it. What do I need to do to get this? And then the big

110
0:11:30.560 --> 0:11:36.080
one, the last one, is plan approved. And plan approved means you've resourced it. So you

111
0:11:36.080 --> 0:11:41.680
know when you're going to deliver it. And that's quite a big hurdle for some projects.

112
0:11:41.680 --> 0:11:45.160
And then away the project work goes. I mean, this is a bit simplified. We all know work

113
0:11:45.160 --> 0:11:50.320
starts a bit in advance. But the way the project goes, and eventually you get to project freeze,

114
0:11:50.320 --> 0:11:56.560
OK, where it's all done. Now, this is brilliant for hardware, OK? It's a very hardware-centric

115
0:11:56.560 --> 0:12:02.120
view of the world because a freeze means something. It's when your chip's gone off to be fabbed,

116
0:12:02.120 --> 0:12:08.280
OK? Doesn't work quite so well for software. So we've modified it for software, OK? And

117
0:12:08.280 --> 0:12:12.720
the first two stages are quite generic because typically we're working with a big block of

118
0:12:12.720 --> 0:12:18.280
common software. We're not writing a compiler from scratch. We're taking the GNU infrastructure,

119
0:12:18.280 --> 0:12:23.760
GCC, binutils, and all that, all millions of lines of it. And that's mostly not changed,

120
0:12:23.760 --> 0:12:29.120
and we're changing a bit. Now, some of that is quite the why and the how. The what and

121
0:12:29.120 --> 0:12:34.880
the why and the how is quite generic. It applies to probably all core five chips, certainly

122
0:12:34.880 --> 0:12:40.760
maybe to all the 32-bit ones. And then for each specific chip, we have multiple plan

123
0:12:40.760 --> 0:12:44.560
approved, which is where we work out when we're going to deliver it for CV30, E40P,

124
0:12:44.560 --> 0:12:51.960
V1, for V2, for S, for X, and so forth. And so we have a whole set. But it's still the

125
0:12:51.960 --> 0:12:58.680
same process of you need to know it's properly resourced and so forth, OK? So we'll see that

126
0:12:58.680 --> 0:13:05.160
a little bit in action. But that whole engineering focus pervades everything, OK? So let's put

127
0:13:05.160 --> 0:13:10.400
the content. Once the compiler toolchain, it's not just the compiler, it's the assembler.

128
0:13:10.400 --> 0:13:15.920
It's the low-level utilities. It's the debugger. It's the libraries. It's the emulation libraries.

129
0:13:15.920 --> 0:13:21.440
It's the standard C libraries, the C++ libraries. And in the ultimate way, if you look at GCC,

130
0:13:21.440 --> 0:13:27.280
this is GCC. It's many, many languages. It's ADO. It's the C, C++ family. It's FORTRAN.

131
0:13:27.280 --> 0:13:31.600
It's Java. It's GO. These days, it's Rust. It's modular to... And of course, we've got

132
0:13:31.600 --> 0:13:36.280
things that sit at the high level like OpenMP and OpenACC. That's a huge lot of stuff. We

133
0:13:36.280 --> 0:13:41.080
have a hasten to say we're a long way off having all of that for the core five. But

134
0:13:41.080 --> 0:13:45.560
it's a lot of code. It's about... It's north of 12 million lines of code and it's a year

135
0:13:45.560 --> 0:13:50.240
or so since I last measured those figures. So it's big. And we're trying to get that

136
0:13:50.240 --> 0:13:56.560
all seamlessly worked through to work on core five. Now, we're not doing it from scratch.

137
0:13:56.560 --> 0:14:01.320
Of course, we're starting from risk five and then we're adding stuff to it. And the humans

138
0:14:01.320 --> 0:14:06.160
say LLVM has the same components but they've got different names and a different set of

139
0:14:06.160 --> 0:14:16.480
languages. So let's look at the ISA extensions for core five. And the core five ISA extensions,

140
0:14:16.480 --> 0:14:26.880
there are nine we're concerned with. Eight of those come from the pulp project. So extra

141
0:14:26.880 --> 0:14:35.440
addressing modes, post incrementing, load and store. Hardware loops. More ALU operations.

142
0:14:35.440 --> 0:14:41.680
And special case branching operations. We've got MAC instructions. We've heard about the

143
0:14:41.680 --> 0:14:47.360
event load. That's a multi-core feature. And then we've got the pulp bit manipulation and

144
0:14:47.360 --> 0:14:52.280
the pulp SIMD. Those are not standard bit manipulation and SIMD. Those are different

145
0:14:52.280 --> 0:14:56.320
ones. But there's been years of development. The reason they're different is they predate

146
0:14:56.320 --> 0:15:05.080
a risk five bit manip and they predate risk five SIMD. And you can see the pulp SIMD is

147
0:15:05.080 --> 0:15:11.800
big. And the reason that Nandni knows so much about built ins is she's done the built ins

148
0:15:11.800 --> 0:15:20.160
to support those 220 SIMD instructions. So she's nearly finished. And then I think she's

149
0:15:20.160 --> 0:15:26.920
going away for a long holiday where she never looks at another built in again. And we've

150
0:15:26.920 --> 0:15:33.680
got ZC star. So we have the first GCC implementation supporting ZC star. And of course these are

151
0:15:33.680 --> 0:15:38.320
standard risk five compilers. You can still use them for risk five. And the hot news is

152
0:15:38.320 --> 0:15:44.360
that core five GCC has a pull request to put ZC star 1.0.1 which is the freeze candidate

153
0:15:44.360 --> 0:15:50.720
support. Once that's been reviewed that will go in there. So we've got a lot. The tool

154
0:15:50.720 --> 0:16:07.360
chain work is all about supporting these pulp extensions. In terms of the built ins you've

155
0:16:07.360 --> 0:16:12.960
heard all about them. But it's a lot of functions. It's not just Nandni. Nandni has a team working

156
0:16:12.960 --> 0:16:21.000
on this. And we've got this naming convention. So we get from naming convention that built

157
0:16:21.000 --> 0:16:27.720
ins for risk five are built in underscore risk five underscore vendor underscore name.

158
0:16:27.720 --> 0:16:33.040
We've got so many we're actually splitting up into ISA extension and name. There is a

159
0:16:33.040 --> 0:16:39.520
rule though if you're you can't just have if what you're doing is a built in is it corresponds

160
0:16:39.520 --> 0:16:44.920
to a standard built in then you must use the standard name. So for example we have in our

161
0:16:44.920 --> 0:16:52.560
arithmetic we have abs so we've got built in abs which is a standard GCC built in.

162
0:16:52.560 --> 0:16:59.640
The built ins actually they have the same name for 32 bit or 64 bit. That is not overloading

163
0:16:59.640 --> 0:17:04.040
in the C plus plus sense because either you're running for a 32 bit target or you're compiling

164
0:17:04.040 --> 0:17:09.440
for a 64 bit target. You have one or the other there. There's not an overload. It's also

165
0:17:09.440 --> 0:17:12.960
the case is built ins are not just another way of doing inline assembler. There's not

166
0:17:12.960 --> 0:17:19.000
a one to one mapping. So for example for the SIMD add scaler there are actually two different

167
0:17:19.000 --> 0:17:24.520
ways of adding scalers in the risk in the core five SIMD. One where the scalers in a

168
0:17:24.520 --> 0:17:28.760
register the other where it's a small integer and you can actually put it is that there's

169
0:17:28.760 --> 0:17:32.480
actually an add immediate instruction. We don't have two built ins. There's a single built

170
0:17:32.480 --> 0:17:39.560
in. And if the second argument is a small constant that fits there it will generate

171
0:17:39.560 --> 0:17:43.680
the immediate version instruction. Otherwise it will load it into a register. And that's

172
0:17:43.680 --> 0:17:47.360
part two of Nandy's talk for the future because that's quite a lot harder to do in a built

173
0:17:47.360 --> 0:17:56.240
in. OK. And there is a specification. It's big. If you put it into if you generate PDF

174
0:17:56.240 --> 0:18:02.440
it's 57 pages long. OK. So. And that's one of the things is built ins built ins are not

175
0:18:02.440 --> 0:18:06.240
quite as easy as you think. There are things you can get wrong there. And you do genuinely

176
0:18:06.240 --> 0:18:13.400
have to think and review it's under review at the moment. That's not finalised. OK. So

177
0:18:13.400 --> 0:18:20.240
testing now if we're going to do full testing of a tool chain. OK. We need a target which

178
0:18:20.240 --> 0:18:23.640
has all these ice extensions. They're not standard risk five. I can't just take standard

179
0:18:23.640 --> 0:18:29.040
risk five QEMU or whatever. OK. You can do some testing. So the standard can you assemble

180
0:18:29.040 --> 0:18:33.080
a test for example don't need an executable target. They are pattern matching. Have you

181
0:18:33.080 --> 0:18:38.040
generated something that looks right. OK. You can do the same with built ins. You saw

182
0:18:38.040 --> 0:18:42.040
it from Nandy's compile time only thing where you look and do a scan assembler to see has

183
0:18:42.040 --> 0:18:48.520
that built in generated just one of the instruction I want. OK. But more generically you need

184
0:18:48.520 --> 0:18:55.200
to be able to execute your tests. OK. So we have two things. One is we have QEMU for core

185
0:18:55.200 --> 0:19:02.040
five. That's a project being led by Wei Wei Li at the programming languages and compiler

186
0:19:02.040 --> 0:19:09.720
technology team at Chinese Academy of Sciences in Beijing. OK. That's a work in progress.

187
0:19:09.720 --> 0:19:17.200
We're expecting that to become available later in 2023. And secondly we're using very later

188
0:19:17.200 --> 0:19:21.480
models. How many people here are familiar with very later. Han show. OK. Most of you.

189
0:19:21.480 --> 0:19:28.160
OK. For those who don't it's a tool that takes a hardware design in very long or system very

190
0:19:28.160 --> 0:19:33.440
long and generates a C plus plus model from it. A cycle accuracy plus plus model and very

191
0:19:33.440 --> 0:19:38.160
later models are really useful because either easy to integrate to toolchain testing and

192
0:19:38.160 --> 0:19:42.800
be they are what's called implementation models. Most models come from the specification of

193
0:19:42.800 --> 0:19:47.120
chip. These are the actual implementation. So we know what your testing is what is physically

194
0:19:47.120 --> 0:19:51.280
going on the chip. And when you have a model it's not just enough to have a model. You've

195
0:19:51.280 --> 0:19:55.000
got to be able to hook to it. So typically you've got to run wrap around some form of

196
0:19:55.000 --> 0:20:00.480
debug service you can connect GDP or LDB. And that's the work in progress. That's due

197
0:20:00.480 --> 0:20:06.240
to be completed in the next few weeks. And then you'll be able to actually run on the

198
0:20:06.240 --> 0:20:17.080
actual model of the actual hardware. Testing policy. LLVM project uses the LLVM into

199
0:20:17.080 --> 0:20:24.800
integration tester. That that is a set of several tens of thousands of tests from source

200
0:20:24.800 --> 0:20:32.600
code down to LLVM IR. Very comprehensive. And we use that. But it isn't a set of execution

201
0:20:32.600 --> 0:20:38.360
tests. Now LLVM does have an executable test suite but it is a set of applications to run

202
0:20:38.360 --> 0:20:42.120
on our own under operating system. And for a small microcontroller they're not suitable.

203
0:20:42.120 --> 0:20:45.680
They need an operating system there. So we can't use the LLVM test suite. So instead

204
0:20:45.680 --> 0:20:51.120
we use a subset of the GNU regression tests to test LLVM compilers. And that's widespread.

205
0:20:51.120 --> 0:20:55.480
That's not something we've invented. That's been done for years. It's only a subset because

206
0:20:55.480 --> 0:20:59.320
there is no point in running the GNU tests of the internal representations inside the

207
0:20:59.320 --> 0:21:03.800
GNU compiler. But things like the torture tests are absolutely fine whether they're

208
0:21:03.800 --> 0:21:09.920
on LLVM or GC. They're compiler agnostic. The GNU tools just uses the GNU regression

209
0:21:09.920 --> 0:21:17.320
tests. Something that we're very hot on is exhaustive testing. OK. It's not just that

210
0:21:17.320 --> 0:21:22.120
oh I tried one thing and it seemed to work. It's a let's make sure we've not missed things.

211
0:21:22.120 --> 0:21:28.720
So starting at the assembler we have both positive and negative testing. By positive

212
0:21:28.720 --> 0:21:34.460
testing we mean testing the compiler does what you want. By negative testing I mean

213
0:21:34.460 --> 0:21:41.660
testing it doesn't do things when it shouldn't. So for example if we're looking at an instruction

214
0:21:41.660 --> 0:21:48.760
that takes a six bit signed constant we will test it with values of minus 33, too small

215
0:21:48.760 --> 0:21:54.200
for a negative number. Minus 32 the biggest negative six bit number. Zero because you

216
0:21:54.200 --> 0:21:58.320
should always test zero because it's a special case. Probably minus seven and plus five and

217
0:21:58.320 --> 0:22:02.840
then we'll test 31 and 32 which is too big. And we will check those bounds. And actually

218
0:22:02.840 --> 0:22:07.040
we added those tests for ZC star and found a whole load of bugs in the ZC star spec as

219
0:22:07.040 --> 0:22:15.000
a consequence. So we do that sort of thing and we also test things like we test the extensions.

220
0:22:15.000 --> 0:22:21.680
I've got the ELW instruction. I test that the ELW instruction is handled by the assembler

221
0:22:21.680 --> 0:22:29.520
when I specify XELW. I also test that it doesn't get recognized when I don't specify XELW.

222
0:22:29.520 --> 0:22:32.480
So that's really important. And one thing I would observe is and I've seen this for

223
0:22:32.480 --> 0:22:38.360
a long time is RISC-V is incredibly weak on its assembly level testing. There are about

224
0:22:38.360 --> 0:22:45.680
ten times as many tests for ARM and x86 as there are for RISC-V. So it's important to

225
0:22:45.680 --> 0:22:54.560
do that. And so we do core five specific, core five specific GNU LD testing because

226
0:22:54.560 --> 0:23:02.120
we're adding some relocations. Do they work? At the moment we've got compilation only tests

227
0:23:02.120 --> 0:23:07.840
of built ins using scan for assembler instructions. But when we've got those models running, the

228
0:23:07.840 --> 0:23:13.240
QEMU and the Verilator model, we'll be adding execution tests. So not only do I generate

229
0:23:13.240 --> 0:23:17.320
the right assembly instruction but it does what I expect. Not only do I generate the

230
0:23:17.320 --> 0:23:24.760
built in but it does what I expect. So we'll be adding those in as well. And that, all

231
0:23:24.760 --> 0:23:30.000
that testing ties into the difference of this is a commercial grade chip, commercial grade

232
0:23:30.000 --> 0:23:36.600
core, sorry, and its associated tool chains. So resourcing. Resourcing is an issue because

233
0:23:36.600 --> 0:23:41.120
software these days on a chip you'll spend twice as much on the software as you do on

234
0:23:41.120 --> 0:23:50.280
the hardware. But open hardware group is inherently mostly hardware company members. We've got

235
0:23:50.280 --> 0:23:54.560
plenty of software members but we're still in a minority. So it is a challenge to get

236
0:23:54.560 --> 0:23:59.120
enough resourcing as part of my contribution and because it makes a lot of contribution

237
0:23:59.120 --> 0:24:05.520
as part of our membership, the PLCT lab in China, they make a big contribution. So that's

238
0:24:05.520 --> 0:24:10.040
coming there. And we actually double up, we use them very much as part of our graduate

239
0:24:10.040 --> 0:24:14.440
training program as well. So part of the graduate allows us to train a new generation of compiler

240
0:24:14.440 --> 0:24:19.480
engineers. But we're also seeing companies like Silicon Labs and Dolphin Design call

241
0:24:19.480 --> 0:24:23.600
out to them because they help to fund those software companies to do the work. So thank

242
0:24:23.600 --> 0:24:27.960
you to both of those. And we do need more of that to come on and I expect it will come

243
0:24:27.960 --> 0:24:36.720
along. Okay. Second is we are not going to maintain out of tree forks of GCC and LLVM.

244
0:24:36.720 --> 0:24:41.920
It's a thankless task. It takes up a lot of time. The goal is to get upstream as vendor

245
0:24:41.920 --> 0:24:46.600
extensions. This is not a new thing. This has been part of GCC since before and part

246
0:24:46.600 --> 0:24:51.920
of LLVM. Okay. And when you have that triple that says what's your target is, that thing

247
0:24:51.920 --> 0:24:57.560
that in your standard compiler says RISC532 unknown hyphen L, hyphen GCC or whatever,

248
0:24:57.560 --> 0:25:02.560
that unknown is the vendor field. And we should be using that. So if you get these tool chains,

249
0:25:02.560 --> 0:25:10.200
you'll find they build as RISC532 hyphen core fee, the vendor hyphen L, hyphen GCC. Okay.

250
0:25:10.200 --> 0:25:14.200
And that's absolutely standard. It's been around forever. You can see in the GCC build,

251
0:25:14.200 --> 0:25:19.080
for example, there are variants of Spark and RISC5 for different manufacturers, for people

252
0:25:19.080 --> 0:25:26.640
who make radiation hardened versions for space and so forth. Okay. That all works fine. RISC5

253
0:25:26.640 --> 0:25:30.960
is designed for this. It's extensible. That's the whole point. There is a missing piece

254
0:25:30.960 --> 0:25:43.640
of the jigsaw, which is in RV32. In the ABI specification, you have relocations. Okay.

255
0:25:43.640 --> 0:25:49.440
There are 256 possible relocation values you can have. The top 64 of those are reserved

256
0:25:49.440 --> 0:25:55.000
for vendors. Okay. That's enough probably for any one vendor, but it's not enough for

257
0:25:55.000 --> 0:26:00.160
all vendors and it requires a centralized way of controlling. So we know how to solve

258
0:26:00.160 --> 0:26:04.720
this problem is that every time you need a relocation to tell you this bit of assembler

259
0:26:04.720 --> 0:26:09.840
when you link it needs adjusting the memory offset, you put down two relocations. One

260
0:26:09.840 --> 0:26:15.200
is to say which vendor you are. And that's just a new vendor. That's just a new relocation

261
0:26:15.200 --> 0:26:22.380
with 32 bits so we can have 4 billion vendors. Okay. And then the second one is say which

262
0:26:22.380 --> 0:26:27.240
of those 64 relocations. But it means the vendor relocations, there's a full set for

263
0:26:27.240 --> 0:26:34.320
every vendor. So we know the concept. One of my other team, Pietra Ferrara, who's sitting

264
0:26:34.320 --> 0:26:40.060
somewhere in the audience, is doing the proof of concept to demonstrate that works. Turns

265
0:26:40.060 --> 0:26:45.920
out the GNU linker is rather running at its limits with the complexity of RISC5. So it's

266
0:26:45.920 --> 0:26:50.200
not a completely trivial task. But we need that before we can fully upstream all this.

267
0:26:50.200 --> 0:26:56.560
The rest of it is all ready to go and it's all done to upstream standards. There's another

268
0:26:56.560 --> 0:27:02.240
thing we found is you noticed I showed you there's two versions of CV32E40P. So we thought

269
0:27:02.240 --> 0:27:06.560
and they've got different instruction encodings. We thought it would be good to actually have

270
0:27:06.560 --> 0:27:13.240
to be able to support both instruction encodings. And if you specify an architecture, you're

271
0:27:13.240 --> 0:27:26.240
allowed to specify my RV32IMAC underscore X ELW. And then you're allowed to say 1P2

272
0:27:26.240 --> 0:27:32.120
to say I want version 1.2. Okay. That's all part of the standard way you name an architecture.

273
0:27:32.120 --> 0:27:37.760
But it turns out it's not supported in the assembler, the GNU assembler. And furthermore,

274
0:27:37.760 --> 0:27:41.640
the GNU assembler is not written in such a way that it's ever going to be easy to support.

275
0:27:41.640 --> 0:27:45.800
And we gave up on that. And in fact, we're only going to support the latest version.

276
0:27:45.800 --> 0:27:51.920
And that probably ties into the way that RISC5 International is going. Okay. So those, if

277
0:27:51.920 --> 0:27:56.280
you like, are the key issues we're addressing. On the upstreaming, we're almost certainly

278
0:27:56.280 --> 0:27:59.960
going to upstream the ISA extensions that don't need vendor-specific relocations. And

279
0:27:59.960 --> 0:28:09.000
we'll put the others up once the vendor-specific relocations are ratified by the PSA ABI group.

280
0:28:09.000 --> 0:28:14.400
So there. Get involved. The projects are all on GitHub. The Open Hardware Group has its

281
0:28:14.400 --> 0:28:21.840
own repository. And if you don't like building from source, you can go to the Embercosm website.

282
0:28:21.840 --> 0:28:28.240
You can download pre-built tool chains for GCC and LLVM, for Core 5, for every operating

283
0:28:28.240 --> 0:28:37.240
system under the sun, all flavors of Linux, Mac, Windows, whatever. Okay. So get involved.

284
0:28:37.240 --> 0:28:42.920
Each of these projects has a project lead. Charlie Keeney leads the LLVM project. Chun

285
0:28:42.920 --> 0:28:48.280
Yul Liao from PLCT. Remember I said how you have different plan approved for the different

286
0:28:48.280 --> 0:28:54.440
variants. She's in charge of the specific project for CV30E40Pv2. Nan Li Jamnadis, who

287
0:28:54.440 --> 0:28:58.920
you heard from just now, leads the GNU tools project and is also actually responsible for

288
0:28:58.920 --> 0:29:06.640
the CV30E40Pv2. Wei Wei Li from PLCT runs the QMU project. And I'm responsible for the

289
0:29:06.640 --> 0:29:11.960
very later modeling because I'm a very later guy. Okay. And part of this is about bringing

290
0:29:11.960 --> 0:29:17.120
on a new generation. That we actually help a new generation on and train. So there is

291
0:29:17.120 --> 0:29:21.320
a half hour call. I'm sorry about the time if you live in America because most of the

292
0:29:21.320 --> 0:29:26.200
people involved are either in China or in Europe. So they're on Friday mornings. There's

293
0:29:26.200 --> 0:29:30.640
a half hour call on LLVM run by Charlie and there's a half hour call on GNU run by Nan

294
0:29:30.640 --> 0:29:35.840
Li. And the idea is that we'll review people collectively. We'll review their pull requests.

295
0:29:35.840 --> 0:29:40.160
And it's as much a training and learning thing as anything. So if you want to get into this

296
0:29:40.160 --> 0:29:45.800
stuff it's actually quite a good way to get a bit of free training. And that's it. So

297
0:29:45.800 --> 0:29:56.480
that's me. That's Ember Cosum. That's the Open Heartbreak Group. Thank you very much.

298
0:29:56.480 --> 0:30:00.480
So we've got a few minutes for questions. I'm happy to take any questions. Yes.

299
0:30:00.480 --> 0:30:07.480
So I'm working in a hardware research group at the university. We do a lot of deepouts.

300
0:30:07.480 --> 0:30:14.720
Previously we've always used the field work from ETH directly or ARABOLINIA. But sometimes

301
0:30:14.720 --> 0:30:19.280
it gives us some troubles. Because for example I'm doing compiler development right now and

302
0:30:19.280 --> 0:30:24.280
then last week I discovered that there was a bug in GDB and nobody is working on GDB

303
0:30:24.280 --> 0:30:28.960
anymore for this specific version that we think now. So I was just wondering do you

304
0:30:28.960 --> 0:30:36.320
maybe have like a time frame for these upstreaming of these extensions? And can we like if tomorrow

305
0:30:36.320 --> 0:30:41.360
we do a deepout should I tell my colleagues to do an open hardware core or should I tell

306
0:30:41.360 --> 0:30:46.040
them to do the stable or the pulp cores in general?

307
0:30:46.040 --> 0:30:50.680
OK. So the question for the recording, the question was about if you're working on the

308
0:30:50.680 --> 0:30:55.760
ETH pulp cores which are still there as fantastic research cores, should you use the old pulp

309
0:30:55.760 --> 0:31:02.760
compiler or should you use the core 5 compiler? So I think there's not a black and white answer

310
0:31:02.760 --> 0:31:08.920
on that. The pulp compiler is a fork of GCC from 2017. So it's quite a long way out. And

311
0:31:08.920 --> 0:31:13.320
that means it hasn't got the latest RISC-V stuff in there. Where we started on the GCC

312
0:31:13.320 --> 0:31:16.760
for this we actually looked at whether we could roll that forward. And it wasn't a sensible

313
0:31:16.760 --> 0:31:22.520
starting point. We started from scratch from the latest GCC.

314
0:31:22.520 --> 0:31:28.440
So in terms of which core you use, I believe ETH Zurich is slowly moving over to more using

315
0:31:28.440 --> 0:31:33.320
the core 5 unless you're particularly big because you might you may as well use these

316
0:31:33.320 --> 0:31:39.520
hardened cores. In that case the obvious thing is to use the core 5 tool chains. And although

317
0:31:39.520 --> 0:31:43.000
they're not yet upstream they're all in the public and there are pre-compiled ones you

318
0:31:43.000 --> 0:31:48.360
can pull up. There is a problem if you're using the old pulp cores because remember

319
0:31:48.360 --> 0:31:55.160
I talked about that version 1 and version 2. The old pulp things are so old they predate

320
0:31:55.160 --> 0:32:00.120
sort of finalization of the RISC-V encoding space. And actually the instruction encodings

321
0:32:00.120 --> 0:32:07.880
trample on future encoding spaces for RISC-V. So the version 2 fixes all that and all the

322
0:32:07.880 --> 0:32:13.280
version 2 instruction encodings are actually now RISC-V compliant. They sit in the custom

323
0:32:13.280 --> 0:32:19.320
0 1 2 3 blocks. What that means is you can't use this compiler because we haven't got the

324
0:32:19.320 --> 0:32:22.880
version 1 stuff because of the versioning issue I talked about to compile for the old

325
0:32:22.880 --> 0:32:28.800
pulp encodings. So that might be a factor you have to bear in mind there. But the old

326
0:32:28.800 --> 0:32:33.620
compiler, I've looked at the old compiler and it comes down to it's a research compiler.

327
0:32:33.620 --> 0:32:38.800
It wasn't designed to be tested and it's designed to prove concepts. And I think I've always

328
0:32:38.800 --> 0:32:44.280
raised its own. That's the job of universities, not to do the exhaustive testing we do. It's

329
0:32:44.280 --> 0:32:48.160
a different purpose. So it's a different type of compiler. But it does mean that occasionally

330
0:32:48.160 --> 0:32:51.920
you get weird behavior. Yeah, so I haven't really answered the question but I've given

331
0:32:51.920 --> 0:32:56.520
you the decision points to look at. I'd love you to use, by the way, I'd love you to use

332
0:32:56.520 --> 0:33:05.800
Core 5 because then you'd be tempted to join in and help here. Any more questions? Yes,

333
0:33:05.800 --> 0:33:19.600
right at the back. Absolutely, yes, I should have said yes. So we have a lot of projects

334
0:33:19.600 --> 0:33:23.960
under there and we bring in that road map I showed. If you look closer you see the dates

335
0:33:23.960 --> 0:33:27.480
were all wrong because some of these have moved out and we've got a load of problems

336
0:33:27.480 --> 0:33:31.240
like the Tristan project that we heard of earlier which are under the open hardware

337
0:33:31.240 --> 0:33:40.040
group. And those of you who use David and Sarah Harris' textbook for design, the WALL-E

338
0:33:40.040 --> 0:33:45.760
processor is being re-implemented as a RISC-V processor and that is being done under open

339
0:33:45.760 --> 0:33:50.080
hardware groups. So your next generation of textbook will have an open hardware group

340
0:33:50.080 --> 0:33:57.760
WALL-E processor in it. So there's more than just those cores I said there. And if you

341
0:33:57.760 --> 0:34:02.360
are working on a core and you think you might want to put it in this framework, come and

342
0:34:02.360 --> 0:34:05.240
talk to one of us. You can talk to Director Rick O'Connor or if you don't know him come

343
0:34:05.240 --> 0:34:12.200
to me and I will introduce you. Yes? I have a stupid question. So I work mostly on applications

344
0:34:12.200 --> 0:34:18.040
actually and in our development we usually, we're starting to converge like developers

345
0:34:18.040 --> 0:34:24.040
and testers are sort of converging into one team. Now you were saying that you actually

346
0:34:24.040 --> 0:34:28.800
have this bit where some people do like the cores and others do the verification. Would

347
0:34:28.800 --> 0:34:33.760
that also be possible to converge at some point? So this is, so the question is why do

348
0:34:33.760 --> 0:34:38.440
we have, I'll paraphrase as why do we have separate core task group and verification

349
0:34:38.440 --> 0:34:44.160
task group? They do work very closely together. This is specifically about hardware verification.

350
0:34:44.160 --> 0:34:48.600
It's not about software verification. Software, the argument is completely different and for

351
0:34:48.600 --> 0:34:54.640
the software the verification and development are closely integrated. I think because hardware

352
0:34:54.640 --> 0:34:59.520
verification is so formally structured there is actually a case to be made for keeping

353
0:34:59.520 --> 0:35:05.720
them separate and having the design team and the verification teams distinct. So it sort

354
0:35:05.720 --> 0:35:10.120
of makes sense. I'm really a software guy. I'm not an expert on hardware but it does

355
0:35:10.120 --> 0:35:15.720
sort of make sense. But the two teams work very closely together but it allows one team

356
0:35:15.720 --> 0:35:20.880
to focus on the UVM based test and verification flow and another to work on the actual implementation

357
0:35:20.880 --> 0:35:30.000
of the chips. Any more questions? Okay. Thank you all very much. That brings the RISC-V

358
0:35:30.000 --> 0:35:46.120
room to an end and I hope you enjoyed it. Thank you.

