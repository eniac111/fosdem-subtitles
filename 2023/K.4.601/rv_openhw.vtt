WEBVTT

00:00.000 --> 00:12.680
Thank you all very much. Thank you for coming along.

00:12.680 --> 00:20.800
My name's Jeremy Bennett. I'm chief executive of Ember Cosm. But Ember Cosm is an engineering

00:20.800 --> 00:26.200
heavy company. We only have one full-time non-engineer in the whole company and it's

00:26.200 --> 00:30.960
not me. So I actually am a working engineer as well as running the company. And we develop

00:30.960 --> 00:37.760
open source mostly compiler tool chains but we also have some open source AI and we also

00:37.760 --> 00:42.080
have some open source operating system stuff. And because most of what we do is pre-silicon

00:42.080 --> 00:48.200
we do an awful lot of open source silicon chip modelling. But I'm also here with another

00:48.200 --> 00:53.720
hat on which is that I am chair of the open hardware groups software task group. So I'm

00:53.720 --> 00:58.320
responsible for all the software developed for the open hardware group. And I'll talk

00:58.320 --> 01:05.200
a bit more about them in a bit. And this talk is part technical but it's partly about the

01:05.200 --> 01:12.680
actual practical side of how we go about developing complex software for an open architecture like

01:12.680 --> 01:27.320
RISC-V. So let's tell you a bit about the open hardware group. So it's a not-for-profit.

01:27.320 --> 01:33.800
It's a member-driven collaboration and it's a mixture of industry companies like mine,

01:33.800 --> 01:41.100
some big companies that you will recognise. NXP is a member for example. It has academics

01:41.100 --> 01:48.320
so quite a few universities are members and part of it. And it also has individual members.

01:48.320 --> 01:51.480
You can contribute as an individual and we have a number of, some of the work I'm going

01:51.480 --> 01:58.520
to talk about has been just done by people who are individual members. And the goal is

01:58.520 --> 02:03.040
high quality and that high quality is the key thing, open source hardware development.

02:03.040 --> 02:07.640
The sort of open source hardware that you can put in a commercial chip and be confident

02:07.640 --> 02:13.760
you can send it off to be fabricated. So it's collaborative and it's open. It's an open

02:13.760 --> 02:22.120
development model. So all these things are open to all. Now the organisation's the open

02:22.120 --> 02:29.280
hardware group but its cores are known as core 5 or core V. So we have a huge family

02:29.280 --> 02:33.840
of processors. I'll talk about them. Everything from the smallest RISC-5.32 to the biggest

02:33.840 --> 02:43.380
RISC-5.64 designs. And these are standard RISC-5 cores but with some customer ISA extensions

02:43.380 --> 02:48.600
for RISC-5. The chief executive is Rick O'Connor and those of you who have been around for

02:48.600 --> 02:53.480
a few years will remember Rick because he was the first chief executive of RISC-5 International

02:53.480 --> 02:59.200
and he's moved from the open source specification world to actually delivering real silicon

02:59.200 --> 03:09.960
IP. Let's look at the ancestry. So open hardware group grows out of an academic industry project

03:09.960 --> 03:17.760
called the parallel ultra low power processor project. Pulp. And that was a collaboration

03:17.760 --> 03:25.080
originally between ETH Zurich, the University of Bologna and ST Microelectronics. ST Microelectronics

03:25.080 --> 03:31.000
no longer active in it and it predates RISC-5. The first part of pulp was done with open

03:31.000 --> 03:38.080
risk but for the last many years it's been a RISC-5 project. And the idea is to get very,

03:38.080 --> 03:44.840
very low power multi-core systems. So that's where we come from. And the cores started

03:44.840 --> 03:51.320
off as these academic research cores. And the point about academic research cores is

03:51.320 --> 03:55.760
they are designed to push the forefront of knowledge forward. They're not designed to

03:55.760 --> 04:00.120
be exhaustively tested for manufacturing and use in a commercial deployment. That's not

04:00.120 --> 04:05.840
the purpose of a university. So the natural transition is that open hardware group takes

04:05.840 --> 04:14.720
that as an outstanding technical base and then takes it into a robust standard. We have

04:14.720 --> 04:21.720
loads and loads of members. So I've copied this off the website and it's the wrong format.

04:21.720 --> 04:25.760
I really want a wider and flatter one. But you'll probably see some logos there. You'll

04:25.760 --> 04:30.920
see Ember Cosm's logos there. The astute of you will notice that Ambers and Web Services

04:30.920 --> 04:35.000
appears to be both a member and a partner. I think they transitioned from a partner to

04:35.000 --> 04:41.800
a member and the slide wasn't properly updated. So we have lots and lots of members. I think

04:41.800 --> 04:51.760
it's up to about 70 now. And it might be worth just saying that when you become a member,

04:51.760 --> 04:56.640
yes you have to pay if you're corporate you have to pay a membership fee. But that's not

04:56.640 --> 05:03.440
the big thing. You can only become a member if you commit resource in terms of what you're

05:03.440 --> 05:08.640
going to contribute. And that dwarfs any membership fee. You cannot be a member unless you're

05:08.640 --> 05:15.960
going to do something. We don't have sleeping members. You've got to be active members.

05:15.960 --> 05:21.440
In terms of an organization, it's very lightweight. And this is one of the big contrasts with

05:21.440 --> 05:27.320
RISC-V International. At a technical level, we only have five committees. We have an overarching

05:27.320 --> 05:32.320
technical working group which has the overall responsibility for the engineering direction.

05:32.320 --> 05:39.880
And it has two, it has co-chairs, it has Jerome Cuerre of Amont from Thales and David Lynch.

05:39.880 --> 05:45.160
And I can't remember where David Lynch comes from actually, but two companies joined chairs.

05:45.160 --> 05:50.400
And that meets every month as the final arbiter of technical stuff. And then all the work

05:50.400 --> 05:55.560
of this organization is handled by just four committees. The CORS group headed up by I

05:55.560 --> 06:05.640
am Bink from Silicon Labs. And that is responsible for the tracking the development of CORS.

06:05.640 --> 06:11.320
The work is done by the member companies. But these are the groups that have oversight

06:11.320 --> 06:17.160
and make sure the quality criterion is maintained. There's a verification task group. And verification

06:17.160 --> 06:22.040
is actually separated from core development, even though the two are desperately tightly

06:22.040 --> 06:27.800
tied in. And that's led by Simon Davidman of Imperus. There's a hardware task group.

06:27.800 --> 06:32.880
And this is a slightly strange name perhaps. But the point of the hardware task group is,

06:32.880 --> 06:41.160
though this is fundamentally a group developing Silicon IP, we do have to have reference implementations.

06:41.160 --> 06:46.000
And the first reference implementation should be coming out later this year, which is the

06:46.000 --> 06:53.200
core five MCU. And that has one of the 32-bit cores in it. And lastly, the software task

06:53.200 --> 06:59.240
group which I lead assisted by Yun-Hai Shang from Alibaba Teahead. And that's responsible

06:59.240 --> 07:03.200
for all the software projects. And again, it's oversight. It's not doing the work because

07:03.200 --> 07:06.760
you have to do the work. If you want to be a member, you have to do the work. We do have

07:06.760 --> 07:13.600
a bit of a problem there because we have mostly hardware members and not enough software members.

07:13.600 --> 07:22.080
In terms of the roadmap, we've got a flagship application core. That's the CV-A6. And that's

07:22.080 --> 07:30.640
a 64-bit full-blown RISC-V core designed to run Linux. And that comes out of the top-end

07:30.640 --> 07:41.960
pulp core under development. There is a smaller 32-bit core, the CV-32A5, which is designed

07:41.960 --> 07:49.640
for, which is designed to try and do a small Linux system. Or of course, we've got the

07:49.640 --> 07:56.340
issue of getting Linux running on 32-bit anyway. You probably can only just make it out. Each

07:56.340 --> 08:03.220
of these projects has a target technology readiness level. Are people familiar with

08:03.220 --> 08:08.680
technology readiness levels? A little bit. Okay. So most of these are aimed at technology

08:08.680 --> 08:16.160
readiness level, which is proven in the environment. CV-A5 is a bit different. It's aimed as TRL4,

08:16.160 --> 08:21.040
which is proven in the lab. And we've got other projects which are outside different

08:21.040 --> 08:28.040
levels. But mostly we're aiming at TRL5. Okay. The flagship, the first project was the CV-32E40P,

08:28.040 --> 08:35.800
which is a microcontroller class 32-bit RISC-V implementation. And the first version of that

08:35.800 --> 08:41.560
is complete. The second version is under development. And actually the work Nandni was talking about

08:41.560 --> 08:47.720
with built-ins is primarily focused at CV-32E40Pv2. You will see sitting there, there's something

08:47.720 --> 08:54.280
called the CV-32E41P. And that's a bit unusual because it's actually only going to TRL3,

08:54.280 --> 09:00.680
which is proof of concept. And it's being developed by Huawei under this group in order

09:00.680 --> 09:10.840
to test out the ZC-Star extension, the new compressed extension, and the ZF-INX, where

09:10.840 --> 09:15.520
you have a shared register bank for floating point and integer. So it's only a proof of

09:15.520 --> 09:20.320
concept chip to verify that those work. And then we have a couple of more forward-looking

09:20.320 --> 09:28.120
ones. CV-32E40S is a version of the original CV-32E40P aimed at security applications.

09:28.120 --> 09:33.320
And the really exciting one is the CV-32E40X. That's a bit further out because the X is

09:33.320 --> 09:38.000
a generic extension interface at the hardware level. So this is designed so you can take

09:38.000 --> 09:43.520
a call. It's really easy to add in a wide range of extensions. And indeed, to the extent

09:43.520 --> 09:48.720
you can do the floating point extension through the CV-32E40X. So that's the roadmap we're

09:48.720 --> 09:56.740
sitting on. So what about the software projects? Well, I'm going to focus on the tool chains.

09:56.740 --> 10:01.280
So the LLVM tool chain, the GNU tool chain. And because we haven't yet got silicon, I'm

10:01.280 --> 10:07.320
going to focus on a couple of software projects, QEMU and the Verilator model. We have other

10:07.320 --> 10:10.680
projects. So I'm responsible for eight projects in tool. There's the SDK, the software development

10:10.680 --> 10:15.440
kit that's actually joined with the hardware group. The hardware abstraction layer so that

10:15.440 --> 10:19.480
we can actually make our software more easily portable as we do more and more of these chips.

10:19.480 --> 10:25.200
Free RTOS with micro-controlling. If you're going to go for an RTOS, the obvious one to

10:25.200 --> 10:29.920
start with is Free RTOS. And Linux, which is really aimed at the CVA6. So we've got

10:29.920 --> 10:36.640
eight projects under our belt. We have a rigorous engineering process. So those of you who work

10:36.640 --> 10:47.280
for big engineering companies are familiar with gate-based processes. So all of the way

10:47.280 --> 10:53.880
we manage these projects is through a gate-based process. You have a project concept gate.

10:53.880 --> 10:58.360
It's where you propose a project. You want to work on this project. You explain what

10:58.360 --> 11:04.440
it is and why we need to do it. And the project will only go ahead if it's voted for by enough

11:04.440 --> 11:08.160
members. And members can't just vote and say, hey, that's a good idea. I'll say yes for

11:08.160 --> 11:12.920
everything. You vote for it. You're going to commit resource to it. Critical thing is

11:12.920 --> 11:17.640
this is a doing organization. So, OK, you're then going to explore it. And then we got

11:17.640 --> 11:24.560
to a project launch gate. And that stage, not only do you know what and why, but now

11:24.560 --> 11:30.560
you know how you're going to do it. What do I need to do to get this? And then the big

11:30.560 --> 11:36.080
one, the last one, is plan approved. And plan approved means you've resourced it. So you

11:36.080 --> 11:41.680
know when you're going to deliver it. And that's quite a big hurdle for some projects.

11:41.680 --> 11:45.160
And then away the project work goes. I mean, this is a bit simplified. We all know work

11:45.160 --> 11:50.320
starts a bit in advance. But the way the project goes, and eventually you get to project freeze,

11:50.320 --> 11:56.560
OK, where it's all done. Now, this is brilliant for hardware, OK? It's a very hardware-centric

11:56.560 --> 12:02.120
view of the world because a freeze means something. It's when your chip's gone off to be fabbed,

12:02.120 --> 12:08.280
OK? Doesn't work quite so well for software. So we've modified it for software, OK? And

12:08.280 --> 12:12.720
the first two stages are quite generic because typically we're working with a big block of

12:12.720 --> 12:18.280
common software. We're not writing a compiler from scratch. We're taking the GNU infrastructure,

12:18.280 --> 12:23.760
GCC, binutils, and all that, all millions of lines of it. And that's mostly not changed,

12:23.760 --> 12:29.120
and we're changing a bit. Now, some of that is quite the why and the how. The what and

12:29.120 --> 12:34.880
the why and the how is quite generic. It applies to probably all core five chips, certainly

12:34.880 --> 12:40.760
maybe to all the 32-bit ones. And then for each specific chip, we have multiple plan

12:40.760 --> 12:44.560
approved, which is where we work out when we're going to deliver it for CV30, E40P,

12:44.560 --> 12:51.960
V1, for V2, for S, for X, and so forth. And so we have a whole set. But it's still the

12:51.960 --> 12:58.680
same process of you need to know it's properly resourced and so forth, OK? So we'll see that

12:58.680 --> 13:05.160
a little bit in action. But that whole engineering focus pervades everything, OK? So let's put

13:05.160 --> 13:10.400
the content. Once the compiler toolchain, it's not just the compiler, it's the assembler.

13:10.400 --> 13:15.920
It's the low-level utilities. It's the debugger. It's the libraries. It's the emulation libraries.

13:15.920 --> 13:21.440
It's the standard C libraries, the C++ libraries. And in the ultimate way, if you look at GCC,

13:21.440 --> 13:27.280
this is GCC. It's many, many languages. It's ADO. It's the C, C++ family. It's FORTRAN.

13:27.280 --> 13:31.600
It's Java. It's GO. These days, it's Rust. It's modular to... And of course, we've got

13:31.600 --> 13:36.280
things that sit at the high level like OpenMP and OpenACC. That's a huge lot of stuff. We

13:36.280 --> 13:41.080
have a hasten to say we're a long way off having all of that for the core five. But

13:41.080 --> 13:45.560
it's a lot of code. It's about... It's north of 12 million lines of code and it's a year

13:45.560 --> 13:50.240
or so since I last measured those figures. So it's big. And we're trying to get that

13:50.240 --> 13:56.560
all seamlessly worked through to work on core five. Now, we're not doing it from scratch.

13:56.560 --> 14:01.320
Of course, we're starting from risk five and then we're adding stuff to it. And the humans

14:01.320 --> 14:06.160
say LLVM has the same components but they've got different names and a different set of

14:06.160 --> 14:16.480
languages. So let's look at the ISA extensions for core five. And the core five ISA extensions,

14:16.480 --> 14:26.880
there are nine we're concerned with. Eight of those come from the pulp project. So extra

14:26.880 --> 14:35.440
addressing modes, post incrementing, load and store. Hardware loops. More ALU operations.

14:35.440 --> 14:41.680
And special case branching operations. We've got MAC instructions. We've heard about the

14:41.680 --> 14:47.360
event load. That's a multi-core feature. And then we've got the pulp bit manipulation and

14:47.360 --> 14:52.280
the pulp SIMD. Those are not standard bit manipulation and SIMD. Those are different

14:52.280 --> 14:56.320
ones. But there's been years of development. The reason they're different is they predate

14:56.320 --> 15:05.080
a risk five bit manip and they predate risk five SIMD. And you can see the pulp SIMD is

15:05.080 --> 15:11.800
big. And the reason that Nandni knows so much about built ins is she's done the built ins

15:11.800 --> 15:20.160
to support those 220 SIMD instructions. So she's nearly finished. And then I think she's

15:20.160 --> 15:26.920
going away for a long holiday where she never looks at another built in again. And we've

15:26.920 --> 15:33.680
got ZC star. So we have the first GCC implementation supporting ZC star. And of course these are

15:33.680 --> 15:38.320
standard risk five compilers. You can still use them for risk five. And the hot news is

15:38.320 --> 15:44.360
that core five GCC has a pull request to put ZC star 1.0.1 which is the freeze candidate

15:44.360 --> 15:50.720
support. Once that's been reviewed that will go in there. So we've got a lot. The tool

15:50.720 --> 16:07.360
chain work is all about supporting these pulp extensions. In terms of the built ins you've

16:07.360 --> 16:12.960
heard all about them. But it's a lot of functions. It's not just Nandni. Nandni has a team working

16:12.960 --> 16:21.000
on this. And we've got this naming convention. So we get from naming convention that built

16:21.000 --> 16:27.720
ins for risk five are built in underscore risk five underscore vendor underscore name.

16:27.720 --> 16:33.040
We've got so many we're actually splitting up into ISA extension and name. There is a

16:33.040 --> 16:39.520
rule though if you're you can't just have if what you're doing is a built in is it corresponds

16:39.520 --> 16:44.920
to a standard built in then you must use the standard name. So for example we have in our

16:44.920 --> 16:52.560
arithmetic we have abs so we've got built in abs which is a standard GCC built in.

16:52.560 --> 16:59.640
The built ins actually they have the same name for 32 bit or 64 bit. That is not overloading

16:59.640 --> 17:04.040
in the C plus plus sense because either you're running for a 32 bit target or you're compiling

17:04.040 --> 17:09.440
for a 64 bit target. You have one or the other there. There's not an overload. It's also

17:09.440 --> 17:12.960
the case is built ins are not just another way of doing inline assembler. There's not

17:12.960 --> 17:19.000
a one to one mapping. So for example for the SIMD add scaler there are actually two different

17:19.000 --> 17:24.520
ways of adding scalers in the risk in the core five SIMD. One where the scalers in a

17:24.520 --> 17:28.760
register the other where it's a small integer and you can actually put it is that there's

17:28.760 --> 17:32.480
actually an add immediate instruction. We don't have two built ins. There's a single built

17:32.480 --> 17:39.560
in. And if the second argument is a small constant that fits there it will generate

17:39.560 --> 17:43.680
the immediate version instruction. Otherwise it will load it into a register. And that's

17:43.680 --> 17:47.360
part two of Nandy's talk for the future because that's quite a lot harder to do in a built

17:47.360 --> 17:56.240
in. OK. And there is a specification. It's big. If you put it into if you generate PDF

17:56.240 --> 18:02.440
it's 57 pages long. OK. So. And that's one of the things is built ins built ins are not

18:02.440 --> 18:06.240
quite as easy as you think. There are things you can get wrong there. And you do genuinely

18:06.240 --> 18:13.400
have to think and review it's under review at the moment. That's not finalised. OK. So

18:13.400 --> 18:20.240
testing now if we're going to do full testing of a tool chain. OK. We need a target which

18:20.240 --> 18:23.640
has all these ice extensions. They're not standard risk five. I can't just take standard

18:23.640 --> 18:29.040
risk five QEMU or whatever. OK. You can do some testing. So the standard can you assemble

18:29.040 --> 18:33.080
a test for example don't need an executable target. They are pattern matching. Have you

18:33.080 --> 18:38.040
generated something that looks right. OK. You can do the same with built ins. You saw

18:38.040 --> 18:42.040
it from Nandy's compile time only thing where you look and do a scan assembler to see has

18:42.040 --> 18:48.520
that built in generated just one of the instruction I want. OK. But more generically you need

18:48.520 --> 18:55.200
to be able to execute your tests. OK. So we have two things. One is we have QEMU for core

18:55.200 --> 19:02.040
five. That's a project being led by Wei Wei Li at the programming languages and compiler

19:02.040 --> 19:09.720
technology team at Chinese Academy of Sciences in Beijing. OK. That's a work in progress.

19:09.720 --> 19:17.200
We're expecting that to become available later in 2023. And secondly we're using very later

19:17.200 --> 19:21.480
models. How many people here are familiar with very later. Han show. OK. Most of you.

19:21.480 --> 19:28.160
OK. For those who don't it's a tool that takes a hardware design in very long or system very

19:28.160 --> 19:33.440
long and generates a C plus plus model from it. A cycle accuracy plus plus model and very

19:33.440 --> 19:38.160
later models are really useful because either easy to integrate to toolchain testing and

19:38.160 --> 19:42.800
be they are what's called implementation models. Most models come from the specification of

19:42.800 --> 19:47.120
chip. These are the actual implementation. So we know what your testing is what is physically

19:47.120 --> 19:51.280
going on the chip. And when you have a model it's not just enough to have a model. You've

19:51.280 --> 19:55.000
got to be able to hook to it. So typically you've got to run wrap around some form of

19:55.000 --> 20:00.480
debug service you can connect GDP or LDB. And that's the work in progress. That's due

20:00.480 --> 20:06.240
to be completed in the next few weeks. And then you'll be able to actually run on the

20:06.240 --> 20:17.080
actual model of the actual hardware. Testing policy. LLVM project uses the LLVM into

20:17.080 --> 20:24.800
integration tester. That that is a set of several tens of thousands of tests from source

20:24.800 --> 20:32.600
code down to LLVM IR. Very comprehensive. And we use that. But it isn't a set of execution

20:32.600 --> 20:38.360
tests. Now LLVM does have an executable test suite but it is a set of applications to run

20:38.360 --> 20:42.120
on our own under operating system. And for a small microcontroller they're not suitable.

20:42.120 --> 20:45.680
They need an operating system there. So we can't use the LLVM test suite. So instead

20:45.680 --> 20:51.120
we use a subset of the GNU regression tests to test LLVM compilers. And that's widespread.

20:51.120 --> 20:55.480
That's not something we've invented. That's been done for years. It's only a subset because

20:55.480 --> 20:59.320
there is no point in running the GNU tests of the internal representations inside the

20:59.320 --> 21:03.800
GNU compiler. But things like the torture tests are absolutely fine whether they're

21:03.800 --> 21:09.920
on LLVM or GC. They're compiler agnostic. The GNU tools just uses the GNU regression

21:09.920 --> 21:17.320
tests. Something that we're very hot on is exhaustive testing. OK. It's not just that

21:17.320 --> 21:22.120
oh I tried one thing and it seemed to work. It's a let's make sure we've not missed things.

21:22.120 --> 21:28.720
So starting at the assembler we have both positive and negative testing. By positive

21:28.720 --> 21:34.460
testing we mean testing the compiler does what you want. By negative testing I mean

21:34.460 --> 21:41.660
testing it doesn't do things when it shouldn't. So for example if we're looking at an instruction

21:41.660 --> 21:48.760
that takes a six bit signed constant we will test it with values of minus 33, too small

21:48.760 --> 21:54.200
for a negative number. Minus 32 the biggest negative six bit number. Zero because you

21:54.200 --> 21:58.320
should always test zero because it's a special case. Probably minus seven and plus five and

21:58.320 --> 22:02.840
then we'll test 31 and 32 which is too big. And we will check those bounds. And actually

22:02.840 --> 22:07.040
we added those tests for ZC star and found a whole load of bugs in the ZC star spec as

22:07.040 --> 22:15.000
a consequence. So we do that sort of thing and we also test things like we test the extensions.

22:15.000 --> 22:21.680
I've got the ELW instruction. I test that the ELW instruction is handled by the assembler

22:21.680 --> 22:29.520
when I specify XELW. I also test that it doesn't get recognized when I don't specify XELW.

22:29.520 --> 22:32.480
So that's really important. And one thing I would observe is and I've seen this for

22:32.480 --> 22:38.360
a long time is RISC-V is incredibly weak on its assembly level testing. There are about

22:38.360 --> 22:45.680
ten times as many tests for ARM and x86 as there are for RISC-V. So it's important to

22:45.680 --> 22:54.560
do that. And so we do core five specific, core five specific GNU LD testing because

22:54.560 --> 23:02.120
we're adding some relocations. Do they work? At the moment we've got compilation only tests

23:02.120 --> 23:07.840
of built ins using scan for assembler instructions. But when we've got those models running, the

23:07.840 --> 23:13.240
QEMU and the Verilator model, we'll be adding execution tests. So not only do I generate

23:13.240 --> 23:17.320
the right assembly instruction but it does what I expect. Not only do I generate the

23:17.320 --> 23:24.760
built in but it does what I expect. So we'll be adding those in as well. And that, all

23:24.760 --> 23:30.000
that testing ties into the difference of this is a commercial grade chip, commercial grade

23:30.000 --> 23:36.600
core, sorry, and its associated tool chains. So resourcing. Resourcing is an issue because

23:36.600 --> 23:41.120
software these days on a chip you'll spend twice as much on the software as you do on

23:41.120 --> 23:50.280
the hardware. But open hardware group is inherently mostly hardware company members. We've got

23:50.280 --> 23:54.560
plenty of software members but we're still in a minority. So it is a challenge to get

23:54.560 --> 23:59.120
enough resourcing as part of my contribution and because it makes a lot of contribution

23:59.120 --> 24:05.520
as part of our membership, the PLCT lab in China, they make a big contribution. So that's

24:05.520 --> 24:10.040
coming there. And we actually double up, we use them very much as part of our graduate

24:10.040 --> 24:14.440
training program as well. So part of the graduate allows us to train a new generation of compiler

24:14.440 --> 24:19.480
engineers. But we're also seeing companies like Silicon Labs and Dolphin Design call

24:19.480 --> 24:23.600
out to them because they help to fund those software companies to do the work. So thank

24:23.600 --> 24:27.960
you to both of those. And we do need more of that to come on and I expect it will come

24:27.960 --> 24:36.720
along. Okay. Second is we are not going to maintain out of tree forks of GCC and LLVM.

24:36.720 --> 24:41.920
It's a thankless task. It takes up a lot of time. The goal is to get upstream as vendor

24:41.920 --> 24:46.600
extensions. This is not a new thing. This has been part of GCC since before and part

24:46.600 --> 24:51.920
of LLVM. Okay. And when you have that triple that says what's your target is, that thing

24:51.920 --> 24:57.560
that in your standard compiler says RISC532 unknown hyphen L, hyphen GCC or whatever,

24:57.560 --> 25:02.560
that unknown is the vendor field. And we should be using that. So if you get these tool chains,

25:02.560 --> 25:10.200
you'll find they build as RISC532 hyphen core fee, the vendor hyphen L, hyphen GCC. Okay.

25:10.200 --> 25:14.200
And that's absolutely standard. It's been around forever. You can see in the GCC build,

25:14.200 --> 25:19.080
for example, there are variants of Spark and RISC5 for different manufacturers, for people

25:19.080 --> 25:26.640
who make radiation hardened versions for space and so forth. Okay. That all works fine. RISC5

25:26.640 --> 25:30.960
is designed for this. It's extensible. That's the whole point. There is a missing piece

25:30.960 --> 25:43.640
of the jigsaw, which is in RV32. In the ABI specification, you have relocations. Okay.

25:43.640 --> 25:49.440
There are 256 possible relocation values you can have. The top 64 of those are reserved

25:49.440 --> 25:55.000
for vendors. Okay. That's enough probably for any one vendor, but it's not enough for

25:55.000 --> 26:00.160
all vendors and it requires a centralized way of controlling. So we know how to solve

26:00.160 --> 26:04.720
this problem is that every time you need a relocation to tell you this bit of assembler

26:04.720 --> 26:09.840
when you link it needs adjusting the memory offset, you put down two relocations. One

26:09.840 --> 26:15.200
is to say which vendor you are. And that's just a new vendor. That's just a new relocation

26:15.200 --> 26:22.380
with 32 bits so we can have 4 billion vendors. Okay. And then the second one is say which

26:22.380 --> 26:27.240
of those 64 relocations. But it means the vendor relocations, there's a full set for

26:27.240 --> 26:34.320
every vendor. So we know the concept. One of my other team, Pietra Ferrara, who's sitting

26:34.320 --> 26:40.060
somewhere in the audience, is doing the proof of concept to demonstrate that works. Turns

26:40.060 --> 26:45.920
out the GNU linker is rather running at its limits with the complexity of RISC5. So it's

26:45.920 --> 26:50.200
not a completely trivial task. But we need that before we can fully upstream all this.

26:50.200 --> 26:56.560
The rest of it is all ready to go and it's all done to upstream standards. There's another

26:56.560 --> 27:02.240
thing we found is you noticed I showed you there's two versions of CV32E40P. So we thought

27:02.240 --> 27:06.560
and they've got different instruction encodings. We thought it would be good to actually have

27:06.560 --> 27:13.240
to be able to support both instruction encodings. And if you specify an architecture, you're

27:13.240 --> 27:26.240
allowed to specify my RV32IMAC underscore X ELW. And then you're allowed to say 1P2

27:26.240 --> 27:32.120
to say I want version 1.2. Okay. That's all part of the standard way you name an architecture.

27:32.120 --> 27:37.760
But it turns out it's not supported in the assembler, the GNU assembler. And furthermore,

27:37.760 --> 27:41.640
the GNU assembler is not written in such a way that it's ever going to be easy to support.

27:41.640 --> 27:45.800
And we gave up on that. And in fact, we're only going to support the latest version.

27:45.800 --> 27:51.920
And that probably ties into the way that RISC5 International is going. Okay. So those, if

27:51.920 --> 27:56.280
you like, are the key issues we're addressing. On the upstreaming, we're almost certainly

27:56.280 --> 27:59.960
going to upstream the ISA extensions that don't need vendor-specific relocations. And

27:59.960 --> 28:09.000
we'll put the others up once the vendor-specific relocations are ratified by the PSA ABI group.

28:09.000 --> 28:14.400
So there. Get involved. The projects are all on GitHub. The Open Hardware Group has its

28:14.400 --> 28:21.840
own repository. And if you don't like building from source, you can go to the Embercosm website.

28:21.840 --> 28:28.240
You can download pre-built tool chains for GCC and LLVM, for Core 5, for every operating

28:28.240 --> 28:37.240
system under the sun, all flavors of Linux, Mac, Windows, whatever. Okay. So get involved.

28:37.240 --> 28:42.920
Each of these projects has a project lead. Charlie Keeney leads the LLVM project. Chun

28:42.920 --> 28:48.280
Yul Liao from PLCT. Remember I said how you have different plan approved for the different

28:48.280 --> 28:54.440
variants. She's in charge of the specific project for CV30E40Pv2. Nan Li Jamnadis, who

28:54.440 --> 28:58.920
you heard from just now, leads the GNU tools project and is also actually responsible for

28:58.920 --> 29:06.640
the CV30E40Pv2. Wei Wei Li from PLCT runs the QMU project. And I'm responsible for the

29:06.640 --> 29:11.960
very later modeling because I'm a very later guy. Okay. And part of this is about bringing

29:11.960 --> 29:17.120
on a new generation. That we actually help a new generation on and train. So there is

29:17.120 --> 29:21.320
a half hour call. I'm sorry about the time if you live in America because most of the

29:21.320 --> 29:26.200
people involved are either in China or in Europe. So they're on Friday mornings. There's

29:26.200 --> 29:30.640
a half hour call on LLVM run by Charlie and there's a half hour call on GNU run by Nan

29:30.640 --> 29:35.840
Li. And the idea is that we'll review people collectively. We'll review their pull requests.

29:35.840 --> 29:40.160
And it's as much a training and learning thing as anything. So if you want to get into this

29:40.160 --> 29:45.800
stuff it's actually quite a good way to get a bit of free training. And that's it. So

29:45.800 --> 29:56.480
that's me. That's Ember Cosum. That's the Open Heartbreak Group. Thank you very much.

29:56.480 --> 30:00.480
So we've got a few minutes for questions. I'm happy to take any questions. Yes.

30:00.480 --> 30:07.480
So I'm working in a hardware research group at the university. We do a lot of deepouts.

30:07.480 --> 30:14.720
Previously we've always used the field work from ETH directly or ARABOLINIA. But sometimes

30:14.720 --> 30:19.280
it gives us some troubles. Because for example I'm doing compiler development right now and

30:19.280 --> 30:24.280
then last week I discovered that there was a bug in GDB and nobody is working on GDB

30:24.280 --> 30:28.960
anymore for this specific version that we think now. So I was just wondering do you

30:28.960 --> 30:36.320
maybe have like a time frame for these upstreaming of these extensions? And can we like if tomorrow

30:36.320 --> 30:41.360
we do a deepout should I tell my colleagues to do an open hardware core or should I tell

30:41.360 --> 30:46.040
them to do the stable or the pulp cores in general?

30:46.040 --> 30:50.680
OK. So the question for the recording, the question was about if you're working on the

30:50.680 --> 30:55.760
ETH pulp cores which are still there as fantastic research cores, should you use the old pulp

30:55.760 --> 31:02.760
compiler or should you use the core 5 compiler? So I think there's not a black and white answer

31:02.760 --> 31:08.920
on that. The pulp compiler is a fork of GCC from 2017. So it's quite a long way out. And

31:08.920 --> 31:13.320
that means it hasn't got the latest RISC-V stuff in there. Where we started on the GCC

31:13.320 --> 31:16.760
for this we actually looked at whether we could roll that forward. And it wasn't a sensible

31:16.760 --> 31:22.520
starting point. We started from scratch from the latest GCC.

31:22.520 --> 31:28.440
So in terms of which core you use, I believe ETH Zurich is slowly moving over to more using

31:28.440 --> 31:33.320
the core 5 unless you're particularly big because you might you may as well use these

31:33.320 --> 31:39.520
hardened cores. In that case the obvious thing is to use the core 5 tool chains. And although

31:39.520 --> 31:43.000
they're not yet upstream they're all in the public and there are pre-compiled ones you

31:43.000 --> 31:48.360
can pull up. There is a problem if you're using the old pulp cores because remember

31:48.360 --> 31:55.160
I talked about that version 1 and version 2. The old pulp things are so old they predate

31:55.160 --> 32:00.120
sort of finalization of the RISC-V encoding space. And actually the instruction encodings

32:00.120 --> 32:07.880
trample on future encoding spaces for RISC-V. So the version 2 fixes all that and all the

32:07.880 --> 32:13.280
version 2 instruction encodings are actually now RISC-V compliant. They sit in the custom

32:13.280 --> 32:19.320
0 1 2 3 blocks. What that means is you can't use this compiler because we haven't got the

32:19.320 --> 32:22.880
version 1 stuff because of the versioning issue I talked about to compile for the old

32:22.880 --> 32:28.800
pulp encodings. So that might be a factor you have to bear in mind there. But the old

32:28.800 --> 32:33.620
compiler, I've looked at the old compiler and it comes down to it's a research compiler.

32:33.620 --> 32:38.800
It wasn't designed to be tested and it's designed to prove concepts. And I think I've always

32:38.800 --> 32:44.280
raised its own. That's the job of universities, not to do the exhaustive testing we do. It's

32:44.280 --> 32:48.160
a different purpose. So it's a different type of compiler. But it does mean that occasionally

32:48.160 --> 32:51.920
you get weird behavior. Yeah, so I haven't really answered the question but I've given

32:51.920 --> 32:56.520
you the decision points to look at. I'd love you to use, by the way, I'd love you to use

32:56.520 --> 33:05.800
Core 5 because then you'd be tempted to join in and help here. Any more questions? Yes,

33:05.800 --> 33:19.600
right at the back. Absolutely, yes, I should have said yes. So we have a lot of projects

33:19.600 --> 33:23.960
under there and we bring in that road map I showed. If you look closer you see the dates

33:23.960 --> 33:27.480
were all wrong because some of these have moved out and we've got a load of problems

33:27.480 --> 33:31.240
like the Tristan project that we heard of earlier which are under the open hardware

33:31.240 --> 33:40.040
group. And those of you who use David and Sarah Harris' textbook for design, the WALL-E

33:40.040 --> 33:45.760
processor is being re-implemented as a RISC-V processor and that is being done under open

33:45.760 --> 33:50.080
hardware groups. So your next generation of textbook will have an open hardware group

33:50.080 --> 33:57.760
WALL-E processor in it. So there's more than just those cores I said there. And if you

33:57.760 --> 34:02.360
are working on a core and you think you might want to put it in this framework, come and

34:02.360 --> 34:05.240
talk to one of us. You can talk to Director Rick O'Connor or if you don't know him come

34:05.240 --> 34:12.200
to me and I will introduce you. Yes? I have a stupid question. So I work mostly on applications

34:12.200 --> 34:18.040
actually and in our development we usually, we're starting to converge like developers

34:18.040 --> 34:24.040
and testers are sort of converging into one team. Now you were saying that you actually

34:24.040 --> 34:28.800
have this bit where some people do like the cores and others do the verification. Would

34:28.800 --> 34:33.760
that also be possible to converge at some point? So this is, so the question is why do

34:33.760 --> 34:38.440
we have, I'll paraphrase as why do we have separate core task group and verification

34:38.440 --> 34:44.160
task group? They do work very closely together. This is specifically about hardware verification.

34:44.160 --> 34:48.600
It's not about software verification. Software, the argument is completely different and for

34:48.600 --> 34:54.640
the software the verification and development are closely integrated. I think because hardware

34:54.640 --> 34:59.520
verification is so formally structured there is actually a case to be made for keeping

34:59.520 --> 35:05.720
them separate and having the design team and the verification teams distinct. So it sort

35:05.720 --> 35:10.120
of makes sense. I'm really a software guy. I'm not an expert on hardware but it does

35:10.120 --> 35:15.720
sort of make sense. But the two teams work very closely together but it allows one team

35:15.720 --> 35:20.880
to focus on the UVM based test and verification flow and another to work on the actual implementation

35:20.880 --> 35:30.000
of the chips. Any more questions? Okay. Thank you all very much. That brings the RISC-V

35:30.000 --> 35:46.120
room to an end and I hope you enjoyed it. Thank you.
