WEBVTT

00:00.000 --> 00:13.080
Welcome, everyone. It's probably the first time in the last three years I actually see

00:13.080 --> 00:22.760
this big auditorium full of people willing to hear something I'm going to rumble about.

00:22.760 --> 00:31.600
I actually wrote a bit of script for this, but I'm bad at the memories in those scripts,

00:31.600 --> 00:44.760
so it will be remembering as I go, rather than seeing something that I wrote about.

00:44.760 --> 00:53.080
For the past 10 years, a team I'm a member of, we are working on a bunch of stuff related

00:53.080 --> 01:03.440
to something that many people think is uninspiring, because it's all about the enterprise use

01:03.440 --> 01:11.240
of Linux, which is just a done deal. Every enterprise uses Linux nowadays.

01:11.240 --> 01:20.640
We kind of look into some of the areas and choose what to work on, because there's always

01:20.640 --> 01:32.160
stuff unfinished and needed to be worked on. Suddenly, there's obviously 10, 15 years ago,

01:32.160 --> 01:39.320
some companies from the west coast, they started to look into, hey, this shiny thing called

01:39.320 --> 01:47.640
the internet and this shiny way of having your account somewhere in the social network

01:47.640 --> 01:55.080
drive your login into your machine, and so on. Here we are, 10, 15 years after talking

01:55.080 --> 02:01.840
about doing similar thing for Linux in enterprise environment and at home.

02:01.840 --> 02:10.560
I will start with a bit of introduction. I'm working at Red Hat for almost 12 years now.

02:10.560 --> 02:21.920
I'm focusing on the identity management, so basically really running accounts in the Linux

02:21.920 --> 02:31.640
systems. Centralized identity management is what we do. Mostly working on these days free

02:31.640 --> 02:42.920
IPE, and I started with Samba 20 years ago, SSSD on the client side, MIT Kerberos for

02:42.920 --> 02:49.120
the authentication and so on. There's a lot of things blended together, and it's really

02:49.120 --> 02:55.400
not a single person or a single project. It's an amalgamation of a lot of activities of

02:55.400 --> 03:06.920
a lot of people around the world. This talk is a kind of a split between past

03:06.920 --> 03:15.080
contemporary things and what we see in future, or what we see now will be in future. Hopefully

03:15.080 --> 03:26.520
in February of 39, if we get this through in up streams first and then manage to collect

03:26.520 --> 03:34.040
this all together in the distributions, which will be a point to talk about a bit later.

03:34.040 --> 03:43.080
In the past, we've been always getting all this stuff with a bunch of assumptions. One

03:43.080 --> 03:53.480
of the really unspoken assumptions is that when you log in into your system, be it Linux

03:53.480 --> 04:01.400
system or Windows system or so on, you don't only want to use that particular system. Typically

04:01.400 --> 04:08.720
you want to go beyond that system. You want to go, well in these days you go onto web

04:08.720 --> 04:16.280
typically and use all these web applications. But before that in office environment, you

04:16.280 --> 04:26.520
were reaching for your nice non-working printer, or you were reaching for something to fetch

04:26.520 --> 04:38.340
files from or get your home drive and all the other stuff, or play games together with

04:38.340 --> 04:47.120
your colleagues on the local network and so on. In many of those cases, you needed to

04:47.120 --> 04:55.520
get through the authentication information that you provided or got at the log in time.

04:55.520 --> 05:02.520
You needed to get this state of authentication translated or correlated into the network

05:02.520 --> 05:11.760
onto the network services. A typical approach that we see these days is that you unlock

05:11.760 --> 05:21.720
your let's say, NOM session. Then there is a secrets manager, which gets your secrets

05:21.720 --> 05:30.040
store unlocked using the password that you provided as a part of login. Then the passwords

05:30.040 --> 05:36.880
from this secret store used transparently by the other applications through some common

05:36.880 --> 05:45.480
APIs like browsers have their own stuff, of course they have their own password managers

05:45.480 --> 05:52.280
and those might be even shareable across multiple devices and so on. But it still doesn't solve

05:52.280 --> 06:00.680
the real problem, which is when you log in into the system and you go to specific network

06:00.680 --> 06:07.760
phase and applications, you need to do this transition or transfer the authentication

06:07.760 --> 06:17.920
state between maybe incompatible or not well connected protocols. It is bridging that we

06:17.920 --> 06:28.680
don't really have in place and in many applications we kind of derive it based on certain things.

06:28.680 --> 06:35.400
In reality, it's much easier in the enterprise world because for almost 40 years we've been

06:35.400 --> 06:44.680
dealing with something that is called Kerberos in different ways of it, which is effectively

06:44.680 --> 06:54.080
a decoupling of the initial authentication and then requesting some authentication tokens

06:54.080 --> 07:01.840
on behalf of you after you got this initial authentication done. That's a nice thing.

07:01.840 --> 07:11.480
Over years Kerberos as a mechanism grown these authentication or how it's called awkwardly

07:11.480 --> 07:19.000
in the Kerberos world pre-authentication mechanisms that allow you to use something more than

07:19.000 --> 07:30.760
just passwords. So you can use for example smart cards or you can use one time codes

07:30.760 --> 07:39.080
two factor authentication mechanisms and so on to log in or initially provide the initial

07:39.080 --> 07:47.040
credentials to obtain the so called ticket grant and ticket in the Kerberos thing. The

07:47.040 --> 07:53.160
good part of it is that this is exactly a way to get the transferable authentication

07:53.160 --> 08:02.200
state. Over years we added to Kerberos ability to record how this initial state was acquired.

08:02.200 --> 08:13.240
So an application can use an API to inquire whether this initial token was obtained with

08:13.240 --> 08:24.400
a password or with a smart card or with some other more strong type of authentication.

08:24.400 --> 08:30.760
So it can differentiate how to behave if for example application specific policy says that

08:30.760 --> 08:37.640
you cannot use this application if you were not using smart cards or you were not using

08:37.640 --> 08:45.160
FIDO2 tokens and so on. Then application can inquire this information and say yeah you

08:45.160 --> 08:51.280
are not allowed to use this. You cannot use sudo on these machines because you're merely

08:51.280 --> 09:02.440
used your password. That kind of thing. And this is the thing that I was doing a lot and

09:02.440 --> 09:10.640
the one thing connected with this is that the complexity of a typical Kerberos environment

09:10.640 --> 09:20.280
is huge. But separating the pre-authentication method is a nice part because it allows to

09:20.280 --> 09:27.800
decouple the other part of complexity. All these tokens or separate devices that you

09:27.800 --> 09:34.440
can use to prove who you are and that you possess these credentials from the actual

09:34.440 --> 09:40.280
applications. It's really splitting up in these two parts is what is important here

09:40.280 --> 09:46.640
because we can write applications once and forever at least the verification of the authentication

09:46.640 --> 09:57.360
authorization there and deal with the rest separately. This is for example how it looks

09:57.360 --> 10:06.280
like in a typical Kerberos environment with free APA or with Samba AD or Microsoft Active

10:06.280 --> 10:14.560
Directory. This is detailed description from the Red Hat's Enterprise Linux Identity Management

10:14.560 --> 10:26.720
Guide. Links in the PDF map just as an example of what we are dealing with. And the fun part

10:26.720 --> 10:36.760
is that how many seven years ago I've been talking in the other room in Janssen about

10:36.760 --> 10:43.440
similar things. So how we started with this. How we started with the enterprise graphical

10:43.440 --> 10:54.880
workstations on Linux. That was how many fifteen Fedora releases in the past. Fifteen that

10:54.880 --> 11:01.360
when I wrote that I kind of did not realize that we are thirty seven now and it's like

11:01.360 --> 11:09.920
seven and a half years back. And almost all this stuff already worked by that time. The

11:09.920 --> 11:17.840
smart cards were possible to use in this environment. Of course there were some issues with the

11:17.840 --> 11:23.040
visual representation how you choose these smart cards and so on. But it's kind of funny

11:23.040 --> 11:28.760
that what I will be showing to you today is kind of similar to what we did seven years

11:28.760 --> 11:36.240
ago. We fixed this problem for smart cards eventually together with the GNOME people

11:36.240 --> 11:48.160
by introducing some interfaces between SSD and GNOME components. GDM and the other parts

11:48.160 --> 11:57.960
of the window manager. So that they can pick up this information and show a nicer UI to

11:57.960 --> 12:03.320
choose who you are based on your smart card and so on. But smart cards were the first

12:03.320 --> 12:12.880
thing we did with this passwordless authentication because you don't need passwords anymore on

12:12.880 --> 12:20.000
this system. So what happened in these seven years and that's a nice period because every

12:20.000 --> 12:25.040
seven years something happens with people. They change themselves and environment around

12:25.040 --> 12:32.640
them changes a lot. So what happened? Actually there was change of winds and that's a fundamental

12:32.640 --> 12:42.720
one. If you remember 2015 2016 a typical office environment first there were offices where

12:42.720 --> 12:48.600
people were working every day going into those offices and they had a network actually where

12:48.600 --> 12:56.880
those computers were connected and enrolled into the whatever domain controllers were

12:56.880 --> 13:06.280
in those offices. So it really was an environment that was for the infrastructure for people

13:06.280 --> 13:15.800
right that you come you switch in your laptop connected and it's it knows what to do. It

13:15.800 --> 13:23.280
was so to say infrastructure for people. Nowadays these are all infrastructure in cloud and

13:23.280 --> 13:30.960
it's not for people it's for applications. You deploy applications some way in the cloud

13:30.960 --> 13:39.040
and all that infrastructure that is there is not for your you as an employee you as

13:39.040 --> 13:45.600
a someone who consumes it. You don't consume that infrastructure anymore. In most cases

13:45.600 --> 13:55.320
of course there are exceptions. In most cases you are consuming the applications and applications

13:55.320 --> 14:02.960
consume that infrastructure. So if your laptop is enrolled in something that's most likely

14:02.960 --> 14:09.000
not the same environment as your applications enrolled. The applications are actually consuming

14:09.000 --> 14:18.640
what they consuming stuff like or else they get tokens they get authorized to get tokens

14:18.640 --> 14:27.280
on your behalf from the identity provider service that is some wag stuff that you don't

14:27.280 --> 14:32.880
really know how is built inside in most cases and you don't care. All you care about is

14:32.880 --> 14:39.280
that you can prove to this identity provider your identity and for that you can use a bunch

14:39.280 --> 14:48.960
of stuff. For most of the cases on the social networks or on a myriad of websites and so

14:48.960 --> 14:56.800
on you don't even prove for them that you possess certain credentials. You prove this

14:56.800 --> 15:04.720
for some identity provider that they connected to and that something that I call bring your

15:04.720 --> 15:14.320
own authentication. So you connect your account in something to your social network account

15:14.320 --> 15:19.840
and you prove to the social network that you are who you are and then that social network

15:19.840 --> 15:26.720
IDP issues talking to that site where you want to be. That's essential to bring your

15:26.720 --> 15:31.800
own authentication to that site. The site doesn't really care how you authenticated

15:31.800 --> 15:40.760
to the social network how you prove yourself. And in fact what becomes out of it is all

15:40.760 --> 15:50.200
infrastructure around OAuth and OIDC is a part of it is built around I have a browser

15:50.200 --> 15:56.120
and this browser is everything I need. There are redirects between different components

15:56.120 --> 16:03.320
and websites they talk to each other on your behalf so this is kind of a new mainframe

16:03.320 --> 16:11.920
where everything runs. So you still need a network access for this to work. And here

16:11.920 --> 16:19.240
we get back to the 2016. In 2016 one of the biggest issues we were identified at that

16:19.240 --> 16:28.440
point for enterprise workers was everyone goes into business trip, goes into the hotel

16:28.440 --> 16:34.400
and every single hotel has captive portal on their Wi-Fi. So in order to log into your

16:34.400 --> 16:40.800
machine using your credentials you have to solve a problem of solving captive portal

16:40.800 --> 16:49.160
before you log into the machine. The fun part is that we never solve this problem at all.

16:49.160 --> 16:54.320
Instead of solving this problem we basically say to ourselves let's remove our machines

16:54.320 --> 17:01.440
from the corporate environment, right? Decouple machine from the environment rather than solving

17:01.440 --> 17:08.480
the problem. Maybe this is a good solution but maybe not because right now to solve to

17:08.480 --> 17:14.680
get this authentication again working for us we need to run browser before we log in

17:14.680 --> 17:26.160
again and running browser before you log in in titles running insecure unknown executable

17:26.160 --> 17:33.440
which is JavaScript code with the access to your hardware which is your at least screen

17:33.440 --> 17:39.760
and GPU and so on because that's what the browsers are requiring to do this stuff. So

17:39.760 --> 17:49.600
that's still the problem to solve and of course some of these problems might be solved but

17:49.600 --> 17:58.040
some of these problems might be hey move the way. So almost everyone has a phone. So this

17:58.040 --> 18:05.880
is somewhere I can run a browser instead of my laptop. So maybe I can run the authentication

18:05.880 --> 18:14.200
and authorization process on this separate device instead of running it on my laptop

18:14.200 --> 18:20.920
when I try to log in. It's kind of getting around the problem but maybe all the problems

18:20.920 --> 18:25.720
are like that. Get around them rather than solve them directly. And in some cases this

18:25.720 --> 18:32.040
is not even a problem. For example if you want to log in over SSH and you're already

18:32.040 --> 18:38.960
logged into your workstation then launching a browser on your already logged in workstation

18:38.960 --> 18:50.840
is easy right. You just need to have a URL to get into. So let's try I hope I will show

18:50.840 --> 19:05.880
this. Let's try a demo. So here I'm trying to SSH into some machine and on the whatever

19:05.880 --> 19:14.720
left side from you I have IDP based on the key clock open source project and this user

19:14.720 --> 19:21.000
it doesn't have the security key associated with it. Now I'm associating so basically

19:21.000 --> 19:30.400
I'm taking this kind of token and connecting it with this user. Okay. I have this token

19:30.400 --> 19:38.080
associated somewhere there and now I can log out of my IDP just to make sure that I don't

19:38.080 --> 19:43.520
reuse the same session that I obtained with the password. Right. So now I'm trying to

19:43.520 --> 19:50.640
SSH and I'm presented with a message that says okay authenticate against this browser

19:50.640 --> 19:57.880
somewhere. So I have a browser it's handy. I'm getting I'm using the security key to

19:57.880 --> 20:05.160
actually authenticate instead of the password. I authenticated into the system now the system

20:05.160 --> 20:11.960
says you're after I said do you after I rise this access. Yes I have for I said this access

20:11.960 --> 20:18.760
and logged into the system but a part of this authorization is that I'm getting a Kerberos

20:18.760 --> 20:25.920
ticket. Kerberos ticket issued to me by my infrastructure and now this Kerberos ticket

20:25.920 --> 20:32.240
can be used for well anything. Anything that's allowed there within this Kerberos environment

20:32.240 --> 20:43.600
so I can SSH with this Kerberos ticket further. I can mount NFS or some of something shares

20:43.600 --> 20:54.480
get access to files. I can use this Kerberos ticket to sudo into the system itself. There

20:54.480 --> 21:03.400
is since last year or actually 2000s first there is a palm module as a part of SSD palm

21:03.400 --> 21:12.080
SSS GSS. This module actually checks that you have active Kerberos ticket and its properties

21:12.080 --> 21:20.440
are good enough to access palm services so you can configure for example sudo to say

21:20.440 --> 21:29.280
that if you have Kerberos active Kerberos ticket with obtain it with the IDP authentication

21:29.280 --> 21:34.960
or smart card then you can use sudo rules on this machine. Which rules is separate from

21:34.960 --> 21:43.000
this but you can get access to sudo with it. You don't have password you never had password

21:43.000 --> 21:50.760
in your system. The password maybe existed somewhere in the IDP in this key clock thing

21:50.760 --> 22:00.840
or in GitHub or GitLab or Google for your company or Azure for your company or your

22:00.840 --> 22:10.920
own like key clock stuff. But the rest will work the same regardless how you get there.

22:10.920 --> 22:19.680
So it's a bit complex in terms of how this is implemented and how it goes. But at the

22:19.680 --> 22:28.800
core of it is we split the process into parts. There's initiates in part which in this case

22:28.800 --> 22:37.400
is the running on the server I tried to log in. There is a part that actually verifies

22:37.400 --> 22:45.960
that your IDP authorized access which is running on the Kerberos key distribution center part

22:45.960 --> 22:52.960
so Kerberos server side. And then there is a client which is in our case SSH trying to

22:52.960 --> 22:59.440
connect to the SSH server which initiates process and of course there is a browser that

22:59.440 --> 23:10.520
you run somewhere. You so you're right there. Probably to use a phone to access that URI.

23:10.520 --> 23:16.800
You probably want to have a QR code instead of the URI or in addition to the URI. This

23:16.800 --> 23:25.200
is one easy kind of thing that we need to implement to make it easier. But also it will

23:25.200 --> 23:31.920
become probably a mandatory part if you want to integrate this with the graphical login

23:31.920 --> 23:39.560
into the system because you cannot run browser yet. But surely you can show the nice picture

23:39.560 --> 23:45.520
that you can access from your phone or other device. And you will need something like that

23:45.520 --> 23:57.680
for the pass keys existing only on your phone. The soft FIDO2 tokens that both Apple and

23:57.680 --> 24:07.200
Google are eager to push to us these days. So effectively the same thing works with the

24:07.200 --> 24:15.480
FIDO2. In fact the demo that I showed was FIDO2 token because the IDP side was going

24:15.480 --> 24:24.800
to configure it to use FIDO2 or WebAuth token instead of password or smart card or OTP whatever

24:24.800 --> 24:34.080
is there. So we already can do this. It's already in fact all the tests that I ran it's

24:34.080 --> 24:41.600
Fedora 37. The one that's already released last November last year. So this password

24:41.600 --> 24:52.400
let's login to the Linux console works on Fedora works on well 8791 and a client side

24:52.400 --> 25:01.280
of it works on Ubuntu 2210 because they have this new SSD version that supports this stuff.

25:01.280 --> 25:21.360
Okay so if I want to do this with the other services let's hope I can get another demo.

25:21.360 --> 25:41.560
Now I can switch to the next one. There's it. Just a second.

25:41.560 --> 26:07.280
Okay so this is basically exactly the same demo just using instead of SSH I'm using VLOK.

26:07.280 --> 26:15.240
VLOK is just a normal application that uses PAM, Plugable Authentication Mechanism module

26:15.240 --> 26:22.760
to lock your system. So typically what happens is that you lock your console and then you

26:22.760 --> 26:28.360
have to provide a password. VLOK doesn't know anything about all this stuff but it works

26:28.360 --> 26:35.440
because we use the standard APIs there. And in this case I don't need to provision the

26:35.440 --> 26:50.880
token obviously because it's already provisioned but I can use it to login into the VLOK application.

26:50.880 --> 26:59.000
This goes just transparently maybe awkwardly because of the URLs and not nice UIs and so

26:59.000 --> 27:06.520
on but still it's there. The most important part here is that in order to all this get

27:06.520 --> 27:12.960
work and we have to have a network and service, this IDP thingy, how we can get without it.

27:12.960 --> 27:22.800
Well FIDO2 has this ability to work locally and not really through the web stuff so we

27:22.800 --> 27:31.400
can run this authentication locally. And all these tokens that Yubico and well this is

27:31.400 --> 27:39.440
Tokenill or some others, they use them all in the isolated environment as well. So we

27:39.440 --> 27:52.440
can actually run it so I got one small demo with this to let's hope I get this started

27:52.440 --> 27:59.280
again. This is recorded with my phone camera because I needed to actually show you that

27:59.280 --> 28:06.440
I press something on the screen. So this screen is locked, right? And now I'm trying to login

28:06.440 --> 28:13.680
into that screen and it asks me to insert this PUSKey device so I'm inserting it in

28:13.680 --> 28:22.400
and you can see that it doesn't actually show you the full message that is shown there.

28:22.400 --> 28:29.640
The part of the message says and press enter before it goes further. So when I press enter

28:29.640 --> 28:36.480
it tries to communicate with the device, it blinks to me and then I have to press a test

28:36.480 --> 28:42.640
that I physically present at the device to login it. And after that I'm unlocking the

28:42.640 --> 28:50.760
same way as with Vlog or SSH through the palm I'm unlocking this. This was my presentation

28:50.760 --> 29:03.880
this morning at the security dev room about the same thing. Now if we go logically further,

29:03.880 --> 29:08.200
this is working actually by the way. I cannot show it on this laptop because as soon as

29:08.200 --> 29:18.040
I lock my screen to unlock the video stream through HDMI will get disconnected and we

29:18.040 --> 29:23.680
will have to wait another five minutes to get my screen working back so you wouldn't

29:23.680 --> 29:32.880
see this on the screen. So believe my camera. Now how we can combine this? Okay, login in

29:32.880 --> 29:39.920
locally with the FIDO2 token is effectively gives me a login into the system but the very

29:39.920 --> 29:47.960
first thing the same problem that I discussed in the beginning applies here. How I transfer

29:47.960 --> 29:56.880
this authentication state that I used the passwordless device to login to other applications.

29:56.880 --> 30:04.000
Well in enterprise environment, whatever we call enterprise environment, for me the last

30:04.000 --> 30:11.240
10 years or so enterprise environment is my home environment because I run what I develop

30:11.240 --> 30:22.080
every IPA in my as my home authentication service. I simply need to transition from

30:22.080 --> 30:30.520
these FIDO2 token authentication to Kerberos ticket using it, right? Sounds simple. Yes

30:30.520 --> 30:39.640
it's also a bit of arrows and lines and so on but it's pretty much in line with this

30:39.640 --> 30:46.560
one. It's just the question of who is communicating with whom to prove that the possession of

30:46.560 --> 30:56.760
credentials is the real one. Okay. Unlike the previous one, I cannot show them of this

30:56.760 --> 31:04.800
one because we are at the point where maybe in two weeks we will complete this implementation.

31:04.800 --> 31:14.520
And of course the amount of bugs to find and fix will get this probably delayed until FIDO3

31:14.520 --> 31:24.080
39 or so. But I really hope to get this working by that time which is by the way just how

31:24.080 --> 31:36.280
many? Seven, nine, nine months away. Sounds a nice number. So that's not everything of

31:36.280 --> 31:47.280
course because well it's only an infrastructural part of it. To get it usable and not to the

31:47.280 --> 31:53.760
point that users will trash their laptops because they cannot read the message. Imagine

31:53.760 --> 32:02.920
this is just a simple insert here, passkey device, the what if this was authenticate

32:02.920 --> 32:12.600
against this URL, HTTPS, something that can't even fit into this box. That's the situation

32:12.600 --> 32:19.880
right now. So we need to fix this with in this case it's a GDM of course, this is the

32:19.880 --> 32:29.520
GNOM display manager. For the login we need to fix this. We started talking with the GDM

32:29.520 --> 32:35.040
developers and there's some common understanding what to do. Similar to what we did with the

32:35.040 --> 32:42.920
smart cards. The nice part of it is that it's mostly about a protocol of communicating between

32:42.920 --> 32:50.200
the PAM service in this case and the display manager through the environmental variables

32:50.200 --> 33:01.280
within the process. So SSDS can tell that I'm now using this type of passwordless authentication.

33:01.280 --> 33:08.560
Please switch to this visualization of it. So we kind of can make it this way that it

33:08.560 --> 33:17.720
works for GNOM but it's also usable for others. And here I come to the point of effort across

33:17.720 --> 33:24.360
multiple projects. You can do this with GNOM but then what to do with KDE, what to do with

33:24.360 --> 33:36.240
XFAC and others. There's a need to agree on something. We can agree on APIs, we can agree

33:36.240 --> 33:41.400
on protocol driving semantics behind this but somebody needs to implement all these

33:41.400 --> 33:51.440
pieces in the end. This is a common effort, us as a community. It's not just one company

33:51.440 --> 34:00.960
or one developer crazy enough can drive and write all this code and get it. We as a community

34:00.960 --> 34:11.400
need to work together to get this done. And of course this is just at the top of the iceberg.

34:11.400 --> 34:20.080
There's a bunch of work needs to be done on the distribution level to make it usable for

34:20.080 --> 34:26.880
clean installations for example. If I want to use this type of the key, if I go to keys

34:26.880 --> 34:35.560
for example for the login into machine, I'm sure probably want to use it also to provision

34:35.560 --> 34:44.880
encryption of my disk. And this is already possible with system D supporting configuration

34:44.880 --> 34:55.280
of lock devices with the FIDO2. In all contemporary distributions, system D already compiled with

34:55.280 --> 35:02.600
support for FIDO2. It's a matter of configuring them. It's the matter of configuring other

35:02.600 --> 35:14.040
services to reuse all of this. But I don't think as much as I like Wiki pages that describe

35:14.040 --> 35:19.960
how to do this in multiple articles, I don't think this is what we should be doing. It's

35:19.960 --> 35:28.760
the distribution level job to polish or add this kind of polish. Again as a community

35:28.760 --> 35:39.000
of distribution developers in Fedora, in Debian, in others, in Arc, we need to focus on this

35:39.000 --> 35:46.840
kind of polishing. When all these pieces ready, sure someone will be faster with the releases

35:46.840 --> 35:53.680
and polishing of it. But in the end, we as a community, we as a community of developers,

35:53.680 --> 36:00.040
users, we are users themselves even if we know how this stuff works. It doesn't mean

36:00.040 --> 36:10.880
that we tolerate how badly it's integrated. So that's my message here. We need to work

36:10.880 --> 36:22.360
as a community to bring it all to us to be pleasant to work with. And with this one,

36:22.360 --> 36:27.560
I guess I'm even on time. Thank you.

36:27.560 --> 36:43.240
My question is about the two factor authentication when there is a password and a security key.

36:43.240 --> 36:49.240
Do you know why in all the workflows the password is asked first and then the security key?

36:49.240 --> 36:55.120
Whereas it likes to me that the security key is the strongest part and it should be better

36:55.120 --> 37:01.160
to first press the button of the key and then enter the password. Is there some movement

37:01.160 --> 37:06.040
to change the current way of doing things?

37:06.040 --> 37:17.600
The question is whether using password and second factor and so on can be one of the

37:17.600 --> 37:27.200
ways of doing it and is there an activity to make it better, let's say this way? Yes

37:27.200 --> 37:33.920
and no. It depends on what we define as the first factor and second factor. One of the

37:33.920 --> 37:41.520
driving factors behind passwordless work in the last 10 years or so across the industry

37:41.520 --> 37:48.680
is the tightening of requirements from the government, specifically from US government.

37:48.680 --> 37:58.040
US government issued so-called zero trust memorandum last year for origin governmental

37:58.040 --> 38:09.800
organization to move by end of fiscal year 2024 to move to passwordless authentication.

38:09.800 --> 38:17.280
This means that they have smart cards already. That's solved but they specifically name Web

38:17.280 --> 38:24.800
Wolf and FIDO2 as one of the alternatives to smart cards. In fact, all of these things

38:24.800 --> 38:31.520
they have pin associated with this which can be looked as a first factor. It's not the

38:31.520 --> 38:41.880
first factor as we understand it. It's a first factor to unlock hardware rather than unlocking

38:41.880 --> 38:50.160
some factor in software. This is the thing which drives some of this work, not necessarily

38:50.160 --> 39:00.960
for us but for many others already. I think there is a value in staking factors. The question

39:00.960 --> 39:08.400
is in which environments you want to use them and so on and configure this this way. Certainly

39:08.400 --> 39:18.160
there is already a mechanism to enable it. For example, PAM already is staking. Technically

39:18.160 --> 39:24.240
you can stack multiple PAM authentication modules in the same configuration for V-lock

39:24.240 --> 39:30.640
or GDM or something and say always enter free passwords from different sources. That already

39:30.640 --> 39:38.600
would be multi-factor, multi-password authentication. One of them this and the other one is the

39:38.600 --> 39:46.520
password and the third one is phase of the moon and so on. You can get that stuff already.

39:46.520 --> 39:52.840
It's the question of adopting to a specific environment where this makes sense. I have

39:52.840 --> 40:03.000
not seen multi-password in the traditional kind of environments yet. If we do something like

40:03.000 --> 40:10.360
integration with the identity providers like I show it in the demo, that gives you possibility

40:10.360 --> 40:17.560
to move this check away into let's say, kick log. Kick log actually has ability to ask

40:17.560 --> 40:26.320
a password or TP and the web often at the same time. You can configure that already.

40:26.320 --> 40:32.560
Again the question is in which direction you want to focus this. Maybe not adding into

40:32.560 --> 40:41.040
SSD or some specific PAM module but instead adding into more flexible and more controllable

40:41.040 --> 40:52.000
source. Any other questions? Yes, here. You were talking about how can distributions and

40:52.000 --> 40:57.800
desktop managers contribute to get a unified interface. I recently prompted to a project

40:57.800 --> 41:05.640
called XTG credentials portal which tries to specify a standardized interface for interacting

41:05.640 --> 41:11.880
with web often credentials such that different KDE and gnome and stuff can hook into this.

41:11.880 --> 41:16.760
I was wondering whether you were aware of this project and if that would be a good place

41:16.760 --> 41:21.120
to maybe start trying to collaborate on a unified interface.

41:21.120 --> 41:31.040
The question is am I aware of the projects like XTG credentials that tries to specify

41:31.040 --> 41:40.080
or unify access to the credentials for things like I think it's for the containerized environments,

41:40.080 --> 41:45.800
desktop applications running in flat pack and so on. Yes, I am aware and that's one

41:45.800 --> 41:52.960
partial thing that I mentioned about the parallel effort there. But it's not for the login.

41:52.960 --> 41:59.080
It's for the reuse of the credentials in the browser or relay in party outside of the container

41:59.080 --> 42:07.200
so you can isolate direct access. That's very important but it's a bit different layer.

42:07.200 --> 42:13.320
It's the layer that we will eventually need to reuse if we want to do this transferable

42:13.320 --> 42:21.200
state of authentication between different places without Kerberos. Yes, we will have

42:21.200 --> 42:33.120
to work with them or they will pass or everyone. Yes.

42:33.120 --> 42:46.960
Hello. So I use ED25519 security keys which SSH supports and it's really simple. So I

42:46.960 --> 42:52.920
just generate a key and I can use it and my SSH team supports it. I don't really need

42:52.920 --> 42:57.200
to run any services. I don't need to use Kerberos. How do we get to a world where everything

42:57.200 --> 43:08.000
is that simple? So the question is why do I need all the things if my SSH keys work

43:08.000 --> 43:16.440
fine with the hardware based tokens, X549 and based certificates and so on. The answer

43:16.440 --> 43:24.960
is simple. It's not an answer for all use cases. You cannot authenticate with these

43:24.960 --> 43:32.040
tokens and these keys to, for example, file services. You cannot use them to authenticate

43:32.040 --> 43:39.360
to NFS. You cannot use them to authenticate to SMB or other resources. Needs are different.

43:39.360 --> 43:45.560
Use cases are different. All of this thing does not replace SSH keys and SSH keys do

43:45.560 --> 43:52.880
not replace this one. They exist in parallel to each other because if you start using FIDO2

43:52.880 --> 44:00.680
tokens you wouldn't be using them exactly the same way on SSH level as well because

44:00.680 --> 44:11.000
SSH will need to generate all the keys based on the same use of the same hardware but different

44:11.000 --> 44:17.440
call specific and application specific thing. And this is where the problem really comes

44:17.440 --> 44:25.840
in. You can find use cases where existing functionality is perfectly usable and secure

44:25.840 --> 44:33.320
and attainable but it's not transferable to the other systems and other protocols. That's

44:33.320 --> 44:41.680
the problem we try to solve. So it's more amending rather than displacing.

44:41.680 --> 45:06.600
Hello. Hello. And thanks for the talk. My question is if I'm a very, very bad person

45:06.600 --> 45:11.960
and want to break the system and steal the Kerberos ticket authentication for example,

45:11.960 --> 45:19.760
what's the easiest way I can do it? So the question is how to steal Kerberos ticket in

45:19.760 --> 45:28.720
the Linux environment in the easiest way despite all the protection mechanisms we want to add.

45:28.720 --> 45:38.160
I probably answer what mechanisms we have so that you may reconsider your activities.

45:38.160 --> 45:49.200
So in comparison, Microsoft some time ago added a virtualized slice where they store

45:49.200 --> 45:55.160
all the credentials so you do not have access to that slice. It's running literally not

45:55.160 --> 46:03.880
as a container, it's like a VM separated from the actual system where they handle all the

46:03.880 --> 46:13.560
security credentials and so on. And you cannot easily store that from the memory of the applications

46:13.560 --> 46:21.120
that try to load this stuff. On Linux side at that point we had a project called GSS

46:21.120 --> 46:33.280
proxy. The GSS proxy is a daemon that runs in separate, typically on the root and it

46:33.280 --> 46:42.560
interjects into GSS API hence the GSS proxy, GSS API operations and interposes access to

46:42.560 --> 46:56.840
all Kerberos crypto material. So when you are a service like HTTP or NFS, you want to

46:56.840 --> 47:04.840
have access to the Kerberos key top so that you can authenticate clients coming to you

47:04.840 --> 47:16.240
and get access to it. Or your IMAP or send mail or something. And GSS proxy basically

47:16.240 --> 47:23.680
removes access to the key tops, removes access to the credential cache that you use. They

47:23.680 --> 47:32.120
are in separate process. So now if you are broken into NFS server like Ganesha or even

47:32.120 --> 47:39.040
the kernel, well kernel one is probably easier target, right, if you happen to find a bug

47:39.040 --> 47:45.920
that allows to exploit it. But you're probably not a Linux Torvalds anymore and it's not

47:45.920 --> 48:00.360
1994 where he found NFS problems to hack into and get the data out, out of NFS. So typically

48:00.360 --> 48:09.200
this privilege separation between the processes works fairly well. If you're root, of course,

48:09.200 --> 48:21.280
you get what you get. In that case, there's some number of ways of preventing root running

48:21.280 --> 48:28.320
processes from accessing the capabilities on the kernel level and on typical steel this

48:28.320 --> 48:38.280
is an operation that should probably be multilayered. Like you have to use kernel capabilities,

48:38.280 --> 48:44.800
then you have to use the file system level capabilities, then SLE, so App Armor to prevent

48:44.800 --> 48:54.960
other access things. But basically with the GSS proxy we get isolation on this level and

48:54.960 --> 49:03.200
also we get the content of the credential caches encrypted. So you can store or you

49:03.200 --> 49:10.360
can steal credential cache if you get access to that. But it will be encrypted with temporary

49:10.360 --> 49:17.360
key that exists only until GSS proxy runs. So even if you steal it, you cannot really

49:17.360 --> 49:26.920
use that one. The other part is that there are credential cache collection types that

49:26.920 --> 49:33.080
do not allow direct access to the credential cache. So for example, a keyring, kernel keyring

49:33.080 --> 49:39.960
where you can store and tighten it fairly tight so that application doesn't get these

49:39.960 --> 49:48.240
keys out. The other one is KCM which is also a separate process accessible over the Unix

49:48.240 --> 49:54.960
domain socket. You don't get direct access to the files either. So there are some mechanisms.

49:54.960 --> 50:02.000
They are not so dramatic as in Windows case where they run it in completely different

50:02.000 --> 50:10.120
way. We are isolated on a hardware level. But we get fairly far away. I've seen people

50:10.120 --> 50:17.960
trying to decode the KCM databases but that presumes that they get access to the physical

50:17.960 --> 50:25.320
root partition so they can read the actual files from the KCM back store. But of course

50:25.320 --> 50:31.640
that if you're root, if you're having access to the root partition, your game is lost in

50:31.640 --> 50:32.640
most cases.

50:32.640 --> 50:33.640
Yep.

50:33.640 --> 50:38.640
Alexandra, many thanks for your interesting talk to give the community.

50:38.640 --> 50:39.640
Thank you very much.

50:39.640 --> 51:02.640
Thank you.
