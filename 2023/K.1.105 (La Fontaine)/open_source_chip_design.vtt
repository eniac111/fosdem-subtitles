WEBVTT

00:00.000 --> 00:11.680
Welcome, everybody. It's amazing to be back. It's amazing to be back in Brussels in person

00:11.680 --> 00:19.000
and see that many people here looking for an answer to a question, can we do an open

00:19.000 --> 00:27.320
source chip design in 45 minutes? And to save you all the hassle of actually just listening

00:27.320 --> 00:41.760
through this talk, yes, we can. Thanks. It's been great. Enjoy Brussels. Or if you want

00:41.760 --> 00:50.640
to know more about how that actually can work, stay here. So we're going to look at technology.

00:50.640 --> 00:56.120
Obviously, this is fast. Then we're going to look at tools and processes, how to build

00:56.120 --> 01:03.120
an open source chip. We were looking at community because this is faster than we want to talk

01:03.120 --> 01:10.080
about the people and communities behind all of these efforts. And we will predict the

01:10.080 --> 01:15.000
future. Let's see how that goes and we'll see some examples of where that potentially

01:15.000 --> 01:26.000
went wrong in the past. So, standing in front of you today is Philip. I'm a hardware developer

01:26.000 --> 01:30.600
and I've been doing a fair amount of software. I've been involved in open source for a fair

01:30.600 --> 01:36.960
amount of time. I gave my first first and target just looked 11 years ago. You find

01:36.960 --> 01:45.120
some contact information there. And I'm currently working at, by now, at this company here,

01:45.120 --> 01:51.680
IBM doing chip verification for high-end mainframe CPUs. So that brings all the new

01:51.680 --> 01:57.800
together, actually. And I'm also maintainer of the open source COCODB project and we'll

01:57.800 --> 02:04.680
get into that in a second. Previously, I was working at Lorisk and OpenTitan. Again, to

02:04.680 --> 02:10.000
buzzwords just for you to Google if you want to. So OpenTitan is a security chip, fully

02:10.000 --> 02:18.440
open source, that you actually can get involved just like any other software community. I'm

02:18.440 --> 02:24.440
here today representing the FOSI Foundation and this is a foundation there to kind of

02:24.440 --> 02:32.840
steward and take care of the open source chip design movement. It's based on individuals

02:32.840 --> 02:37.240
and it's a non-for-profit registered in the UK. Also has been around for quite a while

02:37.240 --> 02:42.320
and was initially born out of the open risk movement that did a open source processor

02:42.320 --> 02:51.160
CPU core back, probably, I don't know how many years by now, 10, 15, something like

02:51.160 --> 03:02.400
that, before risk five was a thing. So that's it for the introduction. Let's go into the

03:02.400 --> 03:13.440
functionality. How do we build a chip? There are two main things that we need. First, we

03:13.440 --> 03:19.120
need to think about, we have an idea, obviously that's where we start, but then at some point

03:19.120 --> 03:26.000
we need to implement the functionality. We do that, looks similar to a regular programming

03:26.000 --> 03:37.240
task. So this is the logic design part. And that one is pretty well understood these days.

03:37.240 --> 03:42.360
Also an open source. We'll see why that is the case and why that has been thriving for

03:42.360 --> 03:51.600
many, many years now. The second part is the back end or the physics or the real world,

03:51.600 --> 03:57.880
the thing that actually gets us closer to not having a description of what our hardware

03:57.880 --> 04:05.520
could do, but actually a real physical chip that we can then potentially hold in our hands.

04:05.520 --> 04:11.120
So this was the part that was trickier so far. And again, we'll get into more of the

04:11.120 --> 04:17.400
details of that. But these two things are the ones we need. We need the logic, the functionality,

04:17.400 --> 04:23.720
and we need the implementation to make this a real thing.

04:23.720 --> 04:35.680
As in so many cases, the terms are overloaded and fuzzy and ambiguous. So for my purpose

04:35.680 --> 04:42.440
here I'm going to use the term front end for the logic part design. And then there will

04:42.440 --> 04:46.720
be a back end as well. So if you're coming from the web world or the JavaScript world,

04:46.720 --> 04:52.120
that probably means something very different to you. So if you have a front end designer

04:52.120 --> 04:58.760
and I'll be under potentially doing JavaScript, because that's what they do as well, or they're

04:58.760 --> 05:03.360
potentially doing chips, you don't know. Has led to interesting conversations in the past,

05:03.360 --> 05:16.400
I must say. So the front end, I kind of briefly alluded to that. It's just like programming.

05:16.400 --> 05:26.760
So there are different levels of programming languages and hierarchies. There is, for example,

05:26.760 --> 05:32.480
high level synthesis starting at the top where you, well, if you would buy such a high level

05:32.480 --> 05:37.560
synthesis tool that would probably tell you you start with an idea and then maybe an algorithm,

05:37.560 --> 05:41.280
something that is fancy, and then just run the tool and you get your chip out of it immediately,

05:41.280 --> 05:49.360
kind of done. Some of them will sell you tools that allow you to start with a, well, in marketing

05:49.360 --> 05:54.600
it sounds like an arbitrarily complex C or C++ code base and just run that high level

05:54.600 --> 06:00.880
synthesis tool and you get a chip design out of it. Nothing, no human involved, works perfectly.

06:00.880 --> 06:06.880
Now anybody who has C and C or C++ code bases will kind of attest this is probably not how

06:06.880 --> 06:17.280
reality works. And it doesn't. Beyond that, again, the boundaries are slightly fuzzy. There are high

06:17.280 --> 06:26.400
level languages that make it ideally more convenient to write a chip. And then at the lowest level

06:26.400 --> 06:33.480
almost, there's always system very lock or very lock and Ph.D.L. Again, system very lock being

06:33.480 --> 06:40.880
kind of slightly misleading in terminology. So system very lock is the current standard for

06:40.880 --> 06:46.160
hardware description languages that was previously called Verilog. Some others use it as system

06:46.160 --> 06:51.680
very lock being the verification language, where Verilog is the design language. Again,

06:51.680 --> 06:56.680
let's make it as confusing as possible. It's the language called system very lock these days. The

06:56.680 --> 07:04.360
alternative is Ph.D.L. Again, just like the C and more or less the C or C++ of the hardware world.

07:04.360 --> 07:12.640
And below there, that's typically not a programming language, just a typically Verilog as well,

07:12.640 --> 07:19.920
just a lower level representation of the same thing that is the net list, which is effectively

07:19.920 --> 07:29.840
a C of ands and ors and then connected by wires. So that's representing your logic. So these are

07:29.840 --> 07:34.560
the kind of programming languages that you would use and we'll get into a couple examples in a

07:34.560 --> 07:47.000
second. And then obviously, there's all the other stuff. Test frameworks, build tools, you need to

07:47.000 --> 07:51.520
have a proper conversation about a build tool, otherwise it's not a real programming environment.

07:51.520 --> 07:58.400
I mean, who are we if we can't argue endlessly about build tools? They're developer productivity

07:58.400 --> 08:05.800
tools. It's actually one of the areas where open source really shines compared to some of the

08:05.800 --> 08:14.040
commercial offerings and simulators. And again, we'll get into those in a second. So let's have a

08:14.040 --> 08:19.360
look at a couple examples. We want to do open source after all. So hardware description

08:19.360 --> 08:24.920
language is that we can choose from. And the list is quite long, even though it kind of narrows

08:24.920 --> 08:31.920
down quickly once you kind of look deeper. So there's system Verilog and Verilog. So this is

08:31.920 --> 08:37.760
a IEEE standard. You can download the standard just like the C standard. And this is effectively

08:37.760 --> 08:46.600
the most commonly used language to do hardware design. It's quite old, which is not per se much

08:46.600 --> 08:51.600
of a problem, but it has been continuously updated. The other problem about system Verilog and Verilog

08:51.600 --> 08:59.520
is kind of years come and go and programming concepts and ideas come and go as well. The

08:59.520 --> 09:05.720
problem is if your language stays around that long, you just add everything. So if you look at the

09:05.720 --> 09:14.040
system Verilog standards, it's huge. Probably not as huge as the C++ standard. But it will have some

09:14.040 --> 09:22.680
interesting corner cases if you look at that. And that has interesting side effects, because now you

09:22.680 --> 09:27.280
have a fair amount of tools. And we'll get to that in a second, how many tools you actually need to

09:27.280 --> 09:34.120
evolve to get a hardware design working. So all of those need to understand ideally the same subset

09:34.120 --> 09:40.440
of system Verilog. And also kind of interpret it the same way. So that's not always the case. That's

09:40.440 --> 09:46.880
why hardware designers who are per se already quite conservative in the tools they're choosing,

09:46.880 --> 09:53.880
will end up with a very kind of old school subset of Verilog that you're in there and allowed to use.

09:53.880 --> 10:02.840
BHDL is another option. Same story there, just slightly different. The Verilog community is much

10:02.840 --> 10:08.480
larger. And especially if you're looking at producing kind of real ASIC chip designs, you're going to

10:08.480 --> 10:16.720
look at Verilog mostly. But then program links as said coming in. So there are some interesting new

10:16.720 --> 10:23.720
ones up there as well. There's BlueSpec. There are a fair amount of Python-based HDLs. And some of

10:23.720 --> 10:30.000
them are more low-level than others. So there is MyGen, Amaranth, and MyHDL and a couple others. So

10:30.000 --> 10:37.440
this is, this by the way, no. It doesn't need to be complete. And it isn't complete. And there are

10:37.440 --> 10:42.240
a number of hardware description languages or programming languages that are based on functional

10:42.240 --> 10:50.280
programming languages. Spinal HDL, Chisel, and Clash for example. Chisel for example being quite

10:50.280 --> 11:00.240
often used these days because, I don't know if you first heard about RISC-V. Let's maybe do this. Raise your hand.

11:00.240 --> 11:10.240
So RISC-V is a open source instructions and architecture. So like the x86 is an instruction set

11:10.240 --> 11:18.920
architecture or ARM v7, v8 is an instruction set architecture. And then kind of then was developed

11:18.920 --> 11:25.960
in Berkeley originally and they also developed a hardware language called Chisel. So the initial

11:25.960 --> 11:30.920
RISC-V core implementation, the Rocket core is implemented in Chisel. And since that's open

11:30.920 --> 11:38.720
source and widely used, kind of Chisel also spread more widely. So you'll see that. And then there is a,

11:38.720 --> 11:47.840
I'm not quite sure how new or old it is, the circuit LLVM effort that kind of tries to build a LLVM

11:47.840 --> 11:55.280
based compiler infrastructure to then place hardware languages or other pieces of functionality on top of.

11:55.280 --> 12:05.680
I've actually not seen that many kind of useful tools coming out of that LLVM based middle layer.

12:05.680 --> 12:13.240
So we'll see what the future brings in that regard. So we choose the programming languages. And then

12:13.240 --> 12:18.880
the next thing you want to do if you actually want to build a chip is ideally not write everything

12:18.880 --> 12:27.000
from scratch. So you reuse, you integrate existing things and they're typically always called IP cores

12:27.000 --> 12:32.120
in that world. So there are a couple options that makes it easier to integrate. So there is no

12:32.120 --> 12:38.200
unfortunately central package manager or something like that, like a cargo or an NPM or something like

12:38.200 --> 12:46.360
that that you would have in the newer software world. So but what you have instead to do is more or less

12:46.360 --> 12:53.680
Google for whatever you might need. And you might find an abandoned Git repository or a

12:53.680 --> 13:00.000
sit drop somewhere that contains what you're looking for. And often it comes with, oh, this has been

13:00.000 --> 13:05.280
potentially taped out. So a chip has been produced out of that and it's stable. So we're not going to touch it again.

13:05.280 --> 13:11.800
So many of these kind of IP cores are considered stable because as soon as you've used them once,

13:11.800 --> 13:17.440
you don't want to touch them again. So you rarely have a kind of fancy community around those cores.

13:17.440 --> 13:23.960
It's just it's there. You use it and then you're on your own. So that was and still is this website

13:23.960 --> 13:30.200
called OpenCores, which was kind of a directory for open source hardware blocks. It's been

13:30.200 --> 13:36.080
unmaintained for quite a while, but it's still there. So if you're looking for cores, it might be a good

13:36.080 --> 13:44.400
option. But again, don't expect that much of an active community around these offerings. And I guess

13:44.400 --> 13:52.360
the best that's why the slide is quite empty option is the school and you'll find something. So now that

13:52.360 --> 13:56.720
we have put together a logic design, we have written some stuff on our own. We choose in the programming

13:56.720 --> 14:02.800
languages nobody else has been using before and we added some IP cores that nobody was maintaining.

14:02.800 --> 14:09.240
So now we want to see if it actually works. I mean, it feels unlikely if I phrase it like that,

14:09.240 --> 14:17.040
but the chances are it actually does. So we need to verify it somehow better or not so good. We

14:17.040 --> 14:23.760
potentially document it. Nah, let's not do that. We want to make it look pretty. I mean, that's what

14:23.760 --> 14:28.640
we spend most of our time. Don't we? I mean, it's two tabs or spaces or indent here or indent there.

14:28.640 --> 14:32.680
It needs to look pretty. Even it doesn't work. So that's something we need to do. And that's

14:32.680 --> 14:37.840
something the open source community was always fantastic about. And that's clearly something

14:37.840 --> 14:46.280
we're bringing to the world of commercial chip design. We need to simulate it because at this

14:46.280 --> 14:52.280
point, we're just doing logic design. So we don't have anything, we don't have a chip yet. So we

14:52.280 --> 14:57.560
somehow need to see what it actually does. And we potentially can run it on FPG. And I'll get to

14:57.560 --> 15:05.680
that in a second. So let's have a look at a couple buzzwords here of what is possible these days in

15:05.680 --> 15:14.440
open source chip design world. Simulators, we start with that one. There are kind of three main

15:14.440 --> 15:20.120
simulators. And you see that they're main simulators because they have a logo. There is a fourth

15:20.120 --> 15:25.520
simulator that's rarely used. NBC doesn't have a logo. So I think that indicates what's going on.

15:25.520 --> 15:33.920
You also see by the style of the logos, what are the older projects? At least it's slightly misleading,

15:33.920 --> 15:40.360
I must say. And so on the top right, we have Ecos Verilog, which is an event-based Verilog

15:40.360 --> 15:46.400
simulator. It has been around for quite a while. It's stable and it works really well. It's widely

15:46.400 --> 15:55.440
used. But it doesn't support much of the more modern system Verilog features. And it's not that

15:55.440 --> 16:01.280
fast. It's sufficiently fast for smaller designs. And it's kind of the standard choice if you just

16:01.280 --> 16:07.920
want to get started. Ecos Verilog works here. If you're looking for a BHDL option, there is GHDL,

16:07.920 --> 16:17.720
I think the most actively maintained BHDL simulator, it says. And there is Verilog in the middle,

16:17.720 --> 16:25.840
which is slightly different because it simulates Verilog as well. The name gives it away, I would

16:25.840 --> 16:32.000
say. But it's a cycle-accurate simulator. So without going into too much of the details here,

16:32.000 --> 16:44.880
if you have a real chip design, you clock it and then you get one clock pass per clock. That's

16:44.880 --> 16:54.600
ridiculous. But that's the only times when Verilator kind of reevaluates things that are going on. In

16:54.600 --> 17:00.080
an event-based simulator, you get a slightly different behavior. Either way, Verilator behaves

17:00.080 --> 17:08.520
pretty much like a real chip would do afterwards. And it's a very, very active community. And it's

17:08.520 --> 17:15.120
typically based around the synthesizable subset of Verilog. Because that's kind of what it targets.

17:15.120 --> 17:20.960
It targets only the logic that you then want to bring on a chip and not so much the system Verilog

17:20.960 --> 17:24.160
that you can use to actually write a test-bencher verification framework around it.

17:24.160 --> 17:34.600
Now verification frameworks, I just mentioned that. Who has heard of UVM? The one up here.

17:34.600 --> 17:42.600
Couple ones. Okay. So UVM is an interesting one. It's a system Verilog verification methodology.

17:42.600 --> 17:49.040
And already, it's a methodology that kind of breathes this air of being designed by a committee.

17:49.040 --> 17:55.800
And that's how it looks. It's effectively a class library, a framework of classes and instructions

17:55.800 --> 18:00.280
on how to use them and when to use them to actually verify a chip. So write a test-bench,

18:00.280 --> 18:09.600
more or less. So that's your Google test of Verilog, if you wish to. And there are a couple

18:09.600 --> 18:13.880
other options. There is, and I mentioned that in my work there. So I'm going to mention that

18:13.880 --> 18:19.400
prominently. There's COCADB which gives you a way to write a test-bench in Python that is then

18:19.400 --> 18:29.200
testing your hardware logic. There's OSVVN for BHDL designs. And there is on the top just one of

18:29.200 --> 18:35.000
the further options. Symbiosis, if you don't want to do simulation-based verification, but you want

18:35.000 --> 18:40.360
to do formal verification. So you want to prove that certain things are happening or not happening.

18:40.360 --> 18:46.720
So this is then effectively using a SAT solver behind the scenes to prove some things can be done

18:46.720 --> 18:52.400
or can't be done. So that's a very different verification approach and works very well for

18:52.400 --> 19:00.280
some problems, but not for all of them. And so you typically, if you're kind of trying to gain

19:00.280 --> 19:05.320
confidence in your design, you definitely go for some simulation-based verification, so simulation

19:05.320 --> 19:13.880
based testing. And then you maybe throw in some formal around some specific areas. And while I'm

19:13.880 --> 19:19.080
putting these here, so this is kind of the way to do verification, not new, but what we see here

19:19.080 --> 19:24.840
that we have a fair amount of options in open source that are very, very high quality and ready

19:24.840 --> 19:35.200
to be used. So that's great. Build systems, and I need to mention the first one first. Who has

19:35.200 --> 19:42.240
heard of Fusuck? Oh, a couple of ones. So there's this guy called Olaf Shingran, quite active on

19:42.240 --> 19:48.960
Twitter as well, and he's always writing award-winning software. So he started that initially when he

19:48.960 --> 19:53.360
just saw a tool that apparently has gained an award, but he couldn't find the award that it was

19:53.360 --> 19:59.200
awarded. So from then on, every tool he's writing is award-winning, even though it has never won any

19:59.200 --> 20:03.840
awards. Actually, I think Fusuck has won one or two awards by now. So I think that's something we

20:03.840 --> 20:09.760
only to copy. Just make sure that we always say our software is award-winning, and from there on,

20:09.760 --> 20:18.800
it's just much better. So Fusuck is a build system for hardware designs, and Edelize is a build

20:18.800 --> 20:25.360
system backend to make kind of the hardware design put together and feed that to a variety of

20:25.360 --> 20:31.280
different tools that are involved. So just like driving your compiler. There is V-Unit, a regression

20:31.280 --> 20:38.640
manager. Well, okay, another maybe interesting term I'm saying regression manager here. So a

20:38.640 --> 20:46.160
regression in the software world would be something was working, and then it would broke it somehow,

20:46.160 --> 20:52.080
so kind of functionality degraded in quality. A regression in the hardware world would be

20:52.080 --> 20:57.280
somebody just running a fair amount of tests. So effectively, you know, I believe CIE would be a

20:57.280 --> 21:04.400
regression, just to add confusing terminology. And there are a fair amount of other options for

21:04.400 --> 21:12.320
build systems. Again, just Google them and then fight about it, obviously. We talked about white

21:12.320 --> 21:18.960
space before, and when you're done with your fighting about your build system, you obviously

21:18.960 --> 21:25.840
need to fight about your right style guide to use for your programming languages. So we have come

21:25.840 --> 21:33.120
accustomed in the software world to there being kind of Clang format and other Go format and other

21:34.400 --> 21:41.120
enforcing or not so much enforcing auto format is there. If you look at a very low code in VHDL code,

21:43.040 --> 21:50.640
you see there is no formatter. And you see often there is kind of no taste either. So

21:50.640 --> 21:58.160
it just looks awful. And if you look through code, then everything looks different, which

21:58.160 --> 22:04.640
isn't that much of a problem in the commercial chip development world, because you own something,

22:04.640 --> 22:08.960
it's kind of it's John's core. So this is kind of the piece of code that John is working on,

22:08.960 --> 22:14.080
only he needs to be able to touch it, which is then up to John, however, they want to

22:15.760 --> 22:19.600
kind of format their code. And I've done that for 20 or 30 or 40 years, so they just

22:19.600 --> 22:26.000
have their in-house style that you also see changing over time. That's not something that

22:26.000 --> 22:36.240
we kind of find normal in kind of these days of software development. So there was an effort,

22:36.240 --> 22:42.400
and it still is an effort to bring formatting, linting, and language server integration,

22:42.400 --> 22:47.680
so that gives you your Visual Studio code integration or your other kinds of integrations.

22:47.680 --> 22:54.000
And variable is the tool to look for there. There is very little lint, part of that very

22:54.000 --> 22:59.840
later simulator that I've shown before, and it actually does more static analysis jobs as well.

23:00.640 --> 23:05.760
And there are a couple other options to choose from. And mostly mentioning the

23:05.760 --> 23:11.200
the very log part here, you'll find that, because that's what I'm most familiar with, but I'm very

23:11.200 --> 23:19.440
sure there is an equivalent BHDL kind of option for many of these things as well. And if you know

23:19.440 --> 23:25.760
them, by the way, just raise your hand and we'll just add it right away. So let's have a look at

23:26.640 --> 23:31.680
just one or two examples. So this is a don't hate to read it in full. So this is a piece of Verilog

23:31.680 --> 23:41.040
on top, assigning something based on a ternary statement. And think about Verilog, it's statically

23:41.040 --> 23:49.680
but it's not statically typed, but it still is easy to assign, for example, 32 bits to 7 bits

23:49.680 --> 23:58.080
all the other way around. And Verilog will, well, most Verilog tools will be, well, very much

23:58.080 --> 24:04.080
ignorant of that fact and just strip off some bits that are not used or padded in some way.

24:04.640 --> 24:10.400
So what you would expect from many languages where the compiler just tells you, well,

24:10.400 --> 24:15.360
this is just bullshit that you've written here. In Verilog you need some further tools to do that,

24:15.360 --> 24:22.720
actually. And variator-lynt is one of the options here. Just a random example of where you actually

24:22.720 --> 24:31.120
need insight into the variables and the constants that are being used. With variable, we now also

24:31.120 --> 24:38.640
can do something that we also know quite well from a software world. It's just have style

24:38.640 --> 24:45.200
links and stuff like that run in CI and actually give you feedback right away. And for example,

24:45.200 --> 24:51.840
here I'm having a screenshot from an open type repository, a pull request, where one of these

24:51.840 --> 24:57.280
parts actually gives you immediately feedback on, well, that's trading space, that's kind of the

24:57.280 --> 25:06.240
most boring example. But also things like rules about naming certain constructs. We don't need

25:06.240 --> 25:11.120
to go into the details of what's happening here. And I think I've seen some people from Ant Micro

25:11.120 --> 25:15.600
here before, as you can see. Where are they? There they are. That's written there. So if you have

25:15.600 --> 25:19.920
questions about variable, I think the people up there are to blame and to ask questions.

25:21.360 --> 25:29.520
Well, I've done a great job. So let's keep it at that for the moment. Front end,

25:30.240 --> 25:34.400
we're doing great in terms of chip design. So we have all the tools. We've seen, like,

25:34.400 --> 25:41.200
that the slides only always had a subset of tools that we can use. So Frontend is doing great and

25:41.200 --> 25:47.680
has been for ages. I mean, one thing I would love to see is that we just stop reinventing Verilog

25:47.680 --> 25:53.360
parsing. It's a huge language. And we have so many tools that all think they can parse Verilog. And

25:53.360 --> 25:58.160
they just can't. They just really can't. I mean, everybody thinks they just strip out that part of

25:58.160 --> 26:03.520
the standard and somebody uses it and you get these weird pipelines that just don't work anymore.

26:03.520 --> 26:09.120
So maybe a unified front end at some point in time. And I know there have been a couple attempts

26:09.120 --> 26:13.360
to actually do that. And it just leads to that situation that you now have one more front end

26:13.360 --> 26:28.720
to care about, as always. Okay. We have our logic design. We can run it on the FPGA. Sure. And

26:28.720 --> 26:34.560
in the FPGA world, there are kind of two main manufacturers of FPGAs and there's something

26:34.560 --> 26:42.640
else. So who does not know what an FPGA is? Okay. Very small number. So it's a field programmable

26:42.640 --> 26:48.880
gate array. So it's effectively a chip that you can reprogram. Let's put it like that in very

26:48.880 --> 26:56.000
simple terms. And normally you would use the tool that the vendor provides you that would be in,

26:56.000 --> 27:01.680
how would they name this day? So it would be Vivado for Xilinx, now some other company, or

27:02.720 --> 27:10.720
Quarters for Altera, now Intel. Whatever. Just get bored. Come on. Stop it. Or if you don't want to

27:10.720 --> 27:18.160
use those close tools, you can use Symbiosis or, well, formerly Simbyflow or now F4FPGA.

27:18.960 --> 27:25.360
And it gives you a reverse engineered way to actually target Xilinx 7 series FPGAs. So these

27:25.360 --> 27:32.880
are the pretty most common FPGAs. And actually do full designs, full open source, using only

27:32.880 --> 27:39.600
open source tools, and get them runnable on an FPGA. The problem there always was that kind of

27:39.600 --> 27:44.880
the programming instructions, the way how to kind of structure a program to put it on an FPGA wasn't

27:44.880 --> 27:50.480
known. That's what they reverse engineered and then put together kind of various open source tools

27:50.480 --> 28:00.240
that then allow you to actually target FPGAs. So the thing is FPGAs are pretty much like if you're

28:00.240 --> 28:09.440
trying to build a phone, but the only thing you can do is actually build that. It's nice.

28:09.440 --> 28:16.000
It's functionality. It's kind of similar. But it's pixely, you know? It's just not the right thing.

28:16.000 --> 28:26.800
And I actually outsourced that work to my niece and nephew. So it's just, well, that's what we want,

28:26.800 --> 28:34.160
don't we? We want kind of open source silicon. We want a real chip. We want this thingy, not that.

28:34.160 --> 28:44.800
So how can we do that? We need the back end. We need the physical implementation.

28:49.280 --> 28:55.920
That adds a whole lot of new complexity, of course. And that's where things become interesting.

28:56.560 --> 29:02.560
And what we want is we want to go from RTL, so that's your register transfer layer,

29:02.560 --> 29:10.720
a layer level. So that's your VeriLock to GDS2. That's a very old data format that you then send

29:10.720 --> 29:20.000
to a company that produces your chips. So that's a fad. So we want a RTL to GDS2 flow. And I have

29:20.000 --> 29:28.480
an example of one here. So we start with VeriLock on the top. We do centers. And I'm not going to

29:28.480 --> 29:34.480
explain them all in detail here, because otherwise we're going to be here for a long time. But just

29:34.480 --> 29:39.680
to demystify some of the acronyms in here. So we do our centers. That gives us our netlist.

29:39.680 --> 29:46.000
We do a static timing analysis. So to see if we have put potentially too much logic

29:46.000 --> 29:49.840
after each other so that you can't clock it anymore, that you only can clock it to

29:49.840 --> 29:55.280
kilohertz or something like that. That's what the static timing analysis does in the first one.

29:55.280 --> 30:00.000
So there is DFT, Design for Test. If you have that chip, you're going to have a hard time

30:00.000 --> 30:05.520
looking inside it. So you want some test structures inside your chip that allow you to observe what's

30:05.520 --> 30:10.720
going on. So these are typically scan chains, something that JTAG was and still is used for,

30:11.520 --> 30:16.960
apart from the many other things that JTAG is being used for. But that's what DFT does. And

30:16.960 --> 30:22.000
these scan chains are automatically inserted normally for all or most registers.

30:22.000 --> 30:28.320
And then you have that. You still have a very locked description. And then you do

30:28.320 --> 30:34.720
flow planning, placement, clock tree synthesis, optimization, and global routing. So in the end

30:34.720 --> 30:42.240
you get a number of transistors and that you connect them somehow and you optimize them

30:42.240 --> 30:50.480
in a way that kind of minimizes or maximizes power or performance or area, depending on what

30:50.480 --> 30:56.080
you're looking for. And all the things that we've skipped over so far that are now relevant in the

30:56.080 --> 31:01.360
physical world. For example, if you have that clock that goes to your chip, you always need to

31:01.360 --> 31:05.040
make sure, obviously also need to make sure that it actually gets distributed across the chip. So

31:05.040 --> 31:09.520
you just have a single pin potentially where it comes in, but it needs to be everywhere. So you

31:09.520 --> 31:14.560
have that clock tree that you need to insert somehow. Something we don't need to worry about,

31:14.560 --> 31:19.440
for example, or not that much worry about if you're doing an FPGA design or a simulation

31:19.440 --> 31:24.960
because that's something FPGA vendor has already done for us. So we are able to kind of ignore

31:24.960 --> 31:32.320
many of these things when we're just doing kind of FPGAs before. And then since we're back in

31:32.320 --> 31:37.120
the physical world and you need to manufacture them, we have antenna diodes that we need to insert.

31:37.120 --> 31:45.280
And after we've done that much processing, we're not quite sure what we got. So what we want to

31:45.280 --> 31:52.160
make sure is at this point that we actually know that still the original design is what we did.

31:52.160 --> 31:58.880
So we do a logic equivalence check. That's the LEC here. And then we do detailed routing,

32:00.640 --> 32:06.640
RC extraction, and other timing analysis. And finally, we're at GDS2 streaming. So that's when

32:06.640 --> 32:12.800
we do the final writing. And then we could be at our GDS2. Easy, isn't it? So just need to kind

32:12.800 --> 32:20.160
of put those tools up together. Done. Beautiful. Why didn't we do that ages ago? I guess we were

32:20.160 --> 32:28.000
too lazy to just do that. Well, the reason is a different one. I just skipped out one part of the

32:28.000 --> 32:38.720
picture. And that's one input up here. That's the PDK, the process design kit. And this is something

32:38.720 --> 32:44.960
you get from a fab. And if you don't get it, you don't get it. You're not going to do any of that.

32:46.320 --> 32:55.520
And I was standing here in 2016, a couple years ago. These were some of the slides.

32:55.520 --> 33:03.600
Style change as well. So we have the process design kit. We are getting there standard cell

33:03.600 --> 33:10.320
libraries. We get a fair amount of design rules. Like if you have ever done kind of PCB manufacturing,

33:10.320 --> 33:14.320
printed circuit boards, you also get a number of rules that you need to obey so that they can

33:14.320 --> 33:21.040
actually manufacture it. It's typically not that long that list. And if you want to fab a chip,

33:21.040 --> 33:27.120
the list is significantly longer. Electric good parameters. So you get it from the foundry. And

33:27.120 --> 33:33.520
you need to sign an NDA for that. That's where we stopped in 2016. That's where we stopped in 2017.

33:33.520 --> 33:39.760
And that's why we said back then, you can't do it as a hobbyist. So just there's no way of doing

33:39.760 --> 33:47.200
that. There were some companies who did it. And low risk was one of them. If you are kind of big

33:47.200 --> 33:53.280
enough, they still allow you to sign that NDA. But that's where we stopped. And then there was

33:53.280 --> 34:05.680
this talk. This was two years ago now. It's 2020, I think. So that's even more. Yeah, let's say two

34:05.680 --> 34:14.800
years plus minus. And where Tim Ansell working at Google was presenting the Skywater PDK. So this is

34:15.680 --> 34:20.880
for the first time ever that, well, at least in the last 20 years, let's put it this way,

34:20.880 --> 34:30.960
a process design kit. So the rules from Foundry were open source. And they are available on GitHub

34:30.960 --> 34:40.320
right there. So let's think and switch over here. Can I? No, I can't. Let's keep it up here. So yes,

34:40.320 --> 34:45.200
you can download them from GitHub. So now you solve that one problem. You actually can now

34:45.200 --> 34:52.480
manufacture a fully open source chip because you do have these rules. The downside here is this is

34:52.480 --> 35:00.800
a 130 nanometer PDK. If you're looking at current three, five nanometer,

35:02.240 --> 35:09.360
chips in your mobile phone, potentially. So when was 130? 130 was this time.

35:09.360 --> 35:17.280
So these are Pentium 4, so 130 nanometer roughly. So that's a net burst architecture.

35:18.560 --> 35:25.200
AMD roughly at the same time. So that's around 2002, where that technology was first introduced.

35:27.120 --> 35:34.080
Maybe you still have some of those PCs actually around. But nonetheless,

35:34.080 --> 35:41.200
this process is still being manufactured. Otherwise, Foundry wouldn't be able to produce

35:41.200 --> 35:45.760
something out of that. So they still have processing lines that actually use that flow.

35:47.520 --> 35:56.000
So the other thing that was happening is that, boobies said, not only we talked to that Foundry

35:56.000 --> 36:03.360
and they gave us this PDK away, we're also funding a shuttle. So that is effectively a

36:03.360 --> 36:08.720
cost effective way to produce chips together with others on a single wafer. And I said we're doing

36:08.720 --> 36:13.920
a couple of those every year. And if you submit a open source design, you get that manufactured for

36:13.920 --> 36:19.840
free, really kind of free as in no cost at all, using only open source tools. So free as in real

36:19.840 --> 36:26.640
free as well. So that for the first time made it possible for everybody who only has internet access

36:26.640 --> 36:32.000
and doesn't need any cash at all to get a chip manufactured. So these are obviously not volume

36:32.000 --> 36:36.960
chips. So these are kind of experimental chips for you to actually give it a try. But you can

36:36.960 --> 36:47.600
for the first time ever, you can. So this was a old Arctic load found that from these 130 nanometer

36:47.600 --> 36:54.400
chips, you know, kind of in a couple of years, they said that was in 2000, we should be able

36:54.400 --> 37:00.480
to reach eight to 10 gigahertz on slightly better note. So I think that was around 70 nanometers.

37:00.480 --> 37:06.960
So if they said that would be possible, I mean, we are only like 18 years behind that prediction.

37:06.960 --> 37:12.480
Now, let's see what we in the open source actually can do. And probably not going to reach this eight

37:12.480 --> 37:18.800
gigahertz. But there's a fair amount of room in those old process notes still to be optimized and

37:20.000 --> 37:27.760
still to be explored. So let's do some exploring, actually. We've seen that picture before of that

37:27.760 --> 37:33.920
flow. You can get that flow very easily. You do a get clone of the open lane repository, you

37:34.720 --> 37:40.400
CD into it, you run make, make test and make mount and that gives you a Docker container.

37:41.200 --> 37:47.600
And that Docker container is something I have open right here. So this is the open lane Docker

37:47.600 --> 37:57.760
container. And since we are reasonably short on time, I'm not gonna run it in full. So I

37:58.560 --> 38:04.960
did run the flow. So this is a trivial design. So that's SPM, a serial parallel multiplier.

38:04.960 --> 38:19.120
So this is a very small piece of code that we will then turn into a chip design. It's part of

38:19.120 --> 38:25.040
the standard demo. So I guess you can give that a try as well. So let's have a look.

38:25.040 --> 38:36.240
The process, I think it runs through in a minute or after two minutes for that trivial design.

38:36.960 --> 38:46.400
For larger design, it takes an hour for a S core and a full SLC taking a couple 10, 20 hours,

38:46.400 --> 38:54.080
depending on how you're doing. It's still not the end of the world. So that was boring somewhere,

38:54.080 --> 39:02.800
isn't it? Let's have a look at the output right away. So it comes with a

39:08.400 --> 39:17.280
GDS viewer. So GDS is the output format, as we said. And just starting from that very log

39:17.280 --> 39:24.800
and using only open source components, you get the full GDS. And that is confusing because

39:24.800 --> 39:31.360
physics are confusing. So let's see if we can get rid of some things here. I'll just have a look at

39:31.360 --> 39:36.320
the left side first. So we see the different cells that are being used. So the sky water foundry

39:36.320 --> 39:43.120
provides us with a number of ands and ors and nots and other things optimized for different

39:43.120 --> 39:50.320
process corners. And they get chosen and then inserted into that design. So let's get rid of

39:50.320 --> 39:55.920
a bit of the stuff that we actually need for physics. So decaps, who needs those? Filers,

39:55.920 --> 40:02.640
nobody said either. So that already gives us a slightly better picture. Maybe we can get rid of

40:02.640 --> 40:11.760
some of those metal layers, the connectivity. I mean, who needs that? And we see we can get closer

40:11.760 --> 40:25.440
to the actual interesting parts. So that is effectively your file that you sent to the foundry.

40:26.080 --> 40:31.360
And you can do that as set free of cost using the chartered program or if you don't want to use that,

40:33.200 --> 40:40.560
you can also pay a company called eFabulous to then fab that for you. As that using only the

40:40.560 --> 40:47.920
open source tools. Since we are really short on time, here are the things that you can have

40:47.920 --> 40:54.640
look and play with. You also, if you don't want to install anything locally, you can have a look

40:54.640 --> 41:02.640
at that link. That gives you a Jupyter notebook, a online way to just actually play around and just

41:02.640 --> 41:08.320
in your browser write some VHDL or Verilog actually in that case and synthesizes and have a look at

41:08.320 --> 41:17.440
the GDS2 in the end. Only in your browser, nothing else needed. There is a project called

41:17.440 --> 41:23.040
Tiny Tape Out where you can get a very, very small chip kind of manufactured and learn how to do it.

41:23.840 --> 41:29.280
And they have a very, very nice GitHub action set up. And I need to show that because it's just

41:29.280 --> 41:38.960
a fantastic. So apart from kind of you have your Verilog and then in the end your GDS, you also get

41:38.960 --> 41:50.640
a built-in 3D GDS viewer that allows you to zoom through your design and see the metal layers,

41:51.200 --> 41:57.360
see everything in there and let's get rid of some of the, oops, there was a wrong button. Oh,

41:57.360 --> 42:05.200
how can I help you? Some of the layers, so that was remove the details and the decaps and then

42:05.840 --> 42:10.960
remove the cell geometry as well. So that's how your standard cells know. And we can actually

42:10.960 --> 42:17.040
look at them and see what they are and also look at the different layers. So that's really cool.

42:17.040 --> 42:21.680
And that shows if you have now only open source tools, you can do all that. You can do that

42:21.680 --> 42:27.600
in a GitHub action where before when you actually had licenses and license servers and all that

42:27.600 --> 42:33.200
crap that comes with software that you need to buy for a lot of money, it's not just expensive,

42:33.200 --> 42:39.120
it's also pain to use and stuff like that would just be possible. So open source is here with

42:39.120 --> 42:49.040
that stuff and it's staying, I'm telling you. So we got that one. And again, the link is there.

42:49.040 --> 42:56.720
So let's have a look at who's actually doing that. So I had a look at some GitHub stats.

42:57.920 --> 43:03.920
So Yoast is the Swintest tool and actually quite old tool. So there are 10 people. Just again,

43:03.920 --> 43:10.240
it's a random month, it's the last month roughly. So 10 people working there. So that's a healthy

43:10.240 --> 43:17.360
community of people adding things. It's not a huge community. And this is a thing we'll see

43:17.360 --> 43:25.840
repeating very later, the simulation tool. 20 people in the last month pushing and doing stuff.

43:27.040 --> 43:35.200
CocoaDB, not that many people but still. The Skywater PDK, now that's the manual effectively

43:35.200 --> 43:41.040
of your PDK. And that doesn't see that many changes. And I think that's one of the areas where

43:41.680 --> 43:45.920
more people could get involved and actually where we have as a community more to figure out because

43:45.920 --> 43:52.320
that description, that PDK is not complete and not error free. Like in any document that you write,

43:52.320 --> 43:58.560
there are probably going to be errors. So we're still looking for more ways how to get people

43:58.560 --> 44:04.480
involved and fix those kind of even small errors. So OpenLane, we've seen that flow.

44:06.320 --> 44:11.680
Recently active as well. We've come OpenRoad, which is within OpenLane, they always make it

44:11.680 --> 44:18.400
like sound similar. But OpenRoad is kind of the majority of those physical design tools and

44:18.400 --> 44:26.640
bundling them together. What OpenRoad has an idea, it was funded by DARPA. And the idea is to be able

44:26.640 --> 44:34.320
to go from an RTL to a GDS2 in 24 hours with no human in the loop, which is something very

44:34.320 --> 44:39.680
different from the normal hardware world where you always have tools that are, well, you can

44:39.680 --> 44:44.000
put it in two ways. You can say the tools are too crappy, so you need to go manually in and fix some

44:44.000 --> 44:48.240
stuff in the way. Or you say the tools are good enough and you just need that human to actually

44:48.240 --> 44:55.600
give it that special touch because hardware is just so difficult. It feels like at times

44:55.600 --> 45:02.080
when you set a compiler isn't exactly good enough to actually really compile my software. So at

45:02.080 --> 45:07.200
times I just go in and just do a bit of hand assembly editing because there's corners like

45:07.200 --> 45:12.080
around memory accesses. So they just need a bit of manual work. So that's how hardware design

45:12.080 --> 45:15.280
works. And that's what they want to change is just make it completely automated.

45:18.160 --> 45:24.960
Just for comparison, this is how things on the Linux kernel would look. So the hardware

45:24.960 --> 45:32.320
community is significantly slow, smaller than the software community. And that's why Ruby,

45:32.320 --> 45:38.880
for example, is funding some of these things. Finding hardware engineers is quite tricky. And

45:38.880 --> 45:43.200
there's just tons of software engineers and tons of good ideas that have been explored and tried

45:43.200 --> 45:48.080
in the software world. So we want to bring that to hardware as well and make it accessible there.

45:49.600 --> 45:56.720
We'll look at very later. And we also see more and more chip designs being submitted to OpenMPW.

45:56.720 --> 46:02.000
So that's the free, as in cost, shuttle program where you can just submit your designs.

46:02.000 --> 46:07.280
So whenever somebody learns, typically by themselves, how to do a chip design and then

46:07.280 --> 46:13.520
submit it, it kind of shows up in that graph. So there have been eight free of those manufacturing

46:13.520 --> 46:21.840
runs now. And there is more to come. The first chips are back. So the MPW1 chips. You see this

46:21.840 --> 46:29.360
is a fair amount of lead time. It takes typically at least two and a half months, roughly, to get

46:29.360 --> 46:34.480
chips back from fab. But then you want to test them and you want to actually potentially fix

46:34.480 --> 46:39.920
errors. And these OpenMPW ones, since all the tooling is new, have still a fair amount of

46:39.920 --> 46:43.600
problems in them. So bringing them up is not quite trivial. And they don't fully work.

46:44.320 --> 46:48.320
But that's what we're learning. And that's why we kind of do that repeatedly and again and again.

46:48.320 --> 46:52.160
So we don't need to be fully correct the first time. We just have a couple more tries.

46:52.160 --> 46:59.840
So looking at the future, always hard. We're going to see innovation. We're going to see

46:59.840 --> 47:03.840
change that nobody predicted. And that's the good thing about making this open source. So somebody

47:03.840 --> 47:09.920
has an idea, can actually give it a try and just see if they can do it. Pretty much before, if you

47:09.920 --> 47:14.080
wanted to do chip design, you had to be within a large company that did it the way they always did.

47:14.080 --> 47:19.120
So you had to do their product, end of story. So there is no that much unpredictable innovation.

47:19.120 --> 47:27.040
Okay. Tools getting more accessible. We can actually get access to them. And finally,

47:27.040 --> 47:32.240
we can actually revolutionize learning about hardware. Before, when I was taking a university

47:32.240 --> 47:38.320
course, it was kind of very boring theoretical. So you had kind of course materials from 10 years

47:38.320 --> 47:42.960
ago from somebody who has never seen a chip being made in their life because they just actually

47:42.960 --> 47:47.680
used the course material that they got 20 years ago. And that's just how teaching evolves. And

47:47.680 --> 47:52.960
that's kind of the teaching we see in very many universities about hardware design. So they might

47:52.960 --> 47:57.280
have a VHDL or Verilog course, but it's so far from reality. It's kind of not even funny.

47:58.640 --> 48:05.360
So we can actually now learn how to do it the real way. There are some news,

48:05.360 --> 48:10.240
letter links up there. And finally, if you actually want to take a paid for learning course

48:10.240 --> 48:15.520
with all those open source tools, there is the zero to AC course from Mad Van. So he helped me

48:15.520 --> 48:22.640
actually preparing some slides to have a look at that stuff. If you're looking for in-person

48:22.640 --> 48:28.720
events, there is a lecture coming up in the US, a open source hardware conference that the Fosse

48:28.720 --> 48:34.960
Foundation has been organizing for a number of years. And there is work off coming back after

48:34.960 --> 48:39.760
COVID, the main open source hardware conference in Munich this year. I think we haven't announced

48:39.760 --> 48:45.520
that very widely at September 15 and 16. And just stay for the October 1st. Just take your hotel

48:45.520 --> 48:52.880
room a couple more days. And this is going to be a great experience. We end with a quote that I

48:52.880 --> 48:58.720
found. An atmosphere of excitement and anticipation pervades these fields. Workers from many backgrounds,

48:58.720 --> 49:04.080
computer scientists, electrical engineers, physics, physicists are collaborating on a common problem

49:04.080 --> 49:10.640
area which has not yet become classical. This territory is vast and largely unexplored. The

49:10.640 --> 49:17.520
rewards for those who simply press forward are great. See how I go around. So this was written

49:19.280 --> 49:28.000
in 1978. And with there again with open source world, let's make this open source

49:28.000 --> 49:34.240
ship design a reality. We have all the necessary ingredients. We have all the necessary tools.

49:34.240 --> 50:01.200
Let's make it happen. Thank you.

50:04.240 --> 50:31.200
Thank you.
