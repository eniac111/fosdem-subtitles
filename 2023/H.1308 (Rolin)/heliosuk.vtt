WEBVTT

00:00.000 --> 00:06.880
Thank you.

00:06.880 --> 00:11.480
So hi, my name is Drew, and I'd like to talk to you today about a new microkernel I've

00:11.480 --> 00:14.000
been working on called Helios.

00:14.000 --> 00:19.120
For context, I work at a place called Sourceset, and I'm the project lead for a new programming

00:19.120 --> 00:21.120
language called Hair.

00:21.120 --> 00:28.040
And I've done many other projects, but that's what's relevant for today.

00:28.040 --> 00:31.280
Helios is a new microkernel.

00:31.280 --> 00:35.080
It's inspired a lot by SEL4, but it differs in many ways.

00:35.080 --> 00:39.920
It's written in this hair programming language that I mentioned, and one of the main motivations

00:39.920 --> 00:43.960
for it is to find out if we can use the hair programming language to write microkernel,

00:43.960 --> 00:46.200
or any kind of kernel, really.

00:46.200 --> 00:52.320
Presently it runs on X8664 and ARM64, and we're thinking about RISC-V in the foreseeable

00:52.320 --> 00:53.320
future.

00:53.320 --> 00:56.360
In terms of the footprint of this kernel, it's pretty small.

00:56.360 --> 01:00.120
The portable code is about 8,500 lines of code.

01:00.120 --> 01:05.040
Each architecture adds about another 3,000 lines of code, all hair code, and then add

01:05.040 --> 01:09.160
on top of that the boot loaders, which are also written in hair, and it's a pretty small

01:09.160 --> 01:10.160
footprint.

01:10.160 --> 01:17.840
We've been working on it for about nine months now, and we use the GPL3 license.

01:17.840 --> 01:21.280
So again, about nine months of progress so far.

01:21.280 --> 01:26.920
Where do we stand in terms of functionality is about here.

01:26.920 --> 01:31.880
We have capability-based security, and the capabilities do work, similar to what SEL4

01:31.880 --> 01:37.600
does, and also similar to SEL4, we have inter-processed communication working using endpoints and

01:37.600 --> 01:42.240
notifications, very similar to SEL4 with some notable differences.

01:42.240 --> 01:48.800
We have scheduler work, we're in user space, and we have multiprocessing, but we don't

01:48.800 --> 01:50.160
have symmetric multiprocessing.

01:50.160 --> 01:54.320
We have only one core at the moment, but we'll do SMP fairly soon.

01:54.320 --> 01:59.240
We also have all of the necessary riggings in place for drivers in user space, so we

01:59.240 --> 02:06.240
have access to ports on x86, and we have memory and map.io support, as well as iRQs are rigged

02:06.240 --> 02:07.920
up.

02:07.920 --> 02:13.360
For booting up the kernel, we currently support EFI on ARM, and Multipoot on x86.

02:13.360 --> 02:18.860
We'll be doing EFI on x86 as well in the future, and our plan is to also do EFI on RISC-V,

02:18.860 --> 02:24.920
so we'll use EFI as the default approach for booting Helios in the future.

02:24.920 --> 02:30.000
Why should we be thinking about writing a new macrokernel, or a new kernel of any sort?

02:30.000 --> 02:35.000
I imagine that for this particular dev room, I don't need to give too many reasons, but

02:35.000 --> 02:39.400
for the sake of anybody who's maybe watching online, the first point is pretty obvious.

02:39.400 --> 02:43.440
It's really fun to write kernels, and that's kind of reason enough, so I'm having a great

02:43.440 --> 02:46.480
time working on it, and that's enough for me.

02:46.480 --> 02:51.000
But also importantly, we've been working on this programming language, Herr, for about

02:51.000 --> 02:55.320
three years now, and it's a systems programming language, and one of our goals is to be able

02:55.320 --> 02:58.800
to write things like kernels, and so in order to prove that we have achieved this goal,

02:58.800 --> 03:02.920
we have to write a kernel with it, and so Helios is that kernel.

03:02.920 --> 03:08.400
I also am a big fan of SCL4's design, but I also have some criticisms of it, and I'm

03:08.400 --> 03:12.160
curious if we do a kernel which is inspired by SCL4, can we make some improvements on

03:12.160 --> 03:14.320
its design?

03:14.320 --> 03:19.840
And if we were to be particularly ambitious, could we perhaps do better than Linux?

03:19.840 --> 03:21.760
We'll see.

03:21.760 --> 03:31.020
I should also point out that this slide deck is going to cover a lot of details which maybe

03:31.020 --> 03:35.160
will seem redundant to people who are already familiar with the design of SCL4, and that

03:35.160 --> 03:39.960
could be a problem with this audience, but please bear with me while I explain things

03:39.960 --> 03:43.520
that you already understand at some point in the future.

03:43.520 --> 03:48.360
So the HAIR programming language, this is the pitch from the website, I won't read it

03:48.360 --> 03:53.080
out to you, but essentially it's a very simple language which is very close to C in terms

03:53.080 --> 03:58.640
of design, but with a lot of benefit of 50 years of hindsight of what could be made better

03:58.640 --> 04:05.400
about C. But compared to other C alternatives that are floating around today like Rust and

04:05.400 --> 04:10.160
Zig and Nim and so on, I would say HAIR is much, much closer to C's original ideas than

04:10.160 --> 04:16.800
any of these other attempts, but it improves in many respects like dealing with modules

04:16.800 --> 04:22.520
and error handling and bounce checked things and some safety features.

04:22.520 --> 04:24.400
So it improves in a number of respects.

04:24.400 --> 04:27.320
It's also very, very simple.

04:27.320 --> 04:32.440
So here we have some more line counts for people who like the line counts.

04:32.440 --> 04:36.600
The HAIR compiler is 18,000 lines of code in C11.

04:36.600 --> 04:41.520
The back end that we use, it's not LLVM, we use CUBE as our back end, is another 12,000

04:41.520 --> 04:43.280
lines of C99.

04:43.280 --> 04:45.840
And then we use binutils for the linker and assembler.

04:45.840 --> 04:46.840
And that's it.

04:46.840 --> 04:52.440
We support three targets, X8664, AR64 and RISC564, which is no coincidence that those are the

04:52.440 --> 04:55.840
targets I'm working on for the macrokernel.

04:55.840 --> 05:00.600
We intend to add more, but this is where the language is at.

05:00.600 --> 05:08.200
I started, you know, again, I started HAIR specifically to work on this kind of project.

05:08.200 --> 05:12.320
And this project exists to validate the language design for this use case.

05:12.320 --> 05:16.160
And also because it's fun and maybe it could be useful.

05:16.160 --> 05:20.160
For those of us who have never seen any HAIR code before, I just have a little snippet

05:20.160 --> 05:22.800
here so you can get a vague idea of what it looks like.

05:22.800 --> 05:26.200
Again, not going to explain this in too much detail, but if you're familiar with C, a lot

05:26.200 --> 05:28.080
of things will seem familiar to you.

05:28.080 --> 05:31.100
And you can probably guess, you know, the double colon does namespaces.

05:31.100 --> 05:33.480
Maybe you can guess what the no return tag does.

05:33.480 --> 05:35.520
It's fairly straightforward programming language.

05:35.520 --> 05:36.800
And this is what it looks like.

05:36.800 --> 05:40.160
The code sample we're looking at here is the portable kernel entry point.

05:40.160 --> 05:44.160
So it starts at the boot letter entry point and then the arch specific entry point.

05:44.160 --> 05:50.480
This is the first line of portable code that runs when you boot the kernel.

05:50.480 --> 05:54.600
So with the context out of the way, let's talk about Helios itself.

05:54.600 --> 05:59.640
We're going to go over a number of things here with respect to the design of Helios

05:59.640 --> 06:01.040
and the implementation of Helios.

06:01.040 --> 06:04.840
So I'm going to talk about our approach to capabilities and on memory management and

06:04.840 --> 06:08.720
some other things specific with how various capabilities actually work like processes

06:08.720 --> 06:12.040
and threads and talk about inter-process communication.

06:12.040 --> 06:18.560
And then also talk a little bit about the implementation as well, not just the design.

06:18.560 --> 06:22.440
So here is the big picture in terms of the implementation.

06:22.440 --> 06:27.040
Again, those who are familiar with SEL4 will find no surprises on this slide.

06:27.040 --> 06:31.960
But essentially, access to all system resources, including kernel objects, is semantically

06:31.960 --> 06:33.600
governed by user space.

06:33.600 --> 06:39.160
And we use the MMU to isolate user space processes from each other and to enforce this capability

06:39.160 --> 06:40.400
model.

06:40.400 --> 06:45.080
On system boot up, the kernel enumerates all of the resources on the system, all of the

06:45.080 --> 06:47.960
memory and all of the IO ports and all the IRQs.

06:47.960 --> 06:52.520
And it prepares capabilities that entitle the bearer to access these resources.

06:52.520 --> 06:57.080
And then it hands all of these off to the first process, the init process, which can

06:57.080 --> 07:03.120
then subject to its own user space policy decisions, choose how to allocate those resources

07:03.120 --> 07:12.760
to various processes in such a way that it can provide a secure system.

07:12.760 --> 07:15.680
So here's a look at our capabilities.

07:15.680 --> 07:21.960
Here's an example here on the left of a fake physical address space.

07:21.960 --> 07:25.040
And on the right shows the kind of state that we'd be storing in this.

07:25.040 --> 07:29.440
So here we have a number of physical pages, one for a capability space, one for a virtual

07:29.440 --> 07:34.680
address space, for a task, a bunch of memory pages, some free memory, and so on.

07:34.680 --> 07:38.180
And in this physical memory, we store the state you see on the right.

07:38.180 --> 07:43.980
So the C space here stores a list of capability slots, very similar to SEL4.

07:43.980 --> 07:47.000
And in those capability slots is a very small amount of state.

07:47.000 --> 07:50.840
They're each, I believe, 64 bytes, so there's not a whole lot to store there.

07:50.840 --> 07:55.320
In this case, a task, which is like a thread or a process, stores a pointer to another

07:55.320 --> 07:59.440
physical memory page where the bulk of its state really lives.

07:59.440 --> 08:06.540
In this case, we have an example of some registers for XDD6.64.

08:06.540 --> 08:12.920
And the access to this state is gated behind the MMU, so only the kernel itself can directly

08:12.920 --> 08:15.120
read from this kind of physical memory.

08:15.120 --> 08:21.000
But then user space, who maybe this process that we're looking at has semantic ownership

08:21.000 --> 08:25.400
over the C space and this V space, they can invoke the kernel to do operations against

08:25.400 --> 08:27.960
those things, but they can't actually directly access the memory.

08:27.960 --> 08:31.920
Instead, the virtual memory can only contain certain kinds of capabilities or certain kinds

08:31.920 --> 08:33.160
of physical memory pages.

08:33.160 --> 08:38.080
So that could be arbitrary general purpose memory, or it could be memory mapped IO, could

08:38.080 --> 08:40.080
end up in their address space.

08:40.080 --> 08:45.400
So while they have semantic ownership over these other capabilities, the actual state

08:45.400 --> 08:53.160
behind them is not accessible to user space.

08:53.160 --> 08:58.440
So in order to work with these capabilities that the user space has semantic ownership

08:58.440 --> 09:01.760
over, it uses, of course, the syscall API.

09:01.760 --> 09:05.020
And Helios has a very, very small syscall API.

09:05.020 --> 09:06.760
It is a microkernel, after all.

09:06.760 --> 09:10.240
We have 14 syscalls, which I have enumerated here.

09:10.240 --> 09:12.800
Twelve of these are for working with capabilities.

09:12.800 --> 09:16.560
And again, if you're familiar with SEL4 here, there's probably no surprises here, except

09:16.560 --> 09:23.280
maybe for syspole, which I'll talk about later.

09:23.280 --> 09:28.840
So here is a little example of how you might invoke a capability on x86 to make use of

09:28.840 --> 09:30.720
the microkernel's API.

09:30.720 --> 09:34.780
Again, you're going to be making a syscall here at the end.

09:34.780 --> 09:38.520
And here we're going to be filling up registers and memory buffers with the information we

09:38.520 --> 09:39.520
want to use.

09:39.520 --> 09:44.720
So this code is going to invoke the vspace map operation, which accepts a page capability,

09:44.720 --> 09:49.720
a virtual address, and a list of mapping flags, like writer or execute.

09:49.720 --> 09:55.600
And its goal is to map a page of physical memory into a slot in a virtual address space.

09:55.600 --> 10:00.800
And in order to invoke this operation, the caller needs to have access to a vspace capability,

10:00.800 --> 10:04.600
which they're going to modify, and a page capability, which they're going to map.

10:04.600 --> 10:07.440
And these capabilities are provided here in two different ways.

10:07.440 --> 10:11.720
The object being invoked is the vspace, and it gets its own register, RDI, which is the

10:11.720 --> 10:14.240
first API register.

10:14.240 --> 10:21.760
The page which is being used, again, similarly to SEL4, is going to be placed into that process's

10:21.760 --> 10:27.660
IPC buffer, which is done here with a fake capability address for the page.

10:27.660 --> 10:33.160
And then we have additional arguments, like the message tag, which contains the operation

10:33.160 --> 10:37.240
name, the number of capabilities, and the number of parameters, and then any additional

10:37.240 --> 10:38.760
arguments to the function.

10:38.760 --> 10:44.320
You run syscall, and the operation happens.

10:44.320 --> 10:48.840
I also want to talk a little bit about the specifics of inter-process communication.

10:48.840 --> 10:55.480
So we have two approaches, and I'll first look at endpoints, which they are kind of

10:55.480 --> 10:57.480
a generalized form of IPC.

10:57.480 --> 11:00.360
And the way you use them is very similar to how you use chronologics.

11:00.360 --> 11:03.840
In fact, the interface is uniform.

11:03.840 --> 11:08.240
But it can send a set of registers or a set of capabilities between tasks.

11:08.240 --> 11:11.720
So one task can transfer a capability to another task.

11:11.720 --> 11:15.780
There is synchronous, so calling send on an endpoint or calling receive on an endpoint

11:15.780 --> 11:19.240
will block until the two tasks run debut.

11:19.240 --> 11:23.960
And if there are many senders or many receivers, then the one who has been blocked the longest

11:23.960 --> 11:28.780
will wake up, so you can have many processes, maybe doing some kind of load balancing operation

11:28.780 --> 11:31.120
against IPC operations.

11:31.120 --> 11:34.040
And also, SEL4 style call and reply is supported.

11:34.040 --> 11:38.160
So if one task does a call rather than a send, then it immediately blocks waiting for the

11:38.160 --> 11:43.560
reply, which is guaranteed to go back to the same thread.

11:43.560 --> 11:49.000
I have here a more detailed example of exactly how that kind of IPC interaction looks on

11:49.000 --> 11:50.600
Helios.

11:50.600 --> 11:55.080
So I have here on the left one task, and on the right two tasks that want to communicate

11:55.080 --> 11:56.400
with each other.

11:56.400 --> 12:00.280
Sometimes the text which is in black is taking place in user space and the text in red is

12:00.280 --> 12:02.560
taking place in kernel space.

12:02.560 --> 12:08.680
So let's say task two is a daemon or a service of some kind which wants to provide a service,

12:08.680 --> 12:13.600
and so it's going to essentially have its main IELP loop call sys receive and then block

12:13.600 --> 12:16.040
until somebody has worked for it to do.

12:16.040 --> 12:20.800
Task one wants to be a consumer of that interface, so it will invoke sys call, and the kernel

12:20.800 --> 12:24.960
will notice that task two is blocked waiting for somebody to call it.

12:24.960 --> 12:29.960
And so the kernel will perform the copy of registers, move any capabilities as necessary,

12:29.960 --> 12:34.160
unblock task two and then block task one while they wait for task two to process the message

12:34.160 --> 12:37.240
and prepare a reply, which is what happens next over here.

12:37.240 --> 12:39.960
The sys call returns from task two.

12:39.960 --> 12:43.720
They process the IPC request according to however they implement their services, and

12:43.720 --> 12:48.520
they call the replies sys call, which copies the reply registers back to task one, very

12:48.520 --> 12:53.080
similar to this fourth step, and then unblocks task one, and then both of them can proceed

12:53.080 --> 13:01.120
onwards with whatever CPU time they're given.

13:01.120 --> 13:04.300
Another interesting feature we have in terms of endpoints, which is one of the things that

13:04.300 --> 13:09.920
distinguishes Helios from SCL4, is support for a pull-like interface.

13:09.920 --> 13:15.020
Similar to Unix's pull-on file descriptors, Helios lets you pull on capabilities.

13:15.020 --> 13:21.240
So this is an example from the serial driver that I implemented for the standard x86 com

13:21.240 --> 13:22.240
ports.

13:22.240 --> 13:25.120
It has two capabilities that mainly cares about.

13:25.120 --> 13:30.280
It has an endpoint capability that it uses to implement its API for consumers of the

13:30.280 --> 13:31.280
serial port.

13:31.280 --> 13:34.920
So if you want to request a read or a write from serial, you'll send a message to this

13:34.920 --> 13:35.920
endpoint.

13:35.920 --> 13:39.840
And then it has an IRQ handler for when the serial port says it's ready to receive or

13:39.840 --> 13:41.800
transmit more data.

13:41.800 --> 13:45.320
And you can prepare a list of capabilities you're interested in and a list of events

13:45.320 --> 13:48.240
you're interested in and block on pull.

13:48.240 --> 13:51.760
And then when one of those is ready to be done, you can call it and it's guaranteed

13:51.760 --> 13:56.600
not to block, very similar to the Unix pull syscall.

13:56.600 --> 14:02.600
And again, I think this is, for me, one of the more notable improvements and derivations

14:02.600 --> 14:06.340
from the SCL4 model.

14:06.340 --> 14:11.560
And I mentioned this earlier, but this interface for doing endpoints and for invoking kernel

14:11.560 --> 14:17.880
objects like virtual address spaces is uniform between user space endpoints and kernel objects.

14:17.880 --> 14:23.240
So it is, for example, possible for a user space process to create a set of endpoints

14:23.240 --> 14:27.960
and then use them to implement an API which is identical to the kernel API.

14:27.960 --> 14:32.080
And if that process is the parent of some other process which thinks it's talking directly

14:32.080 --> 14:35.600
to kernel, it can be sandboxed according to whatever kind of policy you want.

14:35.600 --> 14:41.240
So the kernel is using this API which is uniform with the way that user space communicates

14:41.240 --> 14:46.140
with itself and thus user space can fill the role of the kernel in sometimes.

14:46.140 --> 14:50.840
This can, for example, allow you to very easily run several different Helio systems on the

14:50.840 --> 14:58.720
same computer at once without going to virtualization, which is kind of interesting.

14:58.720 --> 15:04.480
So here I have a little bit more detail on capabilities in particular and the implementation

15:04.480 --> 15:07.880
that some of our capability objects use.

15:07.880 --> 15:12.480
Here we have a capability space on the left which is, again, a little bit distinct from

15:12.480 --> 15:13.480
SCL4.

15:13.480 --> 15:15.120
We don't use guarded page tables.

15:15.120 --> 15:17.040
It's more like a file descriptor table.

15:17.040 --> 15:24.040
It's just zero to however many slots are allocated in that capability space and the process invokes

15:24.040 --> 15:28.280
a capability by its number, not by its address.

15:28.280 --> 15:33.600
Here we have an example of slots where we have a number of things which are preallocated,

15:33.600 --> 15:36.680
but then notably we also have some empty capability slots.

15:36.680 --> 15:41.280
And another derivation from the SCL4 model is that we support capability allocation in

15:41.280 --> 15:42.280
the kernel.

15:42.280 --> 15:46.360
We do this by maintaining inside of empty capabilities a free list.

15:46.360 --> 15:51.960
And so when you invoke an endpoint or you want to allocate a capability, you can set

15:51.960 --> 15:57.760
the capability address to the maximum possible address and the kernel will allocate one for

15:57.760 --> 15:58.760
you using the free list.

15:58.760 --> 16:02.740
You don't have to worry about that state and user space, which is, I think, a very nice

16:02.740 --> 16:08.780
convenience to have and very easy to implement as well.

16:08.780 --> 16:12.560
This is a list of the capabilities that we have implemented.

16:12.560 --> 16:16.280
On the left here is a list of all the capabilities which are available on every architecture.

16:16.280 --> 16:21.460
We have things like memory, device memory, IPC capabilities, threads, and so on.

16:21.460 --> 16:24.760
And then on the right we have a number of additional capabilities which are specific

16:24.760 --> 16:25.760
to each port.

16:25.760 --> 16:33.400
In this case I've listed the capabilities which are used on x86-64.

16:33.400 --> 16:37.280
I'm going to look at just a few of these.

16:37.280 --> 16:39.320
First I want to talk about memory management.

16:39.320 --> 16:45.680
Again, very similar to how we use capability allocation with the C space in the kernel

16:45.680 --> 16:46.920
using a free list.

16:46.920 --> 16:52.320
We also derivate from SEL4 in that general purpose memory uses a free list as well so

16:52.320 --> 16:56.660
you can allocate pages without trying to keep track of a watermark, without trying to reset

16:56.660 --> 16:59.320
your watermark or divide it into smaller objects.

16:59.320 --> 17:03.240
We have a free list of pages so you can just allocate pages which is quite nice.

17:03.240 --> 17:09.520
The only reason this slide is here is to tell you how it differs from SEL4.

17:09.520 --> 17:14.880
We also have address space capabilities, vspaces, which is again similar to SEL4.

17:14.880 --> 17:20.120
In fact, it's so similar that we've cargo-culted this constraint that you can't share page

17:20.120 --> 17:21.120
tables.

17:21.120 --> 17:25.880
I don't really know why SEL4 does that, but once we understand then we will probably either

17:25.880 --> 17:28.600
commit to this or change our mind.

17:28.600 --> 17:32.760
But we have virtual address space capabilities which can be used to manage processes.

17:32.760 --> 17:38.000
And then we have tasks which can be either a thread or a process or something else if

17:38.000 --> 17:39.560
you come up with something creative.

17:39.560 --> 17:44.000
But essentially a task just has a capability space which is optional so that I can do IO

17:44.000 --> 17:48.840
and invoke capabilities as an address space and it receives some CPU time when it is configured

17:48.840 --> 17:49.840
appropriately.

17:49.840 --> 17:51.800
And again, we don't have SMP support yet.

17:51.800 --> 17:53.720
We would like to do that soon.

17:53.720 --> 17:55.800
And for now the scheduler is very simple.

17:55.800 --> 18:01.080
We just have a round robin scheduler, but we would like to expand that in the future.

18:01.080 --> 18:06.280
It should be at least easy enough to add priorities or niceness and we can probably look into

18:06.280 --> 18:09.520
some more sophisticated solutions a little bit later.

18:09.520 --> 18:12.400
Oh, and I missed one on my notes here.

18:12.400 --> 18:16.920
A quick note to add on the topic of address spaces is that I think it's implemented a

18:16.920 --> 18:21.480
little bit more elegantly than SEL4, but I did not write down why in my notes, so you'll

18:21.480 --> 18:25.360
have to take my word for it.

18:25.360 --> 18:29.600
Okay, so that's enough about the design.

18:29.600 --> 18:33.200
I'd like to talk a little bit about the implementation.

18:33.200 --> 18:37.800
The goal is to keep the kernel very straightforward when it comes to booting.

18:37.800 --> 18:43.640
I don't really care for the never ending nightmare which is different ways of booting up computers.

18:43.640 --> 18:50.200
And so the kernel is an ELF executable and the bootloader's job is to do whatever crazy

18:50.200 --> 18:54.440
bullshit is required on whatever platform it's running on to just load a goddamn ELF

18:54.440 --> 18:55.760
executable into memory.

18:55.760 --> 18:58.140
So that's what we've done.

18:58.140 --> 19:02.760
And these bootloaders are also implemented in here, by the way.

19:02.760 --> 19:07.640
We support, again, multi-bit on x86 and EFI on ARH64 and we'll do EFI everywhere soon,

19:07.640 --> 19:11.320
but the bootloader comes up and it's responsible for a few things.

19:11.320 --> 19:13.720
It has to, of course, read the memory map.

19:13.720 --> 19:18.480
It also has to load from the file system any boot modules like similar to an init ramfs

19:18.480 --> 19:23.040
on Linux where it's going to pull out the init binary or the init executable for the

19:23.040 --> 19:27.360
first user space process to run as well as maybe a tarball that init binary wants to

19:27.360 --> 19:30.560
use to read some early drivers from.

19:30.560 --> 19:35.300
It's also going to provide to the kernel that memory map, those boot modules and details

19:35.300 --> 19:39.280
about the loaded kernel like where it was placed in physical memory and so on.

19:39.280 --> 19:43.040
If we're booting with EFI, we're going to pass along some stuff about the EFI runtime

19:43.040 --> 19:49.720
services and if we have a frame buffer at this stage thanks to GOP or multi-boot, we'll

19:49.720 --> 19:56.080
pass that along as well and that will eventually make its way to user space.

19:56.080 --> 19:59.000
Starting boot, we have system initialization.

19:59.000 --> 20:07.320
You saw a little bit of this in the earlier slide which showed the code sample of the

20:07.320 --> 20:08.860
kernel's portable entry point.

20:08.860 --> 20:11.320
That's where the system initialization begins.

20:11.320 --> 20:16.120
Of the three phases of the kernel runtime, we have the boot phase, the system initialization

20:16.120 --> 20:18.160
phase and the runtime phase.

20:18.160 --> 20:23.280
During sys init, the purpose is to do something I hinted at earlier which is to enumerate

20:23.280 --> 20:27.600
all of the system resources, create capabilities for them and then assign them to the init

20:27.600 --> 20:33.480
process which is just again an alpha executable.

20:33.480 --> 20:35.680
We pull that alpha executable in from the boot modules.

20:35.680 --> 20:38.800
The kernel has a simple loader which pulls it into memory.

20:38.800 --> 20:42.480
Enumerate system resources creates enough capabilities to host a task and a v-space

20:42.480 --> 20:46.920
and so on for that initial executable and hand it off.

20:46.920 --> 20:51.680
The basic problem at this stage is not messing up memory.

20:51.680 --> 20:55.080
Everybody who has written a kernel from scratch maybe as opposed to approaching a project

20:55.080 --> 21:00.600
later knows that the hardest thing about memory management is you need memory to manage memory.

21:00.600 --> 21:03.620
There's a lot of stuff in this stage to deal with that.

21:03.620 --> 21:07.840
We also try to enumerate resources on the system at this stage but this is actually

21:07.840 --> 21:09.360
going to change soon.

21:09.360 --> 21:15.400
The kernel at the time of speaking has a PCI driver for x86 or a device tree scanner for

21:15.400 --> 21:20.240
ARM and we try to enumerate the physical address of everything but this is not a good idea

21:20.240 --> 21:25.120
so we're just going to take all physical memory and give it to user space and let it use policy

21:25.120 --> 21:29.520
decisions to figure out who gets what rather than trying to enumerate everything in the

21:29.520 --> 21:31.720
kernel just to keep the kernel smaller.

21:31.720 --> 21:36.160
We definitely don't want to do ACPI so please, please, if anybody here is on the RISC-V board

21:36.160 --> 21:38.800
or something, I'm begging you.

21:38.800 --> 21:40.320
No ACPI.

21:40.320 --> 21:41.720
Device trees.

21:41.720 --> 21:48.200
Then finally we jump to user space and that concludes the sys init.

21:48.200 --> 21:53.280
Speaking of user space, I want to talk a little bit about our future plans.

21:53.280 --> 21:57.280
Here we have the onion of Aries is what is called.

21:57.280 --> 22:02.360
Helios is the kernel at the core of this dream of a larger operating system called the Aries

22:02.360 --> 22:04.000
operating system.

22:04.000 --> 22:09.520
We want to wrap the kernel with various layers to add more functionality.

22:09.520 --> 22:11.360
We have Helios as the kernel.

22:11.360 --> 22:14.640
We've also started working on Mercury which is a framework for writing drivers.

22:14.640 --> 22:19.440
It's basically a user space interface to the kernel API which you can use for drivers plus

22:19.440 --> 22:24.800
some useful functionality like utilities to make it easier to map memory and so on.

22:24.800 --> 22:31.040
Then this Mercury system is applied by Venus which is a collection of drivers, real world

22:31.040 --> 22:33.480
drivers for actual hardware.

22:33.480 --> 22:38.240
At the time of this talk, Helios exists, Mercury mostly exists, and Venus was just started

22:38.240 --> 22:40.200
last week.

22:40.200 --> 22:44.480
Gaia is going to be the next thing that we're going to do on top of this.

22:44.480 --> 22:49.720
Through Mercury and Venus, we'll get this abstract view of the devices on the system

22:49.720 --> 22:54.360
as presented through IPC capabilities.

22:54.360 --> 23:00.000
Then this will be consumed by Gaia and formed into a cohesive user space which is going

23:00.000 --> 23:05.080
to essentially be Unix but everything is not a file, everything is a capability.

23:05.080 --> 23:10.600
You open slash dev slash FB and you get a frame buffer capability rather than an IO

23:10.600 --> 23:12.760
object that you might see on Unix.

23:12.760 --> 23:17.760
Furthermore, the design of Gaia is going to be mostly a combination of inspirations from

23:17.760 --> 23:20.560
Unix and Plan 9.

23:20.560 --> 23:25.680
On top of this, we'll add a POSIX compatibility layer because Gaia is a chance to leave behind

23:25.680 --> 23:29.480
the legacy of POSIX but the legacy of POSIX is strong so we'll have to accommodate it

23:29.480 --> 23:30.480
somehow.

23:30.480 --> 23:34.800
We'll tie all of this up into an operating system called Ares.

23:34.800 --> 23:39.400
Regarding the user space, we're going to build the stuff there.

23:39.400 --> 23:42.460
One other thing I want to show off is something which is part of the Mercury system which

23:42.460 --> 23:46.920
is our DSL for defining IPC interfaces.

23:46.920 --> 23:50.320
We were thinking about not doing a DSL but DSLs are kind of good for this use case so

23:50.320 --> 23:51.600
we made one.

23:51.600 --> 23:54.720
This is an example of a serial device.

23:54.720 --> 23:59.240
It has support for configuring the baud rate and stop bits and parity and so on.

23:59.240 --> 24:04.720
It implements the IO device because it supports read and write as well.

24:04.720 --> 24:11.980
We have a tool called IPC Gen which reads this DSL and generates hair code for it.

24:11.980 --> 24:17.800
This is now mostly working but we're going to start actually writing more real drivers

24:17.800 --> 24:21.840
with it soon so it will be, remains to be seen if we'll like it after we use it for

24:21.840 --> 24:24.920
a while.

24:24.920 --> 24:26.080
Does Helios work?

24:26.080 --> 24:31.080
The answer is self-evidently yes because this slide deck is being presented from this Raspberry

24:31.080 --> 24:36.160
Pi which is running Helios right now.

24:36.160 --> 24:41.760
Thank you.

24:41.760 --> 24:47.040
I have no C code written on this device beyond the point of EDK2.

24:47.040 --> 24:52.160
It has EDK2 to run UA5 but once EDK2 hands over to our EFI bootloader.

24:52.160 --> 24:56.960
From that point forward 100% hair and assembly, just a little bit of assembly.

24:56.960 --> 25:00.680
This port to ARM64 was accomplished over the past eight weeks.

25:00.680 --> 25:07.000
Actually it took exactly 42 days to port the kernel from x86 to AR64.

25:07.000 --> 25:12.480
This system has a simple driver for the Raspberry Pi GPU running in user space to drive the

25:12.480 --> 25:18.200
projector and it has a serial port driver which I'm connected to on my laptop here to

25:18.200 --> 25:23.920
switch between slides because I could not write a USB driver in eight weeks.

25:23.920 --> 25:29.300
The slide deck itself is encoded as quite okay images which are packed into a tarball

25:29.300 --> 25:34.120
and dropped in like an NMRAMFS would be.

25:34.120 --> 25:36.880
There really are very few hacks.

25:36.880 --> 25:44.280
I would say that this is a pretty complete port of the kernel with very little shortcuts

25:44.280 --> 25:46.480
or problems.

25:46.480 --> 25:51.840
The reason why I chose to port the kernel to ARM in 42 days is because I was originally

25:51.840 --> 25:57.800
going to give this talk from a laptop running Helios for x86-64 where I was going to drive

25:57.800 --> 26:01.620
the projector through Intel HD graphics and then I read the Intel HD graphics manuals

26:01.620 --> 26:06.400
and I decided it would be much easier to port the entire kernel to ARM and write an ARM

26:06.400 --> 26:07.400
GPU driver.

26:07.400 --> 26:10.560
So that's what I did.

26:10.560 --> 26:16.040
After about two days of reading the HD graphics manuals I was like I've had enough and then

26:16.040 --> 26:22.000
I pulled down the ARM manual and tried to find a PDF reader which could handle it.

26:22.000 --> 26:28.440
In terms of those hacks and shortcuts, right, there's no SOC specific builds so the same

26:28.440 --> 26:32.360
kernel that I wrote will boot from any ARM device with the standard EFI configuration

26:32.360 --> 26:33.360
and a device tree.

26:33.360 --> 26:35.560
It's not Raspberry Pi specific.

26:35.560 --> 26:38.240
The user space is Raspberry Pi specific.

26:38.240 --> 26:42.120
It's actually Raspberry Pi 4 specific because that's the one I have just because I didn't

26:42.120 --> 26:47.400
feel like doing device tree parsing and user space for the sake of the silly demo.

26:47.400 --> 26:51.660
But all of the silly demo code aside, the stuff that's necessary to make this talk work

26:51.660 --> 26:54.800
is maybe a little bit hacky and Raspberry Pi specific.

26:54.800 --> 26:59.440
The kernel port is a genuine port which is basically feature complete.

26:59.440 --> 27:04.320
I think the only hack that's in place is that I said earlier that the kernel tries to enumerate

27:04.320 --> 27:08.560
the device tree to find physical memory for devices to provide to user space through device

27:08.560 --> 27:11.240
memory capabilities and that was a bad idea.

27:11.240 --> 27:14.920
I was right that it was a bad idea but there is a little bit of a hack in the kernel in

27:14.920 --> 27:21.840
that I just gave all physical memory to the Raspberry Pi, I'm sorry, to user space without

27:21.840 --> 27:23.480
really much critical thought.

27:23.480 --> 27:25.480
That's really the only hack.

27:25.480 --> 27:31.800
The full complete it's done port will correct that oversight by using the EFI memory map

27:31.800 --> 27:37.440
to find memory which is less stupid to just lightly give to user space.

27:37.440 --> 27:43.240
Additionally, I will confess that I don't have support for IRQs in user space so if

27:43.240 --> 27:49.240
I put my finger on the heat sink here, it kind of hurts because it's just busy looping

27:49.240 --> 27:53.280
in user space while I wait for the next slide.

27:53.280 --> 28:00.120
I did get that working before Fostem, I just didn't incorporate it into the loadout for

28:00.120 --> 28:03.280
running the slide deck.

28:03.280 --> 28:07.680
It's a good thing that it's not that hot in here, this would crash.

28:07.680 --> 28:11.560
In total, Helios has been developed in nine months.

28:11.560 --> 28:17.040
The arm port was done in eight weeks and it's sophisticated enough to run this slide deck

28:17.040 --> 28:20.080
which is pretty cool.

28:20.080 --> 28:22.320
What's left to do?

28:22.320 --> 28:28.920
The kernel is mostly done and by done I mean feature complete but not necessarily where

28:28.920 --> 28:29.920
we want it to be.

28:29.920 --> 28:34.160
By feature complete, I mean the kernel API is complete and you can write programs against

28:34.160 --> 28:38.600
it which do everything we want them to do and then other improvements won't maybe not

28:38.600 --> 28:41.320
necessarily affect that API.

28:41.320 --> 28:44.800
Still needs to be polished in a number of places like that device tree issue that I

28:44.800 --> 28:46.160
mentioned is one case.

28:46.160 --> 28:49.340
If you get correct through the code base, you'll find about 100 comments which we need

28:49.340 --> 28:50.680
to address.

28:50.680 --> 28:55.040
One of the more challenging things that we're going to have to do is SMP support but again

28:55.040 --> 28:59.080
the kernel is a total of 15,000 lines of code.

28:59.080 --> 29:04.120
Despite the boogeyman that SMP often appears to be to most kernel hackers, I imagine that

29:04.120 --> 29:09.840
it won't be that difficult for us to do which could be famous last words but we'll see.

29:09.840 --> 29:11.600
I also want to port it to RISC-V.

29:11.600 --> 29:19.800
I have gotten some hair code running on RISC-V at the supervisory level thanks to the efforts

29:19.800 --> 29:22.180
of one of the hair contributors.

29:22.180 --> 29:26.600
We did do some basic OS dev research but we haven't actually ported Helios itself to RISC-V

29:26.600 --> 29:28.040
but we'll do that soon.

29:28.040 --> 29:31.000
I also mentioned that we're going to work on more options for the bootloader so we're

29:31.000 --> 29:33.440
going to try to get EFI going everywhere.

29:33.440 --> 29:40.720
The main blocker for EFI on x86-64 for example is that our programming language which again

29:40.720 --> 29:46.520
is hair which is developed almost alongside this project.

29:46.520 --> 29:52.880
X86 doesn't have support for PIC and so it would kind of be a little bit of a nightmare

29:52.880 --> 29:59.620
to do runtime relocations of the bootloader and assembly or something of that nature so

29:59.620 --> 30:05.280
we're going to do PIC first before we try to do an EFI bootloader for x86 but we do

30:05.280 --> 30:11.240
have PIC for ARM so that's already working.

30:11.240 --> 30:13.000
And then I also want to improve the docs.

30:13.000 --> 30:20.080
I spent the past few weeks in between hacking on the ARM kernel, improving the documentation

30:20.080 --> 30:25.680
on the website Aries-OS.org which there will be a link to in a later slide which is probably

30:25.680 --> 30:29.720
now about 60% complete so if you're curious about the project and maybe you want to try

30:29.720 --> 30:34.280
your hand at a little driver in user space feel free to check that out and wherever you

30:34.280 --> 30:39.960
find a page which is a stub and you need to know what it should say you can come to IRC

30:39.960 --> 30:43.880
and ask about it and we'll fill it in.

30:43.880 --> 30:49.360
After the kernel is polished actually alongside the kernel polish is going to user space where

30:49.360 --> 30:53.520
I explained a lot of the things that we were looking at.

30:53.520 --> 30:57.800
Mercury again mostly exists and Venus is just getting started.

30:57.800 --> 31:02.720
Prior to the introduction of Venus we did have a number of drivers that were built for

31:02.720 --> 31:05.480
the purpose of testing the kernel and testing Mercury and so on.

31:05.480 --> 31:11.080
We obviously have a serial driver for x86, we have a PL011 serial driver for ARM.

31:11.080 --> 31:13.680
We've also done things like E1000 networking.

31:13.680 --> 31:15.560
We did send pings with that.

31:15.560 --> 31:20.780
We did the RDO block devices and a couple of other simple drivers just as we were working

31:20.780 --> 31:23.740
to prove the design of the support code for drivers.

31:23.740 --> 31:30.280
But the support code is mostly done so now we're going to start writing drivers for real.

31:30.280 --> 31:35.880
I need to provide some acknowledgements here to people who helped to make Helios work.

31:35.880 --> 31:39.840
Certainly I mentioned earlier that there's a RISC-V kernel by Alexi Uren.

31:39.840 --> 31:44.920
Ember Savati also did some work on x86 for early kernel attempts.

31:44.920 --> 31:46.440
This was really useful stuff.

31:46.440 --> 31:50.520
None of this code was very little of this code that came from these efforts of A.D.A.

31:50.520 --> 31:55.600
to Helios and these projects never really developed into full systems.

31:55.600 --> 31:59.480
I don't think either of them made it to user space but they were still very useful for

31:59.480 --> 32:04.520
proving out some ideas about how to actually do basic kernel hacking in Heir.

32:04.520 --> 32:05.800
How do we boot up the system?

32:05.800 --> 32:07.000
How do we work from ring zero?

32:07.000 --> 32:08.200
How do we configure the MMU?

32:08.200 --> 32:11.040
How do we do yada yada yada, deal with interrupts and so on?

32:11.040 --> 32:12.440
How do we link it properly?

32:12.440 --> 32:16.240
All questions that had not been answered previously within the context of the Heir programming

32:16.240 --> 32:21.760
language and so this work was definitely instrumental in setting the field upon which Helios could

32:21.760 --> 32:23.000
be built.

32:23.000 --> 32:24.920
Big thanks to these guys.

32:24.920 --> 32:26.600
Also thanks to the Heir community.

32:26.600 --> 32:28.240
There's almost 80 people now.

32:28.240 --> 32:29.920
Obviously I think it's more than 80 now.

32:29.920 --> 32:32.880
There's around 80 people who have been working on the programming language itself.

32:32.880 --> 32:39.800
Again, we've been working on it for about three years now and the project Helios of

32:39.800 --> 32:42.920
course would not be possible without the programming language it's written in.

32:42.920 --> 32:46.200
So a huge shout out to the Heir community for everything they've done.

32:46.200 --> 32:47.840
Very proud of that community.

32:47.840 --> 32:51.400
I also want to thank the OS Dev community on the BarraChat.

32:51.400 --> 32:54.440
Hands up if any of you are in this channel.

32:54.440 --> 32:59.800
So OS Dev on the BarraChat is the single best place to learn about kernel hacking on the

32:59.800 --> 33:00.800
entire internet.

33:00.800 --> 33:04.280
Those guys are so smart and helpful and they're very knowledgeable.

33:04.280 --> 33:07.480
They know everything about kernel hacking and drivers and anything you want to know.

33:07.480 --> 33:11.480
If you want to mess with kernels, go talk to these people.

33:11.480 --> 33:13.160
And also of course to SCL4.

33:13.160 --> 33:16.200
As I'm sure you noticed, we took a whole bunch of ideas from SCL4.

33:16.200 --> 33:20.440
I think SCL4 has got a really cool kernel design and I was really happy to learn about

33:20.440 --> 33:24.640
it and apply a lot of its ideas to my own kernel.

33:24.640 --> 33:27.640
So kernel hacking is fun, Heir is fun, let's all have fun.

33:27.640 --> 33:29.560
That's it.

33:29.560 --> 33:38.160
Thank you so much, Drew.

33:38.160 --> 33:39.160
Any questions from the audience?

33:39.160 --> 33:40.160
Martin.

33:40.160 --> 33:41.160
I'm going to give you guys my talk.

33:41.160 --> 33:47.880
Pass it on to Martin first and then we're going to give you.

33:47.880 --> 33:48.880
Hi.

33:48.880 --> 33:49.880
Thanks for the talk.

33:49.880 --> 33:52.880
Good work.

33:52.880 --> 34:01.920
I was unable to map the standard SCL4 capability derivation tree like starting with untied memory

34:01.920 --> 34:04.840
and then everything that to your slides.

34:04.840 --> 34:06.240
So do you have it as well?

34:06.240 --> 34:07.240
Or?

34:07.240 --> 34:08.340
Yeah, we do.

34:08.340 --> 34:12.660
We just track capability derivations in a manner very similar to SCL4 and it really

34:12.660 --> 34:16.720
would have been smart for me to put in a slide about that.

34:16.720 --> 34:18.240
So thanks for the clarification.

34:18.240 --> 34:22.280
And second, well, I have a hard time formulating it

34:22.280 --> 34:27.400
as a question, so maybe just take it as an unsolicited advice.

34:27.400 --> 34:29.640
Many of the design decisions of SCL4

34:29.640 --> 34:34.280
were strictly motivated by the formal verification target.

34:34.280 --> 34:36.560
So maybe when you have spoken, for example,

34:36.560 --> 34:40.080
about not sharing the pages, et cetera,

34:40.080 --> 34:42.560
just give it a thought that the reason for that

34:42.560 --> 34:49.320
might be that they did not want to make their life harder

34:49.320 --> 34:51.000
regarding the formal verification.

34:51.000 --> 34:52.560
And that might be the only reason.

34:52.560 --> 34:55.400
Yeah, I think I've noticed that for a few other implementation

34:55.400 --> 34:58.200
details from SCL4 when we were studying a kernel to learn

34:58.200 --> 35:00.480
what we could do for ours.

35:00.480 --> 35:04.760
And with examples like sharing page tables,

35:04.760 --> 35:07.200
I had bigger fish to fry, so I left a comment which says,

35:07.200 --> 35:09.080
SCL4 doesn't support copying these,

35:09.080 --> 35:10.960
and I would rather not run into a Heisenberg

35:10.960 --> 35:13.840
because we did it without thinking about it.

35:13.840 --> 35:15.320
And then we can really address it

35:15.320 --> 35:17.240
at some point in the future.

35:17.240 --> 35:17.740
Thanks.

35:21.400 --> 35:22.160
Hi.

35:22.160 --> 35:23.400
Yeah, thanks for the talk.

35:23.400 --> 35:25.800
Very interesting, quite impressive.

35:25.800 --> 35:28.000
Yesterday we were talking about hair,

35:28.000 --> 35:30.920
and thinking about it in retrospect,

35:30.920 --> 35:33.240
it seemed to me, my personal opinion,

35:33.240 --> 35:36.240
that the great mechanisms of language design

35:36.240 --> 35:37.960
are mostly discovered.

35:37.960 --> 35:40.440
Like we have garbage collection and tech unions

35:40.440 --> 35:43.040
and that assuming you agree with that statement

35:43.040 --> 35:45.440
now that you've written that operating system kernel,

35:45.440 --> 35:48.080
would you also say that the great mechanisms how

35:48.080 --> 35:50.600
to write a kernel are established and well-known?

35:50.600 --> 35:52.920
Things like paging, what's the still areas

35:52.920 --> 35:57.000
to experiment in new ways to do memory management?

35:57.000 --> 36:00.160
Things like that.

36:00.160 --> 36:01.480
Interesting question.

36:01.480 --> 36:05.200
I would say that there is a lot of concepts and ideas which

36:05.200 --> 36:07.800
can be applied in the field of OS development, which

36:07.800 --> 36:12.200
are understood, and you can see examples of kernels

36:12.200 --> 36:14.400
and systems which apply these ideas,

36:14.400 --> 36:17.160
and various different designs that you can learn from

36:17.160 --> 36:19.120
and study and maybe apply to your own kernel

36:19.120 --> 36:20.880
if they're the right choice.

36:20.880 --> 36:22.480
And you can make a complete kernel,

36:22.480 --> 36:25.520
which is interesting, basically only using proven ideas, which

36:25.520 --> 36:29.720
is, for the most part, describes Helios.

36:29.720 --> 36:32.160
But at the same time, there's certainly all kinds of research

36:32.160 --> 36:35.040
which is being done into more novel approaches.

36:35.040 --> 36:37.360
There's been talks in this room throughout the day,

36:37.360 --> 36:41.560
which address some of those novel approaches and ideas.

36:41.560 --> 36:43.720
So I would say that there is certainly

36:43.720 --> 36:46.160
room to build a kernel out of understood ideas

36:46.160 --> 36:47.440
and still make it interesting.

36:47.440 --> 36:51.320
But there's also definitely an active frontier of research

36:51.320 --> 36:53.200
ongoing as well.

36:53.200 --> 36:54.520
Thank you.

36:54.520 --> 36:57.720
Thank you so much.

36:57.720 --> 36:58.520
Any other questions?

37:01.920 --> 37:03.560
Yeah, please.

37:03.560 --> 37:07.560
Let me.

37:07.560 --> 37:08.060
Oh.

37:12.200 --> 37:13.400
Yeah.

37:13.400 --> 37:14.480
Thank you for the talk.

37:14.480 --> 37:15.760
You mentioned that you need to have

37:15.760 --> 37:17.320
position-independent code, right?

37:17.320 --> 37:18.200
Yeah.

37:18.200 --> 37:21.440
But I don't understand if you use every driver,

37:21.440 --> 37:24.400
and it's just like a user space process.

37:24.400 --> 37:28.440
So can't you just remap that in MMM so that all the processes,

37:28.440 --> 37:32.000
like a normal Linux process, just have the same memory map?

37:32.000 --> 37:34.160
Yeah, actually, the kernel and user space processes

37:34.160 --> 37:35.680
both use a fixed memory map.

37:35.680 --> 37:37.440
The thing where we would maybe want

37:37.440 --> 37:38.840
to look at position-independent code

37:38.840 --> 37:41.400
is specifically for the case of loading our EFI bootloader

37:41.400 --> 37:43.880
as a P32 plus executable.

37:43.880 --> 37:46.720
After that stage, it's all fixed memory addresses.

37:46.720 --> 37:47.220
OK.

37:47.220 --> 37:48.320
Yeah, then I understand.

37:48.320 --> 37:48.800
Cool.

37:55.280 --> 37:56.160
Hello.

37:56.160 --> 37:57.560
Thank you for the talk.

37:57.560 --> 37:59.680
Can I ask a non-technical element?

37:59.680 --> 38:02.040
You've GPL freed it.

38:02.040 --> 38:03.920
How are you making decisions around the kernel?

38:03.920 --> 38:05.080
Is it an everland dictator?

38:05.080 --> 38:06.080
Are you making decisions?

38:06.080 --> 38:08.600
Or are you having massive conversations about things?

38:08.600 --> 38:12.000
How's that looking at the moment?

38:12.000 --> 38:13.480
The vast majority of the work is just

38:13.480 --> 38:15.360
done by me personally at the moment.

38:15.360 --> 38:16.920
The project is still pretty early on,

38:16.920 --> 38:19.680
but we do have a number of other contributors.

38:19.680 --> 38:21.760
I would say that the group of people

38:21.760 --> 38:24.240
who ought to be consulted on changes

38:24.240 --> 38:28.120
is probably in the ballpark of five people in total.

38:28.120 --> 38:31.040
So we just have a fairly informal community

38:31.040 --> 38:32.000
based on trust.

38:32.000 --> 38:34.680
And we try to be transparent, like I am transparent,

38:34.680 --> 38:35.840
in all of my free software.

38:35.840 --> 38:37.400
So we have a public IRC channel where

38:37.400 --> 38:38.520
we have these discussions.

38:38.520 --> 38:40.160
Anybody can jump in at any time.

38:40.160 --> 38:41.620
And there's a patch review process

38:41.620 --> 38:43.280
which just goes through me at the moment.

38:43.280 --> 38:45.120
But in the hair community, for example,

38:45.120 --> 38:47.000
which is a lot bigger at this stage,

38:47.000 --> 38:49.680
we have something more of a governance model

38:49.680 --> 38:51.480
where there's less of a BDFL and more

38:51.480 --> 38:54.920
of multiple maintainers who all can do code reviews

38:54.920 --> 38:57.160
and improve patches and things like this.

38:57.160 --> 38:59.040
And as the Helios project grows, I imagine

38:59.040 --> 39:01.720
it will adopt a model similar to hair.

39:01.720 --> 39:03.240
And perhaps as hair grows, we'll have

39:03.240 --> 39:05.440
to improve upon the model even further.

39:05.440 --> 39:06.840
But we'll see.

39:06.840 --> 39:07.340
Thank you.

39:07.340 --> 39:08.240
Nice share, by the way.

39:08.240 --> 39:08.740
David.

39:15.700 --> 39:18.400
You mentioned that you don't want to deal with ACPI,

39:18.400 --> 39:21.360
but at the same time, you want to make you have i standard.

39:21.360 --> 39:23.040
So what's the plan there?

39:23.040 --> 39:26.220
Is there any way to solve a thought ACPI in your system?

39:26.220 --> 39:29.920
Because I imagine that it will become mandatory, right?

39:29.920 --> 39:31.280
Yeah.

39:31.280 --> 39:33.480
I'm going to wail and gnash my teeth

39:33.480 --> 39:35.880
and hope it doesn't happen in practice.

39:35.880 --> 39:39.320
Because at the moment, you know something like EDK2.

39:39.320 --> 39:41.560
To be clear, by the way, I don't give a fuck

39:41.560 --> 39:43.000
about non-free firmwares.

39:43.000 --> 39:46.360
So I'm thinking about EDK2 and things like that, or U-Boot

39:46.360 --> 39:50.920
and so on, where there's already an EFI standard UUID

39:50.920 --> 39:52.400
for passing a device tree along.

39:52.400 --> 39:54.760
And they can be configured to do that instead of ACPI, which

39:54.760 --> 39:57.520
is what I'm doing on this Raspberry Pi, for example,

39:57.520 --> 40:00.360
and what I hope to continue to do on RISC-V and so on.

40:00.360 --> 40:04.160
Our proof of concept on RISC-V took the same approach.

40:04.160 --> 40:06.880
But there's very little in the kernel

40:06.880 --> 40:09.440
that actually needs to be concerned with ACPI

40:09.440 --> 40:10.440
versus device trees.

40:10.440 --> 40:12.320
And again, it is a microkernel.

40:12.320 --> 40:15.600
So in the long term, we might just pass along the rather

40:15.600 --> 40:27.560
than the previous one.

40:27.560 --> 40:29.720
At least a little bit in x86, because there's

40:29.720 --> 40:31.760
no device trees.

40:31.760 --> 40:35.200
But fingers in my ears not thinking about the fact

40:35.200 --> 40:38.320
that ACPI is upon us, but we'll probably

40:38.320 --> 40:47.680
have to deal with it at some point.

40:47.680 --> 40:49.240
Thank you for the presentation.

40:49.240 --> 40:51.800
Which software is running the presentation itself,

40:51.800 --> 40:53.680
and how is it combined?

40:53.680 --> 40:57.120
This is just a custom piece of software I wrote myself.

40:57.120 --> 41:00.920
It's a single binary, which is loaded by the bootloader

41:00.920 --> 41:02.000
as the init process.

41:02.000 --> 41:04.720
And then the kernel loads it into an address space

41:04.720 --> 41:06.920
and boots it up as PID1.

41:06.920 --> 41:09.920
And there's additionally a tarball

41:09.920 --> 41:13.040
as a second boot module, which is again loaded into memory

41:13.040 --> 41:15.800
and then passed along to PID1, which

41:15.800 --> 41:17.520
is a tarball full of slides.

41:17.520 --> 41:19.680
And then there's just one statically linked executable,

41:19.680 --> 41:23.320
which contains a serial driver and a GPU driver and the code

41:23.320 --> 41:26.040
to glue everything together.

41:26.040 --> 41:28.360
The code, by the way, is available on source

41:28.360 --> 41:37.360
side if you're curious.

41:37.360 --> 41:41.880
As you mentioned, Elios is heavily inspired by STL4.

41:41.880 --> 41:45.880
So is there any plan on formal verification for Elios?

41:45.880 --> 41:48.080
Or is that just not something you're interested in?

41:48.080 --> 41:52.080
No, I'm not particularly interested in that.

41:52.080 --> 42:00.240
In the back, there's someone.

42:00.240 --> 42:01.920
Thanks for the presentation.

42:01.920 --> 42:02.960
I have a question.

42:02.960 --> 42:05.680
Is it on the roadmap that something like Western

42:05.680 --> 42:09.880
or a other GUI server or other service like that

42:09.880 --> 42:11.920
could potentially be ported to Helios?

42:11.920 --> 42:14.800
I'm actually also the original author of W.R. Roots

42:14.800 --> 42:16.640
and have a lot of experience in Wayland.

42:16.640 --> 42:19.640
And so there is a 100% chance that Wayland will be running

42:19.640 --> 42:21.240
on Helios at some point.

42:21.240 --> 42:24.240
OK.

42:24.240 --> 42:25.240
Any other questions?

42:30.720 --> 42:38.200
So you said for Gaia, you are inspired by Plan 9 and Unix.

42:38.200 --> 42:39.640
What's the best?

42:39.640 --> 42:40.760
What do you plan for Gaia?

42:40.760 --> 42:45.760
What's the best of those both worlds?

42:45.760 --> 42:47.680
It's a little bit hard to say.

42:47.680 --> 42:50.600
At this point, there is less plans and more vision

42:50.600 --> 42:54.280
in that respect because we have at least probably a year of work

42:54.280 --> 42:57.080
before it can really start serious work on Gaia.

42:57.080 --> 42:58.920
But I will say that there is a lot of stuff

42:58.920 --> 43:01.320
I admire about Plan 9.

43:01.320 --> 43:04.960
There's per-process namespaces is one great idea.

43:04.960 --> 43:09.000
I'm also going to go further with the idea of there

43:09.000 --> 43:11.760
not being any kind of global file system at all.

43:11.760 --> 43:14.080
We're also going to take a look at things

43:14.080 --> 43:17.240
like using text-based protocols where possible.

43:17.240 --> 43:20.360
And we're going to use different from Plan 9.

43:20.360 --> 43:24.240
We're going to use this IPC generation thing for places

43:24.240 --> 43:26.680
where text protocols maybe don't make sense.

43:26.680 --> 43:30.200
I also have a lot of admiration for things like MBD on Plan 9.

43:30.200 --> 43:32.560
And so I would like to organize networks perhaps

43:32.560 --> 43:35.440
in a similar fashion.

43:35.440 --> 43:39.360
And also, I would say that the bigger vision for the whole ARIES

43:39.360 --> 43:43.840
system is you can almost say it's correcting a mistake

43:43.840 --> 43:47.160
that Plan 9 made, which is that Plan 9 was correct,

43:47.160 --> 43:49.920
that distributed computing is the future.

43:49.920 --> 43:51.720
But it was incorrect that they would

43:51.720 --> 43:54.720
be distributed across a mainframe and a bunch of thin

43:54.720 --> 43:57.480
clients in an office building, which is how Plan 9 was designed.

43:57.480 --> 43:59.680
In fact, the group of devices which

43:59.680 --> 44:02.000
should be running a uniform operating system

44:02.000 --> 44:04.600
is all of your personal devices, my laptop, my workstation

44:04.600 --> 44:05.880
at home, my phones.

44:05.880 --> 44:08.160
They should all present as a single system.

44:08.160 --> 44:12.200
And so it's very vague and lofty and long-term vision.

44:12.200 --> 44:14.560
But I would like to try and achieve that with the design

44:14.560 --> 44:18.400
of Gaia and ARIES.

44:18.400 --> 44:18.900
Thank you.

44:18.900 --> 44:22.320
Any other questions?

44:22.320 --> 44:24.640
OK, then thank you so much, Drew.

44:24.640 --> 44:25.400
Thanks a lot.

44:25.400 --> 44:25.900
Thank you.

44:25.900 --> 44:26.400
Thank you.

44:26.400 --> 44:26.900
Thank you.

44:26.900 --> 44:27.400
Thank you.

44:27.400 --> 44:27.900
Thank you.

44:27.900 --> 44:28.400
Thank you.

44:28.400 --> 44:28.900
Thank you.

44:28.900 --> 44:29.400
Thank you.

44:29.400 --> 44:29.900
Thank you.

44:29.900 --> 44:30.400
Thank you.

44:30.400 --> 44:51.240
10 minutes break until the next talk.
