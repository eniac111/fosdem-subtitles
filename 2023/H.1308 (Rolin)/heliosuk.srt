1
0:00:00.000 --> 0:00:06.880
Thank you.

2
0:00:06.880 --> 0:00:11.480
So hi, my name is Drew, and I'd like to talk to you today about a new microkernel I've

3
0:00:11.480 --> 0:00:14.000
been working on called Helios.

4
0:00:14.000 --> 0:00:19.120
For context, I work at a place called Sourceset, and I'm the project lead for a new programming

5
0:00:19.120 --> 0:00:21.120
language called Hair.

6
0:00:21.120 --> 0:00:28.040
And I've done many other projects, but that's what's relevant for today.

7
0:00:28.040 --> 0:00:31.280
Helios is a new microkernel.

8
0:00:31.280 --> 0:00:35.080
It's inspired a lot by SEL4, but it differs in many ways.

9
0:00:35.080 --> 0:00:39.920
It's written in this hair programming language that I mentioned, and one of the main motivations

10
0:00:39.920 --> 0:00:43.960
for it is to find out if we can use the hair programming language to write microkernel,

11
0:00:43.960 --> 0:00:46.200
or any kind of kernel, really.

12
0:00:46.200 --> 0:00:52.320
Presently it runs on X8664 and ARM64, and we're thinking about RISC-V in the foreseeable

13
0:00:52.320 --> 0:00:53.320
future.

14
0:00:53.320 --> 0:00:56.360
In terms of the footprint of this kernel, it's pretty small.

15
0:00:56.360 --> 0:01:00.120
The portable code is about 8,500 lines of code.

16
0:01:00.120 --> 0:01:05.040
Each architecture adds about another 3,000 lines of code, all hair code, and then add

17
0:01:05.040 --> 0:01:09.160
on top of that the boot loaders, which are also written in hair, and it's a pretty small

18
0:01:09.160 --> 0:01:10.160
footprint.

19
0:01:10.160 --> 0:01:17.840
We've been working on it for about nine months now, and we use the GPL3 license.

20
0:01:17.840 --> 0:01:21.280
So again, about nine months of progress so far.

21
0:01:21.280 --> 0:01:26.920
Where do we stand in terms of functionality is about here.

22
0:01:26.920 --> 0:01:31.880
We have capability-based security, and the capabilities do work, similar to what SEL4

23
0:01:31.880 --> 0:01:37.600
does, and also similar to SEL4, we have inter-processed communication working using endpoints and

24
0:01:37.600 --> 0:01:42.240
notifications, very similar to SEL4 with some notable differences.

25
0:01:42.240 --> 0:01:48.800
We have scheduler work, we're in user space, and we have multiprocessing, but we don't

26
0:01:48.800 --> 0:01:50.160
have symmetric multiprocessing.

27
0:01:50.160 --> 0:01:54.320
We have only one core at the moment, but we'll do SMP fairly soon.

28
0:01:54.320 --> 0:01:59.240
We also have all of the necessary riggings in place for drivers in user space, so we

29
0:01:59.240 --> 0:02:06.240
have access to ports on x86, and we have memory and map.io support, as well as iRQs are rigged

30
0:02:06.240 --> 0:02:07.920
up.

31
0:02:07.920 --> 0:02:13.360
For booting up the kernel, we currently support EFI on ARM, and Multipoot on x86.

32
0:02:13.360 --> 0:02:18.860
We'll be doing EFI on x86 as well in the future, and our plan is to also do EFI on RISC-V,

33
0:02:18.860 --> 0:02:24.920
so we'll use EFI as the default approach for booting Helios in the future.

34
0:02:24.920 --> 0:02:30.000
Why should we be thinking about writing a new macrokernel, or a new kernel of any sort?

35
0:02:30.000 --> 0:02:35.000
I imagine that for this particular dev room, I don't need to give too many reasons, but

36
0:02:35.000 --> 0:02:39.400
for the sake of anybody who's maybe watching online, the first point is pretty obvious.

37
0:02:39.400 --> 0:02:43.440
It's really fun to write kernels, and that's kind of reason enough, so I'm having a great

38
0:02:43.440 --> 0:02:46.480
time working on it, and that's enough for me.

39
0:02:46.480 --> 0:02:51.000
But also importantly, we've been working on this programming language, Herr, for about

40
0:02:51.000 --> 0:02:55.320
three years now, and it's a systems programming language, and one of our goals is to be able

41
0:02:55.320 --> 0:02:58.800
to write things like kernels, and so in order to prove that we have achieved this goal,

42
0:02:58.800 --> 0:03:02.920
we have to write a kernel with it, and so Helios is that kernel.

43
0:03:02.920 --> 0:03:08.400
I also am a big fan of SCL4's design, but I also have some criticisms of it, and I'm

44
0:03:08.400 --> 0:03:12.160
curious if we do a kernel which is inspired by SCL4, can we make some improvements on

45
0:03:12.160 --> 0:03:14.320
its design?

46
0:03:14.320 --> 0:03:19.840
And if we were to be particularly ambitious, could we perhaps do better than Linux?

47
0:03:19.840 --> 0:03:21.760
We'll see.

48
0:03:21.760 --> 0:03:31.020
I should also point out that this slide deck is going to cover a lot of details which maybe

49
0:03:31.020 --> 0:03:35.160
will seem redundant to people who are already familiar with the design of SCL4, and that

50
0:03:35.160 --> 0:03:39.960
could be a problem with this audience, but please bear with me while I explain things

51
0:03:39.960 --> 0:03:43.520
that you already understand at some point in the future.

52
0:03:43.520 --> 0:03:48.360
So the HAIR programming language, this is the pitch from the website, I won't read it

53
0:03:48.360 --> 0:03:53.080
out to you, but essentially it's a very simple language which is very close to C in terms

54
0:03:53.080 --> 0:03:58.640
of design, but with a lot of benefit of 50 years of hindsight of what could be made better

55
0:03:58.640 --> 0:04:05.400
about C. But compared to other C alternatives that are floating around today like Rust and

56
0:04:05.400 --> 0:04:10.160
Zig and Nim and so on, I would say HAIR is much, much closer to C's original ideas than

57
0:04:10.160 --> 0:04:16.800
any of these other attempts, but it improves in many respects like dealing with modules

58
0:04:16.800 --> 0:04:22.520
and error handling and bounce checked things and some safety features.

59
0:04:22.520 --> 0:04:24.400
So it improves in a number of respects.

60
0:04:24.400 --> 0:04:27.320
It's also very, very simple.

61
0:04:27.320 --> 0:04:32.440
So here we have some more line counts for people who like the line counts.

62
0:04:32.440 --> 0:04:36.600
The HAIR compiler is 18,000 lines of code in C11.

63
0:04:36.600 --> 0:04:41.520
The back end that we use, it's not LLVM, we use CUBE as our back end, is another 12,000

64
0:04:41.520 --> 0:04:43.280
lines of C99.

65
0:04:43.280 --> 0:04:45.840
And then we use binutils for the linker and assembler.

66
0:04:45.840 --> 0:04:46.840
And that's it.

67
0:04:46.840 --> 0:04:52.440
We support three targets, X8664, AR64 and RISC564, which is no coincidence that those are the

68
0:04:52.440 --> 0:04:55.840
targets I'm working on for the macrokernel.

69
0:04:55.840 --> 0:05:00.600
We intend to add more, but this is where the language is at.

70
0:05:00.600 --> 0:05:08.200
I started, you know, again, I started HAIR specifically to work on this kind of project.

71
0:05:08.200 --> 0:05:12.320
And this project exists to validate the language design for this use case.

72
0:05:12.320 --> 0:05:16.160
And also because it's fun and maybe it could be useful.

73
0:05:16.160 --> 0:05:20.160
For those of us who have never seen any HAIR code before, I just have a little snippet

74
0:05:20.160 --> 0:05:22.800
here so you can get a vague idea of what it looks like.

75
0:05:22.800 --> 0:05:26.200
Again, not going to explain this in too much detail, but if you're familiar with C, a lot

76
0:05:26.200 --> 0:05:28.080
of things will seem familiar to you.

77
0:05:28.080 --> 0:05:31.100
And you can probably guess, you know, the double colon does namespaces.

78
0:05:31.100 --> 0:05:33.480
Maybe you can guess what the no return tag does.

79
0:05:33.480 --> 0:05:35.520
It's fairly straightforward programming language.

80
0:05:35.520 --> 0:05:36.800
And this is what it looks like.

81
0:05:36.800 --> 0:05:40.160
The code sample we're looking at here is the portable kernel entry point.

82
0:05:40.160 --> 0:05:44.160
So it starts at the boot letter entry point and then the arch specific entry point.

83
0:05:44.160 --> 0:05:50.480
This is the first line of portable code that runs when you boot the kernel.

84
0:05:50.480 --> 0:05:54.600
So with the context out of the way, let's talk about Helios itself.

85
0:05:54.600 --> 0:05:59.640
We're going to go over a number of things here with respect to the design of Helios

86
0:05:59.640 --> 0:06:01.040
and the implementation of Helios.

87
0:06:01.040 --> 0:06:04.840
So I'm going to talk about our approach to capabilities and on memory management and

88
0:06:04.840 --> 0:06:08.720
some other things specific with how various capabilities actually work like processes

89
0:06:08.720 --> 0:06:12.040
and threads and talk about inter-process communication.

90
0:06:12.040 --> 0:06:18.560
And then also talk a little bit about the implementation as well, not just the design.

91
0:06:18.560 --> 0:06:22.440
So here is the big picture in terms of the implementation.

92
0:06:22.440 --> 0:06:27.040
Again, those who are familiar with SEL4 will find no surprises on this slide.

93
0:06:27.040 --> 0:06:31.960
But essentially, access to all system resources, including kernel objects, is semantically

94
0:06:31.960 --> 0:06:33.600
governed by user space.

95
0:06:33.600 --> 0:06:39.160
And we use the MMU to isolate user space processes from each other and to enforce this capability

96
0:06:39.160 --> 0:06:40.400
model.

97
0:06:40.400 --> 0:06:45.080
On system boot up, the kernel enumerates all of the resources on the system, all of the

98
0:06:45.080 --> 0:06:47.960
memory and all of the IO ports and all the IRQs.

99
0:06:47.960 --> 0:06:52.520
And it prepares capabilities that entitle the bearer to access these resources.

100
0:06:52.520 --> 0:06:57.080
And then it hands all of these off to the first process, the init process, which can

101
0:06:57.080 --> 0:07:03.120
then subject to its own user space policy decisions, choose how to allocate those resources

102
0:07:03.120 --> 0:07:12.760
to various processes in such a way that it can provide a secure system.

103
0:07:12.760 --> 0:07:15.680
So here's a look at our capabilities.

104
0:07:15.680 --> 0:07:21.960
Here's an example here on the left of a fake physical address space.

105
0:07:21.960 --> 0:07:25.040
And on the right shows the kind of state that we'd be storing in this.

106
0:07:25.040 --> 0:07:29.440
So here we have a number of physical pages, one for a capability space, one for a virtual

107
0:07:29.440 --> 0:07:34.680
address space, for a task, a bunch of memory pages, some free memory, and so on.

108
0:07:34.680 --> 0:07:38.180
And in this physical memory, we store the state you see on the right.

109
0:07:38.180 --> 0:07:43.980
So the C space here stores a list of capability slots, very similar to SEL4.

110
0:07:43.980 --> 0:07:47.000
And in those capability slots is a very small amount of state.

111
0:07:47.000 --> 0:07:50.840
They're each, I believe, 64 bytes, so there's not a whole lot to store there.

112
0:07:50.840 --> 0:07:55.320
In this case, a task, which is like a thread or a process, stores a pointer to another

113
0:07:55.320 --> 0:07:59.440
physical memory page where the bulk of its state really lives.

114
0:07:59.440 --> 0:08:06.540
In this case, we have an example of some registers for XDD6.64.

115
0:08:06.540 --> 0:08:12.920
And the access to this state is gated behind the MMU, so only the kernel itself can directly

116
0:08:12.920 --> 0:08:15.120
read from this kind of physical memory.

117
0:08:15.120 --> 0:08:21.000
But then user space, who maybe this process that we're looking at has semantic ownership

118
0:08:21.000 --> 0:08:25.400
over the C space and this V space, they can invoke the kernel to do operations against

119
0:08:25.400 --> 0:08:27.960
those things, but they can't actually directly access the memory.

120
0:08:27.960 --> 0:08:31.920
Instead, the virtual memory can only contain certain kinds of capabilities or certain kinds

121
0:08:31.920 --> 0:08:33.160
of physical memory pages.

122
0:08:33.160 --> 0:08:38.080
So that could be arbitrary general purpose memory, or it could be memory mapped IO, could

123
0:08:38.080 --> 0:08:40.080
end up in their address space.

124
0:08:40.080 --> 0:08:45.400
So while they have semantic ownership over these other capabilities, the actual state

125
0:08:45.400 --> 0:08:53.160
behind them is not accessible to user space.

126
0:08:53.160 --> 0:08:58.440
So in order to work with these capabilities that the user space has semantic ownership

127
0:08:58.440 --> 0:09:01.760
over, it uses, of course, the syscall API.

128
0:09:01.760 --> 0:09:05.020
And Helios has a very, very small syscall API.

129
0:09:05.020 --> 0:09:06.760
It is a microkernel, after all.

130
0:09:06.760 --> 0:09:10.240
We have 14 syscalls, which I have enumerated here.

131
0:09:10.240 --> 0:09:12.800
Twelve of these are for working with capabilities.

132
0:09:12.800 --> 0:09:16.560
And again, if you're familiar with SEL4 here, there's probably no surprises here, except

133
0:09:16.560 --> 0:09:23.280
maybe for syspole, which I'll talk about later.

134
0:09:23.280 --> 0:09:28.840
So here is a little example of how you might invoke a capability on x86 to make use of

135
0:09:28.840 --> 0:09:30.720
the microkernel's API.

136
0:09:30.720 --> 0:09:34.780
Again, you're going to be making a syscall here at the end.

137
0:09:34.780 --> 0:09:38.520
And here we're going to be filling up registers and memory buffers with the information we

138
0:09:38.520 --> 0:09:39.520
want to use.

139
0:09:39.520 --> 0:09:44.720
So this code is going to invoke the vspace map operation, which accepts a page capability,

140
0:09:44.720 --> 0:09:49.720
a virtual address, and a list of mapping flags, like writer or execute.

141
0:09:49.720 --> 0:09:55.600
And its goal is to map a page of physical memory into a slot in a virtual address space.

142
0:09:55.600 --> 0:10:00.800
And in order to invoke this operation, the caller needs to have access to a vspace capability,

143
0:10:00.800 --> 0:10:04.600
which they're going to modify, and a page capability, which they're going to map.

144
0:10:04.600 --> 0:10:07.440
And these capabilities are provided here in two different ways.

145
0:10:07.440 --> 0:10:11.720
The object being invoked is the vspace, and it gets its own register, RDI, which is the

146
0:10:11.720 --> 0:10:14.240
first API register.

147
0:10:14.240 --> 0:10:21.760
The page which is being used, again, similarly to SEL4, is going to be placed into that process's

148
0:10:21.760 --> 0:10:27.660
IPC buffer, which is done here with a fake capability address for the page.

149
0:10:27.660 --> 0:10:33.160
And then we have additional arguments, like the message tag, which contains the operation

150
0:10:33.160 --> 0:10:37.240
name, the number of capabilities, and the number of parameters, and then any additional

151
0:10:37.240 --> 0:10:38.760
arguments to the function.

152
0:10:38.760 --> 0:10:44.320
You run syscall, and the operation happens.

153
0:10:44.320 --> 0:10:48.840
I also want to talk a little bit about the specifics of inter-process communication.

154
0:10:48.840 --> 0:10:55.480
So we have two approaches, and I'll first look at endpoints, which they are kind of

155
0:10:55.480 --> 0:10:57.480
a generalized form of IPC.

156
0:10:57.480 --> 0:11:00.360
And the way you use them is very similar to how you use chronologics.

157
0:11:00.360 --> 0:11:03.840
In fact, the interface is uniform.

158
0:11:03.840 --> 0:11:08.240
But it can send a set of registers or a set of capabilities between tasks.

159
0:11:08.240 --> 0:11:11.720
So one task can transfer a capability to another task.

160
0:11:11.720 --> 0:11:15.780
There is synchronous, so calling send on an endpoint or calling receive on an endpoint

161
0:11:15.780 --> 0:11:19.240
will block until the two tasks run debut.

162
0:11:19.240 --> 0:11:23.960
And if there are many senders or many receivers, then the one who has been blocked the longest

163
0:11:23.960 --> 0:11:28.780
will wake up, so you can have many processes, maybe doing some kind of load balancing operation

164
0:11:28.780 --> 0:11:31.120
against IPC operations.

165
0:11:31.120 --> 0:11:34.040
And also, SEL4 style call and reply is supported.

166
0:11:34.040 --> 0:11:38.160
So if one task does a call rather than a send, then it immediately blocks waiting for the

167
0:11:38.160 --> 0:11:43.560
reply, which is guaranteed to go back to the same thread.

168
0:11:43.560 --> 0:11:49.000
I have here a more detailed example of exactly how that kind of IPC interaction looks on

169
0:11:49.000 --> 0:11:50.600
Helios.

170
0:11:50.600 --> 0:11:55.080
So I have here on the left one task, and on the right two tasks that want to communicate

171
0:11:55.080 --> 0:11:56.400
with each other.

172
0:11:56.400 --> 0:12:00.280
Sometimes the text which is in black is taking place in user space and the text in red is

173
0:12:00.280 --> 0:12:02.560
taking place in kernel space.

174
0:12:02.560 --> 0:12:08.680
So let's say task two is a daemon or a service of some kind which wants to provide a service,

175
0:12:08.680 --> 0:12:13.600
and so it's going to essentially have its main IELP loop call sys receive and then block

176
0:12:13.600 --> 0:12:16.040
until somebody has worked for it to do.

177
0:12:16.040 --> 0:12:20.800
Task one wants to be a consumer of that interface, so it will invoke sys call, and the kernel

178
0:12:20.800 --> 0:12:24.960
will notice that task two is blocked waiting for somebody to call it.

179
0:12:24.960 --> 0:12:29.960
And so the kernel will perform the copy of registers, move any capabilities as necessary,

180
0:12:29.960 --> 0:12:34.160
unblock task two and then block task one while they wait for task two to process the message

181
0:12:34.160 --> 0:12:37.240
and prepare a reply, which is what happens next over here.

182
0:12:37.240 --> 0:12:39.960
The sys call returns from task two.

183
0:12:39.960 --> 0:12:43.720
They process the IPC request according to however they implement their services, and

184
0:12:43.720 --> 0:12:48.520
they call the replies sys call, which copies the reply registers back to task one, very

185
0:12:48.520 --> 0:12:53.080
similar to this fourth step, and then unblocks task one, and then both of them can proceed

186
0:12:53.080 --> 0:13:01.120
onwards with whatever CPU time they're given.

187
0:13:01.120 --> 0:13:04.300
Another interesting feature we have in terms of endpoints, which is one of the things that

188
0:13:04.300 --> 0:13:09.920
distinguishes Helios from SCL4, is support for a pull-like interface.

189
0:13:09.920 --> 0:13:15.020
Similar to Unix's pull-on file descriptors, Helios lets you pull on capabilities.

190
0:13:15.020 --> 0:13:21.240
So this is an example from the serial driver that I implemented for the standard x86 com

191
0:13:21.240 --> 0:13:22.240
ports.

192
0:13:22.240 --> 0:13:25.120
It has two capabilities that mainly cares about.

193
0:13:25.120 --> 0:13:30.280
It has an endpoint capability that it uses to implement its API for consumers of the

194
0:13:30.280 --> 0:13:31.280
serial port.

195
0:13:31.280 --> 0:13:34.920
So if you want to request a read or a write from serial, you'll send a message to this

196
0:13:34.920 --> 0:13:35.920
endpoint.

197
0:13:35.920 --> 0:13:39.840
And then it has an IRQ handler for when the serial port says it's ready to receive or

198
0:13:39.840 --> 0:13:41.800
transmit more data.

199
0:13:41.800 --> 0:13:45.320
And you can prepare a list of capabilities you're interested in and a list of events

200
0:13:45.320 --> 0:13:48.240
you're interested in and block on pull.

201
0:13:48.240 --> 0:13:51.760
And then when one of those is ready to be done, you can call it and it's guaranteed

202
0:13:51.760 --> 0:13:56.600
not to block, very similar to the Unix pull syscall.

203
0:13:56.600 --> 0:14:02.600
And again, I think this is, for me, one of the more notable improvements and derivations

204
0:14:02.600 --> 0:14:06.340
from the SCL4 model.

205
0:14:06.340 --> 0:14:11.560
And I mentioned this earlier, but this interface for doing endpoints and for invoking kernel

206
0:14:11.560 --> 0:14:17.880
objects like virtual address spaces is uniform between user space endpoints and kernel objects.

207
0:14:17.880 --> 0:14:23.240
So it is, for example, possible for a user space process to create a set of endpoints

208
0:14:23.240 --> 0:14:27.960
and then use them to implement an API which is identical to the kernel API.

209
0:14:27.960 --> 0:14:32.080
And if that process is the parent of some other process which thinks it's talking directly

210
0:14:32.080 --> 0:14:35.600
to kernel, it can be sandboxed according to whatever kind of policy you want.

211
0:14:35.600 --> 0:14:41.240
So the kernel is using this API which is uniform with the way that user space communicates

212
0:14:41.240 --> 0:14:46.140
with itself and thus user space can fill the role of the kernel in sometimes.

213
0:14:46.140 --> 0:14:50.840
This can, for example, allow you to very easily run several different Helio systems on the

214
0:14:50.840 --> 0:14:58.720
same computer at once without going to virtualization, which is kind of interesting.

215
0:14:58.720 --> 0:15:04.480
So here I have a little bit more detail on capabilities in particular and the implementation

216
0:15:04.480 --> 0:15:07.880
that some of our capability objects use.

217
0:15:07.880 --> 0:15:12.480
Here we have a capability space on the left which is, again, a little bit distinct from

218
0:15:12.480 --> 0:15:13.480
SCL4.

219
0:15:13.480 --> 0:15:15.120
We don't use guarded page tables.

220
0:15:15.120 --> 0:15:17.040
It's more like a file descriptor table.

221
0:15:17.040 --> 0:15:24.040
It's just zero to however many slots are allocated in that capability space and the process invokes

222
0:15:24.040 --> 0:15:28.280
a capability by its number, not by its address.

223
0:15:28.280 --> 0:15:33.600
Here we have an example of slots where we have a number of things which are preallocated,

224
0:15:33.600 --> 0:15:36.680
but then notably we also have some empty capability slots.

225
0:15:36.680 --> 0:15:41.280
And another derivation from the SCL4 model is that we support capability allocation in

226
0:15:41.280 --> 0:15:42.280
the kernel.

227
0:15:42.280 --> 0:15:46.360
We do this by maintaining inside of empty capabilities a free list.

228
0:15:46.360 --> 0:15:51.960
And so when you invoke an endpoint or you want to allocate a capability, you can set

229
0:15:51.960 --> 0:15:57.760
the capability address to the maximum possible address and the kernel will allocate one for

230
0:15:57.760 --> 0:15:58.760
you using the free list.

231
0:15:58.760 --> 0:16:02.740
You don't have to worry about that state and user space, which is, I think, a very nice

232
0:16:02.740 --> 0:16:08.780
convenience to have and very easy to implement as well.

233
0:16:08.780 --> 0:16:12.560
This is a list of the capabilities that we have implemented.

234
0:16:12.560 --> 0:16:16.280
On the left here is a list of all the capabilities which are available on every architecture.

235
0:16:16.280 --> 0:16:21.460
We have things like memory, device memory, IPC capabilities, threads, and so on.

236
0:16:21.460 --> 0:16:24.760
And then on the right we have a number of additional capabilities which are specific

237
0:16:24.760 --> 0:16:25.760
to each port.

238
0:16:25.760 --> 0:16:33.400
In this case I've listed the capabilities which are used on x86-64.

239
0:16:33.400 --> 0:16:37.280
I'm going to look at just a few of these.

240
0:16:37.280 --> 0:16:39.320
First I want to talk about memory management.

241
0:16:39.320 --> 0:16:45.680
Again, very similar to how we use capability allocation with the C space in the kernel

242
0:16:45.680 --> 0:16:46.920
using a free list.

243
0:16:46.920 --> 0:16:52.320
We also derivate from SEL4 in that general purpose memory uses a free list as well so

244
0:16:52.320 --> 0:16:56.660
you can allocate pages without trying to keep track of a watermark, without trying to reset

245
0:16:56.660 --> 0:16:59.320
your watermark or divide it into smaller objects.

246
0:16:59.320 --> 0:17:03.240
We have a free list of pages so you can just allocate pages which is quite nice.

247
0:17:03.240 --> 0:17:09.520
The only reason this slide is here is to tell you how it differs from SEL4.

248
0:17:09.520 --> 0:17:14.880
We also have address space capabilities, vspaces, which is again similar to SEL4.

249
0:17:14.880 --> 0:17:20.120
In fact, it's so similar that we've cargo-culted this constraint that you can't share page

250
0:17:20.120 --> 0:17:21.120
tables.

251
0:17:21.120 --> 0:17:25.880
I don't really know why SEL4 does that, but once we understand then we will probably either

252
0:17:25.880 --> 0:17:28.600
commit to this or change our mind.

253
0:17:28.600 --> 0:17:32.760
But we have virtual address space capabilities which can be used to manage processes.

254
0:17:32.760 --> 0:17:38.000
And then we have tasks which can be either a thread or a process or something else if

255
0:17:38.000 --> 0:17:39.560
you come up with something creative.

256
0:17:39.560 --> 0:17:44.000
But essentially a task just has a capability space which is optional so that I can do IO

257
0:17:44.000 --> 0:17:48.840
and invoke capabilities as an address space and it receives some CPU time when it is configured

258
0:17:48.840 --> 0:17:49.840
appropriately.

259
0:17:49.840 --> 0:17:51.800
And again, we don't have SMP support yet.

260
0:17:51.800 --> 0:17:53.720
We would like to do that soon.

261
0:17:53.720 --> 0:17:55.800
And for now the scheduler is very simple.

262
0:17:55.800 --> 0:18:01.080
We just have a round robin scheduler, but we would like to expand that in the future.

263
0:18:01.080 --> 0:18:06.280
It should be at least easy enough to add priorities or niceness and we can probably look into

264
0:18:06.280 --> 0:18:09.520
some more sophisticated solutions a little bit later.

265
0:18:09.520 --> 0:18:12.400
Oh, and I missed one on my notes here.

266
0:18:12.400 --> 0:18:16.920
A quick note to add on the topic of address spaces is that I think it's implemented a

267
0:18:16.920 --> 0:18:21.480
little bit more elegantly than SEL4, but I did not write down why in my notes, so you'll

268
0:18:21.480 --> 0:18:25.360
have to take my word for it.

269
0:18:25.360 --> 0:18:29.600
Okay, so that's enough about the design.

270
0:18:29.600 --> 0:18:33.200
I'd like to talk a little bit about the implementation.

271
0:18:33.200 --> 0:18:37.800
The goal is to keep the kernel very straightforward when it comes to booting.

272
0:18:37.800 --> 0:18:43.640
I don't really care for the never ending nightmare which is different ways of booting up computers.

273
0:18:43.640 --> 0:18:50.200
And so the kernel is an ELF executable and the bootloader's job is to do whatever crazy

274
0:18:50.200 --> 0:18:54.440
bullshit is required on whatever platform it's running on to just load a goddamn ELF

275
0:18:54.440 --> 0:18:55.760
executable into memory.

276
0:18:55.760 --> 0:18:58.140
So that's what we've done.

277
0:18:58.140 --> 0:19:02.760
And these bootloaders are also implemented in here, by the way.

278
0:19:02.760 --> 0:19:07.640
We support, again, multi-bit on x86 and EFI on ARH64 and we'll do EFI everywhere soon,

279
0:19:07.640 --> 0:19:11.320
but the bootloader comes up and it's responsible for a few things.

280
0:19:11.320 --> 0:19:13.720
It has to, of course, read the memory map.

281
0:19:13.720 --> 0:19:18.480
It also has to load from the file system any boot modules like similar to an init ramfs

282
0:19:18.480 --> 0:19:23.040
on Linux where it's going to pull out the init binary or the init executable for the

283
0:19:23.040 --> 0:19:27.360
first user space process to run as well as maybe a tarball that init binary wants to

284
0:19:27.360 --> 0:19:30.560
use to read some early drivers from.

285
0:19:30.560 --> 0:19:35.300
It's also going to provide to the kernel that memory map, those boot modules and details

286
0:19:35.300 --> 0:19:39.280
about the loaded kernel like where it was placed in physical memory and so on.

287
0:19:39.280 --> 0:19:43.040
If we're booting with EFI, we're going to pass along some stuff about the EFI runtime

288
0:19:43.040 --> 0:19:49.720
services and if we have a frame buffer at this stage thanks to GOP or multi-boot, we'll

289
0:19:49.720 --> 0:19:56.080
pass that along as well and that will eventually make its way to user space.

290
0:19:56.080 --> 0:19:59.000
Starting boot, we have system initialization.

291
0:19:59.000 --> 0:20:07.320
You saw a little bit of this in the earlier slide which showed the code sample of the

292
0:20:07.320 --> 0:20:08.860
kernel's portable entry point.

293
0:20:08.860 --> 0:20:11.320
That's where the system initialization begins.

294
0:20:11.320 --> 0:20:16.120
Of the three phases of the kernel runtime, we have the boot phase, the system initialization

295
0:20:16.120 --> 0:20:18.160
phase and the runtime phase.

296
0:20:18.160 --> 0:20:23.280
During sys init, the purpose is to do something I hinted at earlier which is to enumerate

297
0:20:23.280 --> 0:20:27.600
all of the system resources, create capabilities for them and then assign them to the init

298
0:20:27.600 --> 0:20:33.480
process which is just again an alpha executable.

299
0:20:33.480 --> 0:20:35.680
We pull that alpha executable in from the boot modules.

300
0:20:35.680 --> 0:20:38.800
The kernel has a simple loader which pulls it into memory.

301
0:20:38.800 --> 0:20:42.480
Enumerate system resources creates enough capabilities to host a task and a v-space

302
0:20:42.480 --> 0:20:46.920
and so on for that initial executable and hand it off.

303
0:20:46.920 --> 0:20:51.680
The basic problem at this stage is not messing up memory.

304
0:20:51.680 --> 0:20:55.080
Everybody who has written a kernel from scratch maybe as opposed to approaching a project

305
0:20:55.080 --> 0:21:00.600
later knows that the hardest thing about memory management is you need memory to manage memory.

306
0:21:00.600 --> 0:21:03.620
There's a lot of stuff in this stage to deal with that.

307
0:21:03.620 --> 0:21:07.840
We also try to enumerate resources on the system at this stage but this is actually

308
0:21:07.840 --> 0:21:09.360
going to change soon.

309
0:21:09.360 --> 0:21:15.400
The kernel at the time of speaking has a PCI driver for x86 or a device tree scanner for

310
0:21:15.400 --> 0:21:20.240
ARM and we try to enumerate the physical address of everything but this is not a good idea

311
0:21:20.240 --> 0:21:25.120
so we're just going to take all physical memory and give it to user space and let it use policy

312
0:21:25.120 --> 0:21:29.520
decisions to figure out who gets what rather than trying to enumerate everything in the

313
0:21:29.520 --> 0:21:31.720
kernel just to keep the kernel smaller.

314
0:21:31.720 --> 0:21:36.160
We definitely don't want to do ACPI so please, please, if anybody here is on the RISC-V board

315
0:21:36.160 --> 0:21:38.800
or something, I'm begging you.

316
0:21:38.800 --> 0:21:40.320
No ACPI.

317
0:21:40.320 --> 0:21:41.720
Device trees.

318
0:21:41.720 --> 0:21:48.200
Then finally we jump to user space and that concludes the sys init.

319
0:21:48.200 --> 0:21:53.280
Speaking of user space, I want to talk a little bit about our future plans.

320
0:21:53.280 --> 0:21:57.280
Here we have the onion of Aries is what is called.

321
0:21:57.280 --> 0:22:02.360
Helios is the kernel at the core of this dream of a larger operating system called the Aries

322
0:22:02.360 --> 0:22:04.000
operating system.

323
0:22:04.000 --> 0:22:09.520
We want to wrap the kernel with various layers to add more functionality.

324
0:22:09.520 --> 0:22:11.360
We have Helios as the kernel.

325
0:22:11.360 --> 0:22:14.640
We've also started working on Mercury which is a framework for writing drivers.

326
0:22:14.640 --> 0:22:19.440
It's basically a user space interface to the kernel API which you can use for drivers plus

327
0:22:19.440 --> 0:22:24.800
some useful functionality like utilities to make it easier to map memory and so on.

328
0:22:24.800 --> 0:22:31.040
Then this Mercury system is applied by Venus which is a collection of drivers, real world

329
0:22:31.040 --> 0:22:33.480
drivers for actual hardware.

330
0:22:33.480 --> 0:22:38.240
At the time of this talk, Helios exists, Mercury mostly exists, and Venus was just started

331
0:22:38.240 --> 0:22:40.200
last week.

332
0:22:40.200 --> 0:22:44.480
Gaia is going to be the next thing that we're going to do on top of this.

333
0:22:44.480 --> 0:22:49.720
Through Mercury and Venus, we'll get this abstract view of the devices on the system

334
0:22:49.720 --> 0:22:54.360
as presented through IPC capabilities.

335
0:22:54.360 --> 0:23:00.000
Then this will be consumed by Gaia and formed into a cohesive user space which is going

336
0:23:00.000 --> 0:23:05.080
to essentially be Unix but everything is not a file, everything is a capability.

337
0:23:05.080 --> 0:23:10.600
You open slash dev slash FB and you get a frame buffer capability rather than an IO

338
0:23:10.600 --> 0:23:12.760
object that you might see on Unix.

339
0:23:12.760 --> 0:23:17.760
Furthermore, the design of Gaia is going to be mostly a combination of inspirations from

340
0:23:17.760 --> 0:23:20.560
Unix and Plan 9.

341
0:23:20.560 --> 0:23:25.680
On top of this, we'll add a POSIX compatibility layer because Gaia is a chance to leave behind

342
0:23:25.680 --> 0:23:29.480
the legacy of POSIX but the legacy of POSIX is strong so we'll have to accommodate it

343
0:23:29.480 --> 0:23:30.480
somehow.

344
0:23:30.480 --> 0:23:34.800
We'll tie all of this up into an operating system called Ares.

345
0:23:34.800 --> 0:23:39.400
Regarding the user space, we're going to build the stuff there.

346
0:23:39.400 --> 0:23:42.460
One other thing I want to show off is something which is part of the Mercury system which

347
0:23:42.460 --> 0:23:46.920
is our DSL for defining IPC interfaces.

348
0:23:46.920 --> 0:23:50.320
We were thinking about not doing a DSL but DSLs are kind of good for this use case so

349
0:23:50.320 --> 0:23:51.600
we made one.

350
0:23:51.600 --> 0:23:54.720
This is an example of a serial device.

351
0:23:54.720 --> 0:23:59.240
It has support for configuring the baud rate and stop bits and parity and so on.

352
0:23:59.240 --> 0:24:04.720
It implements the IO device because it supports read and write as well.

353
0:24:04.720 --> 0:24:11.980
We have a tool called IPC Gen which reads this DSL and generates hair code for it.

354
0:24:11.980 --> 0:24:17.800
This is now mostly working but we're going to start actually writing more real drivers

355
0:24:17.800 --> 0:24:21.840
with it soon so it will be, remains to be seen if we'll like it after we use it for

356
0:24:21.840 --> 0:24:24.920
a while.

357
0:24:24.920 --> 0:24:26.080
Does Helios work?

358
0:24:26.080 --> 0:24:31.080
The answer is self-evidently yes because this slide deck is being presented from this Raspberry

359
0:24:31.080 --> 0:24:36.160
Pi which is running Helios right now.

360
0:24:36.160 --> 0:24:41.760
Thank you.

361
0:24:41.760 --> 0:24:47.040
I have no C code written on this device beyond the point of EDK2.

362
0:24:47.040 --> 0:24:52.160
It has EDK2 to run UA5 but once EDK2 hands over to our EFI bootloader.

363
0:24:52.160 --> 0:24:56.960
From that point forward 100% hair and assembly, just a little bit of assembly.

364
0:24:56.960 --> 0:25:00.680
This port to ARM64 was accomplished over the past eight weeks.

365
0:25:00.680 --> 0:25:07.000
Actually it took exactly 42 days to port the kernel from x86 to AR64.

366
0:25:07.000 --> 0:25:12.480
This system has a simple driver for the Raspberry Pi GPU running in user space to drive the

367
0:25:12.480 --> 0:25:18.200
projector and it has a serial port driver which I'm connected to on my laptop here to

368
0:25:18.200 --> 0:25:23.920
switch between slides because I could not write a USB driver in eight weeks.

369
0:25:23.920 --> 0:25:29.300
The slide deck itself is encoded as quite okay images which are packed into a tarball

370
0:25:29.300 --> 0:25:34.120
and dropped in like an NMRAMFS would be.

371
0:25:34.120 --> 0:25:36.880
There really are very few hacks.

372
0:25:36.880 --> 0:25:44.280
I would say that this is a pretty complete port of the kernel with very little shortcuts

373
0:25:44.280 --> 0:25:46.480
or problems.

374
0:25:46.480 --> 0:25:51.840
The reason why I chose to port the kernel to ARM in 42 days is because I was originally

375
0:25:51.840 --> 0:25:57.800
going to give this talk from a laptop running Helios for x86-64 where I was going to drive

376
0:25:57.800 --> 0:26:01.620
the projector through Intel HD graphics and then I read the Intel HD graphics manuals

377
0:26:01.620 --> 0:26:06.400
and I decided it would be much easier to port the entire kernel to ARM and write an ARM

378
0:26:06.400 --> 0:26:07.400
GPU driver.

379
0:26:07.400 --> 0:26:10.560
So that's what I did.

380
0:26:10.560 --> 0:26:16.040
After about two days of reading the HD graphics manuals I was like I've had enough and then

381
0:26:16.040 --> 0:26:22.000
I pulled down the ARM manual and tried to find a PDF reader which could handle it.

382
0:26:22.000 --> 0:26:28.440
In terms of those hacks and shortcuts, right, there's no SOC specific builds so the same

383
0:26:28.440 --> 0:26:32.360
kernel that I wrote will boot from any ARM device with the standard EFI configuration

384
0:26:32.360 --> 0:26:33.360
and a device tree.

385
0:26:33.360 --> 0:26:35.560
It's not Raspberry Pi specific.

386
0:26:35.560 --> 0:26:38.240
The user space is Raspberry Pi specific.

387
0:26:38.240 --> 0:26:42.120
It's actually Raspberry Pi 4 specific because that's the one I have just because I didn't

388
0:26:42.120 --> 0:26:47.400
feel like doing device tree parsing and user space for the sake of the silly demo.

389
0:26:47.400 --> 0:26:51.660
But all of the silly demo code aside, the stuff that's necessary to make this talk work

390
0:26:51.660 --> 0:26:54.800
is maybe a little bit hacky and Raspberry Pi specific.

391
0:26:54.800 --> 0:26:59.440
The kernel port is a genuine port which is basically feature complete.

392
0:26:59.440 --> 0:27:04.320
I think the only hack that's in place is that I said earlier that the kernel tries to enumerate

393
0:27:04.320 --> 0:27:08.560
the device tree to find physical memory for devices to provide to user space through device

394
0:27:08.560 --> 0:27:11.240
memory capabilities and that was a bad idea.

395
0:27:11.240 --> 0:27:14.920
I was right that it was a bad idea but there is a little bit of a hack in the kernel in

396
0:27:14.920 --> 0:27:21.840
that I just gave all physical memory to the Raspberry Pi, I'm sorry, to user space without

397
0:27:21.840 --> 0:27:23.480
really much critical thought.

398
0:27:23.480 --> 0:27:25.480
That's really the only hack.

399
0:27:25.480 --> 0:27:31.800
The full complete it's done port will correct that oversight by using the EFI memory map

400
0:27:31.800 --> 0:27:37.440
to find memory which is less stupid to just lightly give to user space.

401
0:27:37.440 --> 0:27:43.240
Additionally, I will confess that I don't have support for IRQs in user space so if

402
0:27:43.240 --> 0:27:49.240
I put my finger on the heat sink here, it kind of hurts because it's just busy looping

403
0:27:49.240 --> 0:27:53.280
in user space while I wait for the next slide.

404
0:27:53.280 --> 0:28:00.120
I did get that working before Fostem, I just didn't incorporate it into the loadout for

405
0:28:00.120 --> 0:28:03.280
running the slide deck.

406
0:28:03.280 --> 0:28:07.680
It's a good thing that it's not that hot in here, this would crash.

407
0:28:07.680 --> 0:28:11.560
In total, Helios has been developed in nine months.

408
0:28:11.560 --> 0:28:17.040
The arm port was done in eight weeks and it's sophisticated enough to run this slide deck

409
0:28:17.040 --> 0:28:20.080
which is pretty cool.

410
0:28:20.080 --> 0:28:22.320
What's left to do?

411
0:28:22.320 --> 0:28:28.920
The kernel is mostly done and by done I mean feature complete but not necessarily where

412
0:28:28.920 --> 0:28:29.920
we want it to be.

413
0:28:29.920 --> 0:28:34.160
By feature complete, I mean the kernel API is complete and you can write programs against

414
0:28:34.160 --> 0:28:38.600
it which do everything we want them to do and then other improvements won't maybe not

415
0:28:38.600 --> 0:28:41.320
necessarily affect that API.

416
0:28:41.320 --> 0:28:44.800
Still needs to be polished in a number of places like that device tree issue that I

417
0:28:44.800 --> 0:28:46.160
mentioned is one case.

418
0:28:46.160 --> 0:28:49.340
If you get correct through the code base, you'll find about 100 comments which we need

419
0:28:49.340 --> 0:28:50.680
to address.

420
0:28:50.680 --> 0:28:55.040
One of the more challenging things that we're going to have to do is SMP support but again

421
0:28:55.040 --> 0:28:59.080
the kernel is a total of 15,000 lines of code.

422
0:28:59.080 --> 0:29:04.120
Despite the boogeyman that SMP often appears to be to most kernel hackers, I imagine that

423
0:29:04.120 --> 0:29:09.840
it won't be that difficult for us to do which could be famous last words but we'll see.

424
0:29:09.840 --> 0:29:11.600
I also want to port it to RISC-V.

425
0:29:11.600 --> 0:29:19.800
I have gotten some hair code running on RISC-V at the supervisory level thanks to the efforts

426
0:29:19.800 --> 0:29:22.180
of one of the hair contributors.

427
0:29:22.180 --> 0:29:26.600
We did do some basic OS dev research but we haven't actually ported Helios itself to RISC-V

428
0:29:26.600 --> 0:29:28.040
but we'll do that soon.

429
0:29:28.040 --> 0:29:31.000
I also mentioned that we're going to work on more options for the bootloader so we're

430
0:29:31.000 --> 0:29:33.440
going to try to get EFI going everywhere.

431
0:29:33.440 --> 0:29:40.720
The main blocker for EFI on x86-64 for example is that our programming language which again

432
0:29:40.720 --> 0:29:46.520
is hair which is developed almost alongside this project.

433
0:29:46.520 --> 0:29:52.880
X86 doesn't have support for PIC and so it would kind of be a little bit of a nightmare

434
0:29:52.880 --> 0:29:59.620
to do runtime relocations of the bootloader and assembly or something of that nature so

435
0:29:59.620 --> 0:30:05.280
we're going to do PIC first before we try to do an EFI bootloader for x86 but we do

436
0:30:05.280 --> 0:30:11.240
have PIC for ARM so that's already working.

437
0:30:11.240 --> 0:30:13.000
And then I also want to improve the docs.

438
0:30:13.000 --> 0:30:20.080
I spent the past few weeks in between hacking on the ARM kernel, improving the documentation

439
0:30:20.080 --> 0:30:25.680
on the website Aries-OS.org which there will be a link to in a later slide which is probably

440
0:30:25.680 --> 0:30:29.720
now about 60% complete so if you're curious about the project and maybe you want to try

441
0:30:29.720 --> 0:30:34.280
your hand at a little driver in user space feel free to check that out and wherever you

442
0:30:34.280 --> 0:30:39.960
find a page which is a stub and you need to know what it should say you can come to IRC

443
0:30:39.960 --> 0:30:43.880
and ask about it and we'll fill it in.

444
0:30:43.880 --> 0:30:49.360
After the kernel is polished actually alongside the kernel polish is going to user space where

445
0:30:49.360 --> 0:30:53.520
I explained a lot of the things that we were looking at.

446
0:30:53.520 --> 0:30:57.800
Mercury again mostly exists and Venus is just getting started.

447
0:30:57.800 --> 0:31:02.720
Prior to the introduction of Venus we did have a number of drivers that were built for

448
0:31:02.720 --> 0:31:05.480
the purpose of testing the kernel and testing Mercury and so on.

449
0:31:05.480 --> 0:31:11.080
We obviously have a serial driver for x86, we have a PL011 serial driver for ARM.

450
0:31:11.080 --> 0:31:13.680
We've also done things like E1000 networking.

451
0:31:13.680 --> 0:31:15.560
We did send pings with that.

452
0:31:15.560 --> 0:31:20.780
We did the RDO block devices and a couple of other simple drivers just as we were working

453
0:31:20.780 --> 0:31:23.740
to prove the design of the support code for drivers.

454
0:31:23.740 --> 0:31:30.280
But the support code is mostly done so now we're going to start writing drivers for real.

455
0:31:30.280 --> 0:31:35.880
I need to provide some acknowledgements here to people who helped to make Helios work.

456
0:31:35.880 --> 0:31:39.840
Certainly I mentioned earlier that there's a RISC-V kernel by Alexi Uren.

457
0:31:39.840 --> 0:31:44.920
Ember Savati also did some work on x86 for early kernel attempts.

458
0:31:44.920 --> 0:31:46.440
This was really useful stuff.

459
0:31:46.440 --> 0:31:50.520
None of this code was very little of this code that came from these efforts of A.D.A.

460
0:31:50.520 --> 0:31:55.600
to Helios and these projects never really developed into full systems.

461
0:31:55.600 --> 0:31:59.480
I don't think either of them made it to user space but they were still very useful for

462
0:31:59.480 --> 0:32:04.520
proving out some ideas about how to actually do basic kernel hacking in Heir.

463
0:32:04.520 --> 0:32:05.800
How do we boot up the system?

464
0:32:05.800 --> 0:32:07.000
How do we work from ring zero?

465
0:32:07.000 --> 0:32:08.200
How do we configure the MMU?

466
0:32:08.200 --> 0:32:11.040
How do we do yada yada yada, deal with interrupts and so on?

467
0:32:11.040 --> 0:32:12.440
How do we link it properly?

468
0:32:12.440 --> 0:32:16.240
All questions that had not been answered previously within the context of the Heir programming

469
0:32:16.240 --> 0:32:21.760
language and so this work was definitely instrumental in setting the field upon which Helios could

470
0:32:21.760 --> 0:32:23.000
be built.

471
0:32:23.000 --> 0:32:24.920
Big thanks to these guys.

472
0:32:24.920 --> 0:32:26.600
Also thanks to the Heir community.

473
0:32:26.600 --> 0:32:28.240
There's almost 80 people now.

474
0:32:28.240 --> 0:32:29.920
Obviously I think it's more than 80 now.

475
0:32:29.920 --> 0:32:32.880
There's around 80 people who have been working on the programming language itself.

476
0:32:32.880 --> 0:32:39.800
Again, we've been working on it for about three years now and the project Helios of

477
0:32:39.800 --> 0:32:42.920
course would not be possible without the programming language it's written in.

478
0:32:42.920 --> 0:32:46.200
So a huge shout out to the Heir community for everything they've done.

479
0:32:46.200 --> 0:32:47.840
Very proud of that community.

480
0:32:47.840 --> 0:32:51.400
I also want to thank the OS Dev community on the BarraChat.

481
0:32:51.400 --> 0:32:54.440
Hands up if any of you are in this channel.

482
0:32:54.440 --> 0:32:59.800
So OS Dev on the BarraChat is the single best place to learn about kernel hacking on the

483
0:32:59.800 --> 0:33:00.800
entire internet.

484
0:33:00.800 --> 0:33:04.280
Those guys are so smart and helpful and they're very knowledgeable.

485
0:33:04.280 --> 0:33:07.480
They know everything about kernel hacking and drivers and anything you want to know.

486
0:33:07.480 --> 0:33:11.480
If you want to mess with kernels, go talk to these people.

487
0:33:11.480 --> 0:33:13.160
And also of course to SCL4.

488
0:33:13.160 --> 0:33:16.200
As I'm sure you noticed, we took a whole bunch of ideas from SCL4.

489
0:33:16.200 --> 0:33:20.440
I think SCL4 has got a really cool kernel design and I was really happy to learn about

490
0:33:20.440 --> 0:33:24.640
it and apply a lot of its ideas to my own kernel.

491
0:33:24.640 --> 0:33:27.640
So kernel hacking is fun, Heir is fun, let's all have fun.

492
0:33:27.640 --> 0:33:29.560
That's it.

493
0:33:29.560 --> 0:33:38.160
Thank you so much, Drew.

494
0:33:38.160 --> 0:33:39.160
Any questions from the audience?

495
0:33:39.160 --> 0:33:40.160
Martin.

496
0:33:40.160 --> 0:33:41.160
I'm going to give you guys my talk.

497
0:33:41.160 --> 0:33:47.880
Pass it on to Martin first and then we're going to give you.

498
0:33:47.880 --> 0:33:48.880
Hi.

499
0:33:48.880 --> 0:33:49.880
Thanks for the talk.

500
0:33:49.880 --> 0:33:52.880
Good work.

501
0:33:52.880 --> 0:34:01.920
I was unable to map the standard SCL4 capability derivation tree like starting with untied memory

502
0:34:01.920 --> 0:34:04.840
and then everything that to your slides.

503
0:34:04.840 --> 0:34:06.240
So do you have it as well?

504
0:34:06.240 --> 0:34:07.240
Or?

505
0:34:07.240 --> 0:34:08.340
Yeah, we do.

506
0:34:08.340 --> 0:34:12.660
We just track capability derivations in a manner very similar to SCL4 and it really

507
0:34:12.660 --> 0:34:16.720
would have been smart for me to put in a slide about that.

508
0:34:16.720 --> 0:34:18.240
So thanks for the clarification.

509
0:34:18.240 --> 0:34:22.280
And second, well, I have a hard time formulating it

510
0:34:22.280 --> 0:34:27.400
as a question, so maybe just take it as an unsolicited advice.

511
0:34:27.400 --> 0:34:29.640
Many of the design decisions of SCL4

512
0:34:29.640 --> 0:34:34.280
were strictly motivated by the formal verification target.

513
0:34:34.280 --> 0:34:36.560
So maybe when you have spoken, for example,

514
0:34:36.560 --> 0:34:40.080
about not sharing the pages, et cetera,

515
0:34:40.080 --> 0:34:42.560
just give it a thought that the reason for that

516
0:34:42.560 --> 0:34:49.320
might be that they did not want to make their life harder

517
0:34:49.320 --> 0:34:51.000
regarding the formal verification.

518
0:34:51.000 --> 0:34:52.560
And that might be the only reason.

519
0:34:52.560 --> 0:34:55.400
Yeah, I think I've noticed that for a few other implementation

520
0:34:55.400 --> 0:34:58.200
details from SCL4 when we were studying a kernel to learn

521
0:34:58.200 --> 0:35:00.480
what we could do for ours.

522
0:35:00.480 --> 0:35:04.760
And with examples like sharing page tables,

523
0:35:04.760 --> 0:35:07.200
I had bigger fish to fry, so I left a comment which says,

524
0:35:07.200 --> 0:35:09.080
SCL4 doesn't support copying these,

525
0:35:09.080 --> 0:35:10.960
and I would rather not run into a Heisenberg

526
0:35:10.960 --> 0:35:13.840
because we did it without thinking about it.

527
0:35:13.840 --> 0:35:15.320
And then we can really address it

528
0:35:15.320 --> 0:35:17.240
at some point in the future.

529
0:35:17.240 --> 0:35:17.740
Thanks.

530
0:35:21.400 --> 0:35:22.160
Hi.

531
0:35:22.160 --> 0:35:23.400
Yeah, thanks for the talk.

532
0:35:23.400 --> 0:35:25.800
Very interesting, quite impressive.

533
0:35:25.800 --> 0:35:28.000
Yesterday we were talking about hair,

534
0:35:28.000 --> 0:35:30.920
and thinking about it in retrospect,

535
0:35:30.920 --> 0:35:33.240
it seemed to me, my personal opinion,

536
0:35:33.240 --> 0:35:36.240
that the great mechanisms of language design

537
0:35:36.240 --> 0:35:37.960
are mostly discovered.

538
0:35:37.960 --> 0:35:40.440
Like we have garbage collection and tech unions

539
0:35:40.440 --> 0:35:43.040
and that assuming you agree with that statement

540
0:35:43.040 --> 0:35:45.440
now that you've written that operating system kernel,

541
0:35:45.440 --> 0:35:48.080
would you also say that the great mechanisms how

542
0:35:48.080 --> 0:35:50.600
to write a kernel are established and well-known?

543
0:35:50.600 --> 0:35:52.920
Things like paging, what's the still areas

544
0:35:52.920 --> 0:35:57.000
to experiment in new ways to do memory management?

545
0:35:57.000 --> 0:36:00.160
Things like that.

546
0:36:00.160 --> 0:36:01.480
Interesting question.

547
0:36:01.480 --> 0:36:05.200
I would say that there is a lot of concepts and ideas which

548
0:36:05.200 --> 0:36:07.800
can be applied in the field of OS development, which

549
0:36:07.800 --> 0:36:12.200
are understood, and you can see examples of kernels

550
0:36:12.200 --> 0:36:14.400
and systems which apply these ideas,

551
0:36:14.400 --> 0:36:17.160
and various different designs that you can learn from

552
0:36:17.160 --> 0:36:19.120
and study and maybe apply to your own kernel

553
0:36:19.120 --> 0:36:20.880
if they're the right choice.

554
0:36:20.880 --> 0:36:22.480
And you can make a complete kernel,

555
0:36:22.480 --> 0:36:25.520
which is interesting, basically only using proven ideas, which

556
0:36:25.520 --> 0:36:29.720
is, for the most part, describes Helios.

557
0:36:29.720 --> 0:36:32.160
But at the same time, there's certainly all kinds of research

558
0:36:32.160 --> 0:36:35.040
which is being done into more novel approaches.

559
0:36:35.040 --> 0:36:37.360
There's been talks in this room throughout the day,

560
0:36:37.360 --> 0:36:41.560
which address some of those novel approaches and ideas.

561
0:36:41.560 --> 0:36:43.720
So I would say that there is certainly

562
0:36:43.720 --> 0:36:46.160
room to build a kernel out of understood ideas

563
0:36:46.160 --> 0:36:47.440
and still make it interesting.

564
0:36:47.440 --> 0:36:51.320
But there's also definitely an active frontier of research

565
0:36:51.320 --> 0:36:53.200
ongoing as well.

566
0:36:53.200 --> 0:36:54.520
Thank you.

567
0:36:54.520 --> 0:36:57.720
Thank you so much.

568
0:36:57.720 --> 0:36:58.520
Any other questions?

569
0:37:01.920 --> 0:37:03.560
Yeah, please.

570
0:37:03.560 --> 0:37:07.560
Let me.

571
0:37:07.560 --> 0:37:08.060
Oh.

572
0:37:12.200 --> 0:37:13.400
Yeah.

573
0:37:13.400 --> 0:37:14.480
Thank you for the talk.

574
0:37:14.480 --> 0:37:15.760
You mentioned that you need to have

575
0:37:15.760 --> 0:37:17.320
position-independent code, right?

576
0:37:17.320 --> 0:37:18.200
Yeah.

577
0:37:18.200 --> 0:37:21.440
But I don't understand if you use every driver,

578
0:37:21.440 --> 0:37:24.400
and it's just like a user space process.

579
0:37:24.400 --> 0:37:28.440
So can't you just remap that in MMM so that all the processes,

580
0:37:28.440 --> 0:37:32.000
like a normal Linux process, just have the same memory map?

581
0:37:32.000 --> 0:37:34.160
Yeah, actually, the kernel and user space processes

582
0:37:34.160 --> 0:37:35.680
both use a fixed memory map.

583
0:37:35.680 --> 0:37:37.440
The thing where we would maybe want

584
0:37:37.440 --> 0:37:38.840
to look at position-independent code

585
0:37:38.840 --> 0:37:41.400
is specifically for the case of loading our EFI bootloader

586
0:37:41.400 --> 0:37:43.880
as a P32 plus executable.

587
0:37:43.880 --> 0:37:46.720
After that stage, it's all fixed memory addresses.

588
0:37:46.720 --> 0:37:47.220
OK.

589
0:37:47.220 --> 0:37:48.320
Yeah, then I understand.

590
0:37:48.320 --> 0:37:48.800
Cool.

591
0:37:55.280 --> 0:37:56.160
Hello.

592
0:37:56.160 --> 0:37:57.560
Thank you for the talk.

593
0:37:57.560 --> 0:37:59.680
Can I ask a non-technical element?

594
0:37:59.680 --> 0:38:02.040
You've GPL freed it.

595
0:38:02.040 --> 0:38:03.920
How are you making decisions around the kernel?

596
0:38:03.920 --> 0:38:05.080
Is it an everland dictator?

597
0:38:05.080 --> 0:38:06.080
Are you making decisions?

598
0:38:06.080 --> 0:38:08.600
Or are you having massive conversations about things?

599
0:38:08.600 --> 0:38:12.000
How's that looking at the moment?

600
0:38:12.000 --> 0:38:13.480
The vast majority of the work is just

601
0:38:13.480 --> 0:38:15.360
done by me personally at the moment.

602
0:38:15.360 --> 0:38:16.920
The project is still pretty early on,

603
0:38:16.920 --> 0:38:19.680
but we do have a number of other contributors.

604
0:38:19.680 --> 0:38:21.760
I would say that the group of people

605
0:38:21.760 --> 0:38:24.240
who ought to be consulted on changes

606
0:38:24.240 --> 0:38:28.120
is probably in the ballpark of five people in total.

607
0:38:28.120 --> 0:38:31.040
So we just have a fairly informal community

608
0:38:31.040 --> 0:38:32.000
based on trust.

609
0:38:32.000 --> 0:38:34.680
And we try to be transparent, like I am transparent,

610
0:38:34.680 --> 0:38:35.840
in all of my free software.

611
0:38:35.840 --> 0:38:37.400
So we have a public IRC channel where

612
0:38:37.400 --> 0:38:38.520
we have these discussions.

613
0:38:38.520 --> 0:38:40.160
Anybody can jump in at any time.

614
0:38:40.160 --> 0:38:41.620
And there's a patch review process

615
0:38:41.620 --> 0:38:43.280
which just goes through me at the moment.

616
0:38:43.280 --> 0:38:45.120
But in the hair community, for example,

617
0:38:45.120 --> 0:38:47.000
which is a lot bigger at this stage,

618
0:38:47.000 --> 0:38:49.680
we have something more of a governance model

619
0:38:49.680 --> 0:38:51.480
where there's less of a BDFL and more

620
0:38:51.480 --> 0:38:54.920
of multiple maintainers who all can do code reviews

621
0:38:54.920 --> 0:38:57.160
and improve patches and things like this.

622
0:38:57.160 --> 0:38:59.040
And as the Helios project grows, I imagine

623
0:38:59.040 --> 0:39:01.720
it will adopt a model similar to hair.

624
0:39:01.720 --> 0:39:03.240
And perhaps as hair grows, we'll have

625
0:39:03.240 --> 0:39:05.440
to improve upon the model even further.

626
0:39:05.440 --> 0:39:06.840
But we'll see.

627
0:39:06.840 --> 0:39:07.340
Thank you.

628
0:39:07.340 --> 0:39:08.240
Nice share, by the way.

629
0:39:08.240 --> 0:39:08.740
David.

630
0:39:15.700 --> 0:39:18.400
You mentioned that you don't want to deal with ACPI,

631
0:39:18.400 --> 0:39:21.360
but at the same time, you want to make you have i standard.

632
0:39:21.360 --> 0:39:23.040
So what's the plan there?

633
0:39:23.040 --> 0:39:26.220
Is there any way to solve a thought ACPI in your system?

634
0:39:26.220 --> 0:39:29.920
Because I imagine that it will become mandatory, right?

635
0:39:29.920 --> 0:39:31.280
Yeah.

636
0:39:31.280 --> 0:39:33.480
I'm going to wail and gnash my teeth

637
0:39:33.480 --> 0:39:35.880
and hope it doesn't happen in practice.

638
0:39:35.880 --> 0:39:39.320
Because at the moment, you know something like EDK2.

639
0:39:39.320 --> 0:39:41.560
To be clear, by the way, I don't give a fuck

640
0:39:41.560 --> 0:39:43.000
about non-free firmwares.

641
0:39:43.000 --> 0:39:46.360
So I'm thinking about EDK2 and things like that, or U-Boot

642
0:39:46.360 --> 0:39:50.920
and so on, where there's already an EFI standard UUID

643
0:39:50.920 --> 0:39:52.400
for passing a device tree along.

644
0:39:52.400 --> 0:39:54.760
And they can be configured to do that instead of ACPI, which

645
0:39:54.760 --> 0:39:57.520
is what I'm doing on this Raspberry Pi, for example,

646
0:39:57.520 --> 0:40:00.360
and what I hope to continue to do on RISC-V and so on.

647
0:40:00.360 --> 0:40:04.160
Our proof of concept on RISC-V took the same approach.

648
0:40:04.160 --> 0:40:06.880
But there's very little in the kernel

649
0:40:06.880 --> 0:40:09.440
that actually needs to be concerned with ACPI

650
0:40:09.440 --> 0:40:10.440
versus device trees.

651
0:40:10.440 --> 0:40:12.320
And again, it is a microkernel.

652
0:40:12.320 --> 0:40:15.600
So in the long term, we might just pass along the rather

653
0:40:15.600 --> 0:40:27.560
than the previous one.

654
0:40:27.560 --> 0:40:29.720
At least a little bit in x86, because there's

655
0:40:29.720 --> 0:40:31.760
no device trees.

656
0:40:31.760 --> 0:40:35.200
But fingers in my ears not thinking about the fact

657
0:40:35.200 --> 0:40:38.320
that ACPI is upon us, but we'll probably

658
0:40:38.320 --> 0:40:47.680
have to deal with it at some point.

659
0:40:47.680 --> 0:40:49.240
Thank you for the presentation.

660
0:40:49.240 --> 0:40:51.800
Which software is running the presentation itself,

661
0:40:51.800 --> 0:40:53.680
and how is it combined?

662
0:40:53.680 --> 0:40:57.120
This is just a custom piece of software I wrote myself.

663
0:40:57.120 --> 0:41:00.920
It's a single binary, which is loaded by the bootloader

664
0:41:00.920 --> 0:41:02.000
as the init process.

665
0:41:02.000 --> 0:41:04.720
And then the kernel loads it into an address space

666
0:41:04.720 --> 0:41:06.920
and boots it up as PID1.

667
0:41:06.920 --> 0:41:09.920
And there's additionally a tarball

668
0:41:09.920 --> 0:41:13.040
as a second boot module, which is again loaded into memory

669
0:41:13.040 --> 0:41:15.800
and then passed along to PID1, which

670
0:41:15.800 --> 0:41:17.520
is a tarball full of slides.

671
0:41:17.520 --> 0:41:19.680
And then there's just one statically linked executable,

672
0:41:19.680 --> 0:41:23.320
which contains a serial driver and a GPU driver and the code

673
0:41:23.320 --> 0:41:26.040
to glue everything together.

674
0:41:26.040 --> 0:41:28.360
The code, by the way, is available on source

675
0:41:28.360 --> 0:41:37.360
side if you're curious.

676
0:41:37.360 --> 0:41:41.880
As you mentioned, Elios is heavily inspired by STL4.

677
0:41:41.880 --> 0:41:45.880
So is there any plan on formal verification for Elios?

678
0:41:45.880 --> 0:41:48.080
Or is that just not something you're interested in?

679
0:41:48.080 --> 0:41:52.080
No, I'm not particularly interested in that.

680
0:41:52.080 --> 0:42:00.240
In the back, there's someone.

681
0:42:00.240 --> 0:42:01.920
Thanks for the presentation.

682
0:42:01.920 --> 0:42:02.960
I have a question.

683
0:42:02.960 --> 0:42:05.680
Is it on the roadmap that something like Western

684
0:42:05.680 --> 0:42:09.880
or a other GUI server or other service like that

685
0:42:09.880 --> 0:42:11.920
could potentially be ported to Helios?

686
0:42:11.920 --> 0:42:14.800
I'm actually also the original author of W.R. Roots

687
0:42:14.800 --> 0:42:16.640
and have a lot of experience in Wayland.

688
0:42:16.640 --> 0:42:19.640
And so there is a 100% chance that Wayland will be running

689
0:42:19.640 --> 0:42:21.240
on Helios at some point.

690
0:42:21.240 --> 0:42:24.240
OK.

691
0:42:24.240 --> 0:42:25.240
Any other questions?

692
0:42:30.720 --> 0:42:38.200
So you said for Gaia, you are inspired by Plan 9 and Unix.

693
0:42:38.200 --> 0:42:39.640
What's the best?

694
0:42:39.640 --> 0:42:40.760
What do you plan for Gaia?

695
0:42:40.760 --> 0:42:45.760
What's the best of those both worlds?

696
0:42:45.760 --> 0:42:47.680
It's a little bit hard to say.

697
0:42:47.680 --> 0:42:50.600
At this point, there is less plans and more vision

698
0:42:50.600 --> 0:42:54.280
in that respect because we have at least probably a year of work

699
0:42:54.280 --> 0:42:57.080
before it can really start serious work on Gaia.

700
0:42:57.080 --> 0:42:58.920
But I will say that there is a lot of stuff

701
0:42:58.920 --> 0:43:01.320
I admire about Plan 9.

702
0:43:01.320 --> 0:43:04.960
There's per-process namespaces is one great idea.

703
0:43:04.960 --> 0:43:09.000
I'm also going to go further with the idea of there

704
0:43:09.000 --> 0:43:11.760
not being any kind of global file system at all.

705
0:43:11.760 --> 0:43:14.080
We're also going to take a look at things

706
0:43:14.080 --> 0:43:17.240
like using text-based protocols where possible.

707
0:43:17.240 --> 0:43:20.360
And we're going to use different from Plan 9.

708
0:43:20.360 --> 0:43:24.240
We're going to use this IPC generation thing for places

709
0:43:24.240 --> 0:43:26.680
where text protocols maybe don't make sense.

710
0:43:26.680 --> 0:43:30.200
I also have a lot of admiration for things like MBD on Plan 9.

711
0:43:30.200 --> 0:43:32.560
And so I would like to organize networks perhaps

712
0:43:32.560 --> 0:43:35.440
in a similar fashion.

713
0:43:35.440 --> 0:43:39.360
And also, I would say that the bigger vision for the whole ARIES

714
0:43:39.360 --> 0:43:43.840
system is you can almost say it's correcting a mistake

715
0:43:43.840 --> 0:43:47.160
that Plan 9 made, which is that Plan 9 was correct,

716
0:43:47.160 --> 0:43:49.920
that distributed computing is the future.

717
0:43:49.920 --> 0:43:51.720
But it was incorrect that they would

718
0:43:51.720 --> 0:43:54.720
be distributed across a mainframe and a bunch of thin

719
0:43:54.720 --> 0:43:57.480
clients in an office building, which is how Plan 9 was designed.

720
0:43:57.480 --> 0:43:59.680
In fact, the group of devices which

721
0:43:59.680 --> 0:44:02.000
should be running a uniform operating system

722
0:44:02.000 --> 0:44:04.600
is all of your personal devices, my laptop, my workstation

723
0:44:04.600 --> 0:44:05.880
at home, my phones.

724
0:44:05.880 --> 0:44:08.160
They should all present as a single system.

725
0:44:08.160 --> 0:44:12.200
And so it's very vague and lofty and long-term vision.

726
0:44:12.200 --> 0:44:14.560
But I would like to try and achieve that with the design

727
0:44:14.560 --> 0:44:18.400
of Gaia and ARIES.

728
0:44:18.400 --> 0:44:18.900
Thank you.

729
0:44:18.900 --> 0:44:22.320
Any other questions?

730
0:44:22.320 --> 0:44:24.640
OK, then thank you so much, Drew.

731
0:44:24.640 --> 0:44:25.400
Thanks a lot.

732
0:44:25.400 --> 0:44:25.900
Thank you.

733
0:44:25.900 --> 0:44:26.400
Thank you.

734
0:44:26.400 --> 0:44:26.900
Thank you.

735
0:44:26.900 --> 0:44:27.400
Thank you.

736
0:44:27.400 --> 0:44:27.900
Thank you.

737
0:44:27.900 --> 0:44:28.400
Thank you.

738
0:44:28.400 --> 0:44:28.900
Thank you.

739
0:44:28.900 --> 0:44:29.400
Thank you.

740
0:44:29.400 --> 0:44:29.900
Thank you.

741
0:44:29.900 --> 0:44:30.400
Thank you.

742
0:44:30.400 --> 0:44:51.240
10 minutes break until the next talk.

