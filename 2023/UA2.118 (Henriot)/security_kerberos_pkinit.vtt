WEBVTT

00:00.000 --> 00:20.800
Okay. We can't start? Oh. Okay. Hello. I'm Fraser. I come from Australia. I work at Red

00:20.800 --> 00:31.280
Hat on identity management and PKI solutions. Talking about Kerberos PKInit protocol. I'll

00:31.280 --> 00:39.120
give an overview of the Kerberos authentication protocol. Then I will discuss PKInit, what

00:39.120 --> 00:46.400
its advantages are, how it works, and a short demo. Then I will discuss the security considerations

00:46.400 --> 00:55.120
and give a demonstration of a recently discovered attack against the implementation of Kerberos

00:55.120 --> 01:06.000
PKInit that we have in free IPA. So Kerberos is an authentication protocol based on symmetric

01:06.000 --> 01:12.960
cryptography. It's a single sign-on protocol, so you can authenticate once per day, for example,

01:12.960 --> 01:23.040
and using a token from that initial authentication, you can then authenticate to additional services,

01:23.040 --> 01:34.880
hosts, or users in the organization's infrastructure. It was started at MIT in the late 80s. The current

01:34.880 --> 01:43.120
major version of the protocol is version 5, and it came about in the early 90s. The most recent

01:43.120 --> 01:54.880
IETF document describing the base protocol is RFC 4120, and that was from 2005, so even that version

01:54.880 --> 02:04.000
is nearly 18 years old, but there have been many extensions and enhancements since then. The major

02:04.000 --> 02:12.320
implementations are MIT Kerberos, Microsoft Active Directory, Heimdall, and free IPA, or identity

02:12.320 --> 02:19.120
management in RHEL, which uses MIT Kerberos under the hood with some additional extensions.

02:22.720 --> 02:29.200
The parties in the Kerberos authentication protocol are the client, the key distribution

02:29.200 --> 02:38.240
center, and services. So the key distribution center, or KDC, consists of two services that

02:38.240 --> 02:47.360
are logically distinct within the protocol, but typically combined together into this one party,

02:47.360 --> 02:55.920
which is called the KDC. Users, services, and the KDC itself are all represented as principles

02:55.920 --> 03:00.960
in a realm. So a principle is just a name for a user, host, or service in the realm,

03:01.520 --> 03:07.200
and the realm is the name space for those user, hosts, or services. So often you'll see one company,

03:07.200 --> 03:13.280
one organization might have one realm, but as companies grow or have mergers and acquisitions,

03:14.640 --> 03:18.800
then typically you'll end up with multiple realms in your organization.

03:18.800 --> 03:29.680
Each principle has a long-term secret key, which is shared with the KDC. For users, it's typically

03:29.680 --> 03:37.680
derived from a pass word or pass phrase, so using pbkdf2 or some other key derivation algorithm.

03:38.880 --> 03:45.200
And for hosts and services, the file is often stored in just in a flat file, which we call a

03:45.200 --> 03:53.280
key tab. And the authentication tokens themselves, which are exchanged in this protocol, are called

03:53.280 --> 04:02.560
tickets. So let's do some diagrams. The parties, clients, server, or services, and the KDC.

04:03.120 --> 04:07.600
We can see the client has a key, the server has a key, and the KDC has all of the keys,

04:07.600 --> 04:16.400
including the ticket granting service, TGS key, which is one of the KDC services. So the initial

04:16.400 --> 04:22.800
authentication exchange involves what we call an ASREC or authentication service request. The client

04:22.800 --> 04:29.520
says, hey, it's me, I want to authenticate. Actually, it doesn't necessarily carry any

04:29.520 --> 04:36.080
authentication information. The authentication happens when the KDC responds to the client,

04:36.080 --> 04:44.640
and the response includes a session key randomly generated by the KDC, encrypted to the client's

04:44.640 --> 04:51.840
secret key. So the client does not authenticate to the KDC. There are ways that you can do that,

04:51.840 --> 04:58.000
but in the base protocol, the authentication happens because only the client can decrypt

04:58.000 --> 05:04.640
the response containing the session key. The response also contains a ticket called the

05:04.640 --> 05:09.600
ticket granting ticket, which is not encrypted to the client's key, but rather to the ticket

05:09.600 --> 05:16.000
granting services key. It also contains a copy of the session key and some information about the

05:16.000 --> 05:22.080
client. So the client can decrypt the session key and store the ticket granting ticket.

05:24.160 --> 05:32.880
Later, when the client wants to authenticate to the server, it sends a TGS request to the KDC,

05:32.880 --> 05:37.680
saying, I would like to talk to such and such a principal, in this case, a server.

05:39.040 --> 05:48.080
It includes the ticket granting service ticket, or TGT, and it also includes a time stamp for

05:48.080 --> 05:54.000
a replay attack prevention and some client information encrypted to the session key.

05:54.640 --> 06:01.920
The KDC can use the TGS secret key to decrypt the ticket, pull out the session key,

06:01.920 --> 06:09.040
decrypt the client authenticator, make sure the client info matches up, make sure the time stamp

06:09.040 --> 06:19.840
is within an allowable SKU, and if everything checks out, then in the TGS reply, the KDC can

06:19.840 --> 06:27.280
return a ticket for the server, which contains a new session key, and it also returns the new

06:27.280 --> 06:35.920
session key encrypted under the existing session key for the TGS session. So the client can decrypt

06:35.920 --> 06:42.720
the second session key and store the ticket for the service, the service ticket, and finally,

06:42.720 --> 06:48.320
it can talk to the service. So it sends the application protocol request, it includes the

06:48.320 --> 06:53.120
service ticket, it includes an authenticator encrypted using the second session key.

06:53.120 --> 07:00.560
The server can then use its long-term secret key to decrypt the ticket, pull out the session key,

07:01.520 --> 07:07.440
and then it can use that session key to decrypt the authenticator, make sure the client info

07:07.440 --> 07:12.960
all lines up, make sure the time stamp is within the allowable SKU, and then there's a shared

07:12.960 --> 07:17.760
session key between the client and the server. They can talk whatever protocol they want to talk

07:17.760 --> 07:25.920
using that session key. Okay, so that's the base Kerberos protocol.

07:27.680 --> 07:32.080
Kerberos has a bunch of extensions and integrations. There's a pre-authentication

07:32.080 --> 07:36.960
framework that allows you to integrate additional authentication mechanisms,

07:37.520 --> 07:46.000
such as a TOTP or an HOTP. There are mechanisms for embedding Kerberos authentication in the

07:46.000 --> 07:52.800
GSS API and in SaZL, so that will allow you to use Kerberos authentication with other protocols

07:52.800 --> 08:02.480
that support those authentication frameworks, such as LDAP or SMTP, IMAP, etc. For HTTP,

08:02.480 --> 08:10.480
there's a protocol called Spenego or Spengo, and we can also include authorization information

08:10.480 --> 08:16.960
in the tickets, which contain additional information about the client, how they

08:16.960 --> 08:22.240
authenticated to the KDC. So this is what we call the authentication indicator extension,

08:23.360 --> 08:28.320
and there are other kinds of authentication data. For example, Microsoft Active Directory

08:28.320 --> 08:32.960
includes what's called a PAC. I can't remember what that stands for, but Alexander will know.

08:32.960 --> 08:42.480
Privileged attributes certificate. There you go, so that's the MS PAC extension,

08:42.480 --> 08:47.760
which you'll frequently see when you're working with Active Directory or cross-realm trusts.

08:48.800 --> 08:55.200
With Active Directory, that's that final point. I explained that there were situations where

08:55.200 --> 09:01.120
you're dealing with multiple realms. What if principles from one realm need to communicate

09:01.120 --> 09:06.800
or authenticate to principles in a different realm? That is accomplished by trusts and the

09:06.800 --> 09:14.400
cross-realm authentication mechanisms. So the advantages of Kerberos, well, it's single sign-on,

09:14.400 --> 09:22.640
which improves efficiency and reduces password fatigue for users. The client has to expose their

09:22.640 --> 09:30.720
long-term secret only once until the TGT expires, so maybe once per day at the start of the day,

09:30.720 --> 09:36.640
logging into your workstation, a single authentication happens, and from then on,

09:37.360 --> 09:45.120
you no longer need to explicitly authenticate. It is resistant to the replay attacks. That's why

09:45.120 --> 09:52.560
all of the authenticators include timestamps, and it works well for HTTP as well as bare network

09:52.560 --> 10:02.880
protocols, which is a shortcoming of the predominantly HTTP-centric SSO protocols like SAML

10:02.880 --> 10:10.240
and OpenID Connect. But the problems are, of course, that passwords are not great,

10:10.240 --> 10:16.800
and dealing with passwords or the secret keys in key tabs, making sure that they are rotated,

10:16.800 --> 10:22.960
making sure that they are secure in the first place, can be challenging and burdensome with

10:22.960 --> 10:31.680
substantial administrative overhead. So this brings us to PK-INIT, or public key cryptography

10:31.680 --> 10:39.760
for initial authentication in Kerberos, as the RFC is called. In this protocol extension, the

10:39.760 --> 10:45.120
client can use asymmetric cryptography to authenticate to the KDC,

10:45.120 --> 10:52.720
and the client presents an X509 certificate in its initial authentication request,

10:53.920 --> 11:01.520
as well as a signature made with the public key, or the private key corresponding to the public key

11:02.720 --> 11:10.240
contained in the certificate. The KDC verifies the certificate, the signature, and the binding

11:10.240 --> 11:17.440
of the key in the certificate to the client principle, and if everything checks out, it can

11:17.440 --> 11:25.440
respond with a response encrypted either using Diffie-Hellman or some other analogous key

11:25.440 --> 11:30.960
agreement algorithm, or another public key encryption algorithm, such as direct RSA

11:30.960 --> 11:38.000
encryption. So visualising this, the client in the authentication service request says,

11:38.000 --> 11:42.960
hey, it's me client, but this time it includes some additional pre-authentication data.

11:43.840 --> 11:49.360
It includes a timestamp, and if it wants to use Diffie-Hellman, a client DH value

11:50.240 --> 11:57.440
assigned by its public key, and it includes the X509 certificate containing that public key.

11:59.840 --> 12:06.240
The KDC, once it has verified everything is happy to proceed, then its response

12:06.240 --> 12:14.480
includes the TGT, and it includes the session key encrypted using the public key algorithm,

12:14.480 --> 12:19.200
in this case, Diffie-Hellman, as well as the KDC Diffie-Hellman value that the client will need

12:19.760 --> 12:26.320
to compute the secret with which the session key is encrypted, and then it can decrypt it,

12:26.320 --> 12:32.480
store the session key, store the TGT, and from this point forward, the rest of the protocol

12:32.480 --> 12:42.880
is exactly as before. In Free IPA, by default, we can perform the binding of the certificate

12:42.880 --> 12:49.040
and key to the principal object using an exact certificate match only. So in the principles,

12:49.040 --> 12:55.440
LDAP entry will store a complete copy of the certificate. We optionally support certificate

12:55.440 --> 13:01.040
mapping rules that allow you to be a bit more versatile in how you establish the binding

13:01.040 --> 13:09.440
between the certificate and the principal. For example, if you're using certificates for hosts,

13:09.440 --> 13:16.080
you can pull out the DNS name from the subject alternative name field in the certificate and

13:16.080 --> 13:23.680
construct an LDAP query saying, well, we're looking for hosts whose FQDN matches that DNS name from

13:23.680 --> 13:30.240
the certificate. And the client certificates can be signed by Free IPA's internal CA or by

13:30.240 --> 13:39.120
a third-party CA that the KDC trusts. The user experience for PK unit, you can do it from a CLI,

13:39.120 --> 13:47.680
it's not very pleasant, but you can use SSD integrated with your login manager to improve

13:47.680 --> 13:54.480
that experience, particularly if you're using smart cards or TPM for storing the private keys

13:54.480 --> 14:01.840
or doing additional pre-authentication mechanisms like two-factor authentication. And Windows

14:01.840 --> 14:09.040
offers a similar experience. It should be, in fact, it must be easy for users and friendly for users,

14:09.040 --> 14:14.640
otherwise people will not use it and you will not get the security benefits. So a quick demo.

14:14.640 --> 14:24.560
KList shows me what tickets I currently have. The answer is none. If I K in it as Alice,

14:24.560 --> 14:36.480
I can type Alice's passphrase and I now have a TGT for Alice. So that was a password-based

14:36.480 --> 14:44.960
authentication. And if I ping the IPA server, that's just talking to the Free IPA HTTP API.

14:45.840 --> 14:50.640
Now if I KList, I can see that behind the scenes it's acquired a service ticket

14:51.920 --> 15:02.720
for one of the IPA HTTP servers. I'll just destroy those tickets now and I'll do a PK unit.

15:02.720 --> 15:07.440
So if I change directory here, here I have a certificate and a key.

15:09.920 --> 15:14.560
And I'll just pretty print the cert for you.

15:18.880 --> 15:20.480
So what can we say about this cert?

15:23.840 --> 15:27.760
Actually, I'll tell you what. I'm doing things in the wrong order here. I'm going to do a host

15:27.760 --> 15:48.320
authentication first. So if I do K in it dash X, X509, user identity equals file and the certificate

15:48.320 --> 16:04.080
and the key and a host name. Not a host name rather, but the principle name, host slash

16:04.080 --> 16:12.240
ral78.ipa.test and KList. Here we have our TGT for the host principle.

16:12.240 --> 16:21.440
So PK unit advantages. No more passwords or client shared secrets. The keys can reside

16:21.440 --> 16:28.880
on the smart cards or, for example, in a UBKey, in a TPM or in a hardware security module.

16:28.880 --> 16:33.040
And as I mentioned earlier, the rest of the protocol after the initial authentication

16:33.040 --> 16:40.240
service exchange is unchanged, which makes it easy for services. The complexities. Well,

16:40.240 --> 16:47.040
you need an X509 PKI. This brings in the renewal considerations and revocation considerations.

16:48.480 --> 16:53.920
The hardware. If you want the benefit of the hardware security, that will cause an additional

16:53.920 --> 17:00.560
financial cost to buy the hardware. And binding the public key to the principle is an important

17:00.560 --> 17:09.600
consideration. So in the RFC, RFC 4556, it says, the KDC must also check that the client's public

17:09.600 --> 17:16.320
key used to verify the signature is bound to the client principle name specified in the

17:16.320 --> 17:23.360
authentication service request. And it goes on to suggest how you can do that. A couple of ways you

17:23.360 --> 17:27.440
can do it. You can encode the principle name directly in the certificate in a specialised

17:27.440 --> 17:35.680
subject alternative name. Or you can associate the key directly with the principle in your database.

17:35.680 --> 17:41.680
That is what we have as the default behaviour in free IPA. But that introduces administrative

17:41.680 --> 17:47.120
overhead because when the certificate is renewed or the client rekeys, then you need to make sure

17:47.120 --> 17:53.040
that those entries are up to date. Or you can use other heuristics. For example, if the cert has a

17:53.040 --> 17:59.440
DNS name, pull that out and use that to look up a host. If the certificate has an RFC 822 name,

17:59.440 --> 18:07.040
which is an email address, pull that out, use it to look up a user principle. And you better not

18:07.040 --> 18:17.840
mess this up. Which brings us to the CVE. So if we have a look at the certificate that I used to

18:17.840 --> 18:28.000
get this host principle, server.pen, we'll see something interesting. It doesn't actually mention

18:28.000 --> 18:36.000
that principle name anywhere. The rel78-0. But it does have a subject alternative name. It has two

18:36.000 --> 18:46.000
in fact. One of them is a wildcard DNS name. So what's happening here? It's an LDAP filter injection

18:46.000 --> 18:52.240
vulnerability. Free IPA is not vulnerable in the default config because, as I mentioned, only exact

18:52.240 --> 18:59.760
certificate matches used by default. This bug is in the SSST component. It was already resolved

18:59.760 --> 19:05.920
when I found it. So it was only older but still supported versions that were affected. And the

19:05.920 --> 19:13.840
fix has now been released and the details are public. So what's happening is that the certmap

19:13.840 --> 19:22.800
rule is just pulling the DNS name out of the certificate and concatenating it directly

19:22.800 --> 19:30.880
into the LDAP filter without sanitization. And in LDAP, asterisk is a substring match character.

19:31.440 --> 19:38.000
So using that certificate would let you get a TGT for any host principle in your realm.

19:38.000 --> 19:43.440
And another interesting question is what happens if this is your email address?

19:45.680 --> 19:52.640
Now, this might seem like a stretch but that is a valid email address. And I'm sure many of you

19:52.640 --> 19:59.040
work at companies or have worked at companies where you can request your own email alias at

19:59.040 --> 20:05.440
Red Hat. We certainly do. So if you managed to request an email alias such as this and the

20:05.440 --> 20:12.320
system approved it, and you've got a certificate with that email address on it, and you have a

20:12.320 --> 20:20.320
certmap rule that looks something like this where you're stuffing the subject RFC 822 name

20:20.880 --> 20:25.920
into the query and using it to look up a mail attribute and that was somehow nested inside

20:25.920 --> 20:37.520
an or list expression, then you've just got yourself a domain takeover. So let's see a demo of that.

20:39.680 --> 20:43.200
If there's time, there might not be time, I think. How much?

20:45.600 --> 20:55.440
Five minutes left. So I'm going to skip it. Sorry. I'll tell you what, after I finished the talk,

20:55.440 --> 21:00.960
I'll, if I can, I'll just do it. But let me discuss now the mitigation. So yes,

21:01.840 --> 21:04.800
if you're running a vulnerable version of SSD, you should update it.

21:06.880 --> 21:12.560
The and list rules are harder to exploit than all lists. Just by nature, how the LDAP filter

21:14.560 --> 21:21.120
expressions work. The or list, if you have a single sub expression, then the whole list

21:21.120 --> 21:28.880
expression will match. But an and list, you have to match every sub clause. So it's just

21:28.880 --> 21:34.720
easier to exploit an or list. You should definitely audit what data can get included

21:34.720 --> 21:40.240
in certificates, where that data comes from, and how it's included or encoded in the cert.

21:40.960 --> 21:46.480
And you could use exact certificate matching to avoid this issue. But that does come with the

21:46.480 --> 21:54.960
administrative overheads to handle renewals or rekeys. General security considerations for PK

21:54.960 --> 22:02.320
unit. Well, and this first point is for just all software always, probably escape and sanitise

22:02.320 --> 22:09.360
your inputs, according to how you're using them. You should review your CA trust. So which CA's are

22:09.360 --> 22:19.200
you trusting? What profiles for issuing certificates used or templates? And how are the attributes

22:19.200 --> 22:24.800
that go into the certificates validated? Who can issue the certificates that you trust,

22:25.600 --> 22:32.160
both in terms of their software systems and the agents, human or otherwise, who act to

22:32.160 --> 22:40.240
issue certificates? And can any of the attributes be influenced by users or other parties, such as

22:41.200 --> 22:48.800
if you have your email address alias request system? Just because a value is valid in a

22:48.800 --> 22:55.440
particular context does not mean that it's benign in another context. And the key and principle

22:55.440 --> 23:02.080
binding is a critical aspect of PK unit security and PKI application security in general. It

23:02.080 --> 23:10.160
is as critically important as validating your certificate chain and validating signatures.

23:12.800 --> 23:19.600
The full write up about this issue is at that link on my blog. And there's a link also to the

23:19.600 --> 23:24.880
entry about this issue in the Red Hat CVE database, which includes the list of which

23:24.880 --> 23:32.240
products were affected and where the fixes have happened and where they are not happening.

23:33.120 --> 23:38.640
And that's also all last questions. And then maybe I do the domain takeover demo in a minute.

23:48.240 --> 23:52.960
Maybe we have time for one question. So is there anyone with a question that will be answered in

23:52.960 --> 24:07.120
one minute? They want the demo. Okay. So let's, I need to just change the cert map rules, which

24:07.120 --> 24:20.960
ones are active. Oops. If I can authenticate. Okay. So IPA cert map rule. Find. This is just

24:20.960 --> 24:35.440
the setup. So I need to disable cert map two and enable cert map one. Okay. So this is the rule

24:35.440 --> 24:57.280
that I'm enabling. I didn't enable it. Oh, thank you for that. Okay. Now it's enabled. And I can do

24:57.280 --> 25:07.200
a K in it. Let's see. It'll be there in the scroll back somewhere.

25:12.480 --> 25:13.760
That's server. That's okay.

25:13.760 --> 25:25.120
So the naughty certificate and the naughty key. And I want to be admin.

25:28.560 --> 25:30.800
And now I'm admin and I'll show you the certificate.

25:30.800 --> 25:44.080
Okay. So this certificate was issued to Alice.

25:44.080 --> 26:01.680
And the subject name includes Alice's malicious email alias. Okay. There you have it.

26:01.680 --> 26:12.240
Thank you. Great. Thanks, man.
