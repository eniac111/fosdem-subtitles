WEBVTT

00:00.000 --> 00:12.000
Please give a big welcome to Walter, who is coming from the Netherlands for an introduction

00:12.000 --> 00:15.000
to micropiton.

00:15.000 --> 00:21.840
Well, hello everyone.

00:21.840 --> 00:27.880
Take your seats, you people.

00:27.880 --> 00:33.240
I cringe at every extra person who walks in because it's an extra 100 watts of heating.

00:33.240 --> 00:39.040
It's already quite hot here.

00:39.040 --> 00:45.480
Okay, can start I think.

00:45.480 --> 00:51.320
Okay, that's me and that's a Python subject for today.

00:51.320 --> 00:52.320
I welcome questions.

00:52.320 --> 00:58.960
If anyone wants something while I'm talking, please raise your hand and you'll get a microphone.

00:58.960 --> 01:02.000
And if that takes too much time, I just skip subjects.

01:02.000 --> 01:04.560
Interaction is always nice.

01:04.560 --> 01:08.280
Okay, I'm Walter van Ooye.

01:08.280 --> 01:13.160
I did informatics, the technical version, when it didn't just exist.

01:13.160 --> 01:17.000
I worked in industry for quite a long time.

01:17.000 --> 01:21.440
I still have a web shop and sell things like these stuff.

01:21.440 --> 01:28.440
I worked at Hochshoe Utrecht for a year at Avant to teach technical informatics, of course,

01:28.440 --> 01:32.600
and now I'm employed by a company who does robotics in industry.

01:32.600 --> 01:37.160
But this is about micropiton.

01:37.160 --> 01:42.080
First context, I guess you all know what a microprocessor is.

01:42.080 --> 01:50.800
Way back when they first made a single processor on one chip, it was a very feeble small thing.

01:50.800 --> 01:53.000
And since then we have progressed a lot.

01:53.000 --> 01:56.400
Now we can pack a lot of power in one chip.

01:56.400 --> 01:58.880
But that's still a processor.

01:58.880 --> 02:00.520
It cannot do anything on itself.

02:00.520 --> 02:07.760
It needs external stuff like memory, IO, hard disk to store things permanently, probably

02:07.760 --> 02:11.440
less of cooling like we all do here.

02:11.440 --> 02:15.420
That's one way to use what we can put in a chip.

02:15.420 --> 02:21.600
The other route is don't make necessarily the processor much powerful, but put more

02:21.600 --> 02:23.160
things on a single chip.

02:23.160 --> 02:28.920
More RAM, flash ROM to store code, peripherals to do things in the outside world, and then

02:28.920 --> 02:31.600
you have a microcontroller.

02:31.600 --> 02:33.640
Everything in one chip.

02:33.640 --> 02:39.960
And that's a nice thing not to run your windows on, but to think of things in the real world,

02:39.960 --> 02:45.600
with motors, lets, relays, all kinds of stuff.

02:45.600 --> 02:47.880
That is, if you can still buy them.

02:47.880 --> 02:57.040
Maybe that will be solved in the near future when ASML produces more chip machines.

02:57.040 --> 03:00.440
Compilers and interpreters.

03:00.440 --> 03:09.280
You know, an interpreter looks at source code for line by line, sees what's there, does

03:09.280 --> 03:14.080
it, and then it looks at the next line and does it again.

03:14.080 --> 03:19.680
That's not very quick, but there is no extra steps involved, so when you change your source

03:19.680 --> 03:23.400
code, it immediately has effect.

03:23.400 --> 03:29.120
And when you interact, you interact in its way with that interpreter.

03:29.120 --> 03:34.640
Compiler takes source code, turns later to native machine code, and that is the thing

03:34.640 --> 03:35.880
that runs.

03:35.880 --> 03:40.000
When you interact, when you interact with the program, you interact with the running

03:40.000 --> 03:42.840
native code.

03:42.840 --> 03:43.840
All clear?

03:43.840 --> 03:48.320
I used to be a lecturer, so everyone clear?

03:48.320 --> 03:54.720
And then, of course, no one raised a finger, it's not clear to me.

03:54.720 --> 03:59.040
Things cannot be that simple, so there's combos of compile interpreter.

03:59.040 --> 04:01.640
That's actually how Python generally works.

04:01.640 --> 04:06.280
You have a source code, you have a compiler that translates that source code to an intermediate

04:06.280 --> 04:12.640
representation, and then you have an interpreter that interprets that intermediate code.

04:12.640 --> 04:17.920
Now, you have either the best of both worlds or the worst, I don't know.

04:17.920 --> 04:25.960
This takes some time, but less than real compilation, and this is slower than real running native

04:25.960 --> 04:31.280
code, but it's still somewhat faster than directly interpreting the source code.

04:31.280 --> 04:34.800
Real clear?

04:34.800 --> 04:36.800
Okay.

04:36.800 --> 04:43.640
Python typically runs interpreted, which has benefits and disadvantages, but we'll combine

04:43.640 --> 04:44.640
that.

04:44.640 --> 04:47.600
What's Python's place in the larger world of things?

04:47.600 --> 04:54.360
There are programming language, I think you can recognize the symbols, that make it easy

04:54.360 --> 05:00.280
to change your code, to run it quickly, to think of it, to try things.

05:00.280 --> 05:02.000
It's the one end of the spectrum.

05:02.000 --> 05:07.720
There's the other side of the spectrum, when you write high performance codes, like operating

05:07.720 --> 05:15.600
systems, graphical tools, games and things like that, those language are much less forgiving

05:15.600 --> 05:17.400
in what you do.

05:17.400 --> 05:23.040
It takes a lot of time to compile it correctly, but then they filter out a lot more errors

05:23.040 --> 05:28.800
than those type of languages do, especially the torus for that.

05:28.800 --> 05:35.360
And somewhere in between are the compromises, that's generally used for not too high performance,

05:35.360 --> 05:43.000
but really some easily performance user interaction thing websites, simple graphical applications.

05:43.000 --> 05:45.280
That's the whole scheme of things.

05:45.280 --> 05:49.400
And traditionally, micro-controllers, these kind of things, were programmed with these

05:49.400 --> 05:55.200
kind of languages, because they simply didn't have the resources, speed of the processor,

05:55.200 --> 06:05.640
size of the RAM, size of the flash, to run with these kind of languages.

06:05.640 --> 06:12.680
What really distinguishes the language is whether you are runtime-typed, in Python,

06:12.680 --> 06:18.120
when you have a variable, the runtime system has no ID, whether it's a string or an integer

06:18.120 --> 06:22.360
or a list or whatever, it will find out at runtime.

06:22.360 --> 06:31.120
Very typed languages that's fixed, less flexible for you, easier on the processor.

06:31.120 --> 06:34.960
It compiles to, well, the left side compiles to intermediate languages, some of them are

06:34.960 --> 06:42.480
even really source-interpreted, right side languages are compiled to mostly machine language.

06:42.480 --> 06:45.040
And memory management, an important one.

06:45.040 --> 06:51.600
In Python, you rarely wonder about where your memory is, what memory is used.

06:51.600 --> 06:54.040
The runtime system solves it.

06:54.040 --> 07:02.360
In C and C++, you have to worry a lot about which memory you claimed, what you released,

07:02.360 --> 07:07.480
don't release it too early, or you'll get a nice crash or something else.

07:07.480 --> 07:14.880
And in between, well, you take some care of it, maybe give some hints to the runtime system,

07:14.880 --> 07:17.480
but in general you don't bother too much with it.

07:17.480 --> 07:25.080
So left side, easier programming, right side, quick running.

07:25.080 --> 07:32.080
That's how traditional C Python works, you have your source, you translate it to an intermediate

07:32.080 --> 07:35.760
language representation, that is runs.

07:35.760 --> 07:40.120
And that's all done by your Python system you install.

07:40.120 --> 07:43.600
That's both compiler and interpreter.

07:43.600 --> 07:48.080
Wow, this looks more complex.

07:48.080 --> 07:54.520
This micro Python, you still have a Python system, but now it no longer runs on your

07:54.520 --> 07:58.600
quick fast desktop, it runs on a small microcontroller.

07:58.600 --> 08:02.520
Both the compiler and interpreter run on the microcontroller.

08:02.520 --> 08:07.120
And when your Python application runs, you interact with that microcontroller.

08:07.120 --> 08:11.000
You still have your laptop, because you do the editing.

08:11.000 --> 08:15.760
I don't have an editor running on this thing, so that's the old desktop.

08:15.760 --> 08:22.040
I use Toni, it's a simple Python application, but it's quite useful for interacting with

08:22.040 --> 08:23.480
micro Python.

08:23.480 --> 08:31.880
So I interact with Toni, I edit my code there, it's sent or stored or kept on the microcontroller

08:31.880 --> 08:32.880
itself.

08:32.880 --> 08:38.920
There it is compiled and runs, and then it runs here and hopefully does nice things with

08:38.920 --> 08:41.560
the outside world.

08:41.560 --> 08:43.200
Still clear?

08:43.200 --> 08:46.640
Nothing new, nice.

08:46.640 --> 08:57.500
On the microcontroller, let's say standard, read, evaluate, print loop, so you can do

08:57.500 --> 09:04.880
things like you did on the prompt on the Python on your normal computer.

09:04.880 --> 09:10.720
And evaluate what you did, print it, and it can do more interesting things like linking

09:10.720 --> 09:18.880
lets or reading files that are stored on the chip.

09:18.880 --> 09:23.760
I think we should just show, because it's too...

09:23.760 --> 09:24.260
Okay, here I have a R

09:53.760 --> 10:00.520
We've seen extra drive here, that's the drive we created, and I can copy...

10:00.520 --> 10:07.520
Here's the front end image.

10:07.520 --> 10:14.800
I copy the micro Python image to that drive.

10:14.800 --> 10:16.960
It copies it.

10:16.960 --> 10:18.800
When it's done, it reboots.

10:18.800 --> 10:28.560
Now the extra drive is gone, and I can see...

10:28.560 --> 10:41.200
There's an extra communication port here, that's what the chip made.

10:41.200 --> 10:51.200
I always rename my communication ports to 42, because...

10:51.200 --> 11:05.480
Okay, just repreter to be sure.

11:05.480 --> 11:13.160
Now let's start.

11:13.160 --> 11:26.280
Okay, now here I have a prompt that is running on that small tipi, and just like a good Python

11:26.280 --> 11:32.040
it can print hello.

11:32.040 --> 11:34.700
Doesn't seem like much, but that's happening here.

11:34.700 --> 11:37.240
It's not my laptop that's doing it.

11:37.240 --> 11:42.440
And if you're a bit lazy and you don't want to fiddle with files, you can also...

11:42.440 --> 11:47.200
Oops, boot again.

11:47.200 --> 11:55.360
Here in Toni you can select under options, interpreter, I want to install micro Python,

11:55.360 --> 11:59.200
and for the Raspberry Pi Pico it just knows where to find it.

11:59.200 --> 12:03.400
Ah, internet is working.

12:03.400 --> 12:07.680
It just grabbed the latest version, installed it.

12:07.680 --> 12:09.680
Close.

12:09.680 --> 12:12.840
And I have it running.

12:12.840 --> 12:14.840
Yep, trans.

12:14.840 --> 12:15.840
Nice.

12:15.840 --> 12:20.560
Okay, now I must do something.

12:20.560 --> 12:28.560
Let's take some code.

12:28.560 --> 12:38.920
I can put code simply in the editor and say run this.

12:38.920 --> 12:39.920
No.

12:39.920 --> 12:44.200
Are you able to make it larger, please?

12:44.200 --> 12:47.640
I think that's the wrong direction.

12:47.640 --> 12:49.480
Large enough for you?

12:49.480 --> 12:57.920
And it didn't show that let was not on, but now it's on, so it works.

12:57.920 --> 13:07.160
Now, well, I can maybe I can convince you if I put a zero here and then run it again.

13:07.160 --> 13:08.160
Ah, let's off.

13:08.160 --> 13:12.160
You can all see that?

13:12.160 --> 13:24.480
Well, just on is not that interesting.

13:24.480 --> 13:25.640
Let's blink.

13:25.640 --> 13:28.040
Make it simple, define the pin.

13:28.040 --> 13:35.960
I import the libraries that are standard for this chip, and it allows me to access a pin.

13:35.960 --> 13:39.000
Pin 25 happens to be the onboard LED.

13:39.000 --> 13:45.560
I say it's an output pin, then I make it high, sleep a little time, make it low, sleep a

13:45.560 --> 13:47.960
little time, and repeat it forever.

13:47.960 --> 13:50.800
Okay, that should blinky.

13:50.800 --> 13:53.080
Ah, it blinks.

13:53.080 --> 13:55.280
Oh, nice.

13:55.280 --> 13:59.440
Print the plot for any demo, otherwise your hands will get sore.

13:59.440 --> 14:08.160
Okay, but now when I stop it, it stops and this thing doesn't do anything.

14:08.160 --> 14:11.160
It should stop, it doesn't.

14:11.160 --> 14:19.320
Well, there's always the reboot for that.

14:19.320 --> 14:27.000
It's supposed to be interruptible by that stop button, but since a week it doesn't do

14:27.000 --> 14:28.760
anything, I don't know why.

14:28.760 --> 14:37.240
If I want to do the chip, do something on itself, I have to store this file on the chip.

14:37.240 --> 14:44.520
So I make the blink.py on the chip.

14:44.520 --> 14:49.640
Now it's here, and I can run it from there.

14:49.640 --> 14:53.800
It still blinks, and that's not very interesting.

14:53.800 --> 15:03.560
Now if I stop it and put it on a power bank, it doesn't do anything.

15:03.560 --> 15:04.560
It's a pity.

15:04.560 --> 15:08.720
When it starts, it looks for a main.py and excuse that file.

15:08.720 --> 15:24.040
So if I wanted to start, I have to make a file, import blink, save that as main.py.

15:24.040 --> 15:27.600
Ah, it's amazing.

15:27.600 --> 15:30.120
This irritating, there is a small file system here.

15:30.120 --> 15:35.360
I can make a new file directly delete, but I cannot rename a file.

15:35.360 --> 15:41.240
So let's do the performance way of doing that.

15:41.240 --> 15:47.800
Save as main, not me.

15:47.800 --> 15:53.800
Now I can delete that one.

15:53.800 --> 15:54.800
Nice.

15:54.800 --> 15:59.640
It deleted the correct one.

15:59.640 --> 16:00.840
And that's import blink.

16:00.840 --> 16:07.560
So now if I put it on a power bank, it starts blinking of its own.

16:07.560 --> 16:14.000
But now at least that's what happened yesterday.

16:14.000 --> 16:19.640
When I start to hold it again, now it doesn't want to.

16:19.640 --> 16:21.920
I cannot get into it anymore.

16:21.920 --> 16:23.480
It's breached.

16:23.480 --> 16:28.560
But okay, I can still reload.

16:28.560 --> 16:34.880
But now if I reload the micro-py interpreter again, it keeps the file system.

16:34.880 --> 16:35.880
So it keeps the main.py.

16:35.880 --> 16:38.080
So it doesn't work.

16:38.080 --> 16:47.040
So some clever guy made flash nuke.

16:47.040 --> 16:56.120
And when I put that there, it reboots with that code.

16:56.120 --> 16:59.320
Now it's nothing.

16:59.320 --> 17:07.000
And if I now reboot it, I can put the normal code on it again.

17:07.000 --> 17:10.000
Where it is.

17:10.000 --> 17:14.400
Force the vehicle images.

17:14.400 --> 17:23.440
Okay, put it one over there.

17:23.440 --> 17:26.440
It just USB transfers quite quick.

17:26.440 --> 17:28.720
And now I have a normal behaving.

17:28.720 --> 17:33.600
Yeah, okay, that behaves again.

17:33.600 --> 17:34.600
Nice.

17:34.600 --> 17:36.400
We named CioPort.

17:36.400 --> 17:37.400
You've seen blinky.

17:37.400 --> 17:40.240
You've seen the startup.

17:40.240 --> 17:41.600
Demo of the startup.

17:41.600 --> 17:42.600
Okay.

17:42.600 --> 17:46.240
I was going to demonstrate blinking a LED on a breadboard.

17:46.240 --> 17:47.920
But it's too feeble to bring here.

17:47.920 --> 17:51.960
So let's blink more LEDs.

17:51.960 --> 17:56.320
Or it's better.

17:56.320 --> 18:00.320
Okay.

18:00.320 --> 18:02.560
Now you know why I put all the things on the table.

18:02.560 --> 18:11.000
So I have the correct order of driving everything.

18:11.000 --> 18:13.000
What's on here?

18:13.000 --> 18:25.000
There's a bit.

18:25.000 --> 18:35.920
I can blink a single LED.

18:35.920 --> 18:38.440
Now I use a library I wrote.

18:38.440 --> 18:40.360
And it's loading all those library files.

18:40.360 --> 18:41.600
It takes some time.

18:41.600 --> 18:45.400
And after that, yeah, it really blinks.

18:45.400 --> 18:48.360
I'll come back to that later.

18:48.360 --> 18:52.760
And this one, if I'm a bit insistent, it will probably stop.

18:52.760 --> 18:57.120
Yeah, there it is again.

18:57.120 --> 19:00.800
We can also have more LEDs.

19:00.800 --> 19:07.840
I've made a system that's whatever target ship I use, it has eight pins that are connected

19:07.840 --> 19:08.840
here.

19:08.840 --> 19:11.080
So we can swap it for another board.

19:11.080 --> 19:14.880
The whole different processor still has the same eight pins.

19:14.880 --> 19:16.840
That's the edge library.

19:16.840 --> 19:22.880
And edge.port is those eight pins gathered together in one port.

19:22.880 --> 19:26.320
And I give it to the kit demo.

19:26.320 --> 19:32.680
And then it should first load everything.

19:32.680 --> 19:33.680
And then it's kit.

19:33.680 --> 19:34.680
Okay.

19:34.680 --> 19:37.040
Kit on eight LEDs.

19:37.040 --> 19:46.360
But that's not enough.

19:46.360 --> 19:50.480
You take an I2C extender chip and that chip.

19:50.480 --> 19:53.520
Does it work?

19:53.520 --> 19:57.760
Yes, it works.

19:57.760 --> 20:01.920
And it has more output pins.

20:01.920 --> 20:06.560
Load, load, load, load.

20:06.560 --> 20:09.760
And then have a kit with 16 ports.

20:09.760 --> 20:19.720
And if that's too slow, I think it's boringly slow.

20:19.720 --> 20:24.840
Maybe 10 milliseconds is nice.

20:24.840 --> 20:31.480
Load, load, load, load, load.

20:31.480 --> 20:35.560
Yeah, that's a bit quicker.

20:35.560 --> 20:36.560
Okay.

20:36.560 --> 20:40.560
Back to the sheets.

20:40.560 --> 20:44.640
One more LEDs.

20:44.640 --> 20:45.640
We have some more LEDs.

20:45.640 --> 20:46.640
Okay.

20:46.640 --> 20:51.840
You saw that it spent some time at beginning by loading a few libraries.

20:51.840 --> 20:56.600
It shows because I coded it that way because I want to know how long it takes to load the

20:56.600 --> 20:59.480
libraries and how much RAM it uses.

20:59.480 --> 21:06.400
In general, you can have three ways of putting library code on micro Python.

21:06.400 --> 21:09.920
You can have the source files, the simple.py files.

21:09.920 --> 21:14.080
And then when you load them, they are first compiled and then loaded.

21:14.080 --> 21:20.480
You can also pre-compile those files on your laptop and then load the compiled version.

21:20.480 --> 21:23.560
That's the.mpy files.

21:23.560 --> 21:28.800
You can also take the files and build them into the image you load anyway.

21:28.800 --> 21:31.040
You show me copying that image onto the chip.

21:31.040 --> 21:33.600
You can put your files in there.

21:33.600 --> 21:37.800
And that has effect for how much time it takes.

21:37.800 --> 21:43.160
When I demoted, it was irritatingly long.

21:43.160 --> 21:53.000
My files took about 12 seconds to get loaded from the flash compiled and ready for run.

21:53.000 --> 21:55.800
When I pre-compiled, it's a little bit faster.

21:55.800 --> 22:03.240
And when I freeze it, I build an image of micro Python with those files included.

22:03.240 --> 22:05.240
It gets really fast.

22:05.240 --> 22:08.200
And then it also uses less RAM.

22:08.200 --> 22:12.480
RAM, memory on those chips is always a very scary source.

22:12.480 --> 22:21.080
This chip has about, I think, 130K left after loading this library.

22:21.080 --> 22:22.080
Looks like a lot.

22:22.080 --> 22:27.520
You can eat it quickly, especially if you make screen buffers for LCDs and things like

22:27.520 --> 22:28.520
that.

22:28.520 --> 22:35.200
A 240 by 320 LCD with full color, that's two bytes per color.

22:35.200 --> 22:38.640
I think that's more than is left there.

22:38.640 --> 22:40.680
You couldn't still use it.

22:40.680 --> 22:45.160
So it's very important to conserve that.

22:45.160 --> 22:49.280
When I develop things, I simply take a very fast target.

22:49.280 --> 22:53.280
The TNG is maybe 10 times faster than a pipe pico.

22:53.280 --> 22:56.760
And it has, I think, one megabyte memory.

22:56.760 --> 22:59.280
So that's ample.

22:59.280 --> 23:01.280
But there's always a bot.

23:01.280 --> 23:03.720
But it comes later.

23:03.720 --> 23:04.720
Okay.

23:04.720 --> 23:08.120
Embedding your code into a micro pipe image is not that complex.

23:08.120 --> 23:12.280
I had it running on my Linux machine in maybe an hour.

23:12.280 --> 23:16.160
Then I tried the same recipe on Windows and it fails.

23:16.160 --> 23:19.720
So when it happens, what do you do?

23:19.720 --> 23:21.560
You make a docker container.

23:21.560 --> 23:25.720
So I made a docker container on the Linux machine that does exactly the same thing,

23:25.720 --> 23:26.720
worked.

23:26.720 --> 23:27.720
Then I run it on Windows.

23:27.720 --> 23:28.720
Works too.

23:28.720 --> 23:31.560
It's fine.

23:31.560 --> 23:36.400
And I can show if I take this.

23:36.400 --> 23:47.400
Maybe here.

23:47.400 --> 23:51.400
There it is.

23:51.400 --> 23:58.880
If I import my library, it's...

23:58.880 --> 24:00.760
Okay.

24:00.760 --> 24:04.760
You can do it.

24:04.760 --> 24:07.760
There's a license statement.

24:07.760 --> 24:09.600
A lot of text.

24:09.600 --> 24:10.600
Okay.

24:10.600 --> 24:18.480
Here I have that license statement in the source.

24:18.480 --> 24:21.000
Let's add this is.

24:21.000 --> 24:22.000
Fostem.

24:22.000 --> 24:23.000
Foste?

24:23.000 --> 24:24.000
Whatever.

24:24.000 --> 24:25.000
Okay.

24:25.000 --> 24:34.440
Start a docker container.

24:34.440 --> 24:35.440
It works.

24:35.440 --> 24:37.920
Otherwise it doesn't do it.

24:37.920 --> 24:40.880
It takes some 40 to 400 seconds.

24:40.880 --> 24:44.960
I cannot predict how long.

24:44.960 --> 24:45.960
Of course it's docker.

24:45.960 --> 24:50.640
So all the preparations, loading the Linux image, loading all the development tools,

24:50.640 --> 24:51.640
that's cached.

24:51.640 --> 25:00.920
But then after it, it takes the my library code and then it compiles the micro Python

25:00.920 --> 25:05.920
with that library code edit and that takes some time.

25:05.920 --> 25:08.080
Wait.

25:08.080 --> 25:11.920
Okay.

25:11.920 --> 25:13.920
It's running now.

25:13.920 --> 25:18.400
Didn't take that long.

25:18.400 --> 25:19.960
So what do I do now?

25:19.960 --> 25:24.000
I reboot my chip again.

25:24.000 --> 25:32.880
And now take the new code.

25:32.880 --> 25:43.200
It's the new code.

25:43.200 --> 25:50.000
Copy that to the boot.

25:50.000 --> 25:55.000
Okay.

25:55.000 --> 26:00.520
Let's see what we have here.

26:00.520 --> 26:04.640
Now you no longer see the library files there because they are not present on the internal

26:04.640 --> 26:06.000
file system.

26:06.000 --> 26:24.840
They're built into the micro Python interpreter that I can still...

26:24.840 --> 26:28.240
It's a bit faster now than it used to be.

26:28.240 --> 26:32.120
And now print.

26:32.120 --> 26:40.440
And now license text is expanded so I really have put the changed version of the library

26:40.440 --> 26:41.440
in there.

26:41.440 --> 26:42.440
Okay.

26:42.440 --> 26:45.440
Let's go on.

26:45.440 --> 26:48.200
I showed freezing code.

26:48.200 --> 26:50.000
I still want more LEDs.

26:50.000 --> 26:53.640
Not enough.

26:53.640 --> 26:54.640
Why is more LEDs?

26:54.640 --> 26:59.640
I think this is enough.

26:59.640 --> 27:04.480
Like that.

27:04.480 --> 27:06.480
Okay.

27:06.480 --> 27:07.480
That needs more power.

27:07.480 --> 27:15.160
I cannot power it off the USB port of my laptop so I need external power for that.

27:15.160 --> 27:19.760
All right.

27:19.760 --> 27:31.000
Now I take...

27:31.000 --> 27:34.000
Oh.

27:34.000 --> 27:40.240
It's a microphone.

27:40.240 --> 27:51.520
Okay let's see what's on this chip.

27:51.520 --> 27:54.200
Now I loaded the code from the chip.

27:54.200 --> 27:57.240
I prepared on the chip there.

27:57.240 --> 28:00.520
Don't need to load it from my PC there.

28:00.520 --> 28:03.920
And it runs over there.

28:03.920 --> 28:14.520
And it still loads the library.

28:14.520 --> 28:16.640
So enough LEDs for you.

28:16.640 --> 28:17.640
Okay.

28:17.640 --> 28:20.880
Put it over there.

28:20.880 --> 28:25.600
With so many LEDs you can do nicer things and just put them in the long line.

28:25.600 --> 28:30.360
You can put them in a square and make displays with it.

28:30.360 --> 28:37.360
So take that one off.

28:37.360 --> 28:44.240
Does it stop?

28:44.240 --> 28:50.240
Yeah, it stops.

28:50.240 --> 28:57.240
And let's run that one.

28:57.240 --> 29:07.520
And we are at Fosdam so it prints an F on it.

29:07.520 --> 29:15.040
The code takes a long line of 64 LEDs and then it folds.

29:15.040 --> 29:19.760
It offers 88888 LEDs to make a square.

29:19.760 --> 29:23.240
That's what I call a canvas and I can write text on that.

29:23.240 --> 29:30.240
Sorry?

29:30.240 --> 29:37.880
Timed you mean?

29:37.880 --> 29:58.160
I'm not going to do them all but let's say gf.wait a little bit.

29:58.160 --> 29:59.160
What did I do wrong?

29:59.160 --> 30:03.080
Ah, a slap won't work.

30:03.080 --> 30:11.640
And then because we can't get enough of it.

30:11.640 --> 30:17.840
While true.

30:17.840 --> 30:20.080
Sorry conventions will take one.

30:20.080 --> 30:28.040
Yeah, I need a flush and I need to wait after that.

30:28.040 --> 30:33.480
I need this flush over here.

30:33.480 --> 30:34.480
Oh, they should work.

30:34.480 --> 30:54.480
I didn't prepare this one so let's see.

30:54.480 --> 30:58.160
Something like that.

30:58.160 --> 31:02.080
Ah, yeah, yeah, yeah, yeah.

31:02.080 --> 31:04.120
Okay, demo.

31:04.120 --> 31:05.120
What am I missing?

31:05.120 --> 31:06.120
Yeah.

31:06.120 --> 31:14.720
I sleep here.

31:14.720 --> 31:17.720
Clear right flush sleep.

31:17.720 --> 31:37.880
Oh, you guys are wonderful.

31:37.880 --> 31:40.880
This gets even more hold now.

31:40.880 --> 31:53.320
But I guess two letters is not enough.

31:53.320 --> 31:55.440
Where are more stuff here?

31:55.440 --> 32:00.400
Ah, here are my flexis.

32:00.400 --> 32:02.880
They also sell these things on flexible PCBs.

32:02.880 --> 32:03.880
It's nice.

32:03.880 --> 32:14.880
And then I put this one again.

32:14.880 --> 32:24.720
Like this one.

32:24.720 --> 32:29.400
And now it's garbage.

32:29.400 --> 32:31.320
Anyone has any idea why it's garbage?

32:31.320 --> 32:42.920
Yeah, the first one they go tuck, tuck, tuck, tuck.

32:42.920 --> 32:46.080
And this one goes tuck, tuck, tuck.

32:46.080 --> 32:53.320
Instead going the same direction it's zieksacht.

32:53.320 --> 32:55.360
Okay.

32:55.360 --> 33:09.280
So we must fold it in the zieksacht version.

33:09.280 --> 33:12.280
Yeah.

33:12.280 --> 33:25.960
If you know a better term for it, feel free.

33:25.960 --> 33:29.840
Ah, hit the bug.

33:29.840 --> 33:34.560
Fortunately, I know where to correct this.

33:34.560 --> 33:44.920
Okay, to shosh, it's in canvas, and I made an error there in the zieksachting.

33:44.920 --> 33:47.920
Rotate it.

33:47.920 --> 33:53.760
Yeah, somewhere like here.

33:53.760 --> 34:10.480
It's a forward one here.

34:10.480 --> 34:12.400
It's of course an off by one error.

34:12.400 --> 34:19.920
I have to subtract one more here because size is one beyond.

34:19.920 --> 34:25.920
So plus one, yeah.

34:25.920 --> 34:34.440
Okay, save it.

34:34.440 --> 34:37.200
And run it again.

34:37.200 --> 34:41.560
And just a hint, this won't work.

34:41.560 --> 34:42.800
Why doesn't this work?

34:42.800 --> 34:45.560
I made a stupid mistake.

34:45.560 --> 34:48.560
And it's not in the code.

34:48.560 --> 34:50.560
What?

34:50.560 --> 34:57.840
No, that was a different chip.

34:57.840 --> 34:58.840
But you're hot.

34:58.840 --> 35:02.680
It's hot anyway here.

35:02.680 --> 35:06.760
What did I just edit?

35:06.760 --> 35:10.320
I edited the source code on my laptop.

35:10.320 --> 35:13.000
That's the upper screen here.

35:13.000 --> 35:15.040
This one is a source code on my laptop.

35:15.040 --> 35:18.520
This one is the code on the chip.

35:18.520 --> 35:22.120
I made a mistake resilient times.

35:22.120 --> 35:33.760
So do the same thing, but now on the code here.

35:33.760 --> 35:34.760
That one.

35:34.760 --> 35:40.240
Now you see it's a bit slower because it must first retrieve that code from the chip to

35:40.240 --> 35:41.600
the laptop.

35:41.600 --> 35:42.840
Then I can edit it.

35:42.840 --> 35:48.840
It's the same code, but still I have to edit it.

35:48.840 --> 35:54.280
Well, which one will work?

35:54.280 --> 35:57.320
Ah, that's quick.

35:57.320 --> 35:59.320
Okay, thanks.

35:59.320 --> 36:07.840
I'm not 25, okay, near.

36:07.840 --> 36:13.440
I'm doing something stupid here.

36:13.440 --> 36:18.120
Control-Z is your friend.

36:18.120 --> 36:21.000
And now I've changed it on the...

36:21.000 --> 36:23.120
Okay, there.

36:23.120 --> 36:26.320
And I must still...

36:26.320 --> 36:27.320
It's saving.

36:27.320 --> 36:29.960
And now I run that one again.

36:29.960 --> 36:30.960
It should...

36:30.960 --> 36:31.960
Compile.

36:31.960 --> 36:43.120
There's not the baked in version, this is from source version.

36:43.120 --> 36:45.240
And now it works.

36:45.240 --> 36:46.240
Well...

36:46.240 --> 36:47.240
Okay.

36:47.240 --> 37:03.600
I prepared all kinds of versions.

37:03.600 --> 37:16.680
They do all kinds of things with the ordering of the LEDs on the screens.

37:16.680 --> 37:17.680
Not again.

37:17.680 --> 37:18.680
Okay.

37:18.680 --> 37:19.680
Sorry?

37:19.680 --> 37:35.960
Actually, this is not an accident.

37:35.960 --> 37:37.880
Okay.

37:37.880 --> 37:47.920
So what I do is the XY inverted, and that should be in here somewhere.

37:47.920 --> 37:54.840
Where is the XY inverted?

37:54.840 --> 37:58.560
You asked me to enlarge your letters, so I'm scrolling slowly.

37:58.560 --> 38:10.160
It's called swapped.

38:10.160 --> 38:22.000
What's this one?

38:22.000 --> 38:25.200
Okay.

38:25.200 --> 38:34.600
But do reflect on what I was about to do, that is to edit it in the code stored on the

38:34.600 --> 38:35.600
chip.

38:35.600 --> 38:37.720
That's not a problem.

38:37.720 --> 38:45.160
But then I decouple the chip and start working on the chip, and I just lost my code, or I

38:45.160 --> 38:49.520
don't know where it is on one of the 20 chips I have.

38:49.520 --> 38:53.320
And now it's FO again, so that works.

38:53.320 --> 38:54.320
But that's not a problem.

38:54.320 --> 39:02.840
I frequently don't know where I have put my last version of the code, and Tony doesn't

39:02.840 --> 39:06.800
support GitHub via the microcontroller.

39:06.800 --> 39:09.760
That in fact would be very nice.

39:09.760 --> 39:10.760
Okay.

39:10.760 --> 39:12.480
Never enough.

39:12.480 --> 39:18.400
Let's take more.

39:18.400 --> 39:23.680
Okay.

39:23.680 --> 39:30.680
Now it doesn't know it has more lets, so let's tell it.

39:30.680 --> 39:38.360
Where's the code?

39:38.360 --> 39:46.280
Stop it first.

39:46.280 --> 39:49.480
Stop it.

39:49.480 --> 39:54.320
Then that one.

39:54.320 --> 39:58.120
Sorry?

39:58.120 --> 40:09.040
Oh, that takes a lot of time.

40:09.040 --> 40:16.640
You might do that for consistency, but downloading the live takes one minute.

40:16.640 --> 40:17.640
So not for sure.

40:17.640 --> 40:20.640
That's true.

40:20.640 --> 40:25.120
But then you lose a bit of the essence of using Python.

40:25.120 --> 40:28.960
The essence is you can quickly make a modification.

40:28.960 --> 40:35.080
If I can afford one or two minutes, I might as well use a really compiled language and

40:35.080 --> 40:36.320
spend that much time.

40:36.320 --> 40:39.080
So yeah, you couldn't do it.

40:39.080 --> 40:40.080
Okay.

40:40.080 --> 40:44.280
So I could add one more display, but that's more of the same.

40:44.280 --> 40:49.160
Let's not do that.

40:49.160 --> 40:52.200
Go back to these things.

40:52.200 --> 40:53.480
Yeah.

40:53.480 --> 41:02.120
You saw that again loading the library from source is slow.

41:02.120 --> 41:04.120
You can also use a faster chip.

41:04.120 --> 41:26.600
If I take my fast chip, this one, and take that connection from it and use that one.

41:26.600 --> 41:29.760
Tony stop again and recognize new chip, please.

41:29.760 --> 41:33.880
Yes, it does.

41:33.880 --> 41:41.720
This one even has a separate flash card, so I can store more files on it than if I want.

41:41.720 --> 41:46.600
I can blink on it.

41:46.600 --> 41:49.120
This loads the library quite a bit faster.

41:49.120 --> 41:53.960
It doesn't have an onboard LID, so I blink a whole LCD screen.

41:53.960 --> 41:55.960
It works too.

41:55.960 --> 42:01.960
But sadly, I cannot use this target with the new pixels because it doesn't have the new

42:01.960 --> 42:09.360
pixel library built into the Python version for this chip.

42:09.360 --> 42:14.360
Sometimes you're just screwed.

42:14.360 --> 42:18.940
But I can't, oh, it doesn't want that.

42:18.940 --> 42:22.800
Sometimes when the communication goes wrong, Tony is very confused about what's happening.

42:22.800 --> 42:28.720
You just have to restart the chip or maybe restart Tony or whatever you want.

42:28.720 --> 42:33.160
I can do this one.

42:33.160 --> 42:37.160
Now that will leave that.

42:37.160 --> 42:47.840
I'll go to the sheets again.

42:47.840 --> 42:53.280
I've compared a few target chips that you could use for this kind of work.

42:53.280 --> 42:59.920
The TNC is what I just showed, very fast one, but then it costs 36, so this might be real.

42:59.920 --> 43:04.360
36, maybe I've photographed you all.

43:04.360 --> 43:05.520
It's quite expensive.

43:05.520 --> 43:13.560
If you want to have lots of fun with things that are expendable, the ESP32 and the PyPico

43:13.560 --> 43:20.560
are very good contenders, less than 10 euros and readily available everywhere.

43:20.560 --> 43:24.600
For ESP32s, there are a lot of funny versions of it.

43:24.600 --> 43:31.360
There's a watch with ESP32 in it, I don't know, my computer number.

43:31.360 --> 43:37.960
In a previous situation, I did a demo with it, but it uses Wi-Fi and it has the habit

43:37.960 --> 43:44.200
of working perfectly before you all walk in over tens of meters.

43:44.200 --> 43:48.040
And then when you're all present with all your phones, the reach is reduced to five

43:48.040 --> 43:49.040
centimeters.

43:49.040 --> 43:51.040
That's Greek, havakom, demos.

43:51.040 --> 43:54.720
These are other things.

43:54.720 --> 44:01.800
Adorable camera has a built-in ESP32, can run micro-Python, and then you can transmit

44:01.800 --> 44:11.400
the images over Wi-Fi, at least if you're not all present.

44:11.400 --> 44:14.480
You all know these ones.

44:14.480 --> 44:21.240
The BBC One bits, they can run micro-Python, sort of.

44:21.240 --> 44:28.040
They cannot store files on the flash system, and they can run about 50 lines or so of Python.

44:28.040 --> 44:34.480
So it's nice for a kindergarten Python course, but not for your work.

44:34.480 --> 44:37.600
And this one, I sure hope I get it to work sometime.

44:37.600 --> 44:38.800
It's a Kendrite.

44:38.800 --> 44:41.560
It's down here.

44:41.560 --> 44:46.360
It's quite powerful and also has neural network hardware on it.

44:46.360 --> 44:52.200
But it uses some Chinese version of micro-Python, and Tony doesn't recognize it, so maybe it

44:52.200 --> 44:54.440
works but I don't know how.

44:54.440 --> 44:56.200
10 minutes left.

44:56.200 --> 44:57.320
Thank you.

44:57.320 --> 45:03.080
If you have questions, those are more important than the rest of my sheets, so interrupt me.

45:03.080 --> 45:08.880
A few of those more interesting tips we saw are, in fact, not a pure micro-controller

45:08.880 --> 45:11.640
or pure micro-processor, they are hybrids.

45:11.640 --> 45:18.080
They have a micro-controller core, but an external ROM added, and in some cases even

45:18.080 --> 45:19.840
external RAM.

45:19.840 --> 45:25.480
That is overall a cheaper configuration because optimal, let's say, process parameter for

45:25.480 --> 45:30.840
making micro-tips, flash and RAM, are quite different.

45:30.840 --> 45:36.720
So you can make a cheaper, more effective, make a RAM chip, but you have only RAM cells

45:36.720 --> 45:38.080
on it.

45:38.080 --> 45:47.920
So for instance, the ESP32 doesn't have that much RAM on board, but it can use an external

45:47.920 --> 45:50.840
coupled RAM chip as a buffer for it.

45:50.840 --> 45:56.640
It caches the things, and then you suddenly have a few megabytes of RAM, which is more

45:56.640 --> 45:58.760
actually, but it's a bit slower.

45:58.760 --> 45:59.760
Not that much, but a bit slower.

45:59.760 --> 46:03.240
Excuse me, can you make the slides fullscreen, please?

46:03.240 --> 46:08.240
I will, if I get my cursor back.

46:08.240 --> 46:11.240
Where's my cursor?

46:11.240 --> 46:12.240
Yeah.

46:12.240 --> 46:22.400
Oh, they'll publish the slides, so don't worry.

46:22.400 --> 46:29.080
So then it's nice appearing, and you have the hybrid version in between.

46:29.080 --> 46:34.520
When you work with this thing, RAM is very scarce.

46:34.520 --> 46:38.160
So the more RAM you have, the better, especially if you're working with screen buffers or images

46:38.160 --> 46:43.880
or things from a camera.

46:43.880 --> 46:52.120
The thing is, when files are loaded by Michael Python, it first loads the source, then from

46:52.120 --> 46:54.560
that builds intermediate representation.

46:54.560 --> 46:58.640
That intermediate representation is smaller than the source, but the peak memory usage

46:58.640 --> 47:00.600
is still the full source.

47:00.600 --> 47:07.560
So I cannot load my library as one file on, let's say, an ESP32, because it doesn't have

47:07.560 --> 47:10.960
enough RAM to load that peak amount.

47:10.960 --> 47:14.920
It can load it in compiled form, but not a source form.

47:14.920 --> 47:22.680
So what I do, I split it in a lot of small files, and one trick I often use is I have

47:22.680 --> 47:30.640
a main file which imports all sub-files, and for, let's say, basic classes you must do

47:30.640 --> 47:36.600
that, but for utility things like a driver for an LCD, I use a trampoline function.

47:36.600 --> 47:44.000
It pretends to be the class, but it's a function, and when it's called, it loads the real sub-module,

47:44.000 --> 47:50.840
so it's loaded only when it's needed, and then it calls that with all the arguments.

47:50.840 --> 47:56.840
And such a trampoline takes maybe 50 bytes, while this full file could take a few kilobytes,

47:56.840 --> 47:59.840
so that saves a lot of RAM and loading time.

47:59.840 --> 48:05.840
All right, Stuart, can you get a version of Michael Python which only takes pre-compile

48:05.840 --> 48:08.840
to save space on small machines?

48:08.840 --> 48:10.800
Yeah, you sure can.

48:10.800 --> 48:17.720
So when you really develop something, I think you should take a larger machine, and when

48:17.720 --> 48:23.720
it's in production, take a smaller machine, use a pre-compiled version, yes, of course.

48:23.720 --> 48:24.720
Can I get a question?

48:24.720 --> 48:28.720
Oh, sorry, he asked whether using pre-compiled version saves RAM.

48:28.720 --> 48:29.720
Yes, it does.

48:29.720 --> 48:35.720
Whether you could have a smaller Michael Python program with complete Michael ports to save

48:35.720 --> 48:39.720
space in the Michael Python program?

48:39.720 --> 48:45.720
Yeah, but you still want to tweak with your own main code if you're developing.

48:45.720 --> 48:49.880
If you have a finished product, then all things are different, but I think the main power

48:49.880 --> 48:54.280
of Michael Python is that you can thinker with it at a late stadium.

48:54.280 --> 49:02.280
If you have a finished product, indeed you can freeze it, but if you want that, how did

49:02.280 --> 49:04.280
you develop it?

49:04.280 --> 49:07.720
Presumably on a different processor with more RAM.

49:07.720 --> 49:11.720
Let's think of it.

49:11.720 --> 49:12.720
Limitations.

49:12.720 --> 49:13.720
Yeah?

49:13.720 --> 49:20.720
So we can use pre-compiled large libraries and put them on the chip, and then we can

49:20.720 --> 49:25.720
thinker with our own code, but have the pre-compiled libraries, and is that something to do?

49:25.720 --> 49:26.720
Yeah, indeed.

49:26.720 --> 49:27.720
But there are a lot of pre-comp...

49:27.720 --> 49:36.080
Oh, is it a good idea to have pre-compiled libraries incorporated in the Python interpreter

49:36.080 --> 49:38.200
and then thinker with your own code?

49:38.200 --> 49:40.360
Yeah, I think that's a good approach.

49:40.360 --> 49:44.440
Indeed those libraries are stable, because if you must change in those libraries, you

49:44.440 --> 49:50.280
don't have the source code, at least not on your target chip, and you're stuck in a much

49:50.280 --> 49:51.880
slower development cycle.

49:51.880 --> 49:52.880
So it's...

49:52.880 --> 49:58.120
Well, if things are indeed stable, freeze them in the Michael Python interpreter.

49:58.120 --> 50:04.640
If not, take a large chip and develop on that.

50:04.640 --> 50:05.960
Five minutes left.

50:05.960 --> 50:10.800
Well, you can really develop limitations.

50:10.800 --> 50:19.400
Time-wise, if you're in the, let's say, clock cycles, time domain, if it must be that fast,

50:19.400 --> 50:22.560
then even C or C++ won't do it.

50:22.560 --> 50:28.480
You need hardware or Raspberry Pico Pios.

50:28.480 --> 50:31.880
If you're in the tens or hundreds of cycles, you can use compiled language.

50:31.880 --> 50:36.520
If you're in the thousands of cycles, you can use an interpretive language like Python.

50:36.520 --> 50:42.200
To be concrete, driving those new pixels that requires microseconds timing, you cannot do

50:42.200 --> 50:44.440
that in Python code.

50:44.440 --> 50:50.760
In the Michael Python interpreter, they do it in C code, and that's built in.

50:50.760 --> 50:56.120
Driving a server motor, a hobby server back and forth, that's milliseconds timing.

50:56.120 --> 51:00.040
You can easily do it in Python, in Python source code.

51:00.040 --> 51:04.720
There's a list of deviations from C Python.

51:04.720 --> 51:06.680
You can read it.

51:06.680 --> 51:11.520
They didn't bother me much, except that it doesn't support type hints.

51:11.520 --> 51:16.360
I like type hints from my testing, so I must do the testing on my laptop.

51:16.360 --> 51:22.240
You can test a lot of basic things, not on the small machine between your desktop.

51:22.240 --> 51:31.920
When it's compiled, is it the same byte code as C Python?

51:31.920 --> 51:37.360
When it's compiled, Michael Python intermediate code is different from C Python.

51:37.360 --> 51:43.240
It has its own pre-compiler, which you can download and you can pre-compile it, but it's

51:43.240 --> 51:52.040
different from the standard C Python.

51:52.040 --> 51:54.200
Does Michael Python have the garbage collector?

51:54.200 --> 51:56.080
You can bet it has, yes.

51:56.080 --> 52:02.240
When you want to do really time-critical things, call the garbage collector and do it after

52:02.240 --> 52:03.240
that.

52:03.240 --> 52:05.680
You can be reasonably sure that it's called.

52:05.680 --> 52:11.800
But if you want to do really time-critical, life-critical things, don't use Python.

52:11.800 --> 52:13.400
Sorry.

52:13.400 --> 52:17.040
Okay, I'll skip this one.

52:17.040 --> 52:19.800
What is it good for?

52:19.800 --> 52:22.520
Maybe not for volume production.

52:22.520 --> 52:24.200
For that, you use compiled language.

52:24.200 --> 52:31.960
But for anything that requires tinkering, exploration, lab setups, experiments, education,

52:31.960 --> 52:35.400
it's really nice, too.

52:35.400 --> 52:37.520
What is problems?

52:37.520 --> 52:41.160
I'm always confused by my latest version of the source code is.

52:41.160 --> 52:47.680
I changed what something on that ship, maybe it's on my PC or on GitHub, I don't know.

52:47.680 --> 52:50.480
Where you use B port cannot supply a large current.

52:50.480 --> 52:56.320
If you want things like these pixels to have a separate power supply, the terminology of

52:56.320 --> 53:04.120
Tony with upload and download is reversed from what I think is normal, but have to use

53:04.120 --> 53:05.120
it.

53:05.120 --> 53:06.120
It's not a problem.

53:06.120 --> 53:13.720
If you want to have your code saved from prying eyes, I think forget it.

53:13.720 --> 53:21.280
The intermediate code can be back compiled so anyone can see into your code.

53:21.280 --> 53:28.760
You have large invested interest in your code, maybe Python is not the way.

53:28.760 --> 53:34.840
Then probably you want to make a large amount of products, so it's not the way anyway.

53:34.840 --> 53:39.080
Okay, I did cover some things.

53:39.080 --> 53:40.080
Take away.

53:40.080 --> 53:41.080
Well, start tinkering.

53:41.080 --> 53:42.960
That was a good idea.

53:42.960 --> 53:47.880
Get the same hardware as you would use for an Arduino, get some micro piping cable board,

53:47.880 --> 53:51.680
load it on it, it's five minutes work and start doing things.

53:51.680 --> 53:57.320
Okay, well, if I did that demo, then those pixels would show questions.

53:57.320 --> 54:01.200
But I think we're at times up anyway.

54:01.200 --> 54:02.200
One minute.

54:02.200 --> 54:03.200
One last question.

54:03.200 --> 54:28.360
Yeah, where does it come from?

54:28.360 --> 54:36.160
Micro python is a book of three he asked, well, I did codes come the pin and the machine.

54:36.160 --> 54:41.640
Micro python is a common part and then a specific spot for specific chips and accessing a GPO

54:41.640 --> 54:45.120
pin of a chip is very different from chips.

54:45.120 --> 54:47.960
But it's a it's a that's a very shallow part.

54:47.960 --> 54:50.760
Once you have that you can build a lot of things on top of that.

54:50.760 --> 54:56.240
So the micro python distribution that I used here to compile, I must specify for which

54:56.240 --> 55:00.480
target chip I compile and then it grabs the correct code.

55:00.480 --> 55:02.320
Okay.

55:02.320 --> 55:06.320
Thank you.

55:06.320 --> 55:08.520
Thanks.

55:08.520 --> 55:17.040
I like to order.

55:17.040 --> 55:20.760
Will you be available outside for questions?

55:20.760 --> 55:22.320
So water will be around for questions.

55:22.320 --> 55:24.720
If you have questions on hesitate.

55:24.720 --> 55:28.680
I hope for the smart watches we still have hope.
