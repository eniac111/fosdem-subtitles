1
0:00:00.000 --> 0:00:12.000
Please give a big welcome to Walter, who is coming from the Netherlands for an introduction

2
0:00:12.000 --> 0:00:15.000
to micropiton.

3
0:00:15.000 --> 0:00:21.840
Well, hello everyone.

4
0:00:21.840 --> 0:00:27.880
Take your seats, you people.

5
0:00:27.880 --> 0:00:33.240
I cringe at every extra person who walks in because it's an extra 100 watts of heating.

6
0:00:33.240 --> 0:00:39.040
It's already quite hot here.

7
0:00:39.040 --> 0:00:45.480
Okay, can start I think.

8
0:00:45.480 --> 0:00:51.320
Okay, that's me and that's a Python subject for today.

9
0:00:51.320 --> 0:00:52.320
I welcome questions.

10
0:00:52.320 --> 0:00:58.960
If anyone wants something while I'm talking, please raise your hand and you'll get a microphone.

11
0:00:58.960 --> 0:01:02.000
And if that takes too much time, I just skip subjects.

12
0:01:02.000 --> 0:01:04.560
Interaction is always nice.

13
0:01:04.560 --> 0:01:08.280
Okay, I'm Walter van Ooye.

14
0:01:08.280 --> 0:01:13.160
I did informatics, the technical version, when it didn't just exist.

15
0:01:13.160 --> 0:01:17.000
I worked in industry for quite a long time.

16
0:01:17.000 --> 0:01:21.440
I still have a web shop and sell things like these stuff.

17
0:01:21.440 --> 0:01:28.440
I worked at Hochshoe Utrecht for a year at Avant to teach technical informatics, of course,

18
0:01:28.440 --> 0:01:32.600
and now I'm employed by a company who does robotics in industry.

19
0:01:32.600 --> 0:01:37.160
But this is about micropiton.

20
0:01:37.160 --> 0:01:42.080
First context, I guess you all know what a microprocessor is.

21
0:01:42.080 --> 0:01:50.800
Way back when they first made a single processor on one chip, it was a very feeble small thing.

22
0:01:50.800 --> 0:01:53.000
And since then we have progressed a lot.

23
0:01:53.000 --> 0:01:56.400
Now we can pack a lot of power in one chip.

24
0:01:56.400 --> 0:01:58.880
But that's still a processor.

25
0:01:58.880 --> 0:02:00.520
It cannot do anything on itself.

26
0:02:00.520 --> 0:02:07.760
It needs external stuff like memory, IO, hard disk to store things permanently, probably

27
0:02:07.760 --> 0:02:11.440
less of cooling like we all do here.

28
0:02:11.440 --> 0:02:15.420
That's one way to use what we can put in a chip.

29
0:02:15.420 --> 0:02:21.600
The other route is don't make necessarily the processor much powerful, but put more

30
0:02:21.600 --> 0:02:23.160
things on a single chip.

31
0:02:23.160 --> 0:02:28.920
More RAM, flash ROM to store code, peripherals to do things in the outside world, and then

32
0:02:28.920 --> 0:02:31.600
you have a microcontroller.

33
0:02:31.600 --> 0:02:33.640
Everything in one chip.

34
0:02:33.640 --> 0:02:39.960
And that's a nice thing not to run your windows on, but to think of things in the real world,

35
0:02:39.960 --> 0:02:45.600
with motors, lets, relays, all kinds of stuff.

36
0:02:45.600 --> 0:02:47.880
That is, if you can still buy them.

37
0:02:47.880 --> 0:02:57.040
Maybe that will be solved in the near future when ASML produces more chip machines.

38
0:02:57.040 --> 0:03:00.440
Compilers and interpreters.

39
0:03:00.440 --> 0:03:09.280
You know, an interpreter looks at source code for line by line, sees what's there, does

40
0:03:09.280 --> 0:03:14.080
it, and then it looks at the next line and does it again.

41
0:03:14.080 --> 0:03:19.680
That's not very quick, but there is no extra steps involved, so when you change your source

42
0:03:19.680 --> 0:03:23.400
code, it immediately has effect.

43
0:03:23.400 --> 0:03:29.120
And when you interact, you interact in its way with that interpreter.

44
0:03:29.120 --> 0:03:34.640
Compiler takes source code, turns later to native machine code, and that is the thing

45
0:03:34.640 --> 0:03:35.880
that runs.

46
0:03:35.880 --> 0:03:40.000
When you interact, when you interact with the program, you interact with the running

47
0:03:40.000 --> 0:03:42.840
native code.

48
0:03:42.840 --> 0:03:43.840
All clear?

49
0:03:43.840 --> 0:03:48.320
I used to be a lecturer, so everyone clear?

50
0:03:48.320 --> 0:03:54.720
And then, of course, no one raised a finger, it's not clear to me.

51
0:03:54.720 --> 0:03:59.040
Things cannot be that simple, so there's combos of compile interpreter.

52
0:03:59.040 --> 0:04:01.640
That's actually how Python generally works.

53
0:04:01.640 --> 0:04:06.280
You have a source code, you have a compiler that translates that source code to an intermediate

54
0:04:06.280 --> 0:04:12.640
representation, and then you have an interpreter that interprets that intermediate code.

55
0:04:12.640 --> 0:04:17.920
Now, you have either the best of both worlds or the worst, I don't know.

56
0:04:17.920 --> 0:04:25.960
This takes some time, but less than real compilation, and this is slower than real running native

57
0:04:25.960 --> 0:04:31.280
code, but it's still somewhat faster than directly interpreting the source code.

58
0:04:31.280 --> 0:04:34.800
Real clear?

59
0:04:34.800 --> 0:04:36.800
Okay.

60
0:04:36.800 --> 0:04:43.640
Python typically runs interpreted, which has benefits and disadvantages, but we'll combine

61
0:04:43.640 --> 0:04:44.640
that.

62
0:04:44.640 --> 0:04:47.600
What's Python's place in the larger world of things?

63
0:04:47.600 --> 0:04:54.360
There are programming language, I think you can recognize the symbols, that make it easy

64
0:04:54.360 --> 0:05:00.280
to change your code, to run it quickly, to think of it, to try things.

65
0:05:00.280 --> 0:05:02.000
It's the one end of the spectrum.

66
0:05:02.000 --> 0:05:07.720
There's the other side of the spectrum, when you write high performance codes, like operating

67
0:05:07.720 --> 0:05:15.600
systems, graphical tools, games and things like that, those language are much less forgiving

68
0:05:15.600 --> 0:05:17.400
in what you do.

69
0:05:17.400 --> 0:05:23.040
It takes a lot of time to compile it correctly, but then they filter out a lot more errors

70
0:05:23.040 --> 0:05:28.800
than those type of languages do, especially the torus for that.

71
0:05:28.800 --> 0:05:35.360
And somewhere in between are the compromises, that's generally used for not too high performance,

72
0:05:35.360 --> 0:05:43.000
but really some easily performance user interaction thing websites, simple graphical applications.

73
0:05:43.000 --> 0:05:45.280
That's the whole scheme of things.

74
0:05:45.280 --> 0:05:49.400
And traditionally, micro-controllers, these kind of things, were programmed with these

75
0:05:49.400 --> 0:05:55.200
kind of languages, because they simply didn't have the resources, speed of the processor,

76
0:05:55.200 --> 0:06:05.640
size of the RAM, size of the flash, to run with these kind of languages.

77
0:06:05.640 --> 0:06:12.680
What really distinguishes the language is whether you are runtime-typed, in Python,

78
0:06:12.680 --> 0:06:18.120
when you have a variable, the runtime system has no ID, whether it's a string or an integer

79
0:06:18.120 --> 0:06:22.360
or a list or whatever, it will find out at runtime.

80
0:06:22.360 --> 0:06:31.120
Very typed languages that's fixed, less flexible for you, easier on the processor.

81
0:06:31.120 --> 0:06:34.960
It compiles to, well, the left side compiles to intermediate languages, some of them are

82
0:06:34.960 --> 0:06:42.480
even really source-interpreted, right side languages are compiled to mostly machine language.

83
0:06:42.480 --> 0:06:45.040
And memory management, an important one.

84
0:06:45.040 --> 0:06:51.600
In Python, you rarely wonder about where your memory is, what memory is used.

85
0:06:51.600 --> 0:06:54.040
The runtime system solves it.

86
0:06:54.040 --> 0:07:02.360
In C and C++, you have to worry a lot about which memory you claimed, what you released,

87
0:07:02.360 --> 0:07:07.480
don't release it too early, or you'll get a nice crash or something else.

88
0:07:07.480 --> 0:07:14.880
And in between, well, you take some care of it, maybe give some hints to the runtime system,

89
0:07:14.880 --> 0:07:17.480
but in general you don't bother too much with it.

90
0:07:17.480 --> 0:07:25.080
So left side, easier programming, right side, quick running.

91
0:07:25.080 --> 0:07:32.080
That's how traditional C Python works, you have your source, you translate it to an intermediate

92
0:07:32.080 --> 0:07:35.760
language representation, that is runs.

93
0:07:35.760 --> 0:07:40.120
And that's all done by your Python system you install.

94
0:07:40.120 --> 0:07:43.600
That's both compiler and interpreter.

95
0:07:43.600 --> 0:07:48.080
Wow, this looks more complex.

96
0:07:48.080 --> 0:07:54.520
This micro Python, you still have a Python system, but now it no longer runs on your

97
0:07:54.520 --> 0:07:58.600
quick fast desktop, it runs on a small microcontroller.

98
0:07:58.600 --> 0:08:02.520
Both the compiler and interpreter run on the microcontroller.

99
0:08:02.520 --> 0:08:07.120
And when your Python application runs, you interact with that microcontroller.

100
0:08:07.120 --> 0:08:11.000
You still have your laptop, because you do the editing.

101
0:08:11.000 --> 0:08:15.760
I don't have an editor running on this thing, so that's the old desktop.

102
0:08:15.760 --> 0:08:22.040
I use Toni, it's a simple Python application, but it's quite useful for interacting with

103
0:08:22.040 --> 0:08:23.480
micro Python.

104
0:08:23.480 --> 0:08:31.880
So I interact with Toni, I edit my code there, it's sent or stored or kept on the microcontroller

105
0:08:31.880 --> 0:08:32.880
itself.

106
0:08:32.880 --> 0:08:38.920
There it is compiled and runs, and then it runs here and hopefully does nice things with

107
0:08:38.920 --> 0:08:41.560
the outside world.

108
0:08:41.560 --> 0:08:43.200
Still clear?

109
0:08:43.200 --> 0:08:46.640
Nothing new, nice.

110
0:08:46.640 --> 0:08:57.500
On the microcontroller, let's say standard, read, evaluate, print loop, so you can do

111
0:08:57.500 --> 0:09:04.880
things like you did on the prompt on the Python on your normal computer.

112
0:09:04.880 --> 0:09:10.720
And evaluate what you did, print it, and it can do more interesting things like linking

113
0:09:10.720 --> 0:09:18.880
lets or reading files that are stored on the chip.

114
0:09:18.880 --> 0:09:23.760
I think we should just show, because it's too...

115
0:09:23.760 --> 0:09:24.260
Okay, here I have a R

116
0:09:53.760 --> 0:10:00.520
We've seen extra drive here, that's the drive we created, and I can copy...

117
0:10:00.520 --> 0:10:07.520
Here's the front end image.

118
0:10:07.520 --> 0:10:14.800
I copy the micro Python image to that drive.

119
0:10:14.800 --> 0:10:16.960
It copies it.

120
0:10:16.960 --> 0:10:18.800
When it's done, it reboots.

121
0:10:18.800 --> 0:10:28.560
Now the extra drive is gone, and I can see...

122
0:10:28.560 --> 0:10:41.200
There's an extra communication port here, that's what the chip made.

123
0:10:41.200 --> 0:10:51.200
I always rename my communication ports to 42, because...

124
0:10:51.200 --> 0:11:05.480
Okay, just repreter to be sure.

125
0:11:05.480 --> 0:11:13.160
Now let's start.

126
0:11:13.160 --> 0:11:26.280
Okay, now here I have a prompt that is running on that small tipi, and just like a good Python

127
0:11:26.280 --> 0:11:32.040
it can print hello.

128
0:11:32.040 --> 0:11:34.700
Doesn't seem like much, but that's happening here.

129
0:11:34.700 --> 0:11:37.240
It's not my laptop that's doing it.

130
0:11:37.240 --> 0:11:42.440
And if you're a bit lazy and you don't want to fiddle with files, you can also...

131
0:11:42.440 --> 0:11:47.200
Oops, boot again.

132
0:11:47.200 --> 0:11:55.360
Here in Toni you can select under options, interpreter, I want to install micro Python,

133
0:11:55.360 --> 0:11:59.200
and for the Raspberry Pi Pico it just knows where to find it.

134
0:11:59.200 --> 0:12:03.400
Ah, internet is working.

135
0:12:03.400 --> 0:12:07.680
It just grabbed the latest version, installed it.

136
0:12:07.680 --> 0:12:09.680
Close.

137
0:12:09.680 --> 0:12:12.840
And I have it running.

138
0:12:12.840 --> 0:12:14.840
Yep, trans.

139
0:12:14.840 --> 0:12:15.840
Nice.

140
0:12:15.840 --> 0:12:20.560
Okay, now I must do something.

141
0:12:20.560 --> 0:12:28.560
Let's take some code.

142
0:12:28.560 --> 0:12:38.920
I can put code simply in the editor and say run this.

143
0:12:38.920 --> 0:12:39.920
No.

144
0:12:39.920 --> 0:12:44.200
Are you able to make it larger, please?

145
0:12:44.200 --> 0:12:47.640
I think that's the wrong direction.

146
0:12:47.640 --> 0:12:49.480
Large enough for you?

147
0:12:49.480 --> 0:12:57.920
And it didn't show that let was not on, but now it's on, so it works.

148
0:12:57.920 --> 0:13:07.160
Now, well, I can maybe I can convince you if I put a zero here and then run it again.

149
0:13:07.160 --> 0:13:08.160
Ah, let's off.

150
0:13:08.160 --> 0:13:12.160
You can all see that?

151
0:13:12.160 --> 0:13:24.480
Well, just on is not that interesting.

152
0:13:24.480 --> 0:13:25.640
Let's blink.

153
0:13:25.640 --> 0:13:28.040
Make it simple, define the pin.

154
0:13:28.040 --> 0:13:35.960
I import the libraries that are standard for this chip, and it allows me to access a pin.

155
0:13:35.960 --> 0:13:39.000
Pin 25 happens to be the onboard LED.

156
0:13:39.000 --> 0:13:45.560
I say it's an output pin, then I make it high, sleep a little time, make it low, sleep a

157
0:13:45.560 --> 0:13:47.960
little time, and repeat it forever.

158
0:13:47.960 --> 0:13:50.800
Okay, that should blinky.

159
0:13:50.800 --> 0:13:53.080
Ah, it blinks.

160
0:13:53.080 --> 0:13:55.280
Oh, nice.

161
0:13:55.280 --> 0:13:59.440
Print the plot for any demo, otherwise your hands will get sore.

162
0:13:59.440 --> 0:14:08.160
Okay, but now when I stop it, it stops and this thing doesn't do anything.

163
0:14:08.160 --> 0:14:11.160
It should stop, it doesn't.

164
0:14:11.160 --> 0:14:19.320
Well, there's always the reboot for that.

165
0:14:19.320 --> 0:14:27.000
It's supposed to be interruptible by that stop button, but since a week it doesn't do

166
0:14:27.000 --> 0:14:28.760
anything, I don't know why.

167
0:14:28.760 --> 0:14:37.240
If I want to do the chip, do something on itself, I have to store this file on the chip.

168
0:14:37.240 --> 0:14:44.520
So I make the blink.py on the chip.

169
0:14:44.520 --> 0:14:49.640
Now it's here, and I can run it from there.

170
0:14:49.640 --> 0:14:53.800
It still blinks, and that's not very interesting.

171
0:14:53.800 --> 0:15:03.560
Now if I stop it and put it on a power bank, it doesn't do anything.

172
0:15:03.560 --> 0:15:04.560
It's a pity.

173
0:15:04.560 --> 0:15:08.720
When it starts, it looks for a main.py and excuse that file.

174
0:15:08.720 --> 0:15:24.040
So if I wanted to start, I have to make a file, import blink, save that as main.py.

175
0:15:24.040 --> 0:15:27.600
Ah, it's amazing.

176
0:15:27.600 --> 0:15:30.120
This irritating, there is a small file system here.

177
0:15:30.120 --> 0:15:35.360
I can make a new file directly delete, but I cannot rename a file.

178
0:15:35.360 --> 0:15:41.240
So let's do the performance way of doing that.

179
0:15:41.240 --> 0:15:47.800
Save as main, not me.

180
0:15:47.800 --> 0:15:53.800
Now I can delete that one.

181
0:15:53.800 --> 0:15:54.800
Nice.

182
0:15:54.800 --> 0:15:59.640
It deleted the correct one.

183
0:15:59.640 --> 0:16:00.840
And that's import blink.

184
0:16:00.840 --> 0:16:07.560
So now if I put it on a power bank, it starts blinking of its own.

185
0:16:07.560 --> 0:16:14.000
But now at least that's what happened yesterday.

186
0:16:14.000 --> 0:16:19.640
When I start to hold it again, now it doesn't want to.

187
0:16:19.640 --> 0:16:21.920
I cannot get into it anymore.

188
0:16:21.920 --> 0:16:23.480
It's breached.

189
0:16:23.480 --> 0:16:28.560
But okay, I can still reload.

190
0:16:28.560 --> 0:16:34.880
But now if I reload the micro-py interpreter again, it keeps the file system.

191
0:16:34.880 --> 0:16:35.880
So it keeps the main.py.

192
0:16:35.880 --> 0:16:38.080
So it doesn't work.

193
0:16:38.080 --> 0:16:47.040
So some clever guy made flash nuke.

194
0:16:47.040 --> 0:16:56.120
And when I put that there, it reboots with that code.

195
0:16:56.120 --> 0:16:59.320
Now it's nothing.

196
0:16:59.320 --> 0:17:07.000
And if I now reboot it, I can put the normal code on it again.

197
0:17:07.000 --> 0:17:10.000
Where it is.

198
0:17:10.000 --> 0:17:14.400
Force the vehicle images.

199
0:17:14.400 --> 0:17:23.440
Okay, put it one over there.

200
0:17:23.440 --> 0:17:26.440
It just USB transfers quite quick.

201
0:17:26.440 --> 0:17:28.720
And now I have a normal behaving.

202
0:17:28.720 --> 0:17:33.600
Yeah, okay, that behaves again.

203
0:17:33.600 --> 0:17:34.600
Nice.

204
0:17:34.600 --> 0:17:36.400
We named CioPort.

205
0:17:36.400 --> 0:17:37.400
You've seen blinky.

206
0:17:37.400 --> 0:17:40.240
You've seen the startup.

207
0:17:40.240 --> 0:17:41.600
Demo of the startup.

208
0:17:41.600 --> 0:17:42.600
Okay.

209
0:17:42.600 --> 0:17:46.240
I was going to demonstrate blinking a LED on a breadboard.

210
0:17:46.240 --> 0:17:47.920
But it's too feeble to bring here.

211
0:17:47.920 --> 0:17:51.960
So let's blink more LEDs.

212
0:17:51.960 --> 0:17:56.320
Or it's better.

213
0:17:56.320 --> 0:18:00.320
Okay.

214
0:18:00.320 --> 0:18:02.560
Now you know why I put all the things on the table.

215
0:18:02.560 --> 0:18:11.000
So I have the correct order of driving everything.

216
0:18:11.000 --> 0:18:13.000
What's on here?

217
0:18:13.000 --> 0:18:25.000
There's a bit.

218
0:18:25.000 --> 0:18:35.920
I can blink a single LED.

219
0:18:35.920 --> 0:18:38.440
Now I use a library I wrote.

220
0:18:38.440 --> 0:18:40.360
And it's loading all those library files.

221
0:18:40.360 --> 0:18:41.600
It takes some time.

222
0:18:41.600 --> 0:18:45.400
And after that, yeah, it really blinks.

223
0:18:45.400 --> 0:18:48.360
I'll come back to that later.

224
0:18:48.360 --> 0:18:52.760
And this one, if I'm a bit insistent, it will probably stop.

225
0:18:52.760 --> 0:18:57.120
Yeah, there it is again.

226
0:18:57.120 --> 0:19:00.800
We can also have more LEDs.

227
0:19:00.800 --> 0:19:07.840
I've made a system that's whatever target ship I use, it has eight pins that are connected

228
0:19:07.840 --> 0:19:08.840
here.

229
0:19:08.840 --> 0:19:11.080
So we can swap it for another board.

230
0:19:11.080 --> 0:19:14.880
The whole different processor still has the same eight pins.

231
0:19:14.880 --> 0:19:16.840
That's the edge library.

232
0:19:16.840 --> 0:19:22.880
And edge.port is those eight pins gathered together in one port.

233
0:19:22.880 --> 0:19:26.320
And I give it to the kit demo.

234
0:19:26.320 --> 0:19:32.680
And then it should first load everything.

235
0:19:32.680 --> 0:19:33.680
And then it's kit.

236
0:19:33.680 --> 0:19:34.680
Okay.

237
0:19:34.680 --> 0:19:37.040
Kit on eight LEDs.

238
0:19:37.040 --> 0:19:46.360
But that's not enough.

239
0:19:46.360 --> 0:19:50.480
You take an I2C extender chip and that chip.

240
0:19:50.480 --> 0:19:53.520
Does it work?

241
0:19:53.520 --> 0:19:57.760
Yes, it works.

242
0:19:57.760 --> 0:20:01.920
And it has more output pins.

243
0:20:01.920 --> 0:20:06.560
Load, load, load, load.

244
0:20:06.560 --> 0:20:09.760
And then have a kit with 16 ports.

245
0:20:09.760 --> 0:20:19.720
And if that's too slow, I think it's boringly slow.

246
0:20:19.720 --> 0:20:24.840
Maybe 10 milliseconds is nice.

247
0:20:24.840 --> 0:20:31.480
Load, load, load, load, load.

248
0:20:31.480 --> 0:20:35.560
Yeah, that's a bit quicker.

249
0:20:35.560 --> 0:20:36.560
Okay.

250
0:20:36.560 --> 0:20:40.560
Back to the sheets.

251
0:20:40.560 --> 0:20:44.640
One more LEDs.

252
0:20:44.640 --> 0:20:45.640
We have some more LEDs.

253
0:20:45.640 --> 0:20:46.640
Okay.

254
0:20:46.640 --> 0:20:51.840
You saw that it spent some time at beginning by loading a few libraries.

255
0:20:51.840 --> 0:20:56.600
It shows because I coded it that way because I want to know how long it takes to load the

256
0:20:56.600 --> 0:20:59.480
libraries and how much RAM it uses.

257
0:20:59.480 --> 0:21:06.400
In general, you can have three ways of putting library code on micro Python.

258
0:21:06.400 --> 0:21:09.920
You can have the source files, the simple.py files.

259
0:21:09.920 --> 0:21:14.080
And then when you load them, they are first compiled and then loaded.

260
0:21:14.080 --> 0:21:20.480
You can also pre-compile those files on your laptop and then load the compiled version.

261
0:21:20.480 --> 0:21:23.560
That's the.mpy files.

262
0:21:23.560 --> 0:21:28.800
You can also take the files and build them into the image you load anyway.

263
0:21:28.800 --> 0:21:31.040
You show me copying that image onto the chip.

264
0:21:31.040 --> 0:21:33.600
You can put your files in there.

265
0:21:33.600 --> 0:21:37.800
And that has effect for how much time it takes.

266
0:21:37.800 --> 0:21:43.160
When I demoted, it was irritatingly long.

267
0:21:43.160 --> 0:21:53.000
My files took about 12 seconds to get loaded from the flash compiled and ready for run.

268
0:21:53.000 --> 0:21:55.800
When I pre-compiled, it's a little bit faster.

269
0:21:55.800 --> 0:22:03.240
And when I freeze it, I build an image of micro Python with those files included.

270
0:22:03.240 --> 0:22:05.240
It gets really fast.

271
0:22:05.240 --> 0:22:08.200
And then it also uses less RAM.

272
0:22:08.200 --> 0:22:12.480
RAM, memory on those chips is always a very scary source.

273
0:22:12.480 --> 0:22:21.080
This chip has about, I think, 130K left after loading this library.

274
0:22:21.080 --> 0:22:22.080
Looks like a lot.

275
0:22:22.080 --> 0:22:27.520
You can eat it quickly, especially if you make screen buffers for LCDs and things like

276
0:22:27.520 --> 0:22:28.520
that.

277
0:22:28.520 --> 0:22:35.200
A 240 by 320 LCD with full color, that's two bytes per color.

278
0:22:35.200 --> 0:22:38.640
I think that's more than is left there.

279
0:22:38.640 --> 0:22:40.680
You couldn't still use it.

280
0:22:40.680 --> 0:22:45.160
So it's very important to conserve that.

281
0:22:45.160 --> 0:22:49.280
When I develop things, I simply take a very fast target.

282
0:22:49.280 --> 0:22:53.280
The TNG is maybe 10 times faster than a pipe pico.

283
0:22:53.280 --> 0:22:56.760
And it has, I think, one megabyte memory.

284
0:22:56.760 --> 0:22:59.280
So that's ample.

285
0:22:59.280 --> 0:23:01.280
But there's always a bot.

286
0:23:01.280 --> 0:23:03.720
But it comes later.

287
0:23:03.720 --> 0:23:04.720
Okay.

288
0:23:04.720 --> 0:23:08.120
Embedding your code into a micro pipe image is not that complex.

289
0:23:08.120 --> 0:23:12.280
I had it running on my Linux machine in maybe an hour.

290
0:23:12.280 --> 0:23:16.160
Then I tried the same recipe on Windows and it fails.

291
0:23:16.160 --> 0:23:19.720
So when it happens, what do you do?

292
0:23:19.720 --> 0:23:21.560
You make a docker container.

293
0:23:21.560 --> 0:23:25.720
So I made a docker container on the Linux machine that does exactly the same thing,

294
0:23:25.720 --> 0:23:26.720
worked.

295
0:23:26.720 --> 0:23:27.720
Then I run it on Windows.

296
0:23:27.720 --> 0:23:28.720
Works too.

297
0:23:28.720 --> 0:23:31.560
It's fine.

298
0:23:31.560 --> 0:23:36.400
And I can show if I take this.

299
0:23:36.400 --> 0:23:47.400
Maybe here.

300
0:23:47.400 --> 0:23:51.400
There it is.

301
0:23:51.400 --> 0:23:58.880
If I import my library, it's...

302
0:23:58.880 --> 0:24:00.760
Okay.

303
0:24:00.760 --> 0:24:04.760
You can do it.

304
0:24:04.760 --> 0:24:07.760
There's a license statement.

305
0:24:07.760 --> 0:24:09.600
A lot of text.

306
0:24:09.600 --> 0:24:10.600
Okay.

307
0:24:10.600 --> 0:24:18.480
Here I have that license statement in the source.

308
0:24:18.480 --> 0:24:21.000
Let's add this is.

309
0:24:21.000 --> 0:24:22.000
Fostem.

310
0:24:22.000 --> 0:24:23.000
Foste?

311
0:24:23.000 --> 0:24:24.000
Whatever.

312
0:24:24.000 --> 0:24:25.000
Okay.

313
0:24:25.000 --> 0:24:34.440
Start a docker container.

314
0:24:34.440 --> 0:24:35.440
It works.

315
0:24:35.440 --> 0:24:37.920
Otherwise it doesn't do it.

316
0:24:37.920 --> 0:24:40.880
It takes some 40 to 400 seconds.

317
0:24:40.880 --> 0:24:44.960
I cannot predict how long.

318
0:24:44.960 --> 0:24:45.960
Of course it's docker.

319
0:24:45.960 --> 0:24:50.640
So all the preparations, loading the Linux image, loading all the development tools,

320
0:24:50.640 --> 0:24:51.640
that's cached.

321
0:24:51.640 --> 0:25:00.920
But then after it, it takes the my library code and then it compiles the micro Python

322
0:25:00.920 --> 0:25:05.920
with that library code edit and that takes some time.

323
0:25:05.920 --> 0:25:08.080
Wait.

324
0:25:08.080 --> 0:25:11.920
Okay.

325
0:25:11.920 --> 0:25:13.920
It's running now.

326
0:25:13.920 --> 0:25:18.400
Didn't take that long.

327
0:25:18.400 --> 0:25:19.960
So what do I do now?

328
0:25:19.960 --> 0:25:24.000
I reboot my chip again.

329
0:25:24.000 --> 0:25:32.880
And now take the new code.

330
0:25:32.880 --> 0:25:43.200
It's the new code.

331
0:25:43.200 --> 0:25:50.000
Copy that to the boot.

332
0:25:50.000 --> 0:25:55.000
Okay.

333
0:25:55.000 --> 0:26:00.520
Let's see what we have here.

334
0:26:00.520 --> 0:26:04.640
Now you no longer see the library files there because they are not present on the internal

335
0:26:04.640 --> 0:26:06.000
file system.

336
0:26:06.000 --> 0:26:24.840
They're built into the micro Python interpreter that I can still...

337
0:26:24.840 --> 0:26:28.240
It's a bit faster now than it used to be.

338
0:26:28.240 --> 0:26:32.120
And now print.

339
0:26:32.120 --> 0:26:40.440
And now license text is expanded so I really have put the changed version of the library

340
0:26:40.440 --> 0:26:41.440
in there.

341
0:26:41.440 --> 0:26:42.440
Okay.

342
0:26:42.440 --> 0:26:45.440
Let's go on.

343
0:26:45.440 --> 0:26:48.200
I showed freezing code.

344
0:26:48.200 --> 0:26:50.000
I still want more LEDs.

345
0:26:50.000 --> 0:26:53.640
Not enough.

346
0:26:53.640 --> 0:26:54.640
Why is more LEDs?

347
0:26:54.640 --> 0:26:59.640
I think this is enough.

348
0:26:59.640 --> 0:27:04.480
Like that.

349
0:27:04.480 --> 0:27:06.480
Okay.

350
0:27:06.480 --> 0:27:07.480
That needs more power.

351
0:27:07.480 --> 0:27:15.160
I cannot power it off the USB port of my laptop so I need external power for that.

352
0:27:15.160 --> 0:27:19.760
All right.

353
0:27:19.760 --> 0:27:31.000
Now I take...

354
0:27:31.000 --> 0:27:34.000
Oh.

355
0:27:34.000 --> 0:27:40.240
It's a microphone.

356
0:27:40.240 --> 0:27:51.520
Okay let's see what's on this chip.

357
0:27:51.520 --> 0:27:54.200
Now I loaded the code from the chip.

358
0:27:54.200 --> 0:27:57.240
I prepared on the chip there.

359
0:27:57.240 --> 0:28:00.520
Don't need to load it from my PC there.

360
0:28:00.520 --> 0:28:03.920
And it runs over there.

361
0:28:03.920 --> 0:28:14.520
And it still loads the library.

362
0:28:14.520 --> 0:28:16.640
So enough LEDs for you.

363
0:28:16.640 --> 0:28:17.640
Okay.

364
0:28:17.640 --> 0:28:20.880
Put it over there.

365
0:28:20.880 --> 0:28:25.600
With so many LEDs you can do nicer things and just put them in the long line.

366
0:28:25.600 --> 0:28:30.360
You can put them in a square and make displays with it.

367
0:28:30.360 --> 0:28:37.360
So take that one off.

368
0:28:37.360 --> 0:28:44.240
Does it stop?

369
0:28:44.240 --> 0:28:50.240
Yeah, it stops.

370
0:28:50.240 --> 0:28:57.240
And let's run that one.

371
0:28:57.240 --> 0:29:07.520
And we are at Fosdam so it prints an F on it.

372
0:29:07.520 --> 0:29:15.040
The code takes a long line of 64 LEDs and then it folds.

373
0:29:15.040 --> 0:29:19.760
It offers 88888 LEDs to make a square.

374
0:29:19.760 --> 0:29:23.240
That's what I call a canvas and I can write text on that.

375
0:29:23.240 --> 0:29:30.240
Sorry?

376
0:29:30.240 --> 0:29:37.880
Timed you mean?

377
0:29:37.880 --> 0:29:58.160
I'm not going to do them all but let's say gf.wait a little bit.

378
0:29:58.160 --> 0:29:59.160
What did I do wrong?

379
0:29:59.160 --> 0:30:03.080
Ah, a slap won't work.

380
0:30:03.080 --> 0:30:11.640
And then because we can't get enough of it.

381
0:30:11.640 --> 0:30:17.840
While true.

382
0:30:17.840 --> 0:30:20.080
Sorry conventions will take one.

383
0:30:20.080 --> 0:30:28.040
Yeah, I need a flush and I need to wait after that.

384
0:30:28.040 --> 0:30:33.480
I need this flush over here.

385
0:30:33.480 --> 0:30:34.480
Oh, they should work.

386
0:30:34.480 --> 0:30:54.480
I didn't prepare this one so let's see.

387
0:30:54.480 --> 0:30:58.160
Something like that.

388
0:30:58.160 --> 0:31:02.080
Ah, yeah, yeah, yeah, yeah.

389
0:31:02.080 --> 0:31:04.120
Okay, demo.

390
0:31:04.120 --> 0:31:05.120
What am I missing?

391
0:31:05.120 --> 0:31:06.120
Yeah.

392
0:31:06.120 --> 0:31:14.720
I sleep here.

393
0:31:14.720 --> 0:31:17.720
Clear right flush sleep.

394
0:31:17.720 --> 0:31:37.880
Oh, you guys are wonderful.

395
0:31:37.880 --> 0:31:40.880
This gets even more hold now.

396
0:31:40.880 --> 0:31:53.320
But I guess two letters is not enough.

397
0:31:53.320 --> 0:31:55.440
Where are more stuff here?

398
0:31:55.440 --> 0:32:00.400
Ah, here are my flexis.

399
0:32:00.400 --> 0:32:02.880
They also sell these things on flexible PCBs.

400
0:32:02.880 --> 0:32:03.880
It's nice.

401
0:32:03.880 --> 0:32:14.880
And then I put this one again.

402
0:32:14.880 --> 0:32:24.720
Like this one.

403
0:32:24.720 --> 0:32:29.400
And now it's garbage.

404
0:32:29.400 --> 0:32:31.320
Anyone has any idea why it's garbage?

405
0:32:31.320 --> 0:32:42.920
Yeah, the first one they go tuck, tuck, tuck, tuck.

406
0:32:42.920 --> 0:32:46.080
And this one goes tuck, tuck, tuck.

407
0:32:46.080 --> 0:32:53.320
Instead going the same direction it's zieksacht.

408
0:32:53.320 --> 0:32:55.360
Okay.

409
0:32:55.360 --> 0:33:09.280
So we must fold it in the zieksacht version.

410
0:33:09.280 --> 0:33:12.280
Yeah.

411
0:33:12.280 --> 0:33:25.960
If you know a better term for it, feel free.

412
0:33:25.960 --> 0:33:29.840
Ah, hit the bug.

413
0:33:29.840 --> 0:33:34.560
Fortunately, I know where to correct this.

414
0:33:34.560 --> 0:33:44.920
Okay, to shosh, it's in canvas, and I made an error there in the zieksachting.

415
0:33:44.920 --> 0:33:47.920
Rotate it.

416
0:33:47.920 --> 0:33:53.760
Yeah, somewhere like here.

417
0:33:53.760 --> 0:34:10.480
It's a forward one here.

418
0:34:10.480 --> 0:34:12.400
It's of course an off by one error.

419
0:34:12.400 --> 0:34:19.920
I have to subtract one more here because size is one beyond.

420
0:34:19.920 --> 0:34:25.920
So plus one, yeah.

421
0:34:25.920 --> 0:34:34.440
Okay, save it.

422
0:34:34.440 --> 0:34:37.200
And run it again.

423
0:34:37.200 --> 0:34:41.560
And just a hint, this won't work.

424
0:34:41.560 --> 0:34:42.800
Why doesn't this work?

425
0:34:42.800 --> 0:34:45.560
I made a stupid mistake.

426
0:34:45.560 --> 0:34:48.560
And it's not in the code.

427
0:34:48.560 --> 0:34:50.560
What?

428
0:34:50.560 --> 0:34:57.840
No, that was a different chip.

429
0:34:57.840 --> 0:34:58.840
But you're hot.

430
0:34:58.840 --> 0:35:02.680
It's hot anyway here.

431
0:35:02.680 --> 0:35:06.760
What did I just edit?

432
0:35:06.760 --> 0:35:10.320
I edited the source code on my laptop.

433
0:35:10.320 --> 0:35:13.000
That's the upper screen here.

434
0:35:13.000 --> 0:35:15.040
This one is a source code on my laptop.

435
0:35:15.040 --> 0:35:18.520
This one is the code on the chip.

436
0:35:18.520 --> 0:35:22.120
I made a mistake resilient times.

437
0:35:22.120 --> 0:35:33.760
So do the same thing, but now on the code here.

438
0:35:33.760 --> 0:35:34.760
That one.

439
0:35:34.760 --> 0:35:40.240
Now you see it's a bit slower because it must first retrieve that code from the chip to

440
0:35:40.240 --> 0:35:41.600
the laptop.

441
0:35:41.600 --> 0:35:42.840
Then I can edit it.

442
0:35:42.840 --> 0:35:48.840
It's the same code, but still I have to edit it.

443
0:35:48.840 --> 0:35:54.280
Well, which one will work?

444
0:35:54.280 --> 0:35:57.320
Ah, that's quick.

445
0:35:57.320 --> 0:35:59.320
Okay, thanks.

446
0:35:59.320 --> 0:36:07.840
I'm not 25, okay, near.

447
0:36:07.840 --> 0:36:13.440
I'm doing something stupid here.

448
0:36:13.440 --> 0:36:18.120
Control-Z is your friend.

449
0:36:18.120 --> 0:36:21.000
And now I've changed it on the...

450
0:36:21.000 --> 0:36:23.120
Okay, there.

451
0:36:23.120 --> 0:36:26.320
And I must still...

452
0:36:26.320 --> 0:36:27.320
It's saving.

453
0:36:27.320 --> 0:36:29.960
And now I run that one again.

454
0:36:29.960 --> 0:36:30.960
It should...

455
0:36:30.960 --> 0:36:31.960
Compile.

456
0:36:31.960 --> 0:36:43.120
There's not the baked in version, this is from source version.

457
0:36:43.120 --> 0:36:45.240
And now it works.

458
0:36:45.240 --> 0:36:46.240
Well...

459
0:36:46.240 --> 0:36:47.240
Okay.

460
0:36:47.240 --> 0:37:03.600
I prepared all kinds of versions.

461
0:37:03.600 --> 0:37:16.680
They do all kinds of things with the ordering of the LEDs on the screens.

462
0:37:16.680 --> 0:37:17.680
Not again.

463
0:37:17.680 --> 0:37:18.680
Okay.

464
0:37:18.680 --> 0:37:19.680
Sorry?

465
0:37:19.680 --> 0:37:35.960
Actually, this is not an accident.

466
0:37:35.960 --> 0:37:37.880
Okay.

467
0:37:37.880 --> 0:37:47.920
So what I do is the XY inverted, and that should be in here somewhere.

468
0:37:47.920 --> 0:37:54.840
Where is the XY inverted?

469
0:37:54.840 --> 0:37:58.560
You asked me to enlarge your letters, so I'm scrolling slowly.

470
0:37:58.560 --> 0:38:10.160
It's called swapped.

471
0:38:10.160 --> 0:38:22.000
What's this one?

472
0:38:22.000 --> 0:38:25.200
Okay.

473
0:38:25.200 --> 0:38:34.600
But do reflect on what I was about to do, that is to edit it in the code stored on the

474
0:38:34.600 --> 0:38:35.600
chip.

475
0:38:35.600 --> 0:38:37.720
That's not a problem.

476
0:38:37.720 --> 0:38:45.160
But then I decouple the chip and start working on the chip, and I just lost my code, or I

477
0:38:45.160 --> 0:38:49.520
don't know where it is on one of the 20 chips I have.

478
0:38:49.520 --> 0:38:53.320
And now it's FO again, so that works.

479
0:38:53.320 --> 0:38:54.320
But that's not a problem.

480
0:38:54.320 --> 0:39:02.840
I frequently don't know where I have put my last version of the code, and Tony doesn't

481
0:39:02.840 --> 0:39:06.800
support GitHub via the microcontroller.

482
0:39:06.800 --> 0:39:09.760
That in fact would be very nice.

483
0:39:09.760 --> 0:39:10.760
Okay.

484
0:39:10.760 --> 0:39:12.480
Never enough.

485
0:39:12.480 --> 0:39:18.400
Let's take more.

486
0:39:18.400 --> 0:39:23.680
Okay.

487
0:39:23.680 --> 0:39:30.680
Now it doesn't know it has more lets, so let's tell it.

488
0:39:30.680 --> 0:39:38.360
Where's the code?

489
0:39:38.360 --> 0:39:46.280
Stop it first.

490
0:39:46.280 --> 0:39:49.480
Stop it.

491
0:39:49.480 --> 0:39:54.320
Then that one.

492
0:39:54.320 --> 0:39:58.120
Sorry?

493
0:39:58.120 --> 0:40:09.040
Oh, that takes a lot of time.

494
0:40:09.040 --> 0:40:16.640
You might do that for consistency, but downloading the live takes one minute.

495
0:40:16.640 --> 0:40:17.640
So not for sure.

496
0:40:17.640 --> 0:40:20.640
That's true.

497
0:40:20.640 --> 0:40:25.120
But then you lose a bit of the essence of using Python.

498
0:40:25.120 --> 0:40:28.960
The essence is you can quickly make a modification.

499
0:40:28.960 --> 0:40:35.080
If I can afford one or two minutes, I might as well use a really compiled language and

500
0:40:35.080 --> 0:40:36.320
spend that much time.

501
0:40:36.320 --> 0:40:39.080
So yeah, you couldn't do it.

502
0:40:39.080 --> 0:40:40.080
Okay.

503
0:40:40.080 --> 0:40:44.280
So I could add one more display, but that's more of the same.

504
0:40:44.280 --> 0:40:49.160
Let's not do that.

505
0:40:49.160 --> 0:40:52.200
Go back to these things.

506
0:40:52.200 --> 0:40:53.480
Yeah.

507
0:40:53.480 --> 0:41:02.120
You saw that again loading the library from source is slow.

508
0:41:02.120 --> 0:41:04.120
You can also use a faster chip.

509
0:41:04.120 --> 0:41:26.600
If I take my fast chip, this one, and take that connection from it and use that one.

510
0:41:26.600 --> 0:41:29.760
Tony stop again and recognize new chip, please.

511
0:41:29.760 --> 0:41:33.880
Yes, it does.

512
0:41:33.880 --> 0:41:41.720
This one even has a separate flash card, so I can store more files on it than if I want.

513
0:41:41.720 --> 0:41:46.600
I can blink on it.

514
0:41:46.600 --> 0:41:49.120
This loads the library quite a bit faster.

515
0:41:49.120 --> 0:41:53.960
It doesn't have an onboard LID, so I blink a whole LCD screen.

516
0:41:53.960 --> 0:41:55.960
It works too.

517
0:41:55.960 --> 0:42:01.960
But sadly, I cannot use this target with the new pixels because it doesn't have the new

518
0:42:01.960 --> 0:42:09.360
pixel library built into the Python version for this chip.

519
0:42:09.360 --> 0:42:14.360
Sometimes you're just screwed.

520
0:42:14.360 --> 0:42:18.940
But I can't, oh, it doesn't want that.

521
0:42:18.940 --> 0:42:22.800
Sometimes when the communication goes wrong, Tony is very confused about what's happening.

522
0:42:22.800 --> 0:42:28.720
You just have to restart the chip or maybe restart Tony or whatever you want.

523
0:42:28.720 --> 0:42:33.160
I can do this one.

524
0:42:33.160 --> 0:42:37.160
Now that will leave that.

525
0:42:37.160 --> 0:42:47.840
I'll go to the sheets again.

526
0:42:47.840 --> 0:42:53.280
I've compared a few target chips that you could use for this kind of work.

527
0:42:53.280 --> 0:42:59.920
The TNC is what I just showed, very fast one, but then it costs 36, so this might be real.

528
0:42:59.920 --> 0:43:04.360
36, maybe I've photographed you all.

529
0:43:04.360 --> 0:43:05.520
It's quite expensive.

530
0:43:05.520 --> 0:43:13.560
If you want to have lots of fun with things that are expendable, the ESP32 and the PyPico

531
0:43:13.560 --> 0:43:20.560
are very good contenders, less than 10 euros and readily available everywhere.

532
0:43:20.560 --> 0:43:24.600
For ESP32s, there are a lot of funny versions of it.

533
0:43:24.600 --> 0:43:31.360
There's a watch with ESP32 in it, I don't know, my computer number.

534
0:43:31.360 --> 0:43:37.960
In a previous situation, I did a demo with it, but it uses Wi-Fi and it has the habit

535
0:43:37.960 --> 0:43:44.200
of working perfectly before you all walk in over tens of meters.

536
0:43:44.200 --> 0:43:48.040
And then when you're all present with all your phones, the reach is reduced to five

537
0:43:48.040 --> 0:43:49.040
centimeters.

538
0:43:49.040 --> 0:43:51.040
That's Greek, havakom, demos.

539
0:43:51.040 --> 0:43:54.720
These are other things.

540
0:43:54.720 --> 0:44:01.800
Adorable camera has a built-in ESP32, can run micro-Python, and then you can transmit

541
0:44:01.800 --> 0:44:11.400
the images over Wi-Fi, at least if you're not all present.

542
0:44:11.400 --> 0:44:14.480
You all know these ones.

543
0:44:14.480 --> 0:44:21.240
The BBC One bits, they can run micro-Python, sort of.

544
0:44:21.240 --> 0:44:28.040
They cannot store files on the flash system, and they can run about 50 lines or so of Python.

545
0:44:28.040 --> 0:44:34.480
So it's nice for a kindergarten Python course, but not for your work.

546
0:44:34.480 --> 0:44:37.600
And this one, I sure hope I get it to work sometime.

547
0:44:37.600 --> 0:44:38.800
It's a Kendrite.

548
0:44:38.800 --> 0:44:41.560
It's down here.

549
0:44:41.560 --> 0:44:46.360
It's quite powerful and also has neural network hardware on it.

550
0:44:46.360 --> 0:44:52.200
But it uses some Chinese version of micro-Python, and Tony doesn't recognize it, so maybe it

551
0:44:52.200 --> 0:44:54.440
works but I don't know how.

552
0:44:54.440 --> 0:44:56.200
10 minutes left.

553
0:44:56.200 --> 0:44:57.320
Thank you.

554
0:44:57.320 --> 0:45:03.080
If you have questions, those are more important than the rest of my sheets, so interrupt me.

555
0:45:03.080 --> 0:45:08.880
A few of those more interesting tips we saw are, in fact, not a pure micro-controller

556
0:45:08.880 --> 0:45:11.640
or pure micro-processor, they are hybrids.

557
0:45:11.640 --> 0:45:18.080
They have a micro-controller core, but an external ROM added, and in some cases even

558
0:45:18.080 --> 0:45:19.840
external RAM.

559
0:45:19.840 --> 0:45:25.480
That is overall a cheaper configuration because optimal, let's say, process parameter for

560
0:45:25.480 --> 0:45:30.840
making micro-tips, flash and RAM, are quite different.

561
0:45:30.840 --> 0:45:36.720
So you can make a cheaper, more effective, make a RAM chip, but you have only RAM cells

562
0:45:36.720 --> 0:45:38.080
on it.

563
0:45:38.080 --> 0:45:47.920
So for instance, the ESP32 doesn't have that much RAM on board, but it can use an external

564
0:45:47.920 --> 0:45:50.840
coupled RAM chip as a buffer for it.

565
0:45:50.840 --> 0:45:56.640
It caches the things, and then you suddenly have a few megabytes of RAM, which is more

566
0:45:56.640 --> 0:45:58.760
actually, but it's a bit slower.

567
0:45:58.760 --> 0:45:59.760
Not that much, but a bit slower.

568
0:45:59.760 --> 0:46:03.240
Excuse me, can you make the slides fullscreen, please?

569
0:46:03.240 --> 0:46:08.240
I will, if I get my cursor back.

570
0:46:08.240 --> 0:46:11.240
Where's my cursor?

571
0:46:11.240 --> 0:46:12.240
Yeah.

572
0:46:12.240 --> 0:46:22.400
Oh, they'll publish the slides, so don't worry.

573
0:46:22.400 --> 0:46:29.080
So then it's nice appearing, and you have the hybrid version in between.

574
0:46:29.080 --> 0:46:34.520
When you work with this thing, RAM is very scarce.

575
0:46:34.520 --> 0:46:38.160
So the more RAM you have, the better, especially if you're working with screen buffers or images

576
0:46:38.160 --> 0:46:43.880
or things from a camera.

577
0:46:43.880 --> 0:46:52.120
The thing is, when files are loaded by Michael Python, it first loads the source, then from

578
0:46:52.120 --> 0:46:54.560
that builds intermediate representation.

579
0:46:54.560 --> 0:46:58.640
That intermediate representation is smaller than the source, but the peak memory usage

580
0:46:58.640 --> 0:47:00.600
is still the full source.

581
0:47:00.600 --> 0:47:07.560
So I cannot load my library as one file on, let's say, an ESP32, because it doesn't have

582
0:47:07.560 --> 0:47:10.960
enough RAM to load that peak amount.

583
0:47:10.960 --> 0:47:14.920
It can load it in compiled form, but not a source form.

584
0:47:14.920 --> 0:47:22.680
So what I do, I split it in a lot of small files, and one trick I often use is I have

585
0:47:22.680 --> 0:47:30.640
a main file which imports all sub-files, and for, let's say, basic classes you must do

586
0:47:30.640 --> 0:47:36.600
that, but for utility things like a driver for an LCD, I use a trampoline function.

587
0:47:36.600 --> 0:47:44.000
It pretends to be the class, but it's a function, and when it's called, it loads the real sub-module,

588
0:47:44.000 --> 0:47:50.840
so it's loaded only when it's needed, and then it calls that with all the arguments.

589
0:47:50.840 --> 0:47:56.840
And such a trampoline takes maybe 50 bytes, while this full file could take a few kilobytes,

590
0:47:56.840 --> 0:47:59.840
so that saves a lot of RAM and loading time.

591
0:47:59.840 --> 0:48:05.840
All right, Stuart, can you get a version of Michael Python which only takes pre-compile

592
0:48:05.840 --> 0:48:08.840
to save space on small machines?

593
0:48:08.840 --> 0:48:10.800
Yeah, you sure can.

594
0:48:10.800 --> 0:48:17.720
So when you really develop something, I think you should take a larger machine, and when

595
0:48:17.720 --> 0:48:23.720
it's in production, take a smaller machine, use a pre-compiled version, yes, of course.

596
0:48:23.720 --> 0:48:24.720
Can I get a question?

597
0:48:24.720 --> 0:48:28.720
Oh, sorry, he asked whether using pre-compiled version saves RAM.

598
0:48:28.720 --> 0:48:29.720
Yes, it does.

599
0:48:29.720 --> 0:48:35.720
Whether you could have a smaller Michael Python program with complete Michael ports to save

600
0:48:35.720 --> 0:48:39.720
space in the Michael Python program?

601
0:48:39.720 --> 0:48:45.720
Yeah, but you still want to tweak with your own main code if you're developing.

602
0:48:45.720 --> 0:48:49.880
If you have a finished product, then all things are different, but I think the main power

603
0:48:49.880 --> 0:48:54.280
of Michael Python is that you can thinker with it at a late stadium.

604
0:48:54.280 --> 0:49:02.280
If you have a finished product, indeed you can freeze it, but if you want that, how did

605
0:49:02.280 --> 0:49:04.280
you develop it?

606
0:49:04.280 --> 0:49:07.720
Presumably on a different processor with more RAM.

607
0:49:07.720 --> 0:49:11.720
Let's think of it.

608
0:49:11.720 --> 0:49:12.720
Limitations.

609
0:49:12.720 --> 0:49:13.720
Yeah?

610
0:49:13.720 --> 0:49:20.720
So we can use pre-compiled large libraries and put them on the chip, and then we can

611
0:49:20.720 --> 0:49:25.720
thinker with our own code, but have the pre-compiled libraries, and is that something to do?

612
0:49:25.720 --> 0:49:26.720
Yeah, indeed.

613
0:49:26.720 --> 0:49:27.720
But there are a lot of pre-comp...

614
0:49:27.720 --> 0:49:36.080
Oh, is it a good idea to have pre-compiled libraries incorporated in the Python interpreter

615
0:49:36.080 --> 0:49:38.200
and then thinker with your own code?

616
0:49:38.200 --> 0:49:40.360
Yeah, I think that's a good approach.

617
0:49:40.360 --> 0:49:44.440
Indeed those libraries are stable, because if you must change in those libraries, you

618
0:49:44.440 --> 0:49:50.280
don't have the source code, at least not on your target chip, and you're stuck in a much

619
0:49:50.280 --> 0:49:51.880
slower development cycle.

620
0:49:51.880 --> 0:49:52.880
So it's...

621
0:49:52.880 --> 0:49:58.120
Well, if things are indeed stable, freeze them in the Michael Python interpreter.

622
0:49:58.120 --> 0:50:04.640
If not, take a large chip and develop on that.

623
0:50:04.640 --> 0:50:05.960
Five minutes left.

624
0:50:05.960 --> 0:50:10.800
Well, you can really develop limitations.

625
0:50:10.800 --> 0:50:19.400
Time-wise, if you're in the, let's say, clock cycles, time domain, if it must be that fast,

626
0:50:19.400 --> 0:50:22.560
then even C or C++ won't do it.

627
0:50:22.560 --> 0:50:28.480
You need hardware or Raspberry Pico Pios.

628
0:50:28.480 --> 0:50:31.880
If you're in the tens or hundreds of cycles, you can use compiled language.

629
0:50:31.880 --> 0:50:36.520
If you're in the thousands of cycles, you can use an interpretive language like Python.

630
0:50:36.520 --> 0:50:42.200
To be concrete, driving those new pixels that requires microseconds timing, you cannot do

631
0:50:42.200 --> 0:50:44.440
that in Python code.

632
0:50:44.440 --> 0:50:50.760
In the Michael Python interpreter, they do it in C code, and that's built in.

633
0:50:50.760 --> 0:50:56.120
Driving a server motor, a hobby server back and forth, that's milliseconds timing.

634
0:50:56.120 --> 0:51:00.040
You can easily do it in Python, in Python source code.

635
0:51:00.040 --> 0:51:04.720
There's a list of deviations from C Python.

636
0:51:04.720 --> 0:51:06.680
You can read it.

637
0:51:06.680 --> 0:51:11.520
They didn't bother me much, except that it doesn't support type hints.

638
0:51:11.520 --> 0:51:16.360
I like type hints from my testing, so I must do the testing on my laptop.

639
0:51:16.360 --> 0:51:22.240
You can test a lot of basic things, not on the small machine between your desktop.

640
0:51:22.240 --> 0:51:31.920
When it's compiled, is it the same byte code as C Python?

641
0:51:31.920 --> 0:51:37.360
When it's compiled, Michael Python intermediate code is different from C Python.

642
0:51:37.360 --> 0:51:43.240
It has its own pre-compiler, which you can download and you can pre-compile it, but it's

643
0:51:43.240 --> 0:51:52.040
different from the standard C Python.

644
0:51:52.040 --> 0:51:54.200
Does Michael Python have the garbage collector?

645
0:51:54.200 --> 0:51:56.080
You can bet it has, yes.

646
0:51:56.080 --> 0:52:02.240
When you want to do really time-critical things, call the garbage collector and do it after

647
0:52:02.240 --> 0:52:03.240
that.

648
0:52:03.240 --> 0:52:05.680
You can be reasonably sure that it's called.

649
0:52:05.680 --> 0:52:11.800
But if you want to do really time-critical, life-critical things, don't use Python.

650
0:52:11.800 --> 0:52:13.400
Sorry.

651
0:52:13.400 --> 0:52:17.040
Okay, I'll skip this one.

652
0:52:17.040 --> 0:52:19.800
What is it good for?

653
0:52:19.800 --> 0:52:22.520
Maybe not for volume production.

654
0:52:22.520 --> 0:52:24.200
For that, you use compiled language.

655
0:52:24.200 --> 0:52:31.960
But for anything that requires tinkering, exploration, lab setups, experiments, education,

656
0:52:31.960 --> 0:52:35.400
it's really nice, too.

657
0:52:35.400 --> 0:52:37.520
What is problems?

658
0:52:37.520 --> 0:52:41.160
I'm always confused by my latest version of the source code is.

659
0:52:41.160 --> 0:52:47.680
I changed what something on that ship, maybe it's on my PC or on GitHub, I don't know.

660
0:52:47.680 --> 0:52:50.480
Where you use B port cannot supply a large current.

661
0:52:50.480 --> 0:52:56.320
If you want things like these pixels to have a separate power supply, the terminology of

662
0:52:56.320 --> 0:53:04.120
Tony with upload and download is reversed from what I think is normal, but have to use

663
0:53:04.120 --> 0:53:05.120
it.

664
0:53:05.120 --> 0:53:06.120
It's not a problem.

665
0:53:06.120 --> 0:53:13.720
If you want to have your code saved from prying eyes, I think forget it.

666
0:53:13.720 --> 0:53:21.280
The intermediate code can be back compiled so anyone can see into your code.

667
0:53:21.280 --> 0:53:28.760
You have large invested interest in your code, maybe Python is not the way.

668
0:53:28.760 --> 0:53:34.840
Then probably you want to make a large amount of products, so it's not the way anyway.

669
0:53:34.840 --> 0:53:39.080
Okay, I did cover some things.

670
0:53:39.080 --> 0:53:40.080
Take away.

671
0:53:40.080 --> 0:53:41.080
Well, start tinkering.

672
0:53:41.080 --> 0:53:42.960
That was a good idea.

673
0:53:42.960 --> 0:53:47.880
Get the same hardware as you would use for an Arduino, get some micro piping cable board,

674
0:53:47.880 --> 0:53:51.680
load it on it, it's five minutes work and start doing things.

675
0:53:51.680 --> 0:53:57.320
Okay, well, if I did that demo, then those pixels would show questions.

676
0:53:57.320 --> 0:54:01.200
But I think we're at times up anyway.

677
0:54:01.200 --> 0:54:02.200
One minute.

678
0:54:02.200 --> 0:54:03.200
One last question.

679
0:54:03.200 --> 0:54:28.360
Yeah, where does it come from?

680
0:54:28.360 --> 0:54:36.160
Micro python is a book of three he asked, well, I did codes come the pin and the machine.

681
0:54:36.160 --> 0:54:41.640
Micro python is a common part and then a specific spot for specific chips and accessing a GPO

682
0:54:41.640 --> 0:54:45.120
pin of a chip is very different from chips.

683
0:54:45.120 --> 0:54:47.960
But it's a it's a that's a very shallow part.

684
0:54:47.960 --> 0:54:50.760
Once you have that you can build a lot of things on top of that.

685
0:54:50.760 --> 0:54:56.240
So the micro python distribution that I used here to compile, I must specify for which

686
0:54:56.240 --> 0:55:00.480
target chip I compile and then it grabs the correct code.

687
0:55:00.480 --> 0:55:02.320
Okay.

688
0:55:02.320 --> 0:55:06.320
Thank you.

689
0:55:06.320 --> 0:55:08.520
Thanks.

690
0:55:08.520 --> 0:55:17.040
I like to order.

691
0:55:17.040 --> 0:55:20.760
Will you be available outside for questions?

692
0:55:20.760 --> 0:55:22.320
So water will be around for questions.

693
0:55:22.320 --> 0:55:24.720
If you have questions on hesitate.

694
0:55:24.720 --> 0:55:28.680
I hope for the smart watches we still have hope.

