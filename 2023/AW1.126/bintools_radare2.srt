1
0:00:00.000 --> 0:00:10.760
So, in this presentation, I will try to show you the project, what's the current state,

2
0:00:10.760 --> 0:00:14.800
the features, most used plugins, and which are the main features.

3
0:00:14.800 --> 0:00:18.280
Okay, so first of all, a quick presentation.

4
0:00:18.280 --> 0:00:20.180
I'm Sergio Alvarez.

5
0:00:20.180 --> 0:00:21.920
Everybody knows me by my nickname, which is Pancake.

6
0:00:21.920 --> 0:00:23.320
I'm the author of her tool.

7
0:00:23.320 --> 0:00:29.720
I live in Barcelona and I work at NowSecure, which is a company from US, which we basically

8
0:00:29.720 --> 0:00:33.640
use different static and dynamic instrumentation tools for analyzing applications and find

9
0:00:33.640 --> 0:00:39.000
out privacy issues like identifying if the application is leaking data, stuff like that,

10
0:00:39.000 --> 0:00:45.040
and then generate some reports for the customers and developers to improve the quality of the

11
0:00:45.040 --> 0:00:46.040
applications.

12
0:00:46.040 --> 0:00:50.000
So, I work as a senior mobile security analyst.

13
0:00:50.000 --> 0:00:51.400
I like command line tools.

14
0:00:51.400 --> 0:00:54.440
I like command text interfaces.

15
0:00:54.440 --> 0:01:00.800
I brought many open source software, so my first goal is basically publishing all the

16
0:01:00.800 --> 0:01:05.120
stuff that I'm doing, so I like free software.

17
0:01:05.120 --> 0:01:11.960
I'm maintaining the whole R2 ecosystem nowadays, so I'm basically focusing on R2, but I also

18
0:01:11.960 --> 0:01:18.200
maintain R2Kedra, R2FREEDA, and many other plugins that work with R2.

19
0:01:18.200 --> 0:01:21.840
We have to reduce the font size here.

20
0:01:21.840 --> 0:01:26.680
This slide is a little bit...

21
0:01:26.680 --> 0:01:33.160
So it's a 17-year-old project, so I started this tool basically as a forensic tool.

22
0:01:33.160 --> 0:01:38.440
I wanted to recover some files that are lost in the hard drive.

23
0:01:38.440 --> 0:01:44.200
The thing is that I was working as forensic analyst, but I was not going to use the private

24
0:01:44.200 --> 0:01:47.960
software that was in the company, so I wrote a simple external editor that was able to

25
0:01:47.960 --> 0:01:54.600
find some patterns in the disk and then dump a one megabyte from there.

26
0:01:54.600 --> 0:01:59.000
After this, I was interested in participating in some CTF and different competitions for

27
0:01:59.000 --> 0:02:03.840
recent engineering, and I found out that there were so many tools that didn't really solve

28
0:02:03.840 --> 0:02:04.840
my problem.

29
0:02:04.840 --> 0:02:09.000
So starting by, for example, GDB, it was not possible to script it at the time and typing

30
0:02:09.000 --> 0:02:13.200
comments all the time was tedious, and I just wanted to automate many things.

31
0:02:13.200 --> 0:02:16.320
Also, there was extremely similar details, but it was not possible to extend them with

32
0:02:16.320 --> 0:02:19.760
plugins or anything like this.

33
0:02:19.760 --> 0:02:24.200
There was disassemblers, but object dump is cool, but it's not interactive, and the only

34
0:02:24.200 --> 0:02:27.320
interactive tool was private, which is IDA.

35
0:02:27.320 --> 0:02:33.880
Anyway, there was no real ecosystem for open source to solve any of these problems at once.

36
0:02:33.880 --> 0:02:38.000
There were so many little tools that were solving one problem, but not really being

37
0:02:38.000 --> 0:02:41.240
able to integrate with the rest of the ecosystem or other tools.

38
0:02:41.240 --> 0:02:45.560
So I decided to start picking ideas, picking tools, developing everything from scratch.

39
0:02:45.560 --> 0:02:50.040
That's why I did R2, because R2 is not depending on anything, so you can only depend on the

40
0:02:50.040 --> 0:02:54.000
plastics like Slipsy, and all the rest of the dependencies are written from scratch,

41
0:02:54.000 --> 0:03:00.200
like console handling, red line interface, all the socket interface, parsing libraries,

42
0:03:00.200 --> 0:03:02.960
disassembling things, etc.

43
0:03:02.960 --> 0:03:08.960
It's less sensitive than the LGPL3.

44
0:03:08.960 --> 0:03:12.800
The focus of the project is basically to read other tools and be useful for hackers.

45
0:03:12.800 --> 0:03:18.360
It's not going to be a general purpose solution for all the problems, because, for example,

46
0:03:18.360 --> 0:03:21.040
I don't plan to write disassemblers from scratch.

47
0:03:21.040 --> 0:03:25.520
I think that there are better projects for this, so I'm integrating them into R2.

48
0:03:25.520 --> 0:03:27.960
Same goes for Lipoke.

49
0:03:27.960 --> 0:03:31.840
It's one of the tools that is able to use R2.

50
0:03:31.840 --> 0:03:36.360
It's fully written in C. I mainly focus on portability, because I like the things that

51
0:03:36.360 --> 0:03:38.360
I write to run everywhere.

52
0:03:38.360 --> 0:03:45.600
So the only option nowadays is C. I mean, there are some rasp haters around that.

53
0:03:45.600 --> 0:03:51.200
The thing is that R2 can be compiled into WebAssembly, so you can run R2 inside your

54
0:03:51.200 --> 0:03:52.200
browser.

55
0:03:52.200 --> 0:03:56.840
You can also build it in a static-linked single binary, so you can drop it in a router.

56
0:03:56.840 --> 0:04:01.520
This year I plan to port it to UFE, so you can run R2 inside your bootloader, and then

57
0:04:01.520 --> 0:04:06.640
you can use it in the panoparenting system to use R2, non-file systems, and things like

58
0:04:06.640 --> 0:04:07.640
that.

59
0:04:07.640 --> 0:04:12.480
There are some really high constraints on all the code that R should be in R2.

60
0:04:12.480 --> 0:04:14.800
So there is a CI that is basically verifying everything.

61
0:04:14.800 --> 0:04:20.080
There is a 24-7 fuzzer that is running and finding bugs and fixing them.

62
0:04:20.080 --> 0:04:25.560
So my policy is I don't let bugs stay for more than one day.

63
0:04:25.560 --> 0:04:31.440
So the code cannot contain set jump or aborts or hazards or anything like this, because

64
0:04:31.440 --> 0:04:38.120
if you are doing something in hot, you don't want things to crash or to break.

65
0:04:38.120 --> 0:04:43.680
So the idea is that all the code that is running in R2 must be used from a library, so I don't

66
0:04:43.680 --> 0:04:44.960
want to use, like, double variables.

67
0:04:44.960 --> 0:04:49.400
I don't want to depend on something that if it's not parsing properly, I don't want to

68
0:04:49.400 --> 0:04:50.400
crash.

69
0:04:50.400 --> 0:04:56.000
If the malloc is failing, I want the program to still run.

70
0:04:56.000 --> 0:04:57.000
Things like this.

71
0:04:57.000 --> 0:05:01.800
So there are some concerns that I have when I write code for R2.

72
0:05:01.800 --> 0:05:07.040
It's developing a single repo, but it's separated in different models.

73
0:05:07.040 --> 0:05:11.760
So it's like a big project in one repository, but there is a bunch of libraries.

74
0:05:11.760 --> 0:05:17.320
Each library has a bunch of plugins, and many of these plugins are integrated or exposed

75
0:05:17.320 --> 0:05:20.240
interfaces for extending it with scripting languages.

76
0:05:20.240 --> 0:05:26.400
So at the end, it's basically like a different line of capabilities that can be extended

77
0:05:26.400 --> 0:05:29.120
pretty easily at different layers.

78
0:05:29.120 --> 0:05:30.400
So there is a command line interface.

79
0:05:30.400 --> 0:05:31.400
You have a prompt.

80
0:05:31.400 --> 0:05:32.400
You can type things.

81
0:05:32.400 --> 0:05:38.080
There is a visual mode, which is basically a list of commands that you execute every

82
0:05:38.080 --> 0:05:39.640
time that you press a key.

83
0:05:39.640 --> 0:05:43.200
And then you have the panels mode, which is like you can make splits.

84
0:05:43.200 --> 0:05:44.360
You can have different tabs.

85
0:05:44.360 --> 0:05:48.000
You can have different frames and so on.

86
0:05:48.000 --> 0:05:49.320
And then there is web interface.

87
0:05:49.320 --> 0:05:54.200
There is some people writing graphical interfaces for it, like Yaito, which is the Qt interface

88
0:05:54.200 --> 0:05:56.040
for it.

89
0:05:56.040 --> 0:06:01.280
For scripting, the easiest way for scripting R2 is R2Pipe, which is basically the simplest

90
0:06:01.280 --> 0:06:05.360
interface for interfacing with anything, which is basically you run something.

91
0:06:05.360 --> 0:06:10.320
You pass a string with a command, and then you get the output of the command as a string.

92
0:06:10.320 --> 0:06:13.160
But there is also bindings for the CAPI.

93
0:06:13.160 --> 0:06:17.600
There's automated bindings for Python, for Rust, et cetera.

94
0:06:17.600 --> 0:06:24.720
And there is also support for using these bindings from different scripting languages.

95
0:06:24.720 --> 0:06:29.240
So, what are the libraries implementing or exposing?

96
0:06:29.240 --> 0:06:33.420
So you have the IO library, which is basically abstracting the access to the IO.

97
0:06:33.420 --> 0:06:37.600
This basically defines how you access a file.

98
0:06:37.600 --> 0:06:38.600
Everything is abstract.

99
0:06:38.600 --> 0:06:42.440
This means that a file doesn't need to be anything physical.

100
0:06:42.440 --> 0:06:43.440
There is support.

101
0:06:43.440 --> 0:06:48.040
I mean, you cannot map a full file in memory and then work on it, because this is abstracted

102
0:06:48.040 --> 0:06:49.120
by the IO.

103
0:06:49.120 --> 0:06:56.520
So you can map a remote file running in a remote instance of R2, so you can run R2 as

104
0:06:56.520 --> 0:06:58.120
an instance.

105
0:06:58.120 --> 0:07:01.760
And then you can map, for example, like a ptrace backend, which is basically reading

106
0:07:01.760 --> 0:07:03.520
and writing memory from another process.

107
0:07:03.520 --> 0:07:06.480
And this is another IO interface.

108
0:07:06.480 --> 0:07:08.600
And all that stuff is just the file descriptor.

109
0:07:08.600 --> 0:07:14.160
So when you have one IO open, then you can map this file descriptor into separate maps.

110
0:07:14.160 --> 0:07:18.480
A map is basically a portion of the memory taken from the file descriptor.

111
0:07:18.480 --> 0:07:23.040
So you say that from this offset to this offset from this file descriptor, we'll be mapping

112
0:07:23.040 --> 0:07:27.080
this virtual address in the IO space of R2.

113
0:07:27.080 --> 0:07:29.040
And then there are IO banks.

114
0:07:29.040 --> 0:07:30.940
And the IO banks are basically a bunch of maps.

115
0:07:30.940 --> 0:07:36.020
So you can have separate memory spaces, like, for example, you want to manipulate a thread

116
0:07:36.020 --> 0:07:37.100
local stretch.

117
0:07:37.100 --> 0:07:42.400
You can have one IO space that only contains the contents of the thread local stretch.

118
0:07:42.400 --> 0:07:48.100
But then there is another bank that contains all the memory layout of the processing memory.

119
0:07:48.100 --> 0:07:50.440
And you can do that just by typing comments.

120
0:07:50.440 --> 0:07:52.440
You can do this also by using the API.

121
0:07:52.440 --> 0:07:57.600
But anyway, it's also possible to create, like, secret memory maps, memory layouts.

122
0:07:57.600 --> 0:08:04.520
For example, B850 is like an architecture that is used for auto mobile and things like

123
0:08:04.520 --> 0:08:05.520
that.

124
0:08:05.520 --> 0:08:09.280
And this architecture basically relies on having, like, some solid infrastructure.

125
0:08:09.280 --> 0:08:12.480
So you see there are some models that have, like, two CPUs executing the same code at

126
0:08:12.480 --> 0:08:13.480
the same time.

127
0:08:13.480 --> 0:08:20.280
And there is, like, a verification that two CPUs are doing exactly the same at runtime.

128
0:08:20.280 --> 0:08:22.840
And the memory of this CPU is basically circular.

129
0:08:22.840 --> 0:08:25.600
So there is some references that are going backward.

130
0:08:25.600 --> 0:08:30.280
So you have, like, one instruction at the zero address that is referencing something

131
0:08:30.280 --> 0:08:31.280
up.

132
0:08:31.280 --> 0:08:35.280
And this something up is basically going to the negative of other space.

133
0:08:35.280 --> 0:08:38.840
And this negative other space is not 52-bit in size.

134
0:08:38.840 --> 0:08:41.260
It's 26, for example.

135
0:08:41.260 --> 0:08:44.120
So you can basically configure these kind of things inside the root.

136
0:08:44.120 --> 0:08:49.420
And you can basically get emulation, all the flags, which are basically naming offsets,

137
0:08:49.420 --> 0:08:50.620
in all these things.

138
0:08:50.620 --> 0:08:53.440
And everything will be shaped properly.

139
0:08:53.440 --> 0:08:59.440
You can also define bit size at memory spaces, like, seven bit bytes and things like this.

140
0:08:59.440 --> 0:09:02.000
It's also able to parse binary formats.

141
0:09:02.000 --> 0:09:06.340
This works on any of the memory layouts that I said before.

142
0:09:06.340 --> 0:09:07.340
So you can parse from memory.

143
0:09:07.340 --> 0:09:08.980
You can parse from disk.

144
0:09:08.980 --> 0:09:17.240
There is support for the most known formats, from console binary, from headers, like, etc.

145
0:09:17.240 --> 0:09:21.440
But there is also for LP, Markov, etc.

146
0:09:21.440 --> 0:09:26.480
It's also parsing, DWARF, PDB, and other debug information.

147
0:09:26.480 --> 0:09:31.480
This is only for getting, like, others of memory, taking, like, a file name and so on.

148
0:09:31.480 --> 0:09:34.240
It's not really exporting all the structures and so on.

149
0:09:34.240 --> 0:09:38.600
But it's also possible to do that in the future or using external libraries.

150
0:09:38.600 --> 0:09:46.600
It's also parsing, like, class information from Swift, Objective-C, or C++ binaries.

151
0:09:46.600 --> 0:09:50.000
And all that stuff is integrated inside of those.

152
0:09:50.000 --> 0:09:56.280
So you can, it's subtracting all the information from all these final formats into single naming.

153
0:09:56.280 --> 0:10:01.560
So for example, imports in a P is not the same as, like, an import in ELF.

154
0:10:01.560 --> 0:10:02.600
But for, or two is the same.

155
0:10:02.600 --> 0:10:06.960
So when you're, when it leaves what the, a binary is importing from other libraries,

156
0:10:06.960 --> 0:10:08.760
you can just use give me the imports.

157
0:10:08.760 --> 0:10:13.600
You don't have to use, like, different APIs or different comments depending on the, on

158
0:10:13.600 --> 0:10:14.860
the file format.

159
0:10:14.860 --> 0:10:19.880
So it's unifying all the formats into a single naming.

160
0:10:19.880 --> 0:10:22.200
It's also for disassembling and assembling.

161
0:10:22.200 --> 0:10:24.800
It's using, like, one API.

162
0:10:24.800 --> 0:10:28.440
So there is, like, a library that exposes an interface for doing this.

163
0:10:28.440 --> 0:10:30.840
And this library exposes plugins.

164
0:10:30.840 --> 0:10:33.680
So there's, like, plugins that are used by this API.

165
0:10:33.680 --> 0:10:39.240
And then you can basically implement, like, new architectures, like, writing plugins for,

166
0:10:39.240 --> 0:10:41.080
for this library.

167
0:10:41.080 --> 0:10:44.400
But it's not, not only used for assembling and disassembling, which is basically text

168
0:10:44.400 --> 0:10:45.520
bytes.

169
0:10:45.520 --> 0:10:47.960
There is more low level detailed information.

170
0:10:47.960 --> 0:10:53.640
Like you can, for some architectures you can get, like, a structure metadata, like, which

171
0:10:53.640 --> 0:10:57.740
is the first operand, which is the size of the second argument, things like this.

172
0:10:57.740 --> 0:10:59.040
But it's also exposing a seal.

173
0:10:59.040 --> 0:11:04.400
A seal is, like, a very simple text interface for explaining what an instruction is doing

174
0:11:04.400 --> 0:11:05.400
at low level.

175
0:11:05.400 --> 0:11:07.560
So it's kind of, it's very similar to fourth.

176
0:11:07.560 --> 0:11:09.440
Like a stack-based machine.

177
0:11:09.440 --> 0:11:11.560
And it's basically one statement separated by comma.

178
0:11:11.560 --> 0:11:18.680
So you have, like, o, comma, a x, comma, equals means that it will be pushing the number,

179
0:11:18.680 --> 0:11:22.720
then pushing the resistor name, and then pushing the operation, which is the equal, and then

180
0:11:22.720 --> 0:11:28.300
popping up from the operation to execute the statement.

181
0:11:28.300 --> 0:11:34.520
The reason for that is because there are so many ways to extend or to define an architecture,

182
0:11:34.520 --> 0:11:39.400
and there are some really fucked up things that can be done in so many architectures.

183
0:11:39.400 --> 0:11:44.880
So I was not going to define, like, extensible structures or doing some really complex things

184
0:11:44.880 --> 0:11:49.560
because at the end I was always finding, like, something that was not compatible with another

185
0:11:49.560 --> 0:11:50.560
architecture.

186
0:11:50.560 --> 0:11:54.800
And I end up, like, saying, okay, I just can't define, like, a comma-separated string that

187
0:11:54.800 --> 0:11:59.120
it's just allocated in a single memory chunk, and I can just split it by comma and then

188
0:11:59.120 --> 0:12:00.840
emulate that.

189
0:12:00.840 --> 0:12:05.800
So there is a bunch of tools or libraries that are using a seal to extract this information

190
0:12:05.800 --> 0:12:10.600
and then use that for emulation, use that for extracting information from a specific

191
0:12:10.600 --> 0:12:16.160
instruction, or even for the compiling.

192
0:12:16.160 --> 0:12:20.160
It's very portable, so it works on, supports debugging also.

193
0:12:20.160 --> 0:12:23.080
So you can do local and remote debugging.

194
0:12:23.080 --> 0:12:29.960
This means that you can run R2 as a local debugger in your Linux Mac or iOS device,

195
0:12:29.960 --> 0:12:34.800
but you can also attach to a remote GDB or one DBG, etc.

196
0:12:34.800 --> 0:12:37.360
It's a functionality for searching for different patterns.

197
0:12:37.360 --> 0:12:39.920
So you can search for strings, access the minimal values.

198
0:12:39.920 --> 0:12:44.760
You can also find, like, find me something that is repeated multiple times, and then

199
0:12:44.760 --> 0:12:48.120
it will be finding, like, if there is any pattern that is repeated many times and give

200
0:12:48.120 --> 0:12:50.480
you the offset of these things.

201
0:12:50.480 --> 0:12:56.200
It's also able to generate function signatures, so by taking all the whole analysis for the

202
0:12:56.200 --> 0:12:59.200
program, it will identify all the functions, basic blocks, etc.

203
0:12:59.200 --> 0:13:02.780
And then you can generate, like, metadata for each of these functions.

204
0:13:02.780 --> 0:13:07.160
And this metadata can be imported again to search for this information in another binary.

205
0:13:07.160 --> 0:13:12.240
So you have, like, one binary with dwarf information or debug symbols, then you can re-import this

206
0:13:12.240 --> 0:13:16.760
into a binary that is a strip it, and then you can basically identify these data structures

207
0:13:16.760 --> 0:13:21.640
or functions in another binary that is not containing this data.

208
0:13:21.640 --> 0:13:26.400
It's also possible to give code level, but you can also give data.

209
0:13:26.400 --> 0:13:31.880
You can find, like, using delta diffing, so you have, like, two binaries that contain

210
0:13:31.880 --> 0:13:37.000
the same data, but in different offsets, it will identify which offset is the ship at

211
0:13:37.000 --> 0:13:39.800
the end of the binary and which is the main difference from that.

212
0:13:39.800 --> 0:13:44.360
It's not byte per byte level instruction checking.

213
0:13:44.360 --> 0:13:48.560
You can also give basic blocks, like, you can take the two control flow graphs and then

214
0:13:48.560 --> 0:13:53.080
identifying which basic block is added, which is removed, or if there is, like, a percentage

215
0:13:53.080 --> 0:13:57.600
of difference, so you can use that for bind diffing.

216
0:13:57.600 --> 0:14:02.200
And you can also find differences, like, A, B, D, for getting, like, there is new symbols

217
0:14:02.200 --> 0:14:06.280
removed or things like that.

218
0:14:06.280 --> 0:14:12.800
And I also took code from GRAP group, which is basically the bootloader, and I used that

219
0:14:12.800 --> 0:14:15.880
for parsing file systems.

220
0:14:15.880 --> 0:14:20.840
Things at GRAP is doing a lot of things for, like, assuming that the file system is correct,

221
0:14:20.840 --> 0:14:23.200
and R2 will never assume that anything is correct.

222
0:14:23.200 --> 0:14:27.680
So if there is, like, a corrupted file system, I want to be able to mount it.

223
0:14:27.680 --> 0:14:30.800
So R2 is using this code basically for mounting file systems.

224
0:14:30.800 --> 0:14:35.880
You can have, like, a fake or, like, a virtual file system interface in Sartre 2, and you

225
0:14:35.880 --> 0:14:38.480
can use that for mounting local or remote file systems.

226
0:14:38.480 --> 0:14:39.480
You can use R2 free.

227
0:14:39.480 --> 0:14:42.760
I will show that later, but I don't have time for showing it, but anyway, I will...

228
0:14:42.760 --> 0:14:44.760
You can use Free.

229
0:14:44.760 --> 0:14:49.000
Which is, like, a tool for injecting code in remote applications, and you can use TCP

230
0:14:49.000 --> 0:14:51.600
or USB for communicating with that.

231
0:14:51.600 --> 0:14:52.600
And then Free.

232
0:14:52.600 --> 0:14:55.120
That can expose, like, an interface for accessing files remotely.

233
0:14:55.120 --> 0:14:59.920
So you can mount zips in a remote file system, extract the zip contents from one binary,

234
0:14:59.920 --> 0:15:06.320
parse the binary in local, mount that memory layout in local, and then whatever you would

235
0:15:06.320 --> 0:15:08.520
like to do with these things.

236
0:15:08.520 --> 0:15:14.400
Okay, obviously there is, like, a huge amount of things that can be done with that, so there

237
0:15:14.400 --> 0:15:16.000
is a need for a package manager.

238
0:15:16.000 --> 0:15:17.080
So I wrote R2-PM.

239
0:15:17.080 --> 0:15:21.560
It was like a 200-line shell script, so it's not really a big thing.

240
0:15:21.560 --> 0:15:25.480
But one year ago, they started to write it in C, so this way you can basically run the

241
0:15:25.480 --> 0:15:28.840
package manager anywhere, even in Windows.

242
0:15:28.840 --> 0:15:33.760
So it doesn't depend on anything that is not the same R2.

243
0:15:33.760 --> 0:15:38.480
So this package manager is basically pulling a zip repository, and this repository can

244
0:15:38.480 --> 0:15:39.840
contain, like, scripts.

245
0:15:39.840 --> 0:15:44.160
And this script is basically defining a very simple way for installing and uninstalling.

246
0:15:44.160 --> 0:15:48.560
So it defines instructions for compiling and installing the plugin.

247
0:15:48.560 --> 0:15:54.200
And, yeah, there is, like, basically a amount of tools that are installed in your home,

248
0:15:54.200 --> 0:15:58.120
and also plugins that are loaded by R2.

249
0:15:58.120 --> 0:16:03.920
So the most common or most used plugins for R2 are, for example, about the compilers.

250
0:16:03.920 --> 0:16:04.920
You have, like, R2-DEG.

251
0:16:04.920 --> 0:16:07.280
You have R2-GIDRA, R2-RED-DEG.

252
0:16:07.280 --> 0:16:11.040
So if you know GIDRA, for example, they provide, like, a compiler.

253
0:16:11.040 --> 0:16:16.320
There is, like, a part of the compiler which is written in C++, not in Java.

254
0:16:16.320 --> 0:16:21.800
And this code can be reused for writing at a compiler, so depending on the whole Java

255
0:16:21.800 --> 0:16:22.800
thing.

256
0:16:22.800 --> 0:16:29.560
Then there is RED-DEG, which is the compiler based on LLVM and a bunch of parallel scripts

257
0:16:29.560 --> 0:16:31.200
that mess the thing.

258
0:16:31.200 --> 0:16:36.760
And they basically use the compiler toolchain to do the backwards steps to get from the

259
0:16:36.760 --> 0:16:42.080
binary disassembly to get, like, C-like code for the compiling.

260
0:16:42.080 --> 0:16:44.120
Then you can also use the afra.

261
0:16:44.120 --> 0:16:46.920
There is support for signatures for IDA.

262
0:16:46.920 --> 0:16:48.800
There is, like, native signatures.

263
0:16:48.800 --> 0:16:52.720
There is, like, some repository for people writing this.

264
0:16:52.720 --> 0:16:54.220
And then there is support for to Frida.

265
0:16:54.220 --> 0:16:58.320
If you know Frida, who knows Frida?

266
0:16:58.320 --> 0:16:59.720
Raise your hand.

267
0:16:59.720 --> 0:17:00.720
Okay, half of the room.

268
0:17:00.720 --> 0:17:02.240
It's not the compiler, right?

269
0:17:02.240 --> 0:17:03.240
No.

270
0:17:03.240 --> 0:17:08.720
Frida is a tool that basically injects code in a remote process.

271
0:17:08.720 --> 0:17:11.960
And then there is an agent that is running in a separate thread inside the process.

272
0:17:11.960 --> 0:17:14.760
So you can basically instrument the process at runtime.

273
0:17:14.760 --> 0:17:19.900
And you can basically inject JavaScript code or C or assembly inside the remote process

274
0:17:19.900 --> 0:17:21.760
and instrument that.

275
0:17:21.760 --> 0:17:22.760
You can use that for profiling.

276
0:17:22.760 --> 0:17:24.480
You can use that for modifying behavior.

277
0:17:24.480 --> 0:17:29.080
You can use that for tracing APIs, identifying when the specific function is called with

278
0:17:29.080 --> 0:17:34.640
some arguments and then execute some code inside the remote process.

279
0:17:34.640 --> 0:17:36.640
Most people use JavaScript for doing this.

280
0:17:36.640 --> 0:17:41.720
But you can also use C or with libgam or whatever.

281
0:17:41.720 --> 0:17:46.560
We basically use that for documentation on iOS and Android applications.

282
0:17:46.560 --> 0:17:50.520
So you can use R2 Frida to have, like, an R2 interface for interfacing with Frida, which

283
0:17:50.520 --> 0:17:53.640
means that you don't need to type long JavaScript one-liners.

284
0:17:53.640 --> 0:17:59.280
You can also use R2 comments, like, which are pretty mnemonic and easy to type if you

285
0:17:59.280 --> 0:18:00.280
know them.

286
0:18:00.280 --> 0:18:09.560
And there is also support for external assemblers, like NuGAS or the unicorn library, which is

287
0:18:09.560 --> 0:18:12.560
kind of like a stripping code from LLVM.

288
0:18:12.560 --> 0:18:18.760
And there is also problem solvers, like Radios, as you saw for anger, that are plugins that

289
0:18:18.760 --> 0:18:20.280
basically you define some constraints.

290
0:18:20.280 --> 0:18:23.840
You have a function and you define, OK, I want to know which are the arguments that

291
0:18:23.840 --> 0:18:27.000
I need to pass to this function to reach these specific others.

292
0:18:27.000 --> 0:18:32.840
Like you want to know, for example, if it's possible to create a buffer overflow in a

293
0:18:32.840 --> 0:18:35.520
specific variable in a local stack.

294
0:18:35.520 --> 0:18:38.600
Or you want to define which, or you want to know which is the password that matches a

295
0:18:38.600 --> 0:18:40.120
specific crypto algorithm.

296
0:18:40.120 --> 0:18:45.320
So you can use that to define, OK, I want to know which is the block of bytes of one

297
0:18:45.320 --> 0:18:48.800
specific length that generate this hash, for example.

298
0:18:48.800 --> 0:18:49.800
Things like that.

299
0:18:49.800 --> 0:18:51.480
And these won't be brute forcing.

300
0:18:51.480 --> 0:18:54.480
It's like using problem solvers like Z3 and so on.

301
0:18:54.480 --> 0:18:59.440
So there is like different plugins that are integrated in R2 to use from R2 comments.

302
0:18:59.440 --> 0:19:03.080
And then you can define the preconditions, post-conditions and the boundaries of the

303
0:19:03.080 --> 0:19:04.080
function to emulate.

304
0:19:04.080 --> 0:19:07.320
Then there is also support for parsing data structure.

305
0:19:07.320 --> 0:19:09.680
There is support for Kaitai, there is support for Polk.

306
0:19:09.680 --> 0:19:14.840
This was integrated last week because I didn't know it was possible to have like a library

307
0:19:14.840 --> 0:19:15.840
of Polk.

308
0:19:15.840 --> 0:19:18.760
I was seeing it as a program, not a library.

309
0:19:18.760 --> 0:19:21.180
So it's integrated, but it's not fully integrated.

310
0:19:21.180 --> 0:19:28.520
So I plan to continue integrating it to use like for disassembling, for parsing, headers,

311
0:19:28.520 --> 0:19:30.420
etc.

312
0:19:30.420 --> 0:19:32.760
So what can you do with R2Frieda?

313
0:19:32.760 --> 0:19:38.240
R2Frieda is basically, as I said before, is front-end for R2Frieda.

314
0:19:38.240 --> 0:19:40.700
You can run scripts in your host, in your agent site.

315
0:19:40.700 --> 0:19:46.440
So you can write a JavaScript program that runs in R2, but it can be also loaded in the

316
0:19:46.440 --> 0:19:47.440
remote site.

317
0:19:47.440 --> 0:19:49.400
And you can load and unload plugins.

318
0:19:49.400 --> 0:19:53.960
So you can basically extend the R2Frieda comment set with JavaScript plugins that are loaded

319
0:19:53.960 --> 0:19:56.040
and unloaded at runtime.

320
0:19:56.040 --> 0:19:57.320
It's also scriptable with R2Pipe.

321
0:19:57.320 --> 0:20:03.120
So you can write a program in Python, JavaScript or the language you like that interacts and

322
0:20:03.120 --> 0:20:09.140
automates comments and actions in the host site or the remote site of the R2Frieda site.

323
0:20:09.140 --> 0:20:14.000
So you can spawn applications, you can attach to local remote processes, you can use different

324
0:20:14.000 --> 0:20:18.080
protocol or communication channels like USB, TCP, etc.

325
0:20:18.080 --> 0:20:21.480
And you can promote the file systems.

326
0:20:21.480 --> 0:20:27.840
You can use that for interfacing with tracing, APIs, profiling, and also supports extracting

327
0:20:27.840 --> 0:20:34.840
metadata from Java, Dalvik, Objective-C, and Swift support will be ready by the end of

328
0:20:34.840 --> 0:20:39.000
this year because right now it's supported but it's kind of unstable and the API is changing.

329
0:20:39.000 --> 0:20:41.680
So yeah, certainly it will get better.

330
0:20:41.680 --> 0:20:45.400
Okay, so let's talk about R2Pipe.

331
0:20:45.400 --> 0:20:53.200
Since the first release that I did this year was the 580, I plan to keep ABI stable.

332
0:20:53.200 --> 0:20:54.940
Actually I use ABI in the CI.

333
0:20:54.940 --> 0:20:59.480
So every commit or port records that people send to the project, they verify that it's

334
0:20:59.480 --> 0:21:00.480
ABI stable.

335
0:21:00.480 --> 0:21:02.760
This means that I'm not breaking the ABI.

336
0:21:02.760 --> 0:21:08.280
You can rebuild or update R2 without recompiling all the plugins or the tools that are using

337
0:21:08.280 --> 0:21:10.040
R2Libraries.

338
0:21:10.040 --> 0:21:11.040
This is pretty cool.

339
0:21:11.040 --> 0:21:16.320
And the thing is that I was having some kind of like a contract with myself that I don't

340
0:21:16.320 --> 0:21:20.480
break ABI but this is something that you end up like doing in Ruby when code by hand.

341
0:21:20.480 --> 0:21:25.920
I'm having like a tool that can automate this is great.

342
0:21:25.920 --> 0:21:31.520
But I wanted to have like a runtime, something that can you run from R2 like interpreter

343
0:21:31.520 --> 0:21:38.560
that is not a custom language or like an external library that needs to be integrated and it's

344
0:21:38.560 --> 0:21:39.560
really big.

345
0:21:39.560 --> 0:21:43.680
So I was experimenting for some time with different languages and I ended up like realizing

346
0:21:43.680 --> 0:21:45.600
that QuickJS is the only option.

347
0:21:45.600 --> 0:21:47.640
So I mean Lua is using SetJump.

348
0:21:47.640 --> 0:21:52.520
So you cannot compile with Lua as a WebAssembly plugin.

349
0:21:52.520 --> 0:21:55.560
Also if you want to use SetJump with threads is kind of a mess.

350
0:21:55.560 --> 0:22:00.120
So I end up like picking QuickJS which is the same JavaScript runtime that Frida is

351
0:22:00.120 --> 0:22:01.120
using.

352
0:22:01.120 --> 0:22:05.880
I pick the code from there and as long as every commit in R2 is verifying with fuzzers,

353
0:22:05.880 --> 0:22:08.960
other sanitizers and so on, I end up like finding a lot of issues there.

354
0:22:08.960 --> 0:22:11.240
I send like 12 patches to the project.

355
0:22:11.240 --> 0:22:16.280
So it's basically the fork that is used by Frida.

356
0:22:16.280 --> 0:22:19.280
So all these patches are upstream now.

357
0:22:19.280 --> 0:22:25.040
And the idea is basically that you can use TypeScript and JavaScript from R2 and you can

358
0:22:25.040 --> 0:22:26.120
write code like this.

359
0:22:26.120 --> 0:22:30.480
So you basically have like an R2 pipe interface but it's running inside R2.

360
0:22:30.480 --> 0:22:31.760
You can use this from WebAssembly.

361
0:22:31.760 --> 0:22:38.760
So you can basically open RadaR2.online and then you have like a terminal that you can

362
0:22:38.760 --> 0:22:39.760
run R2.

363
0:22:39.760 --> 0:22:45.600
You can drop a binary inside the browser and use JavaScript to automate a bunch of actions

364
0:22:45.600 --> 0:22:48.400
for analyzing the binary.

365
0:22:48.400 --> 0:22:51.480
Basically as I said before, you have like a command that you run and then you get the

366
0:22:51.480 --> 0:22:55.560
output of the command in exchange.

367
0:22:55.560 --> 0:23:01.440
As long as most of the commands in R2 spit out JSON, you can basically use the CMDJ which

368
0:23:01.440 --> 0:23:05.760
basically get the output of the command and pass the output as JSON.

369
0:23:05.760 --> 0:23:10.520
And then you get like a structured data that you can use for extracting it or processing

370
0:23:10.520 --> 0:23:12.160
it with the tools you like.

371
0:23:12.160 --> 0:23:16.760
I think that JavaScript and JSON are quite standard and useful nowadays.

372
0:23:16.760 --> 0:23:19.480
So you don't need to learn new things.

373
0:23:19.480 --> 0:23:22.040
But there is support for so many other languages.

374
0:23:22.040 --> 0:23:27.640
Like I said here, there is Python support, Rust, Node.js, Rabi, Guile, Nivlisp, Haskell,

375
0:23:27.640 --> 0:23:29.280
Delang, Swift, etc.

376
0:23:29.280 --> 0:23:34.520
So it's very easy to write this simple interface and you can use basically different interfaces

377
0:23:34.520 --> 0:23:35.920
to communicate with R2.

378
0:23:35.920 --> 0:23:41.680
So you can use like a fork and a pipe or you can also use like a TCP socket or an HTTP

379
0:23:41.680 --> 0:23:44.400
interface, WebSockets, whatever you like.

380
0:23:44.400 --> 0:23:48.840
And for the TypeScript thing, it's pretty cool because I'm writing like a types description

381
0:23:48.840 --> 0:23:55.480
that basically defines the APIs of R2 and also the structures that the commands are

382
0:23:55.480 --> 0:23:57.520
returning in JSON format.

383
0:23:57.520 --> 0:24:02.320
This means that you can get the JSON of a command and then you can generate a schema

384
0:24:02.320 --> 0:24:03.320
out of that.

385
0:24:03.320 --> 0:24:05.120
And this schema can be used like a types.

386
0:24:05.120 --> 0:24:14.080
So if you use TypeScript, Lisp server, like the language service that autocompletes the

387
0:24:14.080 --> 0:24:19.520
code, you can basically use that for using tap to autocomplete all the code.

388
0:24:19.520 --> 0:24:24.680
So for example, you can analyze function, you press p.i and then you'll get all the

389
0:24:24.680 --> 0:24:25.720
function name.

390
0:24:25.720 --> 0:24:27.120
You can get all the basic blocks.

391
0:24:27.120 --> 0:24:30.760
For each basic block, you can use tap to get all the fields of this basic block like the

392
0:24:30.760 --> 0:24:35.720
address, the amount of instructions, et cetera.

393
0:24:35.720 --> 0:24:39.000
And for each instruction, you can get the mnemonics, et cetera.

394
0:24:39.000 --> 0:24:40.000
And everything runs.

395
0:24:40.000 --> 0:24:45.680
I mean, you can just like Visual Studio Code or Nailbeam or whatever you like, or MX, I

396
0:24:45.680 --> 0:24:51.960
guess that's also SuperSellows P. And use that for automating and scripting using these

397
0:24:51.960 --> 0:24:53.760
languages.

398
0:24:53.760 --> 0:24:59.000
So R2 is able to visualize that and code in so many different ways.

399
0:24:59.000 --> 0:25:09.260
So all this, I mean, I can press e so you can get the source code of the slides.

400
0:25:09.260 --> 0:25:13.140
So you can see here, this is the content of the slide.

401
0:25:13.140 --> 0:25:18.760
So it's running a bunch of comments in R2 and the output is generated inside the visual

402
0:25:18.760 --> 0:25:22.240
mode that you saw before.

403
0:25:22.240 --> 0:25:23.600
So you can generate graph.

404
0:25:23.600 --> 0:25:28.920
You can, from the control flow graph, you can also generate like a vertical or horizontal

405
0:25:28.920 --> 0:25:31.080
line graph like frame things.

406
0:25:31.080 --> 0:25:37.000
You can disassemble, you can render pictures in bit formats, in RGB format.

407
0:25:37.000 --> 0:25:43.040
You can also generate like a different, like comparing data and identifying which bytes

408
0:25:43.040 --> 0:25:44.640
are changing by changing colors.

409
0:25:44.640 --> 0:25:49.420
You can define like a color for a specific bunch of addresses.

410
0:25:49.420 --> 0:25:54.100
So when you are disassembling, you can mark some regions like hot code or this is like

411
0:25:54.100 --> 0:25:55.960
a portion of code that you're interested in.

412
0:25:55.960 --> 0:25:59.440
And then you get highlights for one specific register.

413
0:25:59.440 --> 0:26:04.080
So you want to highlight SP and then you get SP highlighted in the whole disassembly, things

414
0:26:04.080 --> 0:26:05.840
like that.

415
0:26:05.840 --> 0:26:13.160
But also there is also UIs, but I'm like common line guy, so I prefer to use the shell.

416
0:26:13.160 --> 0:26:18.000
But there is like a Qt interface, but also I started to write like a new graphic interface

417
0:26:18.000 --> 0:26:25.620
using WX widgets because I mean, Qt is great because it's big and it's also so many things.

418
0:26:25.620 --> 0:26:28.920
But I don't like the license, it's so huge.

419
0:26:28.920 --> 0:26:34.960
It's getting like a really huge and it's not handy for the kind of things that I like to

420
0:26:34.960 --> 0:26:35.960
do.

421
0:26:35.960 --> 0:26:39.540
So when I'm developing, I like to have fun and I don't want to be suffering because of

422
0:26:39.540 --> 0:26:43.360
license or companies that are developing things in the background.

423
0:26:43.360 --> 0:26:54.560
So I wrote so many UIs for it too, like in GTK, in using Imble, also other HTML, CSS for

424
0:26:54.560 --> 0:26:58.600
the web UI because I have like a web server inside.

425
0:26:58.600 --> 0:27:04.320
So at the end I want to have fun and I don't want to spend time like learning new APIs

426
0:27:04.320 --> 0:27:05.320
and so on.

427
0:27:05.320 --> 0:27:12.640
So I'm writing like a WG widgets API, a user interface and the idea for this is to not

428
0:27:12.640 --> 0:27:17.680
follow the same flow of interaction flows that people use.

429
0:27:17.680 --> 0:27:21.600
So I want to have like a common line interface but integrated in the UI.

430
0:27:21.600 --> 0:27:25.560
So I want to be able to have multiple windows using multiple sessions or drag and drop things

431
0:27:25.560 --> 0:27:30.760
from one window to another one instead of having like a big thing with panels and the

432
0:27:30.760 --> 0:27:33.280
common interaction ways.

433
0:27:33.280 --> 0:27:35.000
So what's the future?

434
0:27:35.000 --> 0:27:38.240
So there is short and long term plans.

435
0:27:38.240 --> 0:27:44.680
It all depends on my time because most of the things I maintain it or done by me.

436
0:27:44.680 --> 0:27:50.360
There is a lot of contributors but they come and leave so there is like not really a core

437
0:27:50.360 --> 0:27:57.040
developer team or there is no really big plans for having like big organizations and so on.

438
0:27:57.040 --> 0:28:01.960
But the things that I want to be able to keep pushing like stable releases, I want to have

439
0:28:01.960 --> 0:28:07.160
like a stability mainly because there is some people or companies or users that are writing

440
0:28:07.160 --> 0:28:10.800
tools on top of this and I don't want them to write things every time that I make a release

441
0:28:10.800 --> 0:28:13.120
or break without updating this.

442
0:28:13.120 --> 0:28:18.720
I want to have like a create, so which is a rushed API that you can basically specify

443
0:28:18.720 --> 0:28:23.360
the version of Erto that you want to ship and then this create will build Erto inside

444
0:28:23.360 --> 0:28:28.280
with a specific version and then you can use your Erto esthetic link inside your program.

445
0:28:28.280 --> 0:28:34.240
So you don't need to depend on system installations or depend on other things like that.

446
0:28:34.240 --> 0:28:38.720
I want to basically reduce the tech depth because as long as I'm alone doing most of

447
0:28:38.720 --> 0:28:42.880
the things I don't want to depend on humans so I want to reduce the amount of things that

448
0:28:42.880 --> 0:28:44.320
are done manually.

449
0:28:44.320 --> 0:28:50.560
So for example a friend of me wrote the Flatpak integration so there is like a bot that basically

450
0:28:50.560 --> 0:28:55.720
detects when there is like a new release in Erto or in Yaito and when this happens it's

451
0:28:55.720 --> 0:29:00.040
basically pulling the code from all the projects, generating a change log generating a new build

452
0:29:00.040 --> 0:29:03.360
and publishing that automatically.

453
0:29:03.360 --> 0:29:10.600
And you basically get like a graphical interface for Linux and Windows for free.

454
0:29:10.600 --> 0:29:17.360
I want to improve the code coverage and all the testing for fuzzing and yeah, there is

455
0:29:17.360 --> 0:29:23.840
like a lot of things that you can see and if you have questions please let me know after

456
0:29:23.840 --> 0:29:24.840
the talk with some viewers.

457
0:29:24.840 --> 0:29:26.840
I guess that everybody is hungry so.

458
0:29:26.840 --> 0:29:54.340
All right, thank you guys Cam from phased

