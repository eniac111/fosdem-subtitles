WEBVTT

00:00.000 --> 00:10.360
All right. So it's two minutes early, but I have

00:10.360 --> 00:12.800
a tendency to speak and not stop,

00:12.800 --> 00:15.440
so we better get started here.

00:16.440 --> 00:21.920
So I am so tired of doing introductory talks to poke.

00:21.920 --> 00:25.280
So I have decided that this is the last one I'm going to do.

00:25.280 --> 00:27.620
So, but let's see.

00:27.620 --> 00:31.240
Is anyone here familiar with this program somehow?

00:31.240 --> 00:35.320
Yes? Okay. So yeah,

00:35.320 --> 00:37.440
we need to do an introductory talk.

00:37.440 --> 00:40.440
So, GNU poke is

00:40.440 --> 00:43.400
an extensible editor for a structure binary data.

00:43.400 --> 00:46.220
So it is a program that you can actually expand.

00:46.220 --> 00:48.800
We will see how, and you can expand it

00:48.800 --> 00:51.400
actually quite to a very high degree.

00:51.400 --> 00:56.640
And we will see that it's a program that is used to poke,

00:56.640 --> 01:03.120
or to mess, to edit data which is encoded in binary.

01:03.120 --> 01:05.560
We will see what this thing about binary.

01:05.560 --> 01:08.040
Everything is binary at the end of the day.

01:08.040 --> 01:11.440
So first, I'm going to do a very small introduction,

01:11.440 --> 01:13.040
an abstract one.

01:13.040 --> 01:15.720
I mean, why would you use such a program?

01:15.720 --> 01:19.760
Then we will see how we are actually integrating poke in

01:19.760 --> 01:24.080
other programs via a shared object, a library.

01:24.080 --> 01:26.440
Then I will basically talk a little bit about

01:26.440 --> 01:28.760
the project itself, the current status.

01:28.760 --> 01:32.800
We just made a major release that we are very happy about it.

01:32.800 --> 01:36.360
And we are very busy because the project is getting a lot of,

01:36.360 --> 01:38.000
we have a lot of things to do.

01:38.000 --> 01:39.740
It's getting very fun actually.

01:39.740 --> 01:43.080
And then finally, an invitation to you to actually join us

01:43.080 --> 01:46.480
in hacking this program.

01:46.480 --> 01:50.320
So let's start with a very small introduction.

01:50.320 --> 01:55.800
I mean, when it comes to edit binary data,

01:55.800 --> 01:57.040
well, what do you use?

01:57.040 --> 01:58.600
You use a binary editor, right?

02:02.760 --> 02:07.320
If you go around and then you look around in internet about

02:07.320 --> 02:12.400
binary editors, you have the simplest kind, what I call

02:12.400 --> 02:18.520
simple binary editors, which is your garden variety programs

02:18.520 --> 02:21.280
which show you a byte dump.

02:21.280 --> 02:24.280
And then a lot of them also show you the ASCII

02:24.280 --> 02:26.440
representation of the same bytes.

02:26.440 --> 02:28.120
What do you see in the screen?

02:28.120 --> 02:30.080
How many of those programs are around?

02:30.080 --> 02:31.240
Quite a lot of them.

02:31.240 --> 02:32.320
And they are nice.

02:32.320 --> 02:33.040
I mean, they are nice.

02:33.040 --> 02:34.560
They are useful.

02:34.560 --> 02:35.600
They are small.

02:35.600 --> 02:37.120
They are very easy to use.

02:37.120 --> 02:40.600
There is nothing mysterious about them.

02:40.600 --> 02:42.400
They are interactive usually.

02:42.400 --> 02:44.800
The ones that allow you to actually change the value of

02:44.800 --> 02:48.280
those bytes in the files, you just go to the byte you want

02:48.280 --> 02:53.120
to change, you put in the new value for the bytes, ta-da.

02:53.120 --> 02:56.040
If you want to change based on some string, you go to the

02:56.040 --> 02:57.880
ASCII column there.

02:57.880 --> 02:59.840
You go to the position you want to edit.

02:59.840 --> 03:00.800
You change it.

03:00.800 --> 03:03.000
But the file gets updated.

03:03.000 --> 03:03.400
Very nice.

03:03.400 --> 03:04.520
They are interactive.

03:04.520 --> 03:06.640
They support immediate editing.

03:06.640 --> 03:09.880
You go, you change here, and it immediately gets reflected

03:09.880 --> 03:13.840
in the file that you are editing, for example.

03:13.840 --> 03:15.320
What do they let you edit?

03:15.320 --> 03:16.920
In terms of what?

03:16.920 --> 03:17.880
Well, it depends.

03:17.880 --> 03:20.560
But those simple binary editors, they let you operate

03:20.560 --> 03:25.520
in terms of bytes, in terms of strings, like we just

03:25.520 --> 03:29.480
mentioned, and sometimes this is not often, but sometimes

03:29.480 --> 03:30.960
in terms of bits as well.

03:30.960 --> 03:35.080
Some of those basic binary editors, they support down to

03:35.080 --> 03:36.320
the bit level too.

03:39.040 --> 03:41.040
And that's it.

03:41.040 --> 03:42.520
That's the thing.

03:42.520 --> 03:45.520
You can edit in terms of those entities, of those

03:45.520 --> 03:49.800
concepts, bytes, bits, strings sometimes, sometimes numbers.

03:49.800 --> 03:52.280
Then the editor is not so simple anymore.

03:52.280 --> 03:55.920
But it's always a fixed list of abstractions that you can

03:55.920 --> 04:01.320
edit, you manipulate your data using those abstractions.

04:01.320 --> 04:04.360
Then they give you, generally, byte dumps, the ASCII views.

04:04.360 --> 04:07.080
And they have fixed capabilities, depending on

04:07.080 --> 04:10.000
how nice the particular editor is.

04:10.000 --> 04:12.000
Some of them allow you to search for patterns.

04:12.000 --> 04:17.680
Some others to search and replace, to make byte divs.

04:17.680 --> 04:19.120
That kind of thing.

04:19.120 --> 04:22.920
Measure entropy, to search for frame buffers.

04:22.920 --> 04:23.960
That kind of thing.

04:23.960 --> 04:25.200
Simple binary editors.

04:25.200 --> 04:26.440
They are useful.

04:29.880 --> 04:32.760
But then sometimes you have to edit, or you want to edit,

04:32.760 --> 04:36.040
your data in terms not just of bytes or bits, but in terms

04:36.040 --> 04:42.080
of more abstract entities, like MP3 headers, or else

04:42.080 --> 04:46.480
relocations, or lists of numbers, or whatever.

04:46.480 --> 04:51.040
And then for that, you have traditionally specialized

04:51.040 --> 04:54.640
binary editors, which are editors, like the two that you

04:54.640 --> 05:00.440
can see here, that know about some particular format.

05:00.440 --> 05:02.120
Like some of them, the one on the left

05:02.120 --> 05:03.960
knows about the L format.

05:03.960 --> 05:06.760
So you can see a tree view, which is quite nice, you know,

05:06.760 --> 05:09.680
with the different sections in the Ls.

05:09.680 --> 05:13.920
And the one on the right, which is small, but it's nice,

05:13.920 --> 05:17.360
is a very small MP3 editor to edit MP3 files.

05:17.360 --> 05:19.440
Actually, the metadata associated with the MP3,

05:19.440 --> 05:23.400
like the title of the song, the name of the singer,

05:23.400 --> 05:25.320
or whatever, right?

05:25.320 --> 05:27.960
Those specialized binary editors, they are nice too.

05:27.960 --> 05:30.240
They are useful.

05:30.240 --> 05:32.600
But they are not extensible usually.

05:32.600 --> 05:34.960
I mean, you cannot go and say, oh, well, you know.

05:34.960 --> 05:38.640
I mean, in the Ls program here, you know I want to,

05:38.640 --> 05:41.520
you know that Ls sections can contain arbitrary data, right?

05:41.520 --> 05:44.440
So you say, well, I want to use the same editor

05:44.440 --> 05:47.160
to edit the contents of one of the Ls sections.

05:47.160 --> 05:50.800
Usually they don't let you do that.

05:50.800 --> 05:52.400
So they are not extensible.

05:52.400 --> 05:54.680
They also, they are not quite good at dealing

05:54.680 --> 05:56.240
with incorrect data.

05:56.240 --> 06:01.400
So if you get a corrupted L file or some MP3 file

06:01.400 --> 06:04.880
that has problems in it, those editors probably

06:04.880 --> 06:07.520
they are going to refuse to actually open them,

06:07.520 --> 06:08.720
open those files.

06:08.720 --> 06:12.160
And if they do, they are probably going to show you garbage,

06:12.160 --> 06:12.800
right?

06:12.800 --> 06:14.680
So they are not good at that.

06:14.680 --> 06:18.720
And you know it's the typical situation.

06:18.720 --> 06:22.240
Exactly what you need is what they don't implement, right?

06:22.240 --> 06:23.840
It's always like that.

06:23.840 --> 06:27.200
So those are the specialized binary editors.

06:27.200 --> 06:30.880
And then we have Katai's tract and friends,

06:30.880 --> 06:33.240
which is they implement this paradigm of,

06:33.240 --> 06:36.320
as you know, we got a nice presentation before.

06:36.320 --> 06:39.960
The first you decode the data, like with one of the parsers

06:39.960 --> 06:41.840
of Katai's tract, for example.

06:41.840 --> 06:44.400
Then you do your computation with the data.

06:44.400 --> 06:47.800
And then maybe you use an encoder, right,

06:47.800 --> 06:50.000
to write back the modified data.

06:50.000 --> 06:53.760
This is what they call the code compute and code.

06:53.760 --> 06:56.800
Programs like these are also useful.

06:56.800 --> 06:59.800
Those are extensible, like we have seen with Katai's tract.

06:59.800 --> 07:03.840
You can define your own structures.

07:03.840 --> 07:07.360
They use, usually, some sort of declarative way

07:07.360 --> 07:12.400
of describing the layout of those data structures.

07:12.400 --> 07:15.400
They generate code in several target languages.

07:15.400 --> 07:17.840
I don't know why Katai's tract does not generate C. I mean,

07:17.840 --> 07:20.360
to me, I'm so puzzled about that.

07:20.360 --> 07:23.360
But OK.

07:23.360 --> 07:25.120
Usually, those are non-interactive.

07:25.120 --> 07:26.360
They are not interactive.

07:26.360 --> 07:30.280
Like you generate a parser that generates that parser

07:30.280 --> 07:32.360
in some programming language that then you incorporate

07:32.360 --> 07:35.520
your program and then you run, right?

07:35.520 --> 07:38.280
Usually, they are not that good to dealing with incorrect data

07:38.280 --> 07:41.000
either, right?

07:41.000 --> 07:44.400
Because the parser that they generate expects correct data.

07:44.400 --> 07:48.080
And they are either bit-oriented,

07:48.080 --> 07:48.840
which is not common.

07:48.840 --> 07:52.720
I don't know if Katai's tract can deal at a bit level.

07:52.720 --> 07:53.920
Good.

07:53.920 --> 07:55.320
Also, not aligned stuff.

07:58.600 --> 08:01.640
And orbit-oriented.

08:01.640 --> 08:03.160
And often, there are no encoders.

08:03.160 --> 08:04.760
I know that Katai's tract now, they

08:04.760 --> 08:08.360
are starting to add the support for actually writing data back

08:08.360 --> 08:10.160
to the file.

08:10.160 --> 08:10.920
This is nice, too.

08:13.640 --> 08:17.480
And then you have the poke approach, which is circular.

08:21.200 --> 08:23.480
What we wanted with this was the following.

08:23.480 --> 08:28.640
We wanted the immediate aspect of the simple binary editors.

08:28.640 --> 08:31.080
Like, OK, I go to this byte and then I change it.

08:31.080 --> 08:34.840
Now, I mean, now change it immediately.

08:34.840 --> 08:37.040
But also, we wanted the extensibility

08:37.040 --> 08:39.520
and the ability of working with higher abstractions

08:39.520 --> 08:41.560
like you have with the parser generates,

08:41.560 --> 08:43.480
like Katai's tract, for example.

08:43.480 --> 08:45.280
We wanted everything together.

08:45.280 --> 08:50.000
And that is what poke is in few words.

08:50.000 --> 08:53.640
Basically, you describe your data structures,

08:53.640 --> 08:55.920
like in a struct type, for example,

08:55.920 --> 08:58.040
and you can immediately poke at it.

08:58.040 --> 09:01.360
You can immediately update it, edit it, write to it.

09:01.360 --> 09:03.160
And if you are not satisfied with that,

09:03.160 --> 09:05.680
you can on the fly using the same program in the prompt,

09:05.680 --> 09:10.720
you can redefine your data structure and do it again.

09:10.720 --> 09:13.560
This is good for also discovering the format

09:13.560 --> 09:16.520
of what you are editing, like in reverse engineering

09:16.520 --> 09:17.680
and whatnot.

09:17.680 --> 09:20.120
And when you are developing a new format,

09:20.120 --> 09:21.920
you know that kind of use cases.

09:21.920 --> 09:26.400
So it is interactive with the poke application.

09:26.400 --> 09:28.760
It allows immediate editing.

09:28.760 --> 09:31.040
It allows data integrity.

09:31.040 --> 09:35.680
You can define your own complex structure, quite complex ones.

09:35.680 --> 09:39.480
And then it supports a very powerful and to the point

09:39.480 --> 09:41.240
domain specific language.

09:41.240 --> 09:43.240
I'm a big fan of domain specific languages

09:43.240 --> 09:45.040
because we have the ability and the brains

09:45.040 --> 09:47.800
to actually talk in several languages

09:47.800 --> 09:50.160
and write in several programming languages.

09:50.160 --> 09:52.280
And it is so great when a tool actually

09:52.280 --> 09:54.600
gives you the way of expressing things

09:54.600 --> 09:59.960
that are most suitable for the task at hand.

09:59.960 --> 10:02.240
The DSL is called poke as well, like the program,

10:02.240 --> 10:04.920
but with a big P to distinguish the programming language

10:04.920 --> 10:06.760
from the program itself.

10:06.760 --> 10:10.440
It is interactive, aesthetically typed in purpose.

10:10.440 --> 10:14.120
It is garbage collected.

10:14.120 --> 10:16.080
It has some very interesting features,

10:16.080 --> 10:18.400
this programming language, because it's designed to,

10:18.400 --> 10:20.400
you know, to the point, to the task at hand.

10:20.400 --> 10:22.680
So for example, it's not bit oriented,

10:22.680 --> 10:24.400
and it's not byte oriented.

10:24.400 --> 10:27.720
It is unit oriented.

10:27.720 --> 10:31.040
So in poke, when you start talking about offset sizes

10:31.040 --> 10:34.080
in memory and so on, you don't talk in bytes or in bits.

10:34.080 --> 10:38.760
You talk in terms of arbitrary units that you can define.

10:38.760 --> 10:41.960
I'm sorry I cannot get in detail because this is, you know,

10:41.960 --> 10:44.920
like a fast pitch, but you have all the information,

10:44.920 --> 10:47.000
you know, in the internet and so on.

10:47.000 --> 10:50.000
And also it works in bit addressable IOS spaces.

10:50.000 --> 10:53.280
It can work with incorrect data because you

10:53.280 --> 10:55.880
can do non-strict mapping, saying, OK,

10:55.880 --> 10:57.560
I want to disable the constraints,

10:57.560 --> 10:59.200
do that integrate the constraints.

10:59.200 --> 11:02.680
So you can actually discover what you have in front of you

11:02.680 --> 11:05.560
and adapt your own definitions to it and so on.

11:05.560 --> 11:07.800
You can define several versions of the same structure

11:07.800 --> 11:12.320
very easily to be more strict, less strict.

11:12.320 --> 11:13.920
And it is extensible.

11:13.920 --> 11:17.440
We will see that notebook is not just a binary editor.

11:17.440 --> 11:24.960
It is a full infrastructure to write binary utilities as well.

11:24.960 --> 11:27.960
And then similarly to what KITA is trying to do,

11:27.960 --> 11:31.000
for example, when it comes to document formats,

11:31.000 --> 11:33.800
you can use poke also to document formats

11:33.800 --> 11:35.360
and protocols in a functional way

11:35.360 --> 11:37.800
because your same documentation, you can use it, you know,

11:37.800 --> 11:40.960
to actually operate with the data.

11:40.960 --> 11:43.680
To do prototyping, to write binary utilities,

11:43.680 --> 11:46.360
to implement filters, and so on.

11:46.360 --> 11:49.000
And then to integrate in other programs, which is very cool.

11:49.000 --> 11:51.880
I will show you in five minutes one example with the debugger,

11:51.880 --> 11:52.400
with GDB.

11:55.800 --> 12:01.400
Now, poke operates in, it can operate on files, memory

12:01.400 --> 12:05.920
buffers, you know the memory of running processes.

12:05.920 --> 12:09.760
There is a collection of IOD devices, right,

12:09.760 --> 12:12.000
which are what you are editing.

12:12.000 --> 12:15.080
But what a poke program or what you have access

12:15.080 --> 12:18.520
from the command line is to a bit addressable IOS space.

12:18.520 --> 12:23.280
We call those IOS spaces in which you can actually map

12:23.280 --> 12:26.280
or you know manipulate different kind of entities, which

12:26.280 --> 12:29.000
are integers and same integers are things, right,

12:29.000 --> 12:29.960
from the poke language.

12:35.840 --> 12:38.040
OK, we all know what bytes are, right?

12:38.040 --> 12:39.800
You will be surprised many people don't.

12:39.800 --> 12:42.880
They are just little numbers in a certain range, right,

12:42.880 --> 12:49.120
from 0 to 255.

12:49.120 --> 12:50.440
So this is the way you know in poke

12:50.440 --> 12:51.560
you have to refer to bytes.

12:51.560 --> 12:53.600
But what I wanted to show you, because I think

12:53.600 --> 12:57.760
it's the interesting part, is that it's the way that you go,

12:57.760 --> 13:01.880
that in poke you have from bytes to actually encode

13:01.880 --> 13:03.600
in integers, right?

13:03.600 --> 13:06.800
So you see here, I don't know if you can see,

13:06.800 --> 13:09.280
you see here the IOD device there,

13:09.280 --> 13:11.320
which is the underlying device that you are editing,

13:11.320 --> 13:12.920
like the file, right?

13:12.920 --> 13:15.360
And then it has bytes, which are little numbers, right,

13:15.360 --> 13:18.440
from 0 to 255 in the range.

13:18.440 --> 13:22.120
And then the IOS space, which is on top of each byte,

13:22.120 --> 13:25.080
of the bytes, is the bit addressable IOS space

13:25.080 --> 13:27.920
that your poke programs actually see.

13:27.920 --> 13:30.440
But we all know that bits, it's actually

13:30.440 --> 13:31.680
a very interesting thing.

13:31.680 --> 13:35.560
Bits exist usually at the hardware level.

13:35.560 --> 13:38.280
Then they disappear until you will recreate them.

13:38.280 --> 13:42.480
You know virtually, you know on top of those byte numbers,

13:42.480 --> 13:43.160
right?

13:43.160 --> 13:44.760
It's very interesting.

13:44.760 --> 13:48.400
So from poke what you see is the bits

13:48.400 --> 13:51.040
that are conceptually on top of the bytes.

13:51.040 --> 13:54.360
And that's the poke type, for example.

13:54.360 --> 13:57.880
This is an unsigned 16 bits integer

13:57.880 --> 14:02.040
mapped in the IOD device at the first byte.

14:02.040 --> 14:03.240
But this is a boring example.

14:03.240 --> 14:05.840
It gets even more interesting.

14:05.840 --> 14:09.560
What we call wired integers, weird integers, right?

14:09.560 --> 14:12.840
So for example, in poke you can operate with 12 bits

14:12.840 --> 14:15.060
unsigned integers, as naturally as you

14:15.060 --> 14:17.800
will do with a 32 bits unsigned integer.

14:17.800 --> 14:23.280
This is quite cool actually, and useful, believe it or not.

14:23.280 --> 14:24.560
Then we have some conventions, you

14:24.560 --> 14:27.000
know, to refer to the bits and everything.

14:27.000 --> 14:31.840
But this integer actually occupies one full byte,

14:31.840 --> 14:37.440
and then half of the next one.

14:37.440 --> 14:41.640
But also you can go to less than one byte, right?

14:41.640 --> 14:42.720
Like in this case.

14:42.720 --> 14:45.360
So you can actually operate with an unsigned integer of five

14:45.360 --> 14:47.880
bits.

14:47.880 --> 14:51.160
And then it doesn't feel like a complete byte.

14:51.160 --> 14:54.320
Obviously, since everything that there is in a computer

14:54.320 --> 14:57.600
is actually bytes, the drivers level, hardware level,

14:57.600 --> 15:01.680
you know, and everywhere, this is an artifact.

15:01.680 --> 15:04.000
But it's a useful one.

15:04.000 --> 15:10.760
And poke also has full support for an aligned stuff too.

15:10.760 --> 15:13.880
So you can work with actually a 16 unsigned integer,

15:13.880 --> 15:16.680
shift to bits in the IOS space.

15:16.680 --> 15:20.160
Can Kaita Yestrak do that?

15:20.160 --> 15:22.000
Yes, we will have to see.

15:26.520 --> 15:29.720
So yeah, so you could obfuscate your file just by shifting

15:29.720 --> 15:32.480
that three bits to the right, for example.

15:32.480 --> 15:33.200
Why not?

15:33.200 --> 15:33.720
Maybe fun.

15:36.600 --> 15:40.120
I included this here not to impress the cat,

15:40.120 --> 15:41.680
but to give you an impression, you

15:41.680 --> 15:43.520
know, the impression that actually poke,

15:43.520 --> 15:45.160
it's a serious problem.

15:45.160 --> 15:47.120
I mean, it's not just, you know, a stupid problem,

15:47.120 --> 15:49.680
you know, that poking at bytes here and there.

15:49.680 --> 15:51.880
We actually take it very seriously.

15:51.880 --> 15:53.800
And you can do this kind of stuff.

15:53.800 --> 15:56.880
And believe it or not, people need this kind of stuff.

15:56.880 --> 15:59.960
The other day in the IRC, we met the politicians,

15:59.960 --> 16:01.960
which is a community of people who are, you know,

16:01.960 --> 16:03.760
dealing with multics.

16:03.760 --> 16:06.720
And you will not believe what they need.

16:06.720 --> 16:08.280
Really, right?

16:08.280 --> 16:12.960
I mean, like nine bits bytes, you know how it's unbelievable.

16:12.960 --> 16:16.040
And we are struggling to actually give the people

16:16.040 --> 16:18.560
what they need because they have rights too.

16:18.560 --> 16:23.040
The multics people have rights too.

16:23.040 --> 16:28.480
Anyway, so the poke sphere, poke is growing and growing.

16:28.480 --> 16:30.320
This started with one simple.

16:30.320 --> 16:33.720
It was always a little bit special, but you know,

16:33.720 --> 16:34.840
a little program.

16:34.840 --> 16:37.160
But it's getting out of hands at the moment.

16:37.160 --> 16:40.680
And in the sense that we have LeapFolk, which

16:40.680 --> 16:42.440
is a shared object.

16:42.440 --> 16:44.880
Obviously, first I made it in a problem,

16:44.880 --> 16:48.120
but the dodgy in one column, I got an asshole.

16:48.120 --> 16:49.240
Put it in a library.

16:49.240 --> 16:50.160
So I did.

16:50.160 --> 16:53.680
So and then LeapFolk is a shared object

16:53.680 --> 16:56.640
that has the poke incremental compiler, the IOS space

16:56.640 --> 16:57.960
support, and everything.

16:57.960 --> 17:00.880
We will see now with GDB as an example how you can actually

17:00.880 --> 17:03.560
make use of it in your own programs.

17:03.560 --> 17:07.400
Then poke is the command line application, right?

17:07.400 --> 17:08.840
Which uses LeapFolk.

17:08.840 --> 17:11.440
But it's just a program, a very small program,

17:11.440 --> 17:17.000
you know, with a prompt, you know, like,

17:17.000 --> 17:22.120
bin LS, load, you can dump bytes, right?

17:22.120 --> 17:23.080
Sorry, here.

17:23.080 --> 17:31.640
And bar elf, elf, 64, file at 0 bytes, you know.

17:31.640 --> 17:34.920
You know, stuff like this.

17:34.920 --> 17:36.080
The command line application.

17:36.080 --> 17:39.560
But all of the logic is actually in the shared object.

17:39.560 --> 17:42.560
Then you have other applications like GDB, which have,

17:42.560 --> 17:43.600
this is not upstream yet.

17:43.600 --> 17:45.640
It's in a branch upstream, but not in master.

17:45.640 --> 17:48.080
But they can actually use LeapFolk

17:48.080 --> 17:49.480
to give you poke capabilities.

17:49.480 --> 17:53.720
I will show you now in a two minute little demo.

17:53.720 --> 17:56.400
There is a poke daemon too that Muhammad will talk about.

17:56.400 --> 17:56.920
Yeah?

17:56.920 --> 17:58.840
Take a half a minute.

17:58.840 --> 18:02.640
Utilities, the pickles, which are the poke programs that

18:02.640 --> 18:05.640
give you the support for some particular format

18:05.640 --> 18:08.120
or some particular domain.

18:08.120 --> 18:10.760
Then there is an MX interface, of course.

18:10.760 --> 18:15.000
Then there is an MX mode for the poke program, VIM for unholy

18:15.000 --> 18:17.120
people for everything.

18:17.120 --> 18:20.920
You know, the poke code in VIM, in VI.

18:20.920 --> 18:24.320
Something called pokelets, and so on, and so on, and so on.

18:24.320 --> 18:27.160
So it's getting fun.

18:27.160 --> 18:28.400
And then the integration.

18:28.400 --> 18:30.640
I'm very, I like this.

18:36.400 --> 18:39.000
You know, there is one problem when people write a program,

18:39.000 --> 18:42.680
they want it to do everything very well.

18:42.680 --> 18:44.200
And that does not work.

18:44.200 --> 18:46.480
So for example, in poke we have some support

18:46.480 --> 18:48.600
for editing the memory of running processes.

18:48.600 --> 18:49.800
We do.

18:49.800 --> 18:51.240
We do.

18:51.240 --> 18:53.800
Well, I could show you, but I don't have time for that.

18:53.800 --> 18:56.880
Because we have an IOD, which is you can specify the process

18:56.880 --> 18:59.680
ID of a process, and then you can edit the running memory,

18:59.680 --> 19:02.320
you know, of the memory of the running process.

19:02.320 --> 19:04.480
But poke is not a debugger.

19:04.480 --> 19:05.480
It's not.

19:05.480 --> 19:08.040
I mean, it doesn't, there is a dwarf pickle,

19:08.040 --> 19:10.360
but you know not to the same extent that a debugger.

19:10.360 --> 19:11.400
You cannot set breakpoints.

19:11.400 --> 19:17.160
You cannot use ptrace to command a process.

19:17.160 --> 19:19.000
But gdb is a debugger.

19:19.000 --> 19:22.680
So gdb is good at debugging, at running processes, and so on.

19:22.680 --> 19:25.800
And poke is good at poking at data, right?

19:25.800 --> 19:27.920
So let's put them together.

19:27.920 --> 19:30.240
So then the combination is good at both.

19:30.240 --> 19:35.760
And this can be achieved by using libpoke.

19:35.760 --> 19:39.480
So I can show you very fast.

19:39.480 --> 19:42.840
So I have the C file.

19:42.840 --> 19:44.080
You see the C file?

19:44.080 --> 19:47.080
I have a C extract frob with an int tag.

19:47.080 --> 19:49.360
Can you see it properly there?

19:49.360 --> 19:51.360
Yes?

19:51.360 --> 19:52.760
Which one?

19:52.760 --> 19:55.640
Which one?

19:55.640 --> 19:58.840
No, I'm not going to address this.

19:58.840 --> 19:59.760
Trust me.

19:59.760 --> 20:01.200
OK.

20:01.200 --> 20:02.920
So there is this extract type.

20:02.920 --> 20:04.120
Then there is this buffer.

20:04.120 --> 20:07.400
There is this db global variable here, and so on, and so on.

20:07.400 --> 20:07.880
Right?

20:07.880 --> 20:10.400
And an int main.

20:10.400 --> 20:14.960
So then I compile that into an aout.

20:14.960 --> 20:18.560
And then I do home.

20:18.560 --> 20:26.320
This is the poke-capable gdb, a.out, break main, run.

20:26.320 --> 20:27.400
Now I am in main, right?

20:27.400 --> 20:28.720
Here.

20:28.720 --> 20:32.680
And then I can use gdb to look at the database here.

20:32.680 --> 20:35.640
You know this db global variable, and so on.

20:35.640 --> 20:38.800
Now this gdb is extended with poke.

20:38.800 --> 20:42.120
So you have a poke command where you can execute any poke code.

20:42.120 --> 20:44.320
Like this, like 2 plus 2 equals 4.

20:44.320 --> 20:46.360
Brilliant.

20:46.360 --> 20:51.040
But here you can do anything that you can do with poke.

20:51.040 --> 20:54.680
So for example, you could say, and poke in this case

20:54.680 --> 20:57.480
is it has access to the memory of the inferior

20:57.480 --> 20:59.760
that you are debugging with udb.

20:59.760 --> 21:03.600
So even if it's multiprocess or multithread, you switch in gdb

21:03.600 --> 21:06.360
and then poke has access to the memory of the inferior.

21:06.360 --> 21:13.120
So what kind of things you can do?

21:13.120 --> 21:14.320
Well, anything.

21:14.320 --> 21:19.520
I mean, what is the address in gdb of this global variable

21:19.520 --> 21:20.320
here?

21:20.320 --> 21:22.240
Sorry.

21:22.240 --> 21:23.720
That is the address.

21:23.720 --> 21:26.880
So with poke, you could access to that address.

21:26.880 --> 21:31.760
But you have a command which is poke at types, which

21:31.760 --> 21:36.480
is you are telling gdb to make poke aware of all the types

21:36.480 --> 21:40.360
known to gdb at this point in time.

21:40.360 --> 21:42.920
So the type char, the char type int,

21:42.920 --> 21:44.960
destruct prop that we saw before.

21:44.960 --> 21:51.200
And then this translated into poke type definitions

21:51.200 --> 21:53.400
for the key-valent gdb types.

21:53.400 --> 21:56.280
This means that you can go from btf, from ctf, from door,

21:56.280 --> 21:59.800
from any debugging format that gdb understands to poke types

21:59.800 --> 22:02.400
while you are using gdb in this way.

22:02.400 --> 22:07.960
Now, poke now has access to the memory of the inferior.

22:07.960 --> 22:12.440
So we could do, for example, and those are poke expressions,

22:12.440 --> 22:13.000
right?

22:13.000 --> 22:16.520
extract prop at where?

22:16.520 --> 22:18.800
And you can use something we call alien tokens,

22:18.800 --> 22:22.680
which is the address of the gdb symbol db, which

22:22.680 --> 22:24.360
is the variable, right?

22:24.360 --> 22:26.120
And this is the poke extract.

22:26.120 --> 22:28.400
This is not a gdb value.

22:28.400 --> 22:33.840
This is a poke extract, which is poking at inferior memory.

22:33.840 --> 22:35.000
And you, of course, can write.

22:35.000 --> 22:36.680
You can do whatever you want.

22:36.680 --> 22:38.240
You can load pickles.

22:38.240 --> 22:40.040
Why is this useful for?

22:40.040 --> 22:42.360
Well, imagine you are debugging a program that

22:42.360 --> 22:45.440
is some sort of router for TCP.

22:45.440 --> 22:47.920
So the program itself, you have TCP packets

22:47.920 --> 22:49.280
and some buffers in the program.

22:49.280 --> 22:50.760
But the program itself doesn't need

22:50.760 --> 22:54.480
to understand the payload of what it is transporting.

22:54.480 --> 22:56.440
But imagine that you want to take a look at what

22:56.440 --> 22:58.840
is going on there, right?

22:58.840 --> 23:01.240
So then you don't have the Dorf definitions

23:01.240 --> 23:05.160
of the structures that are in the buffer in the payload.

23:05.160 --> 23:06.880
But with poke, you just load your pickle

23:06.880 --> 23:09.440
or you are right your own, and you can poke at it

23:09.440 --> 23:14.280
from gdb in the buffer of the running process, for example.

23:14.280 --> 23:16.440
So this is one example of application.

23:19.560 --> 23:23.440
This is 400 lines of C, the integration using lead poke.

23:23.440 --> 23:24.480
It's very nice.

23:24.480 --> 23:25.920
You know it's easy.

23:25.920 --> 23:28.160
Another example, which is work in progress,

23:28.160 --> 23:30.440
and I can't wait to get this finished,

23:30.440 --> 23:35.320
is basically to add to the assembler a dot poke directive.

23:35.320 --> 23:41.200
Because you know those dot war, dot byte, and so on directives

23:41.200 --> 23:42.800
in the assembler?

23:42.800 --> 23:45.040
They are not portable.

23:45.040 --> 23:47.160
And this is a pain in the ass.

23:47.160 --> 23:49.360
Because when you have to actually, for example,

23:49.360 --> 23:52.360
test Dorf or test, you know, that kind of things,

23:52.360 --> 23:54.880
then they are not portable.

23:54.880 --> 23:58.520
I know it's amazing, but they are not portable.

23:58.520 --> 24:00.720
So see, for example, that.

24:00.720 --> 24:03.400
This is a real example of something I found.

24:03.400 --> 24:05.680
I will not tell where.

24:05.680 --> 24:11.160
Of some people who are actually embedding

24:11.160 --> 24:14.680
some sort of executables inside other sections of some

24:14.680 --> 24:15.200
of the stuff.

24:15.200 --> 24:19.240
This is a video games, you know, kids.

24:19.240 --> 24:20.960
They do these kind of things.

24:20.960 --> 24:26.680
And that is a struct, in theory, of what?

24:26.680 --> 24:28.520
Of some heater, right?

24:28.520 --> 24:30.720
For the PlayStation or whatever.

24:30.720 --> 24:33.440
Well, compare.

24:33.440 --> 24:34.440
You see?

24:34.440 --> 24:37.640
So once we have the integration in the assembler,

24:37.640 --> 24:41.960
then you will be able to load the PSXX pickle.

24:41.960 --> 24:44.080
It will be a small one where you define, you know,

24:44.080 --> 24:46.480
that structure of this executable.

24:46.480 --> 24:49.080
And then you could poke at assembly time,

24:49.080 --> 24:50.640
you know, like that too.

24:50.640 --> 24:53.560
And accessing gas assembler symbols,

24:53.560 --> 24:55.560
you know, using alien tokens, like we saw you

24:55.560 --> 24:58.080
could do with GDB as well.

24:58.080 --> 25:00.000
So this is another example of integration.

25:03.520 --> 25:04.280
Yeah.

25:04.280 --> 25:06.520
So we are on these kind of things now.

25:06.520 --> 25:10.320
We are looking into parasiting other programs, you know,

25:10.320 --> 25:13.400
and incorporating lip poking them.

25:13.400 --> 25:17.840
So they do all the boring work, and we do the fun one.

25:17.840 --> 25:20.440
OK.

25:20.440 --> 25:22.880
So what's the current status of the program?

25:22.880 --> 25:28.840
We just released the POC 3.0 a few days ago.

25:28.840 --> 25:32.640
Up to now, we were doing one major release every year,

25:32.640 --> 25:36.680
and we had a maintenance branch.

25:36.680 --> 25:38.560
But people are not happy.

25:38.560 --> 25:39.440
Why?

25:39.440 --> 25:45.160
Because it was too long, and the difference between POC 2

25:45.160 --> 25:46.920
and POC 3, it was too big.

25:46.920 --> 25:48.240
It was too much.

25:48.240 --> 25:52.080
And actually, we released the POC 2.0, for example.

25:52.080 --> 25:54.640
And in two weeks, we have forgotten about it already,

25:54.640 --> 25:56.120
because we are so happy, you know,

25:56.120 --> 25:59.320
and so excited with the main branch.

25:59.320 --> 26:03.280
So now we are committing to release two big major releases

26:03.280 --> 26:04.160
every year.

26:04.160 --> 26:05.760
Let's see if we can actually do that.

26:09.160 --> 26:14.640
The development, we are old GNU P spots, right?

26:14.640 --> 26:18.400
So we don't use GitHub or anything like that.

26:18.400 --> 26:20.640
So we use a mailing list, and you

26:20.640 --> 26:24.240
send your patch to the mailing list in Unity format,

26:24.240 --> 26:26.360
and so on and so on, right?

26:26.360 --> 26:29.880
And well, that is the website of the project.

26:29.880 --> 26:32.400
We have a Git repository, obviously.

26:32.400 --> 26:34.880
We have a mailing list, a development mailing list.

26:34.880 --> 26:39.040
We have a very nice build box at sourceware.

26:39.040 --> 26:42.800
Thank you very much to the sourceware overseers.

26:42.800 --> 26:45.000
They are doing a great job maintaining

26:45.000 --> 26:47.640
the infrastructure of many GNU programs, including

26:47.640 --> 26:50.400
Polk and also the toolchain, GCC and the Ellipse and so on,

26:50.400 --> 26:51.960
for many years.

26:51.960 --> 26:56.000
And also, we have a pipeline hosted at GitLab

26:56.000 --> 26:57.520
that Bruno Heibel maintains.

26:57.520 --> 27:00.280
And I have no idea how it works.

27:00.280 --> 27:03.040
It's not clear to me what even a pipeline is in that context,

27:03.040 --> 27:04.000
but it's green.

27:04.000 --> 27:05.640
So I guess it's good.

27:08.280 --> 27:11.920
We have a community website.

27:11.920 --> 27:13.400
It's called Polkology.

27:13.400 --> 27:17.280
And we try to get practical information there,

27:17.280 --> 27:20.280
like how can you write your pickles and so on.

27:20.280 --> 27:26.880
And also, I have a blog in my website, where sometimes I

27:26.880 --> 27:30.880
publish small articles, like also with practical stuff.

27:30.880 --> 27:34.480
So how can you do, for example, implementing sparse tables

27:34.480 --> 27:38.480
using Polk or accessing them stuff?

27:38.480 --> 27:43.520
We want to be friendly to users.

27:43.520 --> 27:47.680
And now, starting now, in Polk, we

27:47.680 --> 27:54.160
had in the Polk source distribution, GNU Hacks Polk,

27:54.160 --> 27:59.960
we had a pickles directory with a lot of pickles, right?

27:59.960 --> 28:07.720
Like for P, for L, for DOR, for BTF, for this, for that.

28:07.720 --> 28:12.640
Some instructions said RISC-V, BTF.

28:12.640 --> 28:14.520
But this is getting crowded.

28:14.520 --> 28:18.000
And actually, some pickles are big and complex enough

28:18.000 --> 28:21.920
to actually need their own releases,

28:21.920 --> 28:23.800
so you can have several versions that

28:23.800 --> 28:25.300
work with the same version of Polk.

28:25.300 --> 28:28.680
So we are basically putting some of the pickles

28:28.680 --> 28:30.960
in separated packages.

28:30.960 --> 28:34.400
And that's the case of the ELF pickle and the DORF pickle.

28:34.400 --> 28:36.720
So for example, the ELF pickles, now

28:36.720 --> 28:38.560
they are distributed separately.

28:38.560 --> 28:40.160
Have not made the first release yet,

28:40.160 --> 28:42.920
but they are in the git repository.

28:42.920 --> 28:47.480
They have their own manual and so on, and the DORF pickles

28:47.480 --> 28:48.320
as well.

28:48.320 --> 28:50.040
Those are the first ones.

28:50.040 --> 28:52.840
We want to get the P-Cov support because it's

28:52.840 --> 28:55.760
a huge fat monster, that one.

28:55.760 --> 29:00.200
We want to put it also in its own package.

29:00.200 --> 29:03.200
And also, with nice manuals, I have

29:03.200 --> 29:07.000
to show you this because it is such a pain to do it

29:07.000 --> 29:08.880
that you have to brag about it.

29:08.880 --> 29:14.400
So this is the Polk manual, the GNU Polk manual.

29:14.400 --> 29:17.400
And then when you install the pickles packages,

29:17.400 --> 29:20.960
like Polk DORF and Polk ELF, and here you

29:20.960 --> 29:28.840
have a nicely documented pickles and everything.

29:28.840 --> 29:31.960
And the source distribution.

29:31.960 --> 29:32.480
Sorry?

29:32.480 --> 29:35.480
You use man pages, not the menu.

29:35.480 --> 29:38.040
Well, well.

29:38.040 --> 29:39.640
Oh, well.

29:39.640 --> 29:43.000
We are generating man pages from the tech info.

29:47.320 --> 29:48.760
Yeah.

29:48.760 --> 29:51.240
Then actually, the idea is to use the ELF pickle

29:51.240 --> 29:53.120
because we are new, writing pickles,

29:53.120 --> 29:55.080
because Polk is sort of new, right?

29:55.080 --> 30:00.400
So we are trying to discover our way forward.

30:00.400 --> 30:07.360
But the Polk ELF pickles is sort of the canonical example.

30:07.360 --> 30:09.440
We are using it that way.

30:09.440 --> 30:11.080
We are writing it very carefully.

30:11.080 --> 30:13.120
So if you want to write a complex pickle,

30:13.120 --> 30:13.880
you can look at it.

30:20.680 --> 30:22.200
This is it.

30:22.200 --> 30:24.080
I am so sorry that they could not give you

30:24.080 --> 30:28.840
an actual taste of how this program is.

30:28.840 --> 30:30.240
But there is no time for that.

30:30.240 --> 30:32.280
And there are other videos in the internet

30:32.280 --> 30:35.360
that they have done already.

30:35.360 --> 30:38.120
And then if you want to join the development,

30:38.120 --> 30:40.440
read, please read the hacking file,

30:40.440 --> 30:42.040
because we took the effort of writing it.

30:42.040 --> 30:42.960
It's huge.

30:42.960 --> 30:44.800
It has a lot of good information.

30:44.800 --> 30:49.520
And absolutely no one reads it.

30:49.520 --> 30:51.080
So thank you very much.

30:51.080 --> 31:01.720
Thanks.
