1
0:00:00.000 --> 0:00:10.360
All right. So it's two minutes early, but I have

2
0:00:10.360 --> 0:00:12.800
a tendency to speak and not stop,

3
0:00:12.800 --> 0:00:15.440
so we better get started here.

4
0:00:16.440 --> 0:00:21.920
So I am so tired of doing introductory talks to poke.

5
0:00:21.920 --> 0:00:25.280
So I have decided that this is the last one I'm going to do.

6
0:00:25.280 --> 0:00:27.620
So, but let's see.

7
0:00:27.620 --> 0:00:31.240
Is anyone here familiar with this program somehow?

8
0:00:31.240 --> 0:00:35.320
Yes? Okay. So yeah,

9
0:00:35.320 --> 0:00:37.440
we need to do an introductory talk.

10
0:00:37.440 --> 0:00:40.440
So, GNU poke is

11
0:00:40.440 --> 0:00:43.400
an extensible editor for a structure binary data.

12
0:00:43.400 --> 0:00:46.220
So it is a program that you can actually expand.

13
0:00:46.220 --> 0:00:48.800
We will see how, and you can expand it

14
0:00:48.800 --> 0:00:51.400
actually quite to a very high degree.

15
0:00:51.400 --> 0:00:56.640
And we will see that it's a program that is used to poke,

16
0:00:56.640 --> 0:01:03.120
or to mess, to edit data which is encoded in binary.

17
0:01:03.120 --> 0:01:05.560
We will see what this thing about binary.

18
0:01:05.560 --> 0:01:08.040
Everything is binary at the end of the day.

19
0:01:08.040 --> 0:01:11.440
So first, I'm going to do a very small introduction,

20
0:01:11.440 --> 0:01:13.040
an abstract one.

21
0:01:13.040 --> 0:01:15.720
I mean, why would you use such a program?

22
0:01:15.720 --> 0:01:19.760
Then we will see how we are actually integrating poke in

23
0:01:19.760 --> 0:01:24.080
other programs via a shared object, a library.

24
0:01:24.080 --> 0:01:26.440
Then I will basically talk a little bit about

25
0:01:26.440 --> 0:01:28.760
the project itself, the current status.

26
0:01:28.760 --> 0:01:32.800
We just made a major release that we are very happy about it.

27
0:01:32.800 --> 0:01:36.360
And we are very busy because the project is getting a lot of,

28
0:01:36.360 --> 0:01:38.000
we have a lot of things to do.

29
0:01:38.000 --> 0:01:39.740
It's getting very fun actually.

30
0:01:39.740 --> 0:01:43.080
And then finally, an invitation to you to actually join us

31
0:01:43.080 --> 0:01:46.480
in hacking this program.

32
0:01:46.480 --> 0:01:50.320
So let's start with a very small introduction.

33
0:01:50.320 --> 0:01:55.800
I mean, when it comes to edit binary data,

34
0:01:55.800 --> 0:01:57.040
well, what do you use?

35
0:01:57.040 --> 0:01:58.600
You use a binary editor, right?

36
0:02:02.760 --> 0:02:07.320
If you go around and then you look around in internet about

37
0:02:07.320 --> 0:02:12.400
binary editors, you have the simplest kind, what I call

38
0:02:12.400 --> 0:02:18.520
simple binary editors, which is your garden variety programs

39
0:02:18.520 --> 0:02:21.280
which show you a byte dump.

40
0:02:21.280 --> 0:02:24.280
And then a lot of them also show you the ASCII

41
0:02:24.280 --> 0:02:26.440
representation of the same bytes.

42
0:02:26.440 --> 0:02:28.120
What do you see in the screen?

43
0:02:28.120 --> 0:02:30.080
How many of those programs are around?

44
0:02:30.080 --> 0:02:31.240
Quite a lot of them.

45
0:02:31.240 --> 0:02:32.320
And they are nice.

46
0:02:32.320 --> 0:02:33.040
I mean, they are nice.

47
0:02:33.040 --> 0:02:34.560
They are useful.

48
0:02:34.560 --> 0:02:35.600
They are small.

49
0:02:35.600 --> 0:02:37.120
They are very easy to use.

50
0:02:37.120 --> 0:02:40.600
There is nothing mysterious about them.

51
0:02:40.600 --> 0:02:42.400
They are interactive usually.

52
0:02:42.400 --> 0:02:44.800
The ones that allow you to actually change the value of

53
0:02:44.800 --> 0:02:48.280
those bytes in the files, you just go to the byte you want

54
0:02:48.280 --> 0:02:53.120
to change, you put in the new value for the bytes, ta-da.

55
0:02:53.120 --> 0:02:56.040
If you want to change based on some string, you go to the

56
0:02:56.040 --> 0:02:57.880
ASCII column there.

57
0:02:57.880 --> 0:02:59.840
You go to the position you want to edit.

58
0:02:59.840 --> 0:03:00.800
You change it.

59
0:03:00.800 --> 0:03:03.000
But the file gets updated.

60
0:03:03.000 --> 0:03:03.400
Very nice.

61
0:03:03.400 --> 0:03:04.520
They are interactive.

62
0:03:04.520 --> 0:03:06.640
They support immediate editing.

63
0:03:06.640 --> 0:03:09.880
You go, you change here, and it immediately gets reflected

64
0:03:09.880 --> 0:03:13.840
in the file that you are editing, for example.

65
0:03:13.840 --> 0:03:15.320
What do they let you edit?

66
0:03:15.320 --> 0:03:16.920
In terms of what?

67
0:03:16.920 --> 0:03:17.880
Well, it depends.

68
0:03:17.880 --> 0:03:20.560
But those simple binary editors, they let you operate

69
0:03:20.560 --> 0:03:25.520
in terms of bytes, in terms of strings, like we just

70
0:03:25.520 --> 0:03:29.480
mentioned, and sometimes this is not often, but sometimes

71
0:03:29.480 --> 0:03:30.960
in terms of bits as well.

72
0:03:30.960 --> 0:03:35.080
Some of those basic binary editors, they support down to

73
0:03:35.080 --> 0:03:36.320
the bit level too.

74
0:03:39.040 --> 0:03:41.040
And that's it.

75
0:03:41.040 --> 0:03:42.520
That's the thing.

76
0:03:42.520 --> 0:03:45.520
You can edit in terms of those entities, of those

77
0:03:45.520 --> 0:03:49.800
concepts, bytes, bits, strings sometimes, sometimes numbers.

78
0:03:49.800 --> 0:03:52.280
Then the editor is not so simple anymore.

79
0:03:52.280 --> 0:03:55.920
But it's always a fixed list of abstractions that you can

80
0:03:55.920 --> 0:04:01.320
edit, you manipulate your data using those abstractions.

81
0:04:01.320 --> 0:04:04.360
Then they give you, generally, byte dumps, the ASCII views.

82
0:04:04.360 --> 0:04:07.080
And they have fixed capabilities, depending on

83
0:04:07.080 --> 0:04:10.000
how nice the particular editor is.

84
0:04:10.000 --> 0:04:12.000
Some of them allow you to search for patterns.

85
0:04:12.000 --> 0:04:17.680
Some others to search and replace, to make byte divs.

86
0:04:17.680 --> 0:04:19.120
That kind of thing.

87
0:04:19.120 --> 0:04:22.920
Measure entropy, to search for frame buffers.

88
0:04:22.920 --> 0:04:23.960
That kind of thing.

89
0:04:23.960 --> 0:04:25.200
Simple binary editors.

90
0:04:25.200 --> 0:04:26.440
They are useful.

91
0:04:29.880 --> 0:04:32.760
But then sometimes you have to edit, or you want to edit,

92
0:04:32.760 --> 0:04:36.040
your data in terms not just of bytes or bits, but in terms

93
0:04:36.040 --> 0:04:42.080
of more abstract entities, like MP3 headers, or else

94
0:04:42.080 --> 0:04:46.480
relocations, or lists of numbers, or whatever.

95
0:04:46.480 --> 0:04:51.040
And then for that, you have traditionally specialized

96
0:04:51.040 --> 0:04:54.640
binary editors, which are editors, like the two that you

97
0:04:54.640 --> 0:05:00.440
can see here, that know about some particular format.

98
0:05:00.440 --> 0:05:02.120
Like some of them, the one on the left

99
0:05:02.120 --> 0:05:03.960
knows about the L format.

100
0:05:03.960 --> 0:05:06.760
So you can see a tree view, which is quite nice, you know,

101
0:05:06.760 --> 0:05:09.680
with the different sections in the Ls.

102
0:05:09.680 --> 0:05:13.920
And the one on the right, which is small, but it's nice,

103
0:05:13.920 --> 0:05:17.360
is a very small MP3 editor to edit MP3 files.

104
0:05:17.360 --> 0:05:19.440
Actually, the metadata associated with the MP3,

105
0:05:19.440 --> 0:05:23.400
like the title of the song, the name of the singer,

106
0:05:23.400 --> 0:05:25.320
or whatever, right?

107
0:05:25.320 --> 0:05:27.960
Those specialized binary editors, they are nice too.

108
0:05:27.960 --> 0:05:30.240
They are useful.

109
0:05:30.240 --> 0:05:32.600
But they are not extensible usually.

110
0:05:32.600 --> 0:05:34.960
I mean, you cannot go and say, oh, well, you know.

111
0:05:34.960 --> 0:05:38.640
I mean, in the Ls program here, you know I want to,

112
0:05:38.640 --> 0:05:41.520
you know that Ls sections can contain arbitrary data, right?

113
0:05:41.520 --> 0:05:44.440
So you say, well, I want to use the same editor

114
0:05:44.440 --> 0:05:47.160
to edit the contents of one of the Ls sections.

115
0:05:47.160 --> 0:05:50.800
Usually they don't let you do that.

116
0:05:50.800 --> 0:05:52.400
So they are not extensible.

117
0:05:52.400 --> 0:05:54.680
They also, they are not quite good at dealing

118
0:05:54.680 --> 0:05:56.240
with incorrect data.

119
0:05:56.240 --> 0:06:01.400
So if you get a corrupted L file or some MP3 file

120
0:06:01.400 --> 0:06:04.880
that has problems in it, those editors probably

121
0:06:04.880 --> 0:06:07.520
they are going to refuse to actually open them,

122
0:06:07.520 --> 0:06:08.720
open those files.

123
0:06:08.720 --> 0:06:12.160
And if they do, they are probably going to show you garbage,

124
0:06:12.160 --> 0:06:12.800
right?

125
0:06:12.800 --> 0:06:14.680
So they are not good at that.

126
0:06:14.680 --> 0:06:18.720
And you know it's the typical situation.

127
0:06:18.720 --> 0:06:22.240
Exactly what you need is what they don't implement, right?

128
0:06:22.240 --> 0:06:23.840
It's always like that.

129
0:06:23.840 --> 0:06:27.200
So those are the specialized binary editors.

130
0:06:27.200 --> 0:06:30.880
And then we have Katai's tract and friends,

131
0:06:30.880 --> 0:06:33.240
which is they implement this paradigm of,

132
0:06:33.240 --> 0:06:36.320
as you know, we got a nice presentation before.

133
0:06:36.320 --> 0:06:39.960
The first you decode the data, like with one of the parsers

134
0:06:39.960 --> 0:06:41.840
of Katai's tract, for example.

135
0:06:41.840 --> 0:06:44.400
Then you do your computation with the data.

136
0:06:44.400 --> 0:06:47.800
And then maybe you use an encoder, right,

137
0:06:47.800 --> 0:06:50.000
to write back the modified data.

138
0:06:50.000 --> 0:06:53.760
This is what they call the code compute and code.

139
0:06:53.760 --> 0:06:56.800
Programs like these are also useful.

140
0:06:56.800 --> 0:06:59.800
Those are extensible, like we have seen with Katai's tract.

141
0:06:59.800 --> 0:07:03.840
You can define your own structures.

142
0:07:03.840 --> 0:07:07.360
They use, usually, some sort of declarative way

143
0:07:07.360 --> 0:07:12.400
of describing the layout of those data structures.

144
0:07:12.400 --> 0:07:15.400
They generate code in several target languages.

145
0:07:15.400 --> 0:07:17.840
I don't know why Katai's tract does not generate C. I mean,

146
0:07:17.840 --> 0:07:20.360
to me, I'm so puzzled about that.

147
0:07:20.360 --> 0:07:23.360
But OK.

148
0:07:23.360 --> 0:07:25.120
Usually, those are non-interactive.

149
0:07:25.120 --> 0:07:26.360
They are not interactive.

150
0:07:26.360 --> 0:07:30.280
Like you generate a parser that generates that parser

151
0:07:30.280 --> 0:07:32.360
in some programming language that then you incorporate

152
0:07:32.360 --> 0:07:35.520
your program and then you run, right?

153
0:07:35.520 --> 0:07:38.280
Usually, they are not that good to dealing with incorrect data

154
0:07:38.280 --> 0:07:41.000
either, right?

155
0:07:41.000 --> 0:07:44.400
Because the parser that they generate expects correct data.

156
0:07:44.400 --> 0:07:48.080
And they are either bit-oriented,

157
0:07:48.080 --> 0:07:48.840
which is not common.

158
0:07:48.840 --> 0:07:52.720
I don't know if Katai's tract can deal at a bit level.

159
0:07:52.720 --> 0:07:53.920
Good.

160
0:07:53.920 --> 0:07:55.320
Also, not aligned stuff.

161
0:07:58.600 --> 0:08:01.640
And orbit-oriented.

162
0:08:01.640 --> 0:08:03.160
And often, there are no encoders.

163
0:08:03.160 --> 0:08:04.760
I know that Katai's tract now, they

164
0:08:04.760 --> 0:08:08.360
are starting to add the support for actually writing data back

165
0:08:08.360 --> 0:08:10.160
to the file.

166
0:08:10.160 --> 0:08:10.920
This is nice, too.

167
0:08:13.640 --> 0:08:17.480
And then you have the poke approach, which is circular.

168
0:08:21.200 --> 0:08:23.480
What we wanted with this was the following.

169
0:08:23.480 --> 0:08:28.640
We wanted the immediate aspect of the simple binary editors.

170
0:08:28.640 --> 0:08:31.080
Like, OK, I go to this byte and then I change it.

171
0:08:31.080 --> 0:08:34.840
Now, I mean, now change it immediately.

172
0:08:34.840 --> 0:08:37.040
But also, we wanted the extensibility

173
0:08:37.040 --> 0:08:39.520
and the ability of working with higher abstractions

174
0:08:39.520 --> 0:08:41.560
like you have with the parser generates,

175
0:08:41.560 --> 0:08:43.480
like Katai's tract, for example.

176
0:08:43.480 --> 0:08:45.280
We wanted everything together.

177
0:08:45.280 --> 0:08:50.000
And that is what poke is in few words.

178
0:08:50.000 --> 0:08:53.640
Basically, you describe your data structures,

179
0:08:53.640 --> 0:08:55.920
like in a struct type, for example,

180
0:08:55.920 --> 0:08:58.040
and you can immediately poke at it.

181
0:08:58.040 --> 0:09:01.360
You can immediately update it, edit it, write to it.

182
0:09:01.360 --> 0:09:03.160
And if you are not satisfied with that,

183
0:09:03.160 --> 0:09:05.680
you can on the fly using the same program in the prompt,

184
0:09:05.680 --> 0:09:10.720
you can redefine your data structure and do it again.

185
0:09:10.720 --> 0:09:13.560
This is good for also discovering the format

186
0:09:13.560 --> 0:09:16.520
of what you are editing, like in reverse engineering

187
0:09:16.520 --> 0:09:17.680
and whatnot.

188
0:09:17.680 --> 0:09:20.120
And when you are developing a new format,

189
0:09:20.120 --> 0:09:21.920
you know that kind of use cases.

190
0:09:21.920 --> 0:09:26.400
So it is interactive with the poke application.

191
0:09:26.400 --> 0:09:28.760
It allows immediate editing.

192
0:09:28.760 --> 0:09:31.040
It allows data integrity.

193
0:09:31.040 --> 0:09:35.680
You can define your own complex structure, quite complex ones.

194
0:09:35.680 --> 0:09:39.480
And then it supports a very powerful and to the point

195
0:09:39.480 --> 0:09:41.240
domain specific language.

196
0:09:41.240 --> 0:09:43.240
I'm a big fan of domain specific languages

197
0:09:43.240 --> 0:09:45.040
because we have the ability and the brains

198
0:09:45.040 --> 0:09:47.800
to actually talk in several languages

199
0:09:47.800 --> 0:09:50.160
and write in several programming languages.

200
0:09:50.160 --> 0:09:52.280
And it is so great when a tool actually

201
0:09:52.280 --> 0:09:54.600
gives you the way of expressing things

202
0:09:54.600 --> 0:09:59.960
that are most suitable for the task at hand.

203
0:09:59.960 --> 0:10:02.240
The DSL is called poke as well, like the program,

204
0:10:02.240 --> 0:10:04.920
but with a big P to distinguish the programming language

205
0:10:04.920 --> 0:10:06.760
from the program itself.

206
0:10:06.760 --> 0:10:10.440
It is interactive, aesthetically typed in purpose.

207
0:10:10.440 --> 0:10:14.120
It is garbage collected.

208
0:10:14.120 --> 0:10:16.080
It has some very interesting features,

209
0:10:16.080 --> 0:10:18.400
this programming language, because it's designed to,

210
0:10:18.400 --> 0:10:20.400
you know, to the point, to the task at hand.

211
0:10:20.400 --> 0:10:22.680
So for example, it's not bit oriented,

212
0:10:22.680 --> 0:10:24.400
and it's not byte oriented.

213
0:10:24.400 --> 0:10:27.720
It is unit oriented.

214
0:10:27.720 --> 0:10:31.040
So in poke, when you start talking about offset sizes

215
0:10:31.040 --> 0:10:34.080
in memory and so on, you don't talk in bytes or in bits.

216
0:10:34.080 --> 0:10:38.760
You talk in terms of arbitrary units that you can define.

217
0:10:38.760 --> 0:10:41.960
I'm sorry I cannot get in detail because this is, you know,

218
0:10:41.960 --> 0:10:44.920
like a fast pitch, but you have all the information,

219
0:10:44.920 --> 0:10:47.000
you know, in the internet and so on.

220
0:10:47.000 --> 0:10:50.000
And also it works in bit addressable IOS spaces.

221
0:10:50.000 --> 0:10:53.280
It can work with incorrect data because you

222
0:10:53.280 --> 0:10:55.880
can do non-strict mapping, saying, OK,

223
0:10:55.880 --> 0:10:57.560
I want to disable the constraints,

224
0:10:57.560 --> 0:10:59.200
do that integrate the constraints.

225
0:10:59.200 --> 0:11:02.680
So you can actually discover what you have in front of you

226
0:11:02.680 --> 0:11:05.560
and adapt your own definitions to it and so on.

227
0:11:05.560 --> 0:11:07.800
You can define several versions of the same structure

228
0:11:07.800 --> 0:11:12.320
very easily to be more strict, less strict.

229
0:11:12.320 --> 0:11:13.920
And it is extensible.

230
0:11:13.920 --> 0:11:17.440
We will see that notebook is not just a binary editor.

231
0:11:17.440 --> 0:11:24.960
It is a full infrastructure to write binary utilities as well.

232
0:11:24.960 --> 0:11:27.960
And then similarly to what KITA is trying to do,

233
0:11:27.960 --> 0:11:31.000
for example, when it comes to document formats,

234
0:11:31.000 --> 0:11:33.800
you can use poke also to document formats

235
0:11:33.800 --> 0:11:35.360
and protocols in a functional way

236
0:11:35.360 --> 0:11:37.800
because your same documentation, you can use it, you know,

237
0:11:37.800 --> 0:11:40.960
to actually operate with the data.

238
0:11:40.960 --> 0:11:43.680
To do prototyping, to write binary utilities,

239
0:11:43.680 --> 0:11:46.360
to implement filters, and so on.

240
0:11:46.360 --> 0:11:49.000
And then to integrate in other programs, which is very cool.

241
0:11:49.000 --> 0:11:51.880
I will show you in five minutes one example with the debugger,

242
0:11:51.880 --> 0:11:52.400
with GDB.

243
0:11:55.800 --> 0:12:01.400
Now, poke operates in, it can operate on files, memory

244
0:12:01.400 --> 0:12:05.920
buffers, you know the memory of running processes.

245
0:12:05.920 --> 0:12:09.760
There is a collection of IOD devices, right,

246
0:12:09.760 --> 0:12:12.000
which are what you are editing.

247
0:12:12.000 --> 0:12:15.080
But what a poke program or what you have access

248
0:12:15.080 --> 0:12:18.520
from the command line is to a bit addressable IOS space.

249
0:12:18.520 --> 0:12:23.280
We call those IOS spaces in which you can actually map

250
0:12:23.280 --> 0:12:26.280
or you know manipulate different kind of entities, which

251
0:12:26.280 --> 0:12:29.000
are integers and same integers are things, right,

252
0:12:29.000 --> 0:12:29.960
from the poke language.

253
0:12:35.840 --> 0:12:38.040
OK, we all know what bytes are, right?

254
0:12:38.040 --> 0:12:39.800
You will be surprised many people don't.

255
0:12:39.800 --> 0:12:42.880
They are just little numbers in a certain range, right,

256
0:12:42.880 --> 0:12:49.120
from 0 to 255.

257
0:12:49.120 --> 0:12:50.440
So this is the way you know in poke

258
0:12:50.440 --> 0:12:51.560
you have to refer to bytes.

259
0:12:51.560 --> 0:12:53.600
But what I wanted to show you, because I think

260
0:12:53.600 --> 0:12:57.760
it's the interesting part, is that it's the way that you go,

261
0:12:57.760 --> 0:13:01.880
that in poke you have from bytes to actually encode

262
0:13:01.880 --> 0:13:03.600
in integers, right?

263
0:13:03.600 --> 0:13:06.800
So you see here, I don't know if you can see,

264
0:13:06.800 --> 0:13:09.280
you see here the IOD device there,

265
0:13:09.280 --> 0:13:11.320
which is the underlying device that you are editing,

266
0:13:11.320 --> 0:13:12.920
like the file, right?

267
0:13:12.920 --> 0:13:15.360
And then it has bytes, which are little numbers, right,

268
0:13:15.360 --> 0:13:18.440
from 0 to 255 in the range.

269
0:13:18.440 --> 0:13:22.120
And then the IOS space, which is on top of each byte,

270
0:13:22.120 --> 0:13:25.080
of the bytes, is the bit addressable IOS space

271
0:13:25.080 --> 0:13:27.920
that your poke programs actually see.

272
0:13:27.920 --> 0:13:30.440
But we all know that bits, it's actually

273
0:13:30.440 --> 0:13:31.680
a very interesting thing.

274
0:13:31.680 --> 0:13:35.560
Bits exist usually at the hardware level.

275
0:13:35.560 --> 0:13:38.280
Then they disappear until you will recreate them.

276
0:13:38.280 --> 0:13:42.480
You know virtually, you know on top of those byte numbers,

277
0:13:42.480 --> 0:13:43.160
right?

278
0:13:43.160 --> 0:13:44.760
It's very interesting.

279
0:13:44.760 --> 0:13:48.400
So from poke what you see is the bits

280
0:13:48.400 --> 0:13:51.040
that are conceptually on top of the bytes.

281
0:13:51.040 --> 0:13:54.360
And that's the poke type, for example.

282
0:13:54.360 --> 0:13:57.880
This is an unsigned 16 bits integer

283
0:13:57.880 --> 0:14:02.040
mapped in the IOD device at the first byte.

284
0:14:02.040 --> 0:14:03.240
But this is a boring example.

285
0:14:03.240 --> 0:14:05.840
It gets even more interesting.

286
0:14:05.840 --> 0:14:09.560
What we call wired integers, weird integers, right?

287
0:14:09.560 --> 0:14:12.840
So for example, in poke you can operate with 12 bits

288
0:14:12.840 --> 0:14:15.060
unsigned integers, as naturally as you

289
0:14:15.060 --> 0:14:17.800
will do with a 32 bits unsigned integer.

290
0:14:17.800 --> 0:14:23.280
This is quite cool actually, and useful, believe it or not.

291
0:14:23.280 --> 0:14:24.560
Then we have some conventions, you

292
0:14:24.560 --> 0:14:27.000
know, to refer to the bits and everything.

293
0:14:27.000 --> 0:14:31.840
But this integer actually occupies one full byte,

294
0:14:31.840 --> 0:14:37.440
and then half of the next one.

295
0:14:37.440 --> 0:14:41.640
But also you can go to less than one byte, right?

296
0:14:41.640 --> 0:14:42.720
Like in this case.

297
0:14:42.720 --> 0:14:45.360
So you can actually operate with an unsigned integer of five

298
0:14:45.360 --> 0:14:47.880
bits.

299
0:14:47.880 --> 0:14:51.160
And then it doesn't feel like a complete byte.

300
0:14:51.160 --> 0:14:54.320
Obviously, since everything that there is in a computer

301
0:14:54.320 --> 0:14:57.600
is actually bytes, the drivers level, hardware level,

302
0:14:57.600 --> 0:15:01.680
you know, and everywhere, this is an artifact.

303
0:15:01.680 --> 0:15:04.000
But it's a useful one.

304
0:15:04.000 --> 0:15:10.760
And poke also has full support for an aligned stuff too.

305
0:15:10.760 --> 0:15:13.880
So you can work with actually a 16 unsigned integer,

306
0:15:13.880 --> 0:15:16.680
shift to bits in the IOS space.

307
0:15:16.680 --> 0:15:20.160
Can Kaita Yestrak do that?

308
0:15:20.160 --> 0:15:22.000
Yes, we will have to see.

309
0:15:26.520 --> 0:15:29.720
So yeah, so you could obfuscate your file just by shifting

310
0:15:29.720 --> 0:15:32.480
that three bits to the right, for example.

311
0:15:32.480 --> 0:15:33.200
Why not?

312
0:15:33.200 --> 0:15:33.720
Maybe fun.

313
0:15:36.600 --> 0:15:40.120
I included this here not to impress the cat,

314
0:15:40.120 --> 0:15:41.680
but to give you an impression, you

315
0:15:41.680 --> 0:15:43.520
know, the impression that actually poke,

316
0:15:43.520 --> 0:15:45.160
it's a serious problem.

317
0:15:45.160 --> 0:15:47.120
I mean, it's not just, you know, a stupid problem,

318
0:15:47.120 --> 0:15:49.680
you know, that poking at bytes here and there.

319
0:15:49.680 --> 0:15:51.880
We actually take it very seriously.

320
0:15:51.880 --> 0:15:53.800
And you can do this kind of stuff.

321
0:15:53.800 --> 0:15:56.880
And believe it or not, people need this kind of stuff.

322
0:15:56.880 --> 0:15:59.960
The other day in the IRC, we met the politicians,

323
0:15:59.960 --> 0:16:01.960
which is a community of people who are, you know,

324
0:16:01.960 --> 0:16:03.760
dealing with multics.

325
0:16:03.760 --> 0:16:06.720
And you will not believe what they need.

326
0:16:06.720 --> 0:16:08.280
Really, right?

327
0:16:08.280 --> 0:16:12.960
I mean, like nine bits bytes, you know how it's unbelievable.

328
0:16:12.960 --> 0:16:16.040
And we are struggling to actually give the people

329
0:16:16.040 --> 0:16:18.560
what they need because they have rights too.

330
0:16:18.560 --> 0:16:23.040
The multics people have rights too.

331
0:16:23.040 --> 0:16:28.480
Anyway, so the poke sphere, poke is growing and growing.

332
0:16:28.480 --> 0:16:30.320
This started with one simple.

333
0:16:30.320 --> 0:16:33.720
It was always a little bit special, but you know,

334
0:16:33.720 --> 0:16:34.840
a little program.

335
0:16:34.840 --> 0:16:37.160
But it's getting out of hands at the moment.

336
0:16:37.160 --> 0:16:40.680
And in the sense that we have LeapFolk, which

337
0:16:40.680 --> 0:16:42.440
is a shared object.

338
0:16:42.440 --> 0:16:44.880
Obviously, first I made it in a problem,

339
0:16:44.880 --> 0:16:48.120
but the dodgy in one column, I got an asshole.

340
0:16:48.120 --> 0:16:49.240
Put it in a library.

341
0:16:49.240 --> 0:16:50.160
So I did.

342
0:16:50.160 --> 0:16:53.680
So and then LeapFolk is a shared object

343
0:16:53.680 --> 0:16:56.640
that has the poke incremental compiler, the IOS space

344
0:16:56.640 --> 0:16:57.960
support, and everything.

345
0:16:57.960 --> 0:17:00.880
We will see now with GDB as an example how you can actually

346
0:17:00.880 --> 0:17:03.560
make use of it in your own programs.

347
0:17:03.560 --> 0:17:07.400
Then poke is the command line application, right?

348
0:17:07.400 --> 0:17:08.840
Which uses LeapFolk.

349
0:17:08.840 --> 0:17:11.440
But it's just a program, a very small program,

350
0:17:11.440 --> 0:17:17.000
you know, with a prompt, you know, like,

351
0:17:17.000 --> 0:17:22.120
bin LS, load, you can dump bytes, right?

352
0:17:22.120 --> 0:17:23.080
Sorry, here.

353
0:17:23.080 --> 0:17:31.640
And bar elf, elf, 64, file at 0 bytes, you know.

354
0:17:31.640 --> 0:17:34.920
You know, stuff like this.

355
0:17:34.920 --> 0:17:36.080
The command line application.

356
0:17:36.080 --> 0:17:39.560
But all of the logic is actually in the shared object.

357
0:17:39.560 --> 0:17:42.560
Then you have other applications like GDB, which have,

358
0:17:42.560 --> 0:17:43.600
this is not upstream yet.

359
0:17:43.600 --> 0:17:45.640
It's in a branch upstream, but not in master.

360
0:17:45.640 --> 0:17:48.080
But they can actually use LeapFolk

361
0:17:48.080 --> 0:17:49.480
to give you poke capabilities.

362
0:17:49.480 --> 0:17:53.720
I will show you now in a two minute little demo.

363
0:17:53.720 --> 0:17:56.400
There is a poke daemon too that Muhammad will talk about.

364
0:17:56.400 --> 0:17:56.920
Yeah?

365
0:17:56.920 --> 0:17:58.840
Take a half a minute.

366
0:17:58.840 --> 0:18:02.640
Utilities, the pickles, which are the poke programs that

367
0:18:02.640 --> 0:18:05.640
give you the support for some particular format

368
0:18:05.640 --> 0:18:08.120
or some particular domain.

369
0:18:08.120 --> 0:18:10.760
Then there is an MX interface, of course.

370
0:18:10.760 --> 0:18:15.000
Then there is an MX mode for the poke program, VIM for unholy

371
0:18:15.000 --> 0:18:17.120
people for everything.

372
0:18:17.120 --> 0:18:20.920
You know, the poke code in VIM, in VI.

373
0:18:20.920 --> 0:18:24.320
Something called pokelets, and so on, and so on, and so on.

374
0:18:24.320 --> 0:18:27.160
So it's getting fun.

375
0:18:27.160 --> 0:18:28.400
And then the integration.

376
0:18:28.400 --> 0:18:30.640
I'm very, I like this.

377
0:18:36.400 --> 0:18:39.000
You know, there is one problem when people write a program,

378
0:18:39.000 --> 0:18:42.680
they want it to do everything very well.

379
0:18:42.680 --> 0:18:44.200
And that does not work.

380
0:18:44.200 --> 0:18:46.480
So for example, in poke we have some support

381
0:18:46.480 --> 0:18:48.600
for editing the memory of running processes.

382
0:18:48.600 --> 0:18:49.800
We do.

383
0:18:49.800 --> 0:18:51.240
We do.

384
0:18:51.240 --> 0:18:53.800
Well, I could show you, but I don't have time for that.

385
0:18:53.800 --> 0:18:56.880
Because we have an IOD, which is you can specify the process

386
0:18:56.880 --> 0:18:59.680
ID of a process, and then you can edit the running memory,

387
0:18:59.680 --> 0:19:02.320
you know, of the memory of the running process.

388
0:19:02.320 --> 0:19:04.480
But poke is not a debugger.

389
0:19:04.480 --> 0:19:05.480
It's not.

390
0:19:05.480 --> 0:19:08.040
I mean, it doesn't, there is a dwarf pickle,

391
0:19:08.040 --> 0:19:10.360
but you know not to the same extent that a debugger.

392
0:19:10.360 --> 0:19:11.400
You cannot set breakpoints.

393
0:19:11.400 --> 0:19:17.160
You cannot use ptrace to command a process.

394
0:19:17.160 --> 0:19:19.000
But gdb is a debugger.

395
0:19:19.000 --> 0:19:22.680
So gdb is good at debugging, at running processes, and so on.

396
0:19:22.680 --> 0:19:25.800
And poke is good at poking at data, right?

397
0:19:25.800 --> 0:19:27.920
So let's put them together.

398
0:19:27.920 --> 0:19:30.240
So then the combination is good at both.

399
0:19:30.240 --> 0:19:35.760
And this can be achieved by using libpoke.

400
0:19:35.760 --> 0:19:39.480
So I can show you very fast.

401
0:19:39.480 --> 0:19:42.840
So I have the C file.

402
0:19:42.840 --> 0:19:44.080
You see the C file?

403
0:19:44.080 --> 0:19:47.080
I have a C extract frob with an int tag.

404
0:19:47.080 --> 0:19:49.360
Can you see it properly there?

405
0:19:49.360 --> 0:19:51.360
Yes?

406
0:19:51.360 --> 0:19:52.760
Which one?

407
0:19:52.760 --> 0:19:55.640
Which one?

408
0:19:55.640 --> 0:19:58.840
No, I'm not going to address this.

409
0:19:58.840 --> 0:19:59.760
Trust me.

410
0:19:59.760 --> 0:20:01.200
OK.

411
0:20:01.200 --> 0:20:02.920
So there is this extract type.

412
0:20:02.920 --> 0:20:04.120
Then there is this buffer.

413
0:20:04.120 --> 0:20:07.400
There is this db global variable here, and so on, and so on.

414
0:20:07.400 --> 0:20:07.880
Right?

415
0:20:07.880 --> 0:20:10.400
And an int main.

416
0:20:10.400 --> 0:20:14.960
So then I compile that into an aout.

417
0:20:14.960 --> 0:20:18.560
And then I do home.

418
0:20:18.560 --> 0:20:26.320
This is the poke-capable gdb, a.out, break main, run.

419
0:20:26.320 --> 0:20:27.400
Now I am in main, right?

420
0:20:27.400 --> 0:20:28.720
Here.

421
0:20:28.720 --> 0:20:32.680
And then I can use gdb to look at the database here.

422
0:20:32.680 --> 0:20:35.640
You know this db global variable, and so on.

423
0:20:35.640 --> 0:20:38.800
Now this gdb is extended with poke.

424
0:20:38.800 --> 0:20:42.120
So you have a poke command where you can execute any poke code.

425
0:20:42.120 --> 0:20:44.320
Like this, like 2 plus 2 equals 4.

426
0:20:44.320 --> 0:20:46.360
Brilliant.

427
0:20:46.360 --> 0:20:51.040
But here you can do anything that you can do with poke.

428
0:20:51.040 --> 0:20:54.680
So for example, you could say, and poke in this case

429
0:20:54.680 --> 0:20:57.480
is it has access to the memory of the inferior

430
0:20:57.480 --> 0:20:59.760
that you are debugging with udb.

431
0:20:59.760 --> 0:21:03.600
So even if it's multiprocess or multithread, you switch in gdb

432
0:21:03.600 --> 0:21:06.360
and then poke has access to the memory of the inferior.

433
0:21:06.360 --> 0:21:13.120
So what kind of things you can do?

434
0:21:13.120 --> 0:21:14.320
Well, anything.

435
0:21:14.320 --> 0:21:19.520
I mean, what is the address in gdb of this global variable

436
0:21:19.520 --> 0:21:20.320
here?

437
0:21:20.320 --> 0:21:22.240
Sorry.

438
0:21:22.240 --> 0:21:23.720
That is the address.

439
0:21:23.720 --> 0:21:26.880
So with poke, you could access to that address.

440
0:21:26.880 --> 0:21:31.760
But you have a command which is poke at types, which

441
0:21:31.760 --> 0:21:36.480
is you are telling gdb to make poke aware of all the types

442
0:21:36.480 --> 0:21:40.360
known to gdb at this point in time.

443
0:21:40.360 --> 0:21:42.920
So the type char, the char type int,

444
0:21:42.920 --> 0:21:44.960
destruct prop that we saw before.

445
0:21:44.960 --> 0:21:51.200
And then this translated into poke type definitions

446
0:21:51.200 --> 0:21:53.400
for the key-valent gdb types.

447
0:21:53.400 --> 0:21:56.280
This means that you can go from btf, from ctf, from door,

448
0:21:56.280 --> 0:21:59.800
from any debugging format that gdb understands to poke types

449
0:21:59.800 --> 0:22:02.400
while you are using gdb in this way.

450
0:22:02.400 --> 0:22:07.960
Now, poke now has access to the memory of the inferior.

451
0:22:07.960 --> 0:22:12.440
So we could do, for example, and those are poke expressions,

452
0:22:12.440 --> 0:22:13.000
right?

453
0:22:13.000 --> 0:22:16.520
extract prop at where?

454
0:22:16.520 --> 0:22:18.800
And you can use something we call alien tokens,

455
0:22:18.800 --> 0:22:22.680
which is the address of the gdb symbol db, which

456
0:22:22.680 --> 0:22:24.360
is the variable, right?

457
0:22:24.360 --> 0:22:26.120
And this is the poke extract.

458
0:22:26.120 --> 0:22:28.400
This is not a gdb value.

459
0:22:28.400 --> 0:22:33.840
This is a poke extract, which is poking at inferior memory.

460
0:22:33.840 --> 0:22:35.000
And you, of course, can write.

461
0:22:35.000 --> 0:22:36.680
You can do whatever you want.

462
0:22:36.680 --> 0:22:38.240
You can load pickles.

463
0:22:38.240 --> 0:22:40.040
Why is this useful for?

464
0:22:40.040 --> 0:22:42.360
Well, imagine you are debugging a program that

465
0:22:42.360 --> 0:22:45.440
is some sort of router for TCP.

466
0:22:45.440 --> 0:22:47.920
So the program itself, you have TCP packets

467
0:22:47.920 --> 0:22:49.280
and some buffers in the program.

468
0:22:49.280 --> 0:22:50.760
But the program itself doesn't need

469
0:22:50.760 --> 0:22:54.480
to understand the payload of what it is transporting.

470
0:22:54.480 --> 0:22:56.440
But imagine that you want to take a look at what

471
0:22:56.440 --> 0:22:58.840
is going on there, right?

472
0:22:58.840 --> 0:23:01.240
So then you don't have the Dorf definitions

473
0:23:01.240 --> 0:23:05.160
of the structures that are in the buffer in the payload.

474
0:23:05.160 --> 0:23:06.880
But with poke, you just load your pickle

475
0:23:06.880 --> 0:23:09.440
or you are right your own, and you can poke at it

476
0:23:09.440 --> 0:23:14.280
from gdb in the buffer of the running process, for example.

477
0:23:14.280 --> 0:23:16.440
So this is one example of application.

478
0:23:19.560 --> 0:23:23.440
This is 400 lines of C, the integration using lead poke.

479
0:23:23.440 --> 0:23:24.480
It's very nice.

480
0:23:24.480 --> 0:23:25.920
You know it's easy.

481
0:23:25.920 --> 0:23:28.160
Another example, which is work in progress,

482
0:23:28.160 --> 0:23:30.440
and I can't wait to get this finished,

483
0:23:30.440 --> 0:23:35.320
is basically to add to the assembler a dot poke directive.

484
0:23:35.320 --> 0:23:41.200
Because you know those dot war, dot byte, and so on directives

485
0:23:41.200 --> 0:23:42.800
in the assembler?

486
0:23:42.800 --> 0:23:45.040
They are not portable.

487
0:23:45.040 --> 0:23:47.160
And this is a pain in the ass.

488
0:23:47.160 --> 0:23:49.360
Because when you have to actually, for example,

489
0:23:49.360 --> 0:23:52.360
test Dorf or test, you know, that kind of things,

490
0:23:52.360 --> 0:23:54.880
then they are not portable.

491
0:23:54.880 --> 0:23:58.520
I know it's amazing, but they are not portable.

492
0:23:58.520 --> 0:24:00.720
So see, for example, that.

493
0:24:00.720 --> 0:24:03.400
This is a real example of something I found.

494
0:24:03.400 --> 0:24:05.680
I will not tell where.

495
0:24:05.680 --> 0:24:11.160
Of some people who are actually embedding

496
0:24:11.160 --> 0:24:14.680
some sort of executables inside other sections of some

497
0:24:14.680 --> 0:24:15.200
of the stuff.

498
0:24:15.200 --> 0:24:19.240
This is a video games, you know, kids.

499
0:24:19.240 --> 0:24:20.960
They do these kind of things.

500
0:24:20.960 --> 0:24:26.680
And that is a struct, in theory, of what?

501
0:24:26.680 --> 0:24:28.520
Of some heater, right?

502
0:24:28.520 --> 0:24:30.720
For the PlayStation or whatever.

503
0:24:30.720 --> 0:24:33.440
Well, compare.

504
0:24:33.440 --> 0:24:34.440
You see?

505
0:24:34.440 --> 0:24:37.640
So once we have the integration in the assembler,

506
0:24:37.640 --> 0:24:41.960
then you will be able to load the PSXX pickle.

507
0:24:41.960 --> 0:24:44.080
It will be a small one where you define, you know,

508
0:24:44.080 --> 0:24:46.480
that structure of this executable.

509
0:24:46.480 --> 0:24:49.080
And then you could poke at assembly time,

510
0:24:49.080 --> 0:24:50.640
you know, like that too.

511
0:24:50.640 --> 0:24:53.560
And accessing gas assembler symbols,

512
0:24:53.560 --> 0:24:55.560
you know, using alien tokens, like we saw you

513
0:24:55.560 --> 0:24:58.080
could do with GDB as well.

514
0:24:58.080 --> 0:25:00.000
So this is another example of integration.

515
0:25:03.520 --> 0:25:04.280
Yeah.

516
0:25:04.280 --> 0:25:06.520
So we are on these kind of things now.

517
0:25:06.520 --> 0:25:10.320
We are looking into parasiting other programs, you know,

518
0:25:10.320 --> 0:25:13.400
and incorporating lip poking them.

519
0:25:13.400 --> 0:25:17.840
So they do all the boring work, and we do the fun one.

520
0:25:17.840 --> 0:25:20.440
OK.

521
0:25:20.440 --> 0:25:22.880
So what's the current status of the program?

522
0:25:22.880 --> 0:25:28.840
We just released the POC 3.0 a few days ago.

523
0:25:28.840 --> 0:25:32.640
Up to now, we were doing one major release every year,

524
0:25:32.640 --> 0:25:36.680
and we had a maintenance branch.

525
0:25:36.680 --> 0:25:38.560
But people are not happy.

526
0:25:38.560 --> 0:25:39.440
Why?

527
0:25:39.440 --> 0:25:45.160
Because it was too long, and the difference between POC 2

528
0:25:45.160 --> 0:25:46.920
and POC 3, it was too big.

529
0:25:46.920 --> 0:25:48.240
It was too much.

530
0:25:48.240 --> 0:25:52.080
And actually, we released the POC 2.0, for example.

531
0:25:52.080 --> 0:25:54.640
And in two weeks, we have forgotten about it already,

532
0:25:54.640 --> 0:25:56.120
because we are so happy, you know,

533
0:25:56.120 --> 0:25:59.320
and so excited with the main branch.

534
0:25:59.320 --> 0:26:03.280
So now we are committing to release two big major releases

535
0:26:03.280 --> 0:26:04.160
every year.

536
0:26:04.160 --> 0:26:05.760
Let's see if we can actually do that.

537
0:26:09.160 --> 0:26:14.640
The development, we are old GNU P spots, right?

538
0:26:14.640 --> 0:26:18.400
So we don't use GitHub or anything like that.

539
0:26:18.400 --> 0:26:20.640
So we use a mailing list, and you

540
0:26:20.640 --> 0:26:24.240
send your patch to the mailing list in Unity format,

541
0:26:24.240 --> 0:26:26.360
and so on and so on, right?

542
0:26:26.360 --> 0:26:29.880
And well, that is the website of the project.

543
0:26:29.880 --> 0:26:32.400
We have a Git repository, obviously.

544
0:26:32.400 --> 0:26:34.880
We have a mailing list, a development mailing list.

545
0:26:34.880 --> 0:26:39.040
We have a very nice build box at sourceware.

546
0:26:39.040 --> 0:26:42.800
Thank you very much to the sourceware overseers.

547
0:26:42.800 --> 0:26:45.000
They are doing a great job maintaining

548
0:26:45.000 --> 0:26:47.640
the infrastructure of many GNU programs, including

549
0:26:47.640 --> 0:26:50.400
Polk and also the toolchain, GCC and the Ellipse and so on,

550
0:26:50.400 --> 0:26:51.960
for many years.

551
0:26:51.960 --> 0:26:56.000
And also, we have a pipeline hosted at GitLab

552
0:26:56.000 --> 0:26:57.520
that Bruno Heibel maintains.

553
0:26:57.520 --> 0:27:00.280
And I have no idea how it works.

554
0:27:00.280 --> 0:27:03.040
It's not clear to me what even a pipeline is in that context,

555
0:27:03.040 --> 0:27:04.000
but it's green.

556
0:27:04.000 --> 0:27:05.640
So I guess it's good.

557
0:27:08.280 --> 0:27:11.920
We have a community website.

558
0:27:11.920 --> 0:27:13.400
It's called Polkology.

559
0:27:13.400 --> 0:27:17.280
And we try to get practical information there,

560
0:27:17.280 --> 0:27:20.280
like how can you write your pickles and so on.

561
0:27:20.280 --> 0:27:26.880
And also, I have a blog in my website, where sometimes I

562
0:27:26.880 --> 0:27:30.880
publish small articles, like also with practical stuff.

563
0:27:30.880 --> 0:27:34.480
So how can you do, for example, implementing sparse tables

564
0:27:34.480 --> 0:27:38.480
using Polk or accessing them stuff?

565
0:27:38.480 --> 0:27:43.520
We want to be friendly to users.

566
0:27:43.520 --> 0:27:47.680
And now, starting now, in Polk, we

567
0:27:47.680 --> 0:27:54.160
had in the Polk source distribution, GNU Hacks Polk,

568
0:27:54.160 --> 0:27:59.960
we had a pickles directory with a lot of pickles, right?

569
0:27:59.960 --> 0:28:07.720
Like for P, for L, for DOR, for BTF, for this, for that.

570
0:28:07.720 --> 0:28:12.640
Some instructions said RISC-V, BTF.

571
0:28:12.640 --> 0:28:14.520
But this is getting crowded.

572
0:28:14.520 --> 0:28:18.000
And actually, some pickles are big and complex enough

573
0:28:18.000 --> 0:28:21.920
to actually need their own releases,

574
0:28:21.920 --> 0:28:23.800
so you can have several versions that

575
0:28:23.800 --> 0:28:25.300
work with the same version of Polk.

576
0:28:25.300 --> 0:28:28.680
So we are basically putting some of the pickles

577
0:28:28.680 --> 0:28:30.960
in separated packages.

578
0:28:30.960 --> 0:28:34.400
And that's the case of the ELF pickle and the DORF pickle.

579
0:28:34.400 --> 0:28:36.720
So for example, the ELF pickles, now

580
0:28:36.720 --> 0:28:38.560
they are distributed separately.

581
0:28:38.560 --> 0:28:40.160
Have not made the first release yet,

582
0:28:40.160 --> 0:28:42.920
but they are in the git repository.

583
0:28:42.920 --> 0:28:47.480
They have their own manual and so on, and the DORF pickles

584
0:28:47.480 --> 0:28:48.320
as well.

585
0:28:48.320 --> 0:28:50.040
Those are the first ones.

586
0:28:50.040 --> 0:28:52.840
We want to get the P-Cov support because it's

587
0:28:52.840 --> 0:28:55.760
a huge fat monster, that one.

588
0:28:55.760 --> 0:29:00.200
We want to put it also in its own package.

589
0:29:00.200 --> 0:29:03.200
And also, with nice manuals, I have

590
0:29:03.200 --> 0:29:07.000
to show you this because it is such a pain to do it

591
0:29:07.000 --> 0:29:08.880
that you have to brag about it.

592
0:29:08.880 --> 0:29:14.400
So this is the Polk manual, the GNU Polk manual.

593
0:29:14.400 --> 0:29:17.400
And then when you install the pickles packages,

594
0:29:17.400 --> 0:29:20.960
like Polk DORF and Polk ELF, and here you

595
0:29:20.960 --> 0:29:28.840
have a nicely documented pickles and everything.

596
0:29:28.840 --> 0:29:31.960
And the source distribution.

597
0:29:31.960 --> 0:29:32.480
Sorry?

598
0:29:32.480 --> 0:29:35.480
You use man pages, not the menu.

599
0:29:35.480 --> 0:29:38.040
Well, well.

600
0:29:38.040 --> 0:29:39.640
Oh, well.

601
0:29:39.640 --> 0:29:43.000
We are generating man pages from the tech info.

602
0:29:47.320 --> 0:29:48.760
Yeah.

603
0:29:48.760 --> 0:29:51.240
Then actually, the idea is to use the ELF pickle

604
0:29:51.240 --> 0:29:53.120
because we are new, writing pickles,

605
0:29:53.120 --> 0:29:55.080
because Polk is sort of new, right?

606
0:29:55.080 --> 0:30:00.400
So we are trying to discover our way forward.

607
0:30:00.400 --> 0:30:07.360
But the Polk ELF pickles is sort of the canonical example.

608
0:30:07.360 --> 0:30:09.440
We are using it that way.

609
0:30:09.440 --> 0:30:11.080
We are writing it very carefully.

610
0:30:11.080 --> 0:30:13.120
So if you want to write a complex pickle,

611
0:30:13.120 --> 0:30:13.880
you can look at it.

612
0:30:20.680 --> 0:30:22.200
This is it.

613
0:30:22.200 --> 0:30:24.080
I am so sorry that they could not give you

614
0:30:24.080 --> 0:30:28.840
an actual taste of how this program is.

615
0:30:28.840 --> 0:30:30.240
But there is no time for that.

616
0:30:30.240 --> 0:30:32.280
And there are other videos in the internet

617
0:30:32.280 --> 0:30:35.360
that they have done already.

618
0:30:35.360 --> 0:30:38.120
And then if you want to join the development,

619
0:30:38.120 --> 0:30:40.440
read, please read the hacking file,

620
0:30:40.440 --> 0:30:42.040
because we took the effort of writing it.

621
0:30:42.040 --> 0:30:42.960
It's huge.

622
0:30:42.960 --> 0:30:44.800
It has a lot of good information.

623
0:30:44.800 --> 0:30:49.520
And absolutely no one reads it.

624
0:30:49.520 --> 0:30:51.080
So thank you very much.

625
0:30:51.080 --> 0:31:01.720
Thanks.

