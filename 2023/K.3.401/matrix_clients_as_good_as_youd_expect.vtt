WEBVTT

00:00.000 --> 00:06.900
All right, well, hello everyone.

00:06.900 --> 00:08.680
You'll notice I'm not Ben, this is Ben.

00:08.680 --> 00:09.680
Hi, I'm Ben.

00:09.680 --> 00:14.440
There's three of us here to talk to you about different things, all about improving clients

00:14.440 --> 00:19.120
and making them as fast as you would normally expect them to be.

00:19.120 --> 00:21.000
So first of all, my name is Keegan.

00:21.000 --> 00:23.440
I'm going to be talking about sign sync.

00:23.440 --> 00:29.440
And then you've got Ben going to talk about the Rust SDK and Maro about Element X.

00:29.440 --> 00:31.960
So first of all, sign sync and a bit about myself.

00:31.960 --> 00:35.200
I'm a staff software engineer at Element.

00:35.200 --> 00:39.800
And I've worked on many different projects over the years and more recently working on

00:39.800 --> 00:43.080
things like Dendrite and Peer-to-Peer and sign sync.

00:43.080 --> 00:45.440
But first of all, what even is sign sync?

00:45.440 --> 00:52.920
So for context, sign sync, the current sync mechanism in Matrix is really, really slow.

00:52.920 --> 00:58.480
So if you have, you know, you go and open up your mobile app after a weekend away or

00:58.480 --> 01:00.240
something like that, it takes a little while to sync.

01:00.240 --> 01:04.880
It could take 30 seconds or a minute, depending on how many rooms are on your account.

01:04.880 --> 01:07.480
And this is kind of bad, right?

01:07.480 --> 01:10.160
We'd like it to sync instantly.

01:10.160 --> 01:13.560
And the whole point of sign sync is trying to make that happen, trying to make it sync

01:13.560 --> 01:15.360
instantly or virtually instantly.

01:15.360 --> 01:18.800
There was a talk last year on the online FOSDEM.

01:18.800 --> 01:22.720
If you want to know more information about the deep dive of how sign sync works, and

01:22.720 --> 01:24.880
there's a QR code there.

01:24.880 --> 01:29.240
But I'm not going to be covering too much detail about how sign sync works, other than

01:29.240 --> 01:34.280
enough to kind of fill in the gaps if you have no idea what this is.

01:34.280 --> 01:39.440
So at a high level, sign sync works by sorting and filtering.

01:39.440 --> 01:43.080
So you can see here, you've got all the rooms on the user's account.

01:43.080 --> 01:46.880
And then you can filter that set of rooms down in some way.

01:46.880 --> 01:50.480
So for example, you could filter it based on like, I want encrypted rooms or I want

01:50.480 --> 01:52.360
DM rooms, things like that.

01:52.360 --> 01:55.240
And then you can apply some sort of sorting operation to them.

01:55.240 --> 02:00.720
So you might say, sort them by the room name, or you could say, sort by recency.

02:00.720 --> 02:06.000
So like the last timestamp in the room or by the number of notification counts, number

02:06.000 --> 02:09.920
of unread messages and stuff that mention your name and that sort of thing.

02:09.920 --> 02:16.040
And then you can request the first five rooms, 10 rooms, 20 rooms, and things like that.

02:16.040 --> 02:19.920
Also the rooms themselves, you can filter the room state using sign sync.

02:19.920 --> 02:23.200
So in normal sync, you will go and get all of the room state.

02:23.200 --> 02:26.360
And if there's a lot of room state, that's not great.

02:26.360 --> 02:30.960
So in sign sync, you can specify, I'm only interested in like the topic of the room and

02:30.960 --> 02:32.280
whether it's encrypted or not.

02:32.280 --> 02:35.440
And that's it.

02:35.440 --> 02:39.120
This is a pretty big change to how matrix works today.

02:39.120 --> 02:43.680
So how is this actually going to, like how are we actually going to do this in practice?

02:43.680 --> 02:48.340
So in practice, there is a go process, which is the sign sync proxy, which I've been working

02:48.340 --> 02:55.360
on for over a year now, which has a Postgres database attached and it will go and do sync

02:55.360 --> 03:01.000
V2 requests on your behalf to an upstream server.

03:01.000 --> 03:06.320
It could be Synapse, could be Dendrite, whatever, it doesn't really matter, it could be conduit.

03:06.320 --> 03:11.860
And the important thing here is that this proxy exposes a sign sync API.

03:11.860 --> 03:18.000
So it exposes a new endpoint, a new sync endpoint, and then a client can go and try the, you

03:18.000 --> 03:21.560
can actually try the sign sync API and see how it feels to them.

03:21.560 --> 03:25.400
So they don't need to have a particular implementation on Synapse.

03:25.400 --> 03:27.680
So we'll wait for these implementations to land.

03:27.680 --> 03:33.180
You can try it on your own server if you run a proxy.

03:33.180 --> 03:36.720
In terms of a protocol level, what this looks like is you can see here, you've got like

03:36.720 --> 03:41.680
some lists, it's a list subject, and then you can specify things like things we were

03:41.680 --> 03:42.680
talking about before.

03:42.680 --> 03:46.160
So you can say you've got the ranges there, you've got, so that's how many like the top

03:46.160 --> 03:51.840
end rooms that you want, the sort ordering that you want, as well as any filters you

03:51.840 --> 03:52.840
apply here.

03:52.840 --> 03:56.480
And here you can see we're filtered by is-dm-true, and that's going to be used to populate the

03:56.480 --> 03:59.840
people tab, say, on the web.

03:59.840 --> 04:02.060
You also have these things with room subscriptions.

04:02.060 --> 04:07.200
They are kind of like the room lists, but this is when you know the specific room ID.

04:07.200 --> 04:13.760
So if you follow a permalink, which may include the room ID, or if you refresh the page and

04:13.760 --> 04:19.320
you know that this person was currently viewing this room, that room may not be in this list,

04:19.320 --> 04:20.320
right?

04:20.320 --> 04:24.080
So you would need to subscribe to that room directly because you know the room ID.

04:24.080 --> 04:28.120
And typically, though, as well, the kinds of information you want here is different.

04:28.120 --> 04:33.680
So in here, we are requesting all the state in the room and a much higher timeline limit

04:33.680 --> 04:39.400
because this is being used to populate the actual full room view.

04:39.400 --> 04:41.440
The response is very similar as well.

04:41.440 --> 04:46.160
So you have a list object here, and then you get a list of room IDs that are used to populate

04:46.160 --> 04:47.760
the correct ordering here.

04:47.760 --> 04:52.760
And then you also have a top-level rooms array, a rooms object, and then that's just the key

04:52.760 --> 04:56.960
value maps where the keys are the room IDs and then the values are all the data that

04:56.960 --> 04:58.760
you requested.

04:58.760 --> 05:05.120
So these all get aggregated together, which I will speak about a bit later.

05:05.120 --> 05:08.760
In terms of what's new, so if you followed SidingSync, then you might be like, okay,

05:08.760 --> 05:12.440
I know all this, but what's actually happened over the past year?

05:12.440 --> 05:14.640
We have clients from SidingSync.

05:14.640 --> 05:16.080
So this is from Element Web.

05:16.080 --> 05:18.360
It's got a nice, scary warning there.

05:18.360 --> 05:19.360
So it's great.

05:19.360 --> 05:23.800
It all works on web, but also it actually works on mobile devices as well, thanks to

05:23.800 --> 05:28.580
the Rust SDK, which I'll leave for Ben to talk about.

05:28.580 --> 05:32.140
So there's also a whole bunch of new extension MSCs.

05:32.140 --> 05:37.520
So extension MSCs are an idea of trying to break up the complexity of SidingSync because

05:37.520 --> 05:42.720
the sync API is by far one of the most, not the most complicated part of the client server

05:42.720 --> 05:46.880
API, and trying to put everything into one MSC is going to be doomed to failure.

05:46.880 --> 05:53.240
So we're trying to specify a core part of the MSC, the core part of what is syncing,

05:53.240 --> 05:58.600
which is the syncing rooms, and working out the sorts and the filter arguments, and then

05:58.600 --> 06:01.720
we're leaving two extensions, all the extra stuff on top.

06:01.720 --> 06:04.640
And the idea is that you can opt into any of these things.

06:04.640 --> 06:08.600
So if your client doesn't do receipts, then great, don't subscribe to receipts.

06:08.600 --> 06:11.040
Don't even enable this extension.

06:11.040 --> 06:13.440
Briefly how these extensions work.

06:13.440 --> 06:17.720
So these two extensions go together because they ultimately are used to make encryption

06:17.720 --> 06:19.120
work in encrypted rooms.

06:19.120 --> 06:22.120
So you can see, well, actually you can't see at all.

06:22.120 --> 06:25.360
Here is an encrypted event.

06:25.360 --> 06:29.240
So there's basically, you have to trust me, there's a psychotext here with lots of gibberish

06:29.240 --> 06:35.880
effectively, and then you need a room key to go decrypt it into your normal text.

06:35.880 --> 06:42.000
The way that works is that you need to get keys via your two device messages.

06:42.000 --> 06:44.680
That's why they go together.

06:44.680 --> 06:51.200
The other thing here is that it implements another MSC called Dropping Sales Sent to

06:51.200 --> 06:52.200
Device Messages.

06:52.200 --> 06:56.360
You can barely see it on here, but this is an output from Postgres, which is trying to

06:56.360 --> 07:03.480
work out how many unread or unacknowledged two device events are there for a given user's

07:03.480 --> 07:04.480
device.

07:04.480 --> 07:07.840
And you might think that might be, say, 100, maybe 1,000 tops.

07:07.840 --> 07:10.640
It turns out this can be a lot.

07:10.640 --> 07:15.720
This is several hundred thousand unread or unacknowledged two device events.

07:15.720 --> 07:20.040
And it turns out when I analyzed a lot of this, this was almost entirely down to room

07:20.040 --> 07:26.320
keys being requested and then either canceled or successfully sent.

07:26.320 --> 07:34.000
So this MSC 3944 basically says, hey, if you request a room key and then you subsequently

07:34.000 --> 07:39.240
cancel that request, you're going to go and delete those two device messages so they don't

07:39.240 --> 07:41.240
just keep stacking up in this way.

07:41.240 --> 07:46.440
And that obviously really helps reduce the amount of bandwidth for sign sync as well.

07:46.440 --> 07:49.000
The other thing we've got is account data.

07:49.000 --> 07:53.520
If you wonder what account data does, if you've ever used the breadcrumbs thing at the top

07:53.520 --> 07:58.040
here on Element Web, that's synchronized using account data.

07:58.040 --> 08:03.400
Also account data is really, really useful for working out accurate notification counts.

08:03.400 --> 08:09.200
So at the bottom here, you can just about see that you've got some messages here.

08:09.200 --> 08:10.400
You've got a message in a timeline.

08:10.400 --> 08:11.400
This is encrypted.

08:11.400 --> 08:14.680
And it says here notification count one.

08:14.680 --> 08:16.360
Notification counts are the gray numbers.

08:16.360 --> 08:19.440
And you've got a highlight count of zero, which is the red number.

08:19.440 --> 08:24.360
And yet on the UI, you can see that it's a red number and it's gone to one.

08:24.360 --> 08:30.960
So some things happened here where the client has worked out that, oh, I should use this

08:30.960 --> 08:33.320
as a highlight count, not a notification count.

08:33.320 --> 08:35.720
It's overridden what the service told it.

08:35.720 --> 08:40.280
And what's happened here is that the client has decrypted the message.

08:40.280 --> 08:47.120
And then it's checked the message to say, hey, is there any app mention or any specific

08:47.120 --> 08:49.080
keywords based on your push rules?

08:49.080 --> 08:53.960
And if that is true, then it knows, ah, OK, I need to actually make this a red highlight

08:53.960 --> 08:57.840
rather than just a normal gray and red count.

08:57.840 --> 08:59.240
And that's done using push rules.

08:59.240 --> 09:03.840
And push rules is stored as an account data.

09:03.840 --> 09:06.120
Final two ones are receipts and typing.

09:06.120 --> 09:08.080
Thank you.

09:08.080 --> 09:12.520
So hopefully you know what receipts and typing notifications are.

09:12.520 --> 09:18.400
And the main changes for sliding sync is that the receipts are lazily loaded.

09:18.400 --> 09:21.320
So you might think, well, what does that mean exactly?

09:21.320 --> 09:28.240
Well, if you get a time limit of 10, then you will get those 10 events and then you

09:28.240 --> 09:32.640
will get the receipts for those 10 events and you won't get receipts for any other events.

09:32.640 --> 09:36.160
And you might think, hasn't it always done this?

09:36.160 --> 09:37.600
Well, not really.

09:37.600 --> 09:41.400
So here's some JQ for Matrix HQ, which is this room ID.

09:41.400 --> 09:47.520
And it's just pulling out the receipt EDU and then kind of checking roughly how many

09:47.520 --> 09:48.520
receipts there are.

09:48.520 --> 09:50.320
And you know, Matrix HQ is quite a big room.

09:50.320 --> 09:52.120
So you might think, you know, 100,000.

09:52.120 --> 09:56.760
No, there's quite a lot of rooms, quite a lot of receipts in there.

09:56.760 --> 09:59.240
And this is not great from a bandwidth perspective, right?

09:59.240 --> 10:06.040
We don't want to be sending 53,000 read receipts, particularly for events which you are unlikely

10:06.040 --> 10:07.040
to ever view, right?

10:07.040 --> 10:12.040
Because this could be, these could be for events that occurred like a year ago.

10:12.040 --> 10:14.120
So starting sync also fixes that.

10:14.120 --> 10:20.640
So with all these performance optimizations, a very large account with 4,000 rooms can

10:20.640 --> 10:27.480
take less than a second to actually sync, which is down from 15 minutes on SyncV2.

10:27.480 --> 10:31.360
So very happy with that, but it's still not really good enough where, you know, we're

10:31.360 --> 10:33.720
trying to go big or go home kind of way, kind of thing.

10:33.720 --> 10:37.600
So we want to make it even faster.

10:37.600 --> 10:39.160
So it is literally instant.

10:39.160 --> 10:41.840
You don't want to have to be waiting a couple of seconds.

10:41.840 --> 10:45.280
It should just kind of open up, just like most other best-trained clients, you can just

10:45.280 --> 10:47.400
open them up and they just work.

10:47.400 --> 10:52.320
The problem is that things are going to get a lot worse here, which I will talk about

10:52.320 --> 10:54.280
in a moment.

10:54.280 --> 11:01.440
So we've added in a bunch of tracing to the proxy server.

11:01.440 --> 11:05.040
So things like, this is runtime trace.

11:05.040 --> 11:06.720
So you can see exactly the control flow.

11:06.720 --> 11:11.400
There's some spans there, and you can see various optimizations that were done.

11:11.400 --> 11:15.240
So this is identifying so bits of code.

11:15.240 --> 11:17.280
Lots and lots and lots of commits.

11:17.280 --> 11:19.280
Sometimes it's just you forgot to add an index.

11:19.280 --> 11:22.840
Sometimes you should be doing things in bulk instead of doing things sequentially.

11:22.840 --> 11:26.560
So lots of work has gone into this.

11:26.560 --> 11:32.080
And also, if you were going for 100 milliseconds, kind of aiming for 100 milliseconds, the actual

11:32.080 --> 11:36.360
amount of data you send is important because this starts to become quite a large factor

11:36.360 --> 11:39.240
in the total time it takes.

11:39.240 --> 11:44.840
We can do simple things like de-duplication and enabling gzip for large responses, which

11:44.840 --> 11:52.140
we now do, and as well as that we can aggressively cache things in memory wherever possible.

11:52.140 --> 11:55.480
So we don't have to query the database when clients send a request.

11:55.480 --> 12:01.840
So there's three levels of caching involved at the proxy level, whereas a global cache

12:01.840 --> 12:09.480
which contains information which doesn't change for any user, it's a constant.

12:09.480 --> 12:15.240
So things like the number of joined users in a room, it's the same if you're Alice or

12:15.240 --> 12:16.240
if you're Bob.

12:16.240 --> 12:17.760
It's always going to be the same.

12:17.760 --> 12:21.960
Whereas things like the user cache or things like what's the unread count for this room,

12:21.960 --> 12:24.360
well, that's going to change depending on which user.

12:24.360 --> 12:29.520
And then the connections are things like which room subscriptions have you got or which lists

12:29.520 --> 12:33.640
like what are your top end rooms or whatever your sliding window is.

12:33.640 --> 12:38.720
Interesting thing to note here is that the room name is actually not global data.

12:38.720 --> 12:43.520
The data that's used to calculate the room name is global data and is the same for everyone,

12:43.520 --> 12:47.720
but the room name itself isn't because of DMs.

12:47.720 --> 12:51.280
So if you have a DM with Alice and Bob, then from Alice's point of view the room name is

12:51.280 --> 12:54.160
Bob, but from Bob's point of view the room name is Alice.

12:54.160 --> 12:59.400
So just very, lots of optimizations have been done.

12:59.400 --> 13:04.600
So with all of this, we're now getting less than 100 milliseconds, which is what we wanted,

13:04.600 --> 13:10.520
but it's still not good enough because things are going to get a lot worse because clients,

13:10.520 --> 13:14.600
really, it's all up to the clients because clients are not flying support and they want

13:14.600 --> 13:15.680
instant access.

13:15.680 --> 13:20.120
They don't want to have to be having to do a network request to, when they click on a

13:20.120 --> 13:21.280
room they want to just see the list.

13:21.280 --> 13:22.280
They don't want to see a spinner.

13:22.280 --> 13:27.480
And in the best case you have a spinner for half a second maybe and then it loads, which

13:27.480 --> 13:30.640
is not great but maybe acceptable.

13:30.640 --> 13:33.920
But then if you're on a mobile app and you go into a tunnel, then it's just going to

13:33.920 --> 13:36.080
spin it forever and then you're sad.

13:36.080 --> 13:41.040
So users expect these things to work instantly.

13:41.040 --> 13:44.080
And you can, you know, Sizing Sync has ways that you can fix this.

13:44.080 --> 13:48.800
So if you want to go and instantly see the room timeline, that's fine because we can

13:48.800 --> 13:50.000
pre-cache the room timeline.

13:50.000 --> 13:54.760
You can use a higher timeline limit and then you can go and pre-cache that so you see the

13:54.760 --> 14:00.560
room list you click through and immediately you see all the events, at least a screen's

14:00.560 --> 14:02.240
worth of events.

14:02.240 --> 14:05.360
For the other thing, which is you want to scroll the room list instantly and smoothly,

14:05.360 --> 14:10.600
well you can opt out of the sliding windows entirely and you can just request really small

14:10.600 --> 14:14.400
stub information like I just want the avatar, I just want the room name and that's it.

14:14.400 --> 14:19.520
And then you'll know the position, the room name, the avatar and then you can just request

14:19.520 --> 14:20.560
all the rooms entirely.

14:20.560 --> 14:23.720
So that will scale with the number of rooms in the user's account.

14:23.720 --> 14:27.840
But it's, you know, it's possible.

14:27.840 --> 14:31.240
And you can use something like this to say timeline limit of zero.

14:31.240 --> 14:32.680
But there's a problem here, right?

14:32.680 --> 14:37.560
Because you have a timeline limit of 20 on the first one, then a timeline limit of zero.

14:37.560 --> 14:40.120
So you kind of want a bit of both.

14:40.120 --> 14:44.360
So it turns out what clients really want is delayed data delivery.

14:44.360 --> 14:48.320
So the API wasn't originally designed for that a year ago.

14:48.320 --> 14:52.520
So we've made a lot of changes to support this kind of idea of delayed data delivery.

14:52.520 --> 14:55.200
So one of the things is timeline trickling.

14:55.200 --> 14:59.600
So what timeline trickling is, is that you can initially request a set of rooms and you

14:59.600 --> 15:03.440
can say I want only the most recent message in this room.

15:03.440 --> 15:08.240
And then at a later point you can say, okay, now I want the last 10 messages in this room.

15:08.240 --> 15:13.800
And then it will go and effectively back paginate those messages for you.

15:13.800 --> 15:18.360
Likewise the clients want all the rooms in the accounts.

15:18.360 --> 15:22.880
And they want maybe more detail on the rooms that are in the viewport.

15:22.880 --> 15:27.480
So again, you can support this by having two lists effectively.

15:27.480 --> 15:30.960
You've got one list, which is just the visible rooms.

15:30.960 --> 15:35.200
That might have more accurate information for like room previews.

15:35.200 --> 15:39.720
So you got room preview, you might have typing notifications, you might register for typing

15:39.720 --> 15:41.760
notifications in those rooms.

15:41.760 --> 15:46.320
But then you're not really interested in typing notifications for rooms really far down the

15:46.320 --> 15:47.320
list.

15:47.320 --> 15:50.480
In the background you can just have a separate list which just kind of in the background

15:50.480 --> 15:56.880
goes and gets all the other rooms and all the core information that you need.

15:56.880 --> 16:00.440
So this has kind of been a huge trade off, right?

16:00.440 --> 16:06.080
On the one hand you've got sync v2, which is getting everything and is super slow.

16:06.080 --> 16:09.120
But it's got fantastic offline support as a result of that.

16:09.120 --> 16:10.920
And on the other side you've got sliding sync.

16:10.920 --> 16:11.920
It's super fast.

16:11.920 --> 16:14.400
You're only literally getting the data that you need.

16:14.400 --> 16:18.440
But there's compromises to be made there because you have to do network requests all the time

16:18.440 --> 16:21.160
and things can be slower.

16:21.160 --> 16:22.440
There's only so fast you can do.

16:22.440 --> 16:25.120
There's only so much you can optimize the server.

16:25.120 --> 16:29.320
So really I think Element is kind of aiming to do something like that.

16:29.320 --> 16:34.160
So it's mostly kind of sliding sync, but the arch compromises and trade offs that are

16:34.160 --> 16:38.960
being made to try to give a really good offline experience as well.

16:38.960 --> 16:43.200
So in terms of what's next, we need to add threads.

16:43.200 --> 16:46.200
Because there's no threading support at all in sliding sync.

16:46.200 --> 16:51.480
And threads obviously only recently landed and was enabled everywhere.

16:51.480 --> 16:57.480
Threads is complicated because threads are changes fundamental answers to questions like,

16:57.480 --> 16:59.360
is this room unread?

16:59.360 --> 17:03.360
Because normally you could just be like, well, what's your read marker?

17:03.360 --> 17:04.360
What's most recent event?

17:04.360 --> 17:06.200
OK, it must be unread.

17:06.200 --> 17:11.920
Whereas now you could have scenarios where the most recent event in the room is on a

17:11.920 --> 17:12.920
thread.

17:12.920 --> 17:17.200
So if you were just to click on a room and you see the timeline, they're all messages.

17:17.200 --> 17:20.960
But in a thread three days ago, there's actually a newer message.

17:20.960 --> 17:26.880
So adding support for threads is going to be quite tricky to get right.

17:26.880 --> 17:28.860
And we'll have to probably iterate on it quite a lot.

17:28.860 --> 17:30.640
But it is coming.

17:30.640 --> 17:35.160
The other thing we're going to be adding in is this concept called Delta tokens, which

17:35.160 --> 17:39.440
unless you've read the MSC, you'll have no idea what it is.

17:39.440 --> 17:43.960
Basically what Delta tokens are is to, sliding sync has a problem at the moment, the proxy

17:43.960 --> 17:46.120
server, because it has amnesia.

17:46.120 --> 17:50.520
So it will time out your connection if you don't use it for, say, half an hour.

17:50.520 --> 17:52.360
And it will clean up all that in memory state.

17:52.360 --> 17:55.320
All those caches and things get cleaned up.

17:55.320 --> 18:01.800
And the problem is that then when you reconnect, even though your client has stored those rooms

18:01.800 --> 18:06.400
and stored a lot of the timeline and stored a bunch of room state, the proxy server doesn't

18:06.400 --> 18:07.440
know this.

18:07.440 --> 18:09.620
So it's going to resend that information to you.

18:09.620 --> 18:18.600
So the point of Delta tokens is to say, hey, remember me, I already know about these events.

18:18.600 --> 18:23.560
And then those events aren't sent to the client again in duplicate.

18:23.560 --> 18:25.160
Few more API optimizations.

18:25.160 --> 18:31.560
We recently swapped to using lists as keys, which basically means that instead of representing

18:31.560 --> 18:37.480
the requests and response lists as an array of lists, they're now just a big key value

18:37.480 --> 18:42.480
map, which makes it easier because you can then reference an individual list by the list

18:42.480 --> 18:43.480
key name.

18:43.480 --> 18:48.920
So for things like extensions, this is great because you could then have a way of expressing,

18:48.920 --> 18:52.960
I want typing notifications, but only on these named lists.

18:52.960 --> 18:56.520
Whereas before that was very difficult to express.

18:56.520 --> 18:59.680
And we also really want to have comprehensive client support.

18:59.680 --> 19:04.040
It's getting reasonably stable now, and it's certainly very performant.

19:04.040 --> 19:09.080
And element web uses sign sync natively in the JS SDK.

19:09.080 --> 19:12.080
But obviously that doesn't really work for mobile.

19:12.080 --> 19:18.520
And it would be nice to have some sort of SDK that could be used for Android and iOS

19:18.520 --> 19:21.640
and maybe even web at some point.

19:21.640 --> 19:22.640
I think there is.

19:22.640 --> 19:36.160
Yes.

19:36.160 --> 19:39.640
Let's talk about the rest SDK.

19:39.640 --> 19:43.040
So this is, sorry, overall a very technical talk.

19:43.040 --> 19:45.360
You've already noticed that.

19:45.360 --> 19:47.720
But I'm going to lighten up a little bit more.

19:47.720 --> 19:49.360
But first about me, so I'm Ben.

19:49.360 --> 19:50.360
Hi.

19:50.360 --> 19:51.480
My name is the only name in the presentation.

19:51.480 --> 19:53.240
I don't know why.

19:53.240 --> 19:56.200
These guys have more work and show more stuff.

19:56.200 --> 20:02.320
I've led the rust SDK team for the last year for element.

20:02.320 --> 20:07.400
And I've been working in decentralization, decentralized tech for a couple years already.

20:07.400 --> 20:11.320
I worked at Parry Tech before with leading the substrate client team there.

20:11.320 --> 20:16.280
If you know blockchains, it's one of the most favorite blockchain building systems.

20:16.280 --> 20:20.680
I'm going to be working as a technique for actual global where we're building on top

20:20.680 --> 20:25.800
of the rust SDK, an organizing app for NGOs and civil society.

20:25.800 --> 20:28.840
So I've been working in this for over a decade.

20:28.840 --> 20:37.120
You might know me from almost not at all threatening talk I gave at Jason like 2017.

20:37.120 --> 20:41.960
That was already about like, how do you do decentralized privacy first technology.

20:41.960 --> 20:44.920
Enough about me.

20:44.920 --> 20:48.840
Let's talk about, let me tell you a little story.

20:48.840 --> 20:51.680
We're back in 2019, 2020.

20:51.680 --> 20:54.040
And it's the state of the clients.

20:54.040 --> 20:58.800
For the sake of argument, I'm talking about element clients here because I think there's

20:58.800 --> 21:00.600
exceptions to what I'm going to tell you.

21:00.600 --> 21:02.840
But let me tell you two truth and a lie.

21:02.840 --> 21:04.280
And you can tell me if you can spot the lie.

21:04.280 --> 21:10.840
So truth number one, many clients out there don't actually implement end-to-end encryption,

21:10.840 --> 21:15.440
which is pretty sad because it's a very fundamental part of what we're working on.

21:15.440 --> 21:21.000
That is mostly because it's hard even if you use the most widely used library.

21:21.000 --> 21:22.000
That is a C library.

21:22.000 --> 21:25.680
There's always a slightly dated, like a lot of knowledge that has been built up that is

21:25.680 --> 21:31.640
not easy to ingrain in this existing library anymore.

21:31.640 --> 21:35.880
Clients usually implement the entire HTTP or at least most of the state machine around

21:35.880 --> 21:42.760
room, room state, who's allowed to write as well as entire messaging mechanics themselves

21:42.760 --> 21:45.320
in their own language, in their own environment.

21:45.320 --> 21:48.080
Or because we have that, clients are super fast.

21:48.080 --> 21:52.520
It is totally integrated into the system that they are.

21:52.520 --> 21:55.760
And it's just a smooth experience.

21:55.760 --> 22:00.800
I don't have to ask you, you know which one of this is a lie, the cake is a lie.

22:00.800 --> 22:03.000
At this time, enter our hero.

22:03.000 --> 22:04.000
Our hero is Damir.

22:04.000 --> 22:07.400
Damir is working as a crypto dev for Element.

22:07.400 --> 22:08.760
He's a Rust enthusiast.

22:08.760 --> 22:12.360
And he knows the crypto in and out.

22:12.360 --> 22:19.000
He's intending to rewrite a plugin that he's using for an ISC client, which is called WeChat,

22:19.000 --> 22:20.360
that connects to matrix.

22:20.360 --> 22:25.960
Because of simple problems that are limitations in the Python implementation that WeChat offers,

22:25.960 --> 22:29.360
he wants to rewrite it in Rust.

22:29.360 --> 22:31.600
But he doesn't really find a good place to build it on.

22:31.600 --> 22:35.360
This is not an actual representation, but we're going to use it for now.

22:35.360 --> 22:38.000
So he goes out and says, okay, let's write this.

22:38.000 --> 22:39.000
How hard could it be?

22:39.000 --> 22:45.000
He quickly realizes, okay, so the crypto side with the C, I would like to have that in Rust.

22:45.000 --> 22:48.600
I'm going to get that Y in a second.

22:48.600 --> 22:51.560
And he pulls that out later, which is now called Vodosimac.

22:51.560 --> 22:55.640
You might have heard about that, which is our crypto implementation that we're pushing

22:55.640 --> 22:59.800
forward as a live-all mis-deprecate.

22:59.800 --> 23:02.960
But he figures out the stuff around that to make crypto work.

23:02.960 --> 23:07.880
Not the encryption itself, but the entire thing of how do I know which messages to encrypt

23:07.880 --> 23:13.000
with what key, in what room, what if a message comes in and I don't have the encryption key?

23:13.000 --> 23:17.920
All of that state management around that is actually as complicated and as problematic

23:17.920 --> 23:19.680
as the actual crypto.

23:19.680 --> 23:23.760
And that is why a lot of people try to use the crypto, but then fail in doing all of

23:23.760 --> 23:25.560
that, making it a really terrible experience.

23:25.560 --> 23:28.360
And then I drop it and say, oh, let's not do encryption.

23:28.360 --> 23:31.440
That's too hard.

23:31.440 --> 23:35.440
But he continues and pushes on because he really wants that for WeChat and starts out

23:35.440 --> 23:41.240
with what we know as the Rust metrics SDK.

23:41.240 --> 23:43.280
So why did he pick Rust?

23:43.280 --> 23:47.520
I'm not talking in his name, but I'm going to give you some reasons why.

23:47.520 --> 23:53.320
If you heard about Rust before, you probably heard about it because it's the most popular,

23:53.320 --> 23:56.040
most beloved language.

23:56.040 --> 23:59.880
Six years running now on the Stack Overflow system.

23:59.880 --> 24:01.920
So who here has heard about Rust?

24:01.920 --> 24:03.600
All right.

24:03.600 --> 24:04.600
Who has used Rust?

24:04.600 --> 24:05.600
Keep your hands up.

24:05.600 --> 24:06.600
OK.

24:06.600 --> 24:07.600
OK.

24:07.600 --> 24:10.280
That's fairly good.

24:10.280 --> 24:17.160
And while that is definitely true to some degree, like there's a lot of love for that

24:17.160 --> 24:22.680
language, it's even bigger in crypto because encryption, building encryption and building

24:22.680 --> 24:24.640
that safely is really hard.

24:24.640 --> 24:27.800
At the same time, you're not you can't really go for Python or that kind of stuff because

24:27.800 --> 24:30.000
it's, well, too inefficient.

24:30.000 --> 24:34.780
So most information used to you see Rust seemed like such a nice alternative.

24:34.780 --> 24:37.840
So inside crypto and encryption, Rust is already a big thing.

24:37.840 --> 24:41.600
So that's probably the main reason he chose it because he wanted to use it.

24:41.600 --> 24:49.180
But there's also a good amount of actual reasons why Rust makes sense to build this with.

24:49.180 --> 24:53.960
This is a screenshot of the website of RustLang.org from yesterday.

24:53.960 --> 24:59.520
I'm going to break it down a little more because we have to understand one key thing.

24:59.520 --> 25:04.400
Rust was invented by Mozilla to build a new browser.

25:04.400 --> 25:06.200
They had Firefox 2010, 2011.

25:06.200 --> 25:08.720
They were like, there's so much C, C++ in here.

25:08.720 --> 25:10.600
It's so complicated.

25:10.600 --> 25:14.120
We barely know how we can change stuff ourselves.

25:14.120 --> 25:17.760
And it's like it's still Netscape code base in there, right?

25:17.760 --> 25:20.240
Like it's like 20 years of stuff.

25:20.240 --> 25:21.920
So they were like, let's build a new browser.

25:21.920 --> 25:26.680
And it's called the server project as a recent research project.

25:26.680 --> 25:30.560
And through that, they realized like there's certain things we'd like to have for new languages.

25:30.560 --> 25:35.080
And they started building their own language to build a browser.

25:35.080 --> 25:36.200
That project still exists.

25:36.200 --> 25:38.640
It's server.org today.

25:38.640 --> 25:42.880
Mozilla has handed off the management to the Linux Foundation.

25:42.880 --> 25:43.880
It's still a research project.

25:43.880 --> 25:45.800
I recommend if you want to start with Rust.

25:45.800 --> 25:49.720
That is a really good community to start with.

25:49.720 --> 25:59.120
But the key point here is that it was a language built by practitioners for practitioners.

25:59.120 --> 26:04.200
They didn't set out to say like, hey, let's make a theoretically proven language.

26:04.200 --> 26:06.760
Let's make a really beautiful looking language.

26:06.760 --> 26:08.240
All of these ideals were not existing.

26:08.240 --> 26:12.280
They wanted a language that they can use that they're more efficient in building a browser

26:12.280 --> 26:13.720
with, which is already quite hard.

26:13.720 --> 26:17.520
If you say like, I want to build a browser, that's a lot of stuff you have to do.

26:17.520 --> 26:23.680
And so they set out to build this is the previous claim that Rust had, which is a type safe

26:23.680 --> 26:24.680
systems language.

26:24.680 --> 26:30.000
So systems language like level of C, C++ with zero cost abstractions.

26:30.000 --> 26:34.000
Built by practitioners.

26:34.000 --> 26:35.360
So it's a modern language.

26:35.360 --> 26:38.560
It reached 1.0 in 2015.

26:38.560 --> 26:41.480
It is S, B, D, S, C, and C++.

26:41.480 --> 26:44.320
Sometimes it's B, D, R. The most famous example is rip-grab.

26:44.320 --> 26:48.960
If you go for that, it's like 10 times faster than the next comparable implementation to

26:48.960 --> 26:52.800
grab over a lot of files.

26:52.800 --> 26:57.080
And it does all of that without any garbage collector or VM.

26:57.080 --> 27:00.280
Again, the goal is to have zero cost abstractions.

27:00.280 --> 27:03.720
Any abstraction that Rust gives you and a lot of the abstractions that the community

27:03.720 --> 27:09.280
also gives you in their own crates has the idea of like, we can lower that down at compile

27:09.280 --> 27:10.560
time to nothing.

27:10.560 --> 27:12.480
It doesn't actually exist.

27:12.480 --> 27:14.600
Or like garbage collector cycles, no.

27:14.600 --> 27:16.280
VM below that, no.

27:16.280 --> 27:18.680
It should work on an embedded system.

27:18.680 --> 27:23.480
That rules out a lot of places.

27:23.480 --> 27:27.040
But all of that without memory safety bugs.

27:27.040 --> 27:31.160
Just probably the biggest concern for any security researcher.

27:31.160 --> 27:36.720
Like buffer overflows are non-existent effectively in Rust.

27:36.720 --> 27:40.600
Very famously, like a couple of days ago, Google announced that since they have been

27:40.600 --> 27:48.400
shipping Rust in Android, I think a third of the code that they ship in Android is now

27:48.400 --> 27:50.280
Rust.

27:50.280 --> 27:55.280
Their amount of memory bugs has halved even lesser than that.

27:55.280 --> 27:59.480
And that is their main concern so far.

27:59.480 --> 28:01.400
Most of that happens at compile time.

28:01.400 --> 28:05.440
So at compile time, the compiler is a little more annoying and telling you, like, you need

28:05.440 --> 28:07.160
to tell me where this memory is going to go.

28:07.160 --> 28:15.000
I said in this thread on that thread, but it also means that after it compiles, it runs.

28:15.000 --> 28:18.720
But again, because it's built from practitioners for practitioners, it's not just about the

28:18.720 --> 28:19.720
language.

28:19.720 --> 28:22.600
Like, you need to be able to actually work with that.

28:22.600 --> 28:26.720
That means that it's very famous for its very good tooling.

28:26.720 --> 28:32.680
It has a really nice compiler that very famously when people jump from other languages and

28:32.680 --> 28:35.800
they run through the first error, they see the compiler complaining, they switch immediately

28:35.800 --> 28:37.320
back to look at the code.

28:37.320 --> 28:38.320
In Rust, you don't do that.

28:38.320 --> 28:42.200
The compiler is probably going to tell you what you need to change, or at least what

28:42.200 --> 28:45.280
things you need to change to make that run.

28:45.280 --> 28:46.880
That is a completely behavioral change.

28:46.880 --> 28:51.400
The compiler is your friend telling you, look, you need to just tell me, is that in this

28:51.400 --> 28:52.400
thread or that thread?

28:52.400 --> 28:55.400
This is what I assume you would want to do.

28:55.400 --> 28:58.600
It can be wrong, of course, because you have higher level abstraction that you need to

28:58.600 --> 28:59.760
work with.

28:59.760 --> 29:01.200
But overall, it's pretty good.

29:01.200 --> 29:08.160
The same for Cargo, which is the package management system and build system, but also Rust up,

29:08.160 --> 29:17.800
which is the meta version of organizing your own Rust installation.

29:17.800 --> 29:25.760
All of that, it provides with being built against the LLVM backend, which means it's

29:25.760 --> 29:27.880
more or less instantly portable.

29:27.880 --> 29:33.760
When you can run it and you don't have any specific architecture code for your Mac, it

29:33.760 --> 29:36.160
will compile for Windows as well.

29:36.160 --> 29:38.880
You basically just have to say there's another target.

29:38.880 --> 29:43.360
The way that LLVM works, it has an abstract syntax tree of its own in between.

29:43.360 --> 29:45.480
We compile basically Rust compiles to that.

29:45.480 --> 29:49.520
Then everything that LLVM supports as a target, it can compile to.

29:49.520 --> 29:50.960
That is pretty amazing.

29:50.960 --> 29:58.800
It lets to Rust being the very first language that had native support for WebAssembly as

29:58.800 --> 30:00.320
a target language.

30:00.320 --> 30:03.880
Because it was just switching on, oh yeah, the target for that.

30:03.880 --> 30:09.080
At the same time, sorry, my voice isn't still losing the stick.

30:09.080 --> 30:12.160
It allows you to have a C compatible lib interface.

30:12.160 --> 30:20.560
That makes it really nice to embed it into other stuff and use it as a library.

30:20.560 --> 30:22.680
All right.

30:22.680 --> 30:24.760
That's Rust.

30:24.760 --> 30:29.920
What currently do we have in the Rust SDK now, a year later?

30:29.920 --> 30:37.200
The idea is essentially that everything you need to have to build a matrix client, it

30:37.200 --> 30:39.200
should be there.

30:39.200 --> 30:40.720
Better is included.

30:40.720 --> 30:45.840
That specifically means we have an async type safe API.

30:45.840 --> 30:47.720
Like requests you do, they're type safe.

30:47.720 --> 30:48.720
They come back.

30:48.720 --> 30:55.680
The fact that the JSON comes back is what it needs to be.

30:55.680 --> 30:57.600
It has a full featured room state.

30:57.600 --> 31:01.400
So for every room that you're in, it can tell you can you write in that room, what kind

31:01.400 --> 31:05.960
of messages can you write, what are the other users in the room, what is their avatar, what

31:05.960 --> 31:07.440
other states do they have.

31:07.440 --> 31:10.400
All of that stuff, it is managing for you.

31:10.400 --> 31:14.360
You don't have to bother too much about that.

31:14.360 --> 31:16.480
It has a persistent storage layer support.

31:16.480 --> 31:20.800
So you don't have to worry about caching it or putting it somewhere locally.

31:20.800 --> 31:22.560
You can still do that on your own if you want.

31:22.560 --> 31:24.160
It is a pluggable interface.

31:24.160 --> 31:29.760
But it already comes with a native version which is deprecated, slapped, replaced with

31:29.760 --> 31:34.760
the SP lite which is still partially there for crypto but not from the other side yet.

31:34.760 --> 31:39.520
But it also has, for example, support for Web, for index DB.

31:39.520 --> 31:41.200
So you can run it in the browser.

31:41.200 --> 31:44.320
One of the examples is an echo bot that runs in your browser in Wasm.

31:44.320 --> 31:48.440
It's pretty awesome.

31:48.440 --> 31:53.480
And for us, almost the most important part is that it has transparent end-to-end encryption

31:53.480 --> 31:54.720
support.

31:54.720 --> 31:59.560
When you're in a room and that room is encrypted, it's going to send the messages out to get

31:59.560 --> 32:04.320
the keys that you need to allow you to verify with a different device.

32:04.320 --> 32:09.720
But from the point that you join with a new device and you send, you just say room send

32:09.720 --> 32:13.520
and you give it the message, it's going to send an encrypted message.

32:13.520 --> 32:14.800
That's it.

32:14.800 --> 32:19.520
For the most part of it, unless user interaction is required, you don't have to bother about

32:19.520 --> 32:20.520
that.

32:20.520 --> 32:21.520
It's going to store that information.

32:21.520 --> 32:25.440
It's going to make sure that when you start up the next time through the storage support

32:25.440 --> 32:28.000
that you have all the keys there.

32:28.000 --> 32:31.600
You don't have to bother about there being an additional end-to-end encryption that you

32:31.600 --> 32:33.680
have to take care with.

32:33.680 --> 32:37.440
Already mentioned that it has Wasm and Web support.

32:37.440 --> 32:43.040
And because of the C layer, we're also able to offer support to different bindings out

32:43.040 --> 32:44.040
there.

32:44.040 --> 32:47.760
So we have two bindings that are used in the next generation of element apps.

32:47.760 --> 32:52.120
We're going to see that later for Kotlin and Swift through UniFFI.

32:52.120 --> 32:58.080
But there's also custom bindings for Node.js and for JS on the web as well.

32:58.080 --> 33:03.440
I think there's Python bindings out there, but they're not maintained by us.

33:03.440 --> 33:09.020
This all allows us to go beyond what we have so far.

33:09.020 --> 33:15.000
It allows us to ingrain more of the stuff that different clients and implementations

33:15.000 --> 33:18.600
have been using, but that has barely cross-pollinated.

33:18.600 --> 33:22.280
If you had a really clever way of managing your timeline in Android, the iOS people wouldn't

33:22.280 --> 33:24.360
know.

33:24.360 --> 33:27.440
That all converges into this singular place now.

33:27.440 --> 33:31.580
That allows us to do a lot more things a lot quicker.

33:31.580 --> 33:36.600
One of the things that we currently do is we offer a new experimental timeline API that

33:36.600 --> 33:38.720
manages the state for you.

33:38.720 --> 33:44.000
Back in 2018, 2019, editing messages came around, and that fundamentally changed the

33:44.000 --> 33:46.200
idea of an event in matrix.

33:46.200 --> 33:51.680
It's just not a stream of events anymore, but events acting upon other events.

33:51.680 --> 33:54.620
This changes a message from a previous thing.

33:54.620 --> 33:56.880
With a new timeline API, you don't have to bother.

33:56.880 --> 34:01.120
We're just going to tell you, oh, position 17, this is now this.

34:01.120 --> 34:02.760
The same is true for redactions.

34:02.760 --> 34:04.520
The same is true for reactions.

34:04.520 --> 34:10.240
Out of these things and soon threads, I don't know how we're going to do threads yet, but

34:10.240 --> 34:12.520
that all is supposed to be right there.

34:12.520 --> 34:15.880
You don't have to bother about the state machine changes that this requires.

34:15.880 --> 34:20.320
It's just going to tell you, hey, you need to render a different thing now.

34:20.320 --> 34:25.200
The other thing that was mentioned before as well is support for sliding sync.

34:25.200 --> 34:26.200
Both of these are still experimental.

34:26.200 --> 34:30.200
You have to actively switch them on because it's interfaces that we're not confident with

34:30.200 --> 34:33.680
that are going to stick exactly the way they are, but there's implementations out there

34:33.680 --> 34:34.680
using that.

34:34.680 --> 34:35.680
All right.

34:35.680 --> 34:36.680
Does it work?

34:36.680 --> 34:40.680
Does it live up to the promise?

34:40.680 --> 34:43.160
Let's see.

34:43.160 --> 34:48.320
In order to build sliding sync, I built a small testing UI.

34:48.320 --> 34:53.720
With sliding sync right now, this is Mr. Big, my test account.

34:53.720 --> 34:57.640
I don't know how many rooms, but usually loading it on element web is like a minute for the

34:57.640 --> 35:00.200
initial sync.

35:00.200 --> 35:07.640
With my timeline, with sliding sync up and this testing system, it's 200 milliseconds.

35:07.640 --> 35:10.400
It's 200 milliseconds to render the room.

35:10.400 --> 35:13.240
You can see this down here.

35:13.240 --> 35:17.320
To pull up all other rooms, it's like another 30 milliseconds.

35:17.320 --> 35:20.520
So yeah, it's fast.

35:20.520 --> 35:25.920
It does what it's supposed to do.

35:25.920 --> 35:26.920
Is that actually true?

35:26.920 --> 35:27.920
I'm a core developer.

35:27.920 --> 35:34.040
Of course, the thing that I'm building here is hopefully going to work, but how plausible

35:34.040 --> 35:37.040
is that as a SDK?

35:37.040 --> 35:38.680
Maybe I'm just building a lot of stuff.

35:38.680 --> 35:41.240
Let's take a look at the thing itself.

35:41.240 --> 35:47.640
The implementation on top of the Rust SDK for this UI is a whopping 2,000 lines.

35:47.640 --> 35:50.160
It's pretty small.

35:50.160 --> 35:54.600
Most of that is actually two-e-realm stuff because actually two-e's in Rust are not that

35:54.600 --> 35:56.520
great, so you have to do a lot of state management.

35:56.520 --> 36:04.400
The actual implementation of managing the Rust SDK is less than 130 lines of code.

36:04.400 --> 36:09.040
Everything else you saw, including that this stores it on your hard drive, totally abstracted

36:09.040 --> 36:10.040
away.

36:10.040 --> 36:12.520
I don't have to bother about this from that perspective.

36:12.520 --> 36:16.760
I would say, yeah, definitely.

36:16.760 --> 36:18.600
It does SDK.

36:18.600 --> 36:22.280
But again, I'm a core developer.

36:22.280 --> 36:24.400
Hopefully it's easy for me to build this.

36:24.400 --> 36:28.800
It should be fairly okay to build something as quick.

36:28.800 --> 36:34.120
But of course, it's supposed to be working for you.

36:34.120 --> 36:38.880
For that, we've also brushed up our game a little bit on documentation.

36:38.880 --> 36:43.800
One thing I would like you to look at... I have to check the time.

36:43.800 --> 36:45.600
It's all right.

36:45.600 --> 36:48.920
We have reorganized the repo a little bit to make it a little cleaner.

36:48.920 --> 36:51.760
You can see there's a bunch of stuff around that.

36:51.760 --> 36:57.800
There's X-TAS, which is our task manager, benchmarks, testing that should be self-explanatory.

36:57.800 --> 37:02.020
We have the bindings in the uniFFI bindgen to organize bindings.

37:02.020 --> 37:05.080
We have the labs, which is also where you find the Jack-in implementation if you're

37:05.080 --> 37:07.760
curious about this.

37:07.760 --> 37:11.800
But the main stuff lives in crates and contravers, other things built on hub.

37:11.800 --> 37:15.120
We have an examples folder exactly for this kind of stuff.

37:15.120 --> 37:19.160
So let me quickly set a puzzle, roughly.

37:19.160 --> 37:24.840
I put the slides into the dev room if you want to look at them.

37:24.840 --> 37:29.560
Quickly run through the SDK bot 101 thing.

37:29.560 --> 37:34.040
It allows you to directly use that from the repo with that command.

37:34.040 --> 37:36.680
What you see on the first screen is just the imports that we need.

37:36.680 --> 37:44.440
You see mostly Rust SDK stuff, some minor managing around that.

37:44.440 --> 37:48.560
If you scroll down, if you're familiar with Rust, you know that binary has this main function.

37:48.560 --> 37:49.720
We use Tokyo here.

37:49.720 --> 37:50.720
It's an async function.

37:50.720 --> 37:52.880
Told you, async API.

37:52.880 --> 37:57.640
Most of that is just parsing in a very ugly way the command line and then handing it over

37:57.640 --> 38:01.000
to login and sync.

38:01.000 --> 38:03.500
This login and sync sets up some minor stuff.

38:03.500 --> 38:08.680
You see that we have a lot of information about this in code comments right here for

38:08.680 --> 38:09.920
you.

38:09.920 --> 38:13.440
It does even set up a flat store.

38:13.440 --> 38:15.520
You can call the login username.

38:15.520 --> 38:22.640
You can give it a name for the bot that is the device that you will see.

38:22.640 --> 38:26.480
It logs in.

38:26.480 --> 38:31.120
Going further, I don't have the time to go through the entire thing, but it explains everything

38:31.120 --> 38:33.080
here.

38:33.080 --> 38:35.000
This bot does two things.

38:35.000 --> 38:39.800
For every room that you ask it to join, it will automatically join, which is this first

38:39.800 --> 38:40.920
event handler.

38:40.920 --> 38:43.480
The second event handler is reacting on messages.

38:43.480 --> 38:47.880
An event handler in the client is basically just a callback that you can say, like, when

38:47.880 --> 38:52.480
these kind of events come in, please tell me and then I react to this.

38:52.480 --> 38:56.120
Those themselves can be async again pretty nice.

38:56.120 --> 38:58.200
Then it just starts syncing.

38:58.200 --> 39:00.940
That's all it does.

39:00.940 --> 39:02.200
Which means it's running the sync loop.

39:02.200 --> 39:04.880
This does not at this point use sliding sync.

39:04.880 --> 39:07.720
As I told you, it's kind of experimental.

39:07.720 --> 39:10.280
Let's look at the room message.

39:10.280 --> 39:15.800
When we receive a message, we can again mention it before.

39:15.800 --> 39:19.600
It's going to give us the actual room message in a typed format.

39:19.600 --> 39:24.800
We can rely on the compiler here to make sure that things are as they should be.

39:24.800 --> 39:27.040
We make sure that we are in this room.

39:27.040 --> 39:30.200
We try to figure out if it's a text message.

39:30.200 --> 39:34.480
If it's a text message, we check for is it a dollar bank party?

39:34.480 --> 39:38.960
If so, we're going to respond with the message.

39:38.960 --> 39:41.400
That's all the thing does.

39:41.400 --> 39:42.680
In reality, it looks like this.

39:42.680 --> 39:48.480
I'm showing you this is just regular main at the moment.

39:48.480 --> 39:53.800
If I run the bot, this is slightly capped so you can't see my password.

39:53.800 --> 39:56.240
I'm here connected to that bot.

39:56.240 --> 39:57.240
You see that I'm in here.

39:57.240 --> 40:01.400
I added two more prints that are not in main right now to make it a little cleaner.

40:01.400 --> 40:02.400
I'm sending a message.

40:02.400 --> 40:05.240
We see that this message is ignored.

40:05.240 --> 40:09.200
If I send bank party, you can see it's reacting.

40:09.200 --> 40:10.600
It's sending this.

40:10.600 --> 40:14.400
Most importantly, this is an encrypted room.

40:14.400 --> 40:21.040
I didn't have to do anything to build a bot that allows me to live and interact with an

40:21.040 --> 40:22.040
encrypted room.

40:22.040 --> 40:23.040
That's an encrypted message.

40:23.040 --> 40:24.200
I didn't have to do anything.

40:24.200 --> 40:25.440
You saw that there was no setup.

40:25.440 --> 40:27.800
I hadn't to manage anything.

40:27.800 --> 40:33.560
The Rust SDK did all of that for me.

40:33.560 --> 40:39.720
If you want to learn more, you can find all of the code at metrics.metrics.slck.

40:39.720 --> 40:45.960
You can join our developer and talk about the Rust SDK room.

40:45.960 --> 40:50.040
The example you just saw is inside the examples folder, getting started.

40:50.040 --> 40:51.040
Jack in.

40:51.040 --> 40:52.840
The other clients you saw before is in the labs.

40:52.840 --> 40:53.840
Jack in.

40:53.840 --> 40:56.160
All of that code, obviously.

40:56.160 --> 40:57.800
I really recommend going for the getting started.

40:57.800 --> 41:00.000
It has a lot of documentation.

41:00.000 --> 41:06.640
I also want to send an honorable mention to Benjamin, who was working on Trinity, which

41:06.640 --> 41:12.400
is built on top of the Rust SDK, a bot framework, I would say.

41:12.400 --> 41:18.200
It allows you to write some very small Rust that is compiled to Wasm that it runs in the

41:18.200 --> 41:20.120
client that can react to messages.

41:20.120 --> 41:24.600
You can write just the message part and say, I have a bot that reacts to messages.

41:24.600 --> 41:25.600
This is one.

41:25.600 --> 41:26.600
Oh, yeah.

41:26.600 --> 41:29.600
The element is hiring.

41:29.600 --> 41:38.720
If you are interested in working on this full-time, element IOR charisma.

41:38.720 --> 41:40.280
We're going to have time for questions later.

41:40.280 --> 41:44.640
We have to get through all of these first.

41:44.640 --> 41:46.600
Let's see what you can actually build with this.

41:46.600 --> 41:47.600
Thank you.

41:47.600 --> 41:48.600
That's a long one.

41:48.600 --> 41:49.600
You want time?

41:49.600 --> 41:50.600
Yeah.

41:50.600 --> 41:51.600
You want time?

41:51.600 --> 41:52.600
Yeah.

41:52.600 --> 42:01.960
You want time?

42:01.960 --> 42:03.480
So hello, everyone.

42:03.480 --> 42:04.480
My name is Mauro.

42:04.480 --> 42:09.000
Honestly, my colleagues at a slide where they presented themselves.

42:09.000 --> 42:11.080
I don't have such a thing.

42:11.080 --> 42:12.480
So I have to be brief.

42:12.480 --> 42:13.480
I come from Italy.

42:13.480 --> 42:14.480
Naples.

42:14.480 --> 42:15.480
I'm a software engineer.

42:15.480 --> 42:16.480
Work at Element.

42:16.480 --> 42:22.360
I mostly work on the iOS side of things and started working also on some Rust implementations.

42:22.360 --> 42:27.400
Today, we're going to talk about the new client ElementX.

42:27.400 --> 42:33.800
So this new client is pretty much being built with the idea of well-defined goals.

42:33.800 --> 42:36.800
The first of them is pretty much user experience.

42:36.800 --> 42:42.200
The thing is that we really wanted to improve over the user experience of the current element

42:42.200 --> 42:43.200
implementation.

42:43.200 --> 42:50.120
The thing is that Element was started as pretty much a showcase for what metrics were scalable

42:50.120 --> 42:51.120
of.

42:51.120 --> 42:56.880
It was a bit like an app made by engineers, for engineers.

42:56.880 --> 43:00.400
So yeah, not everyone is into this kind of stuff.

43:00.400 --> 43:03.320
So sometimes it's a bit hard to use for the average user.

43:03.320 --> 43:05.160
And we want to improve over this.

43:05.160 --> 43:10.680
Also, we want, of course, to have a performance to be another very important goal, actually

43:10.680 --> 43:12.040
just as important as UX.

43:12.040 --> 43:16.840
We're actually, thanks to the slide and sync implementation on ElementX, we're aiming to

43:16.840 --> 43:19.640
actually launch the app in less than 100 milliseconds.

43:19.640 --> 43:22.880
That's pretty much the thing that we're aiming for.

43:22.880 --> 43:26.400
And of course, also optimize the bandwidth usage.

43:26.400 --> 43:30.040
Also we want to build an app that is reliable just from the start.

43:30.040 --> 43:36.980
So testing code coverage is pretty much right from the start of the project, a niger priority.

43:36.980 --> 43:41.200
And also we want to build the app in a way that is actually relying on shared components

43:41.200 --> 43:42.200
pretty much.

43:42.200 --> 43:45.560
The Mattress Crisis Decay is just one of them.

43:45.560 --> 43:50.640
But of course, we're planning to build more components that will be shared across different

43:50.640 --> 43:53.600
implementation, across different platforms, different projects.

43:53.600 --> 43:55.520
So not even necessarily ElementX.

43:55.520 --> 43:57.880
It is that we will be able to use them.

43:57.880 --> 44:02.320
And of course, anyone in the open source community will be able to use them.

44:02.320 --> 44:06.240
So why are we writing the Android and the iOS app?

44:06.240 --> 44:09.280
That's actually a good question because some of these goals could also be achieved with

44:09.280 --> 44:11.720
a very big refactor.

44:11.720 --> 44:16.400
But let's go more in depth on why we want to do our write.

44:16.400 --> 44:19.080
So let's start with Element iOS.

44:19.080 --> 44:21.600
Element iOS, it's quite old.

44:21.600 --> 44:25.880
It started in 2015.

44:25.880 --> 44:30.280
Essentially it was, as I say, pretty much a POC to showcase what metrics was capable

44:30.280 --> 44:32.480
of.

44:32.480 --> 44:37.360
It started as being named the Metrics iOS console, in fact.

44:37.360 --> 44:42.800
And it went through a bunch of identity crisis and changed name three times.

44:42.800 --> 44:47.680
I guess it was first console, then Vator, then Riot.

44:47.680 --> 44:48.680
Now it's Element.

44:48.680 --> 44:54.240
Let's hope it's going to stick with Element.

44:54.240 --> 44:59.320
And it was built by engineers to showcase pretty much what metrics was capable of.

44:59.320 --> 45:03.840
But the thing is that, first of all, as I say, the user experience was not great.

45:03.840 --> 45:11.280
Second, it was made with some very old components, written on Objective-C, that used some very

45:11.280 --> 45:16.200
old architectural pattern, like MVC, which should stand for...

45:16.200 --> 45:18.200
What would be a controller?

45:18.200 --> 45:21.720
But it stands more for a massive controller because you're not fighting this massive

45:21.720 --> 45:22.720
controller.

45:22.720 --> 45:27.280
It's just a huge mess and you start looking at 60,000 lines of code in a controller and

45:27.280 --> 45:29.440
you're like, oh my God, why am I alive?

45:29.440 --> 45:31.040
And so, yeah.

45:31.040 --> 45:34.640
You don't want to see that anymore, pretty much.

45:34.640 --> 45:37.400
We want to move to a newer architecture.

45:37.400 --> 45:43.520
And also, even if we did a lot of refactors on the Element iOS implementation, you essentially...

45:43.520 --> 45:49.120
Yeah, we were essentially not able to change all the old implementations since they were

45:49.120 --> 45:53.440
very hard to maintain and we still relied on these components a lot.

45:53.440 --> 45:59.000
So yeah, core components are still using these old implementations.

45:59.000 --> 46:03.280
Half of the code is still in Objective-C and core coverage is quite low.

46:03.280 --> 46:06.360
So we decided to experiment a bit in Q2 2022.

46:06.360 --> 46:13.000
We decided to pretty much build a minimum client using the matrix process decay and

46:13.000 --> 46:17.680
pretty much the state of the art frameworks provided by Apple, like SwiftUI, but not only

46:17.680 --> 46:20.320
that, like, not so async-await and things like that.

46:20.320 --> 46:26.880
So yeah, and we were actually able to build this new minimum client that had a room list

46:26.880 --> 46:28.480
timeline.

46:28.480 --> 46:30.680
And it was, it was a technical success.

46:30.680 --> 46:32.760
It was super fast and amazing.

46:32.760 --> 46:40.720
So we decided to build on top of this second POC by giving more focus on the UX because

46:40.720 --> 46:46.320
I just said, yeah, now we have a performance client, but now we need to have a simple client

46:46.320 --> 46:48.640
that anyone is able to use.

46:48.640 --> 46:52.000
So Element iOS was then born.

46:52.000 --> 46:56.160
On the Android side, things are slightly different because technically speaking, the Android

46:56.160 --> 47:00.720
application already had to rewrite in 2019.

47:00.720 --> 47:02.240
So we had two choices.

47:02.240 --> 47:09.240
We could essentially just take the Android SDK, put it on the side, and pretty much replace

47:09.240 --> 47:11.040
it with the Rust SDK.

47:11.040 --> 47:13.160
That would be okay.

47:13.160 --> 47:17.880
Or maybe just rewrite it from scratch and using pretty much the state of art frameworks

47:17.880 --> 47:21.720
that Android provides right now, like, for example, Jetpack Compose.

47:21.720 --> 47:24.200
In the end, we decided to go for the latter for two reasons.

47:24.200 --> 47:28.680
First of all, I mean, if we're building an application on iOS that uses the latest frameworks,

47:28.680 --> 47:31.400
why do we want to do the same for Android?

47:31.400 --> 47:32.400
And second, UX.

47:32.400 --> 47:36.280
As I said, UX was a very, very important concern.

47:36.280 --> 47:40.720
So even if you wanted to rebuild the app from scratch or rewrite it to just pretty much

47:40.720 --> 47:45.880
change some stuff with the existing app, it would still require pretty much a huge UX

47:45.880 --> 47:52.240
overall, which in the end made the rewrite even more sense.

47:52.240 --> 47:56.480
So pretty much obviously the architecture of element that's structured.

47:56.480 --> 47:59.640
Well, we have pretty much the backbone of the client.

47:59.640 --> 48:02.000
It's pretty much all sitting in the magic Rust SDK.

48:02.000 --> 48:03.640
It's all there.

48:03.640 --> 48:09.900
And the magic Rust SDK through UniSFI is able to expose WIFT bindings and Kotlin bindings.

48:09.900 --> 48:17.560
It's interesting because, as pretty much Ben said, it's exposing objects that are reactive,

48:17.560 --> 48:22.000
that the client is the only thing that needs to care about, that needs to care about the

48:22.000 --> 48:23.960
events of the events, the newer events.

48:23.960 --> 48:27.920
It just needs to know that the event has been changed and it's in that place.

48:27.920 --> 48:30.560
It needs to know that it's a new event that came afterwards and so on.

48:30.560 --> 48:37.600
So the idea is that these objects that the bindings expose are actually already ready

48:37.600 --> 48:39.120
to be displayed essentially.

48:39.120 --> 48:41.640
So you just need to render them on the UI.

48:41.640 --> 48:44.920
And that makes development way, way easier.

48:44.920 --> 48:50.600
And of course, the sliding sync is pretty much a requirement on element tax.

48:50.600 --> 48:55.080
And since it's been built with the idea that sliding sync will be pretty much next standard

48:55.080 --> 48:56.080
for the clients.

48:56.080 --> 49:02.120
And so it will only work with servers that implement for now the sliding sync proxy essentially.

49:02.120 --> 49:09.440
So this is an example of how the code is pretty much translated from Rust into Zwift and Kotlin

49:09.440 --> 49:10.520
through UniSFI.

49:10.520 --> 49:12.400
As you can see, there is this the timeline item.

49:12.400 --> 49:16.760
I would say this is pretty much an object that is pretty much like a view model.

49:16.760 --> 49:18.360
It's already ready to be displayed.

49:18.360 --> 49:24.080
I just pretty much need to take the presentation data from this object and render them on the

49:24.080 --> 49:25.080
UI.

49:25.080 --> 49:26.080
And that's it.

49:26.080 --> 49:32.760
Which will make implementing clients for the future with the matrix Rust SDK way, way easier.

49:32.760 --> 49:37.560
So the bindings are pretty much in a separate repo.

49:37.560 --> 49:42.840
Anyone can download them as a file, a year file for Android or as an XC framework for

49:42.840 --> 49:44.240
Zwift implementations.

49:44.240 --> 49:48.760
Or you can just pretty much use a package manager like Maven Central on Android or Zwift

49:48.760 --> 49:52.880
package manager on Zwift implementations essentially.

49:52.880 --> 49:55.800
I think it's Zwift implementations because actually it's interesting.

49:55.800 --> 49:59.880
But the matrix Rust SDK is capable of running on any Apple system target.

49:59.880 --> 50:05.160
So I really can't wait someone crazy enough to build a client for Apple Watch or Apple

50:05.160 --> 50:06.160
TV.

50:06.160 --> 50:10.080
I'm pretty sure that the 10 people in the world at Apple TV will be very pleased that

50:10.080 --> 50:12.720
there is a matrix client on.

50:12.720 --> 50:15.040
On the Apple TV.

50:15.040 --> 50:17.760
So yeah.

50:17.760 --> 50:22.120
But of course, ElementX is going to share more than just the Rust SDK.

50:22.120 --> 50:29.560
We're pretty much trying to build other components that we hope to share just across ElementX

50:29.560 --> 50:31.280
but across multiple projects.

50:31.280 --> 50:36.080
For example, we want to build an OpenID Connect component, an element called component.

50:36.080 --> 50:39.560
And of course, since the two apps are pretty much the same up on different platforms, they're

50:39.560 --> 50:42.800
going to share translation, they're going to share design tokens.

50:42.800 --> 50:50.600
So why don't we just pretty much make a component to share these elements already.

50:50.600 --> 50:57.800
And we're actually also building an interesting component which is called rich text editor,

50:57.800 --> 51:06.320
which is essentially an SDK of written Rust that then exposes these bindings in Zwift

51:06.320 --> 51:12.040
and Kotlin through edf5 and also in WebAssembly.

51:12.040 --> 51:19.840
And it's essentially a UI framework that you can import into your client to render rich

51:19.840 --> 51:25.000
text in what you see is what you get fashioned, essentially.

51:25.000 --> 51:28.240
It's something that is going to come also into ElementX.

51:28.240 --> 51:29.760
So keep an eye for it.

51:29.760 --> 51:31.920
But hey, what's this slide?

51:31.920 --> 51:34.120
Oh, actually, it's already there.

51:34.120 --> 51:35.920
Oh, but this is not ElementX.

51:35.920 --> 51:37.280
It is Element.

51:37.280 --> 51:40.760
The rich text editor is already an element right now.

51:40.760 --> 51:45.560
But in iOS, Android, and Web, you can enable it in Labs.

51:45.560 --> 51:48.960
You can just go to Labs, enable it, and test it.

51:48.960 --> 51:53.600
And if you're able to break it, just send us a specific deck and we'll try to fix it

51:53.600 --> 51:55.480
as soon as possible.

51:55.480 --> 51:57.600
It's a project that I've worked on.

51:57.600 --> 51:59.000
I'm very proud of it.

51:59.000 --> 52:02.840
I think we actually did something really great because it's a very simple way to pretty much

52:02.840 --> 52:08.400
it's a way in which you can create rich text without need of using markdowns and see all

52:08.400 --> 52:13.240
they look like, which will make life easier for you to create something like this.

52:13.240 --> 52:17.080
Because I challenge everyone to make something like this with markdowns.

52:17.080 --> 52:20.520
You'd go crazy with that.

52:20.520 --> 52:25.320
So yeah, the good thing is that this rich text editor SDK that we built, I mean, it's

52:25.320 --> 52:27.720
not just for metrics, metrics client.

52:27.720 --> 52:30.480
I mean, technically speaking, anyone could use this.

52:30.480 --> 52:32.520
Maybe you want to make a note app.

52:32.520 --> 52:38.160
You want to make, I don't know, like an app that is your diary, whatever you want, you

52:38.160 --> 52:39.680
can pretty much implement this.

52:39.680 --> 52:42.760
And if you want to test it, you can scan the QR code.

52:42.760 --> 52:47.400
You will get pretty much to the latest main implementation on web.

52:47.400 --> 52:48.880
It's a test debug version there.

52:48.880 --> 52:51.440
The one on Labs is more stable.

52:51.440 --> 52:54.440
This one is more to play around with it.

52:54.440 --> 53:00.080
It's cool because this one, it allows you to pretty much see how the rich text is transformed

53:00.080 --> 53:07.680
into a DOM representation, which is in Rust, and then transformed back into an HTML, which

53:07.680 --> 53:11.480
is the one that we are sending over at metrics clients course.

53:11.480 --> 53:15.280
So of course, testing for liability, another important keyword.

53:15.280 --> 53:17.800
It's something that we want to pretty much improve.

53:17.800 --> 53:24.360
And so pretty much we built a very, yeah, very stack test infrastructure that we hope

53:24.360 --> 53:26.600
is going to cover all these areas.

53:26.600 --> 53:29.280
It's already covering most of these areas.

53:29.280 --> 53:36.360
And yeah, pretty much make the app more reliable and the project way, way safer.

53:36.360 --> 53:39.760
So yeah, ElementX actually has come with a lot of benefits.

53:39.760 --> 53:44.000
First of all, on the tech side, it's way, way faster.

53:44.000 --> 53:47.240
But because the metrics versus decay, I mean, it's amazing.

53:47.240 --> 53:51.600
Makes things easier, both for the development standpoint, because you just write it once

53:51.600 --> 53:53.520
and deploy it everywhere.

53:53.520 --> 53:58.040
But at the same time, the fact that you just have your models already ready to be displayed,

53:58.040 --> 54:00.680
it's amazing.

54:00.680 --> 54:04.000
And also, slide-insync.

54:04.000 --> 54:09.040
And of course, the use of the collective UIs like SwiftUI and Jetpack Compose makes development

54:09.040 --> 54:13.600
time actually faster.

54:13.600 --> 54:18.240
And actually, also easier to test, I would say.

54:18.240 --> 54:22.160
But also, the UI performance also has been improved, actually.

54:22.160 --> 54:27.880
Also sharing components is something that will benefit not only just ElementX, but pretty

54:27.880 --> 54:32.000
much any client that wants to implement a metrics client.

54:32.000 --> 54:35.160
But actually, we hope that some of the sharing components that we're building will not just

54:35.160 --> 54:39.600
benefit the metrics community, but the overall open source community.

54:39.600 --> 54:44.240
So yeah, the major benefit actually should not focus just on the main benefit that we

54:44.240 --> 54:45.920
are offering on the tech side.

54:45.920 --> 54:49.160
We actually want to focus on the benefit we are really offering to the users, because

54:49.160 --> 54:54.240
in the end, the main focus element tax, yeah, it's performance, it's tech, it's sharing

54:54.240 --> 54:58.840
performance, but of course, it's making the app more usable, more accessible, easier to

54:58.840 --> 54:59.840
use.

54:59.840 --> 55:02.960
We want to make an app that is not just...

55:02.960 --> 55:08.200
We want to make an app that essentially also can be used by your friends and family to

55:08.200 --> 55:10.440
chat with you even casually during the day.

55:10.440 --> 55:14.040
So not just for people that essentially want to keep their conversation safe and secure

55:14.040 --> 55:17.680
for the metrics protocol.

55:17.680 --> 55:18.680
Roadmap.

55:18.680 --> 55:23.600
Pretty much, this is the present and the future of element tax.

55:23.600 --> 55:31.680
For now, you can log in, check the room list, timeline, send messages, edit, reply, react.

55:31.680 --> 55:33.440
But there are some restrictions.

55:33.440 --> 55:35.640
First of all, of course, as I said, sliding sync is required.

55:35.640 --> 55:39.680
So if your server doesn't look at it as a sliding sync proxy, yeah, you can pretty much

55:39.680 --> 55:42.320
use the client on that server.

55:42.320 --> 55:47.200
Also it only supports authentication.

55:47.200 --> 55:50.040
And authentication, it's only through the metrics protocol.

55:50.040 --> 55:55.120
We want to support also IDC and registration, but when we will build the IDC component,

55:55.120 --> 55:56.120
we will support that.

55:56.120 --> 55:58.720
Device verification is there, but only for emoji.

55:58.720 --> 56:00.880
So no QRV education yet.

56:00.880 --> 56:03.040
And also no messages to the description.

56:03.040 --> 56:10.480
Yeah, this is pretty much where you can find the element X iOS version repo.

56:10.480 --> 56:12.540
There will be a public test flight coming soon.

56:12.540 --> 56:14.720
And actually, Matthew, we'll demo this in...

56:14.720 --> 56:16.720
We'll demo this this afternoon?

56:16.720 --> 56:17.720
Okay.

56:17.720 --> 56:19.640
That's the plan.

56:19.640 --> 56:24.000
And regarding the element X Android, it's a bit behind the schedule because, as I say,

56:24.000 --> 56:26.840
it was developed after element X iOS.

56:26.840 --> 56:28.640
So it's more in a state of being set up.

56:28.640 --> 56:33.440
But of course, you can try to run it to check the state of the repo.

56:33.440 --> 56:37.080
If you want to play around with it, this is pretty much where you can find the actual

56:37.080 --> 56:39.520
repo of element X Android.

56:39.520 --> 56:43.080
This is pretty much the roadmap on what we plan to do.

56:43.080 --> 56:44.280
It's actually more than a plan.

56:44.280 --> 56:45.920
It's more like what we...

56:45.920 --> 56:49.520
Let's say it's more like... it's not a deadline.

56:49.520 --> 56:53.160
It's more like what we imagine we're able to achieve in these dates.

56:53.160 --> 56:57.160
And I was also told to be as vague as possible.

56:57.160 --> 57:03.200
So for the release date or the public launch, I will just say that they will come sometime

57:03.200 --> 57:04.200
in the future.

57:04.200 --> 57:05.200
Oh, all right.

57:05.200 --> 57:06.200
Okay.

57:06.200 --> 57:08.880
And that should deal with it.

57:08.880 --> 57:10.560
So yeah, that's all.

57:10.560 --> 57:13.920
And we can do, I think, a rapid QA session, right?

57:13.920 --> 57:14.920
Yes.

57:14.920 --> 57:15.920
We have 10 minutes.

57:15.920 --> 57:16.920
Oh, okay.

57:16.920 --> 57:17.920
Nice.

57:17.920 --> 57:18.920
Retro schedule.

57:18.920 --> 57:19.920
Nice.

57:19.920 --> 57:20.920
Okay.

57:20.920 --> 57:21.920
Yeah.

57:21.920 --> 57:22.920
It's split around.

57:22.920 --> 57:23.920
Yeah.

57:23.920 --> 57:24.920
Please go ahead.

57:24.920 --> 57:32.920
If I remember correctly, the sliding sync option in element web said that you can't disable

57:32.920 --> 57:34.920
it in the warning.

57:34.920 --> 57:36.240
Why is that?

57:36.240 --> 57:39.360
So the question is, let me repeat it for the camera.

57:39.360 --> 57:46.200
Why can't you disable the sliding sync labs feature in the current version?

57:46.200 --> 57:48.400
Mostly because of end-to-end encrypted messages.

57:48.400 --> 57:54.040
You would risk being unable to decrypt your end-to-end encrypted messages in that session.

57:54.040 --> 58:01.320
So the reason why is because when you log into the proxy, it's going to be syncing on

58:01.320 --> 58:02.320
your account, right?

58:02.320 --> 58:04.360
And it's going to sync forever.

58:04.360 --> 58:06.520
Well, until the access token gets invalidated.

58:06.520 --> 58:08.600
But it's going to be syncing on your behalf.

58:08.600 --> 58:14.600
If you toggled sliding sync on then off, if you turned it off, then your element web would

58:14.600 --> 58:18.440
be using the V2 sync as well as the proxy.

58:18.440 --> 58:20.560
Because the proxy didn't know you toggled it off.

58:20.560 --> 58:23.440
So that means you've got two sync loops for your account.

58:23.440 --> 58:28.320
And that's going to cause problems when it causes a race condition.

58:28.320 --> 58:32.560
Because two device messages, when they're acknowledged and they get acknowledged by

58:32.560 --> 58:36.460
increasing the synths token, they get deleted on the server.

58:36.460 --> 58:41.280
So if your element web was super, super fast and managed to race ahead slightly of the

58:41.280 --> 58:48.000
proxy, then it would go and get all the two device events and the proxy would not.

58:48.000 --> 58:49.000
Or vice versa.

58:49.000 --> 58:52.680
And vice versa is the problem that's trying to warn against.

58:52.680 --> 58:58.680
So if the proxy was ahead, then you would not get a certain two device events.

58:58.680 --> 59:02.160
And therefore, you may potentially lose room keys and therefore may potentially be unable

59:02.160 --> 59:04.200
to decrypt messages.

59:04.200 --> 59:06.960
Hopefully that's good.

59:06.960 --> 59:13.320
Do you have any data on whether sliding sync significantly impacts server load?

59:13.320 --> 59:16.040
So the question is, what about server load on sliding sync?

59:16.040 --> 59:18.480
Do we have any data?

59:18.480 --> 59:24.400
I need clarification because do you mean at a proxy level or do you mean in like a general

59:24.400 --> 59:27.160
sense for native implementations of the server?

59:27.160 --> 59:31.040
Does using sliding sync improve server performance?

59:31.040 --> 59:32.840
A native implementation, yes, it would.

59:32.840 --> 59:37.000
So that's one of the reasons why the existing sync implementation is slow.

59:37.000 --> 59:39.960
It's just because the servers have to do an awful lot of work.

59:39.960 --> 59:41.800
And obviously I've been developing on Dendrite.

59:41.800 --> 59:44.720
I know exactly what things are slow there.

59:44.720 --> 59:52.800
So a lot of the API that's exposed to the clients are basically efficient ways that

59:52.800 --> 59:53.800
you can do it.

59:53.800 --> 59:55.400
So you only get the current state of rooms.

59:55.400 --> 59:57.880
You don't tend to need to go back in time.

59:57.880 --> 01:00:00.700
You don't need to remember all your synths tokens since the beginning of time.

01:00:00.700 --> 01:00:03.040
These are things that slow down the processing.

01:00:03.040 --> 01:00:07.480
So yes, a native implementation, but a proxy implementation obviously is a sync loop that's

01:00:07.480 --> 01:00:11.080
going to be made so that will increase load, right?

01:00:11.080 --> 01:00:14.080
Because that's going to be constantly syncing on your account.

01:00:14.080 --> 01:00:16.080
In the back.

01:00:16.080 --> 01:00:23.080
Is there any plan to handle multiple accounts in a client?

01:00:23.080 --> 01:00:26.080
So you have like an account on your local server.

01:00:26.080 --> 01:00:29.080
How can you use both in the same thing?

01:00:29.080 --> 01:00:31.040
That's an element X question, I guess.

01:00:31.040 --> 01:00:33.200
Wait, let me repeat it first.

01:00:33.200 --> 01:00:38.600
So the question is about multi-user account support in the app.

01:00:38.600 --> 01:00:43.040
It's something that we're discussing, but for now there is no definite plan.

01:00:43.040 --> 01:00:44.040
Yeah, we'll do it.

01:00:44.040 --> 01:00:49.320
It's a little cool that we don't have it today.

01:00:49.320 --> 01:00:52.720
From the metrics SDK side, I can tell you that you can do it.

01:00:52.720 --> 01:00:53.920
That's not an issue.

01:00:53.920 --> 01:00:55.480
So I think you were next.

01:00:55.480 --> 01:00:56.480
Saul, you.

01:00:56.480 --> 01:01:03.360
So two part question, one is how far out do you think sliding sync is from actually being

01:01:03.360 --> 01:01:05.360
like urged and finalized as a spec?

01:01:05.360 --> 01:01:10.560
And then second part to that is are there plans to do a native implementation for those

01:01:10.560 --> 01:01:12.560
APIs and synapse?

01:01:12.560 --> 01:01:15.040
You want to repeat the question?

01:01:15.040 --> 01:01:18.400
Yeah, so the question is basically how long it's going to take for sliding sync to land

01:01:18.400 --> 01:01:21.040
and will we get native implementations and synapse?

01:01:21.040 --> 01:01:23.720
You will get a native implementation in synapse.

01:01:23.720 --> 01:01:25.880
I don't know when.

01:01:25.880 --> 01:01:30.680
And yes, we're going to try to merge and land it as soon as it's practically possible, which

01:01:30.680 --> 01:01:34.040
there's a lot of things we need to fix.

01:01:34.040 --> 01:01:36.080
Things like threading and stuff just doesn't work.

01:01:36.080 --> 01:01:40.440
That's actually one of the biggest blockers at the moment from us trying out just defaulting

01:01:40.440 --> 01:01:45.840
element web to sliding sync on by default is that for compatible service, obviously,

01:01:45.840 --> 01:01:49.280
is the fact that we don't have threading support so you wouldn't have feature parity.

01:01:49.280 --> 01:01:54.560
So when we do have feature parity, then there could be element web clients which enable

01:01:54.560 --> 01:01:55.560
it by default.

01:01:55.560 --> 01:01:57.960
There could be in labs, will be enabled in labs by default.

01:01:57.960 --> 01:02:03.520
So we're getting there, but I can't give you a time, unfortunately.

01:02:03.520 --> 01:02:05.520
Thank you.

01:02:05.520 --> 01:02:07.520
You're next.

01:02:07.520 --> 01:02:09.520
I saw you.

01:02:09.520 --> 01:02:23.680
So the question is the authentication parts in the rest of the SDK.

01:02:23.680 --> 01:02:28.920
So yes, we have login via user name and password.

01:02:28.920 --> 01:02:35.680
We have implemented OIDC in general, but I don't think it's fully tested.

01:02:35.680 --> 01:02:38.720
And we have an SSO feature as well.

01:02:38.720 --> 01:02:44.880
So we ask the server, the specification says that the server tells us what is possible.

01:02:44.880 --> 01:02:47.240
And then we allow you to use those.

01:02:47.240 --> 01:02:50.960
So generally, yeah, if your server is SSO, you can use metrics SDK with it.

01:02:50.960 --> 01:02:51.960
Jan here.

01:02:51.960 --> 01:02:55.120
Question from the internet.

01:02:55.120 --> 01:02:56.120
I heard about them.

01:02:56.120 --> 01:03:02.440
Are there any plans or what is the status of the matrix RTC in the RUS SDK?

01:03:02.440 --> 01:03:08.480
So the question is about RTC in the RUS SDK.

01:03:08.480 --> 01:03:13.920
If you followed the RTC talk before, you notice that most of the RTC part of the RTC is actually

01:03:13.920 --> 01:03:16.680
offloaded to WebRTC in the current implementation.

01:03:16.680 --> 01:03:19.560
So going through a web view.

01:03:19.560 --> 01:03:23.200
For us, as RUS, that means we don't have to bother about most of that.

01:03:23.200 --> 01:03:27.600
There's only some signaling that happens on the actual metrics protocol.

01:03:27.600 --> 01:03:33.840
So we don't have at the moment the plan to implement an actual RTC our side.

01:03:33.840 --> 01:03:41.580
I wouldn't see where you would want to do that for other than that view.

01:03:41.580 --> 01:03:46.080
So currently, it's not on the roadmap, at least for our site.

01:03:46.080 --> 01:03:50.600
Any thoughts about IoT?

01:03:50.600 --> 01:03:59.520
Now that you have that, like users don't have the ones.

01:03:59.520 --> 01:04:00.520
Yeah.

01:04:00.520 --> 01:04:02.200
So that's a common one.

01:04:02.200 --> 01:04:05.760
As RUS is very, so the question is about IoT devices.

01:04:05.760 --> 01:04:06.760
Could you do that with RUS?

01:04:06.760 --> 01:04:08.760
I see you can.

01:04:08.760 --> 01:04:11.200
Yes.

01:04:11.200 --> 01:04:13.000
That is generally possible.

01:04:13.000 --> 01:04:17.960
We have because of the storage systems and some other things in there, and because metrics

01:04:17.960 --> 01:04:23.280
itself is still quite heavy as an overall protocol, we have tried to get it into an

01:04:23.280 --> 01:04:24.480
actual embedded device.

01:04:24.480 --> 01:04:25.480
That is not at the moment possible.

01:04:25.480 --> 01:04:29.680
We would have to improve a lot on the way that we use RUS.

01:04:29.680 --> 01:04:32.200
RUS itself provides that, but we can't do that.

01:04:32.200 --> 01:04:36.720
But you can use it, for example, on an Android, not an Android, you know, because there's

01:04:36.720 --> 01:04:38.520
a, but a Raspberry Pi.

01:04:38.520 --> 01:04:42.320
We know of people that run Raspberry Pis that have signals coming in and then they use the

01:04:42.320 --> 01:04:45.280
RUS SDK to send it over into rooms.

01:04:45.280 --> 01:04:48.800
That is definitely possible because it's more or less just a bot, right?

01:04:48.800 --> 01:04:51.320
From our perspective, it's just a bot.

01:04:51.320 --> 01:04:56.120
So that is possible, but you still need a significant amount of memory at the moment,

01:04:56.120 --> 01:05:00.600
and that would make it not possible for actual embedded devices yet.

01:05:00.600 --> 01:05:02.280
If anybody wants to do that, come to me.

01:05:02.280 --> 01:05:06.960
I can show you and mentor you and help you because it would be very exciting if we had

01:05:06.960 --> 01:05:08.360
possibility to do that.

01:05:08.360 --> 01:05:10.000
Jan, another question from the internet?

01:05:10.000 --> 01:05:14.880
There was a question about the element X, what you see is what you get editor.

01:05:14.880 --> 01:05:22.160
Is it still possible to use just markdown if you want to just use markdown?

01:05:22.160 --> 01:05:23.480
So the question is about the element X.

01:05:23.480 --> 01:05:28.560
With your big editor, can you still use markdown if you want to use markdown?

01:05:28.560 --> 01:05:33.800
Yeah, actually, even on the current element implementation that is on the client, you

01:05:33.800 --> 01:05:35.400
can actually also still use markdown.

01:05:35.400 --> 01:05:41.280
So there's an option that allows you to turn off the rich text and turn back the simple

01:05:41.280 --> 01:05:42.280
text.

01:05:42.280 --> 01:05:45.040
And when the simple text is on, pretty much you can use markdowns.

01:05:45.040 --> 01:05:51.720
But when it renders, I guess, in what you see, what you get, fashion.

01:05:51.720 --> 01:05:55.640
The question is about does the markdown then render in the WYSIWYG?

01:05:55.640 --> 01:05:57.160
No.

01:05:57.160 --> 01:06:01.160
When you're using the simple text version, it's rendering pretty much like a simple text

01:06:01.160 --> 01:06:02.160
with the markdowns.

01:06:02.160 --> 01:06:04.000
So any plans?

01:06:04.000 --> 01:06:08.200
Or maybe in the rich text with the markdowns?

01:06:08.200 --> 01:06:09.200
Currently not.

01:06:09.200 --> 01:06:12.800
We're pretty much trying to build the rich text editor as it is with just the rich text

01:06:12.800 --> 01:06:18.560
using the formatting toolbar to be the most performant and good and simple to it as possible.

01:06:18.560 --> 01:06:23.320
But it is something that for sure when we have a very stable product, we will work into

01:06:23.320 --> 01:06:24.320
it.

01:06:24.320 --> 01:06:25.320
We will look into it.

01:06:25.320 --> 01:06:26.320
No question, Amir?

01:06:26.320 --> 01:06:32.320
Will this finally unite the markdown subtexts that you can use in different element clients?

01:06:32.320 --> 01:06:37.720
Will that finally reduce the amount of different markdown syntaxes that you can use in element

01:06:37.720 --> 01:06:38.720
clients?

01:06:38.720 --> 01:06:42.280
I'm not sure about the question, actually.

01:06:42.280 --> 01:06:43.280
Okay.

01:06:43.280 --> 01:06:48.560
Will the WYSIWYG editor in simple text mode use one unified markdown implementation so

01:06:48.560 --> 01:06:53.960
you don't have to remember different variants of markdown and different clients?

01:06:53.960 --> 01:06:59.000
But you're talking if we are going in the future to support the markdowns inside the

01:06:59.000 --> 01:07:02.400
WYSIWYG directly without turning off the rich text?

01:07:02.400 --> 01:07:04.400
This is what you mean?

01:07:04.400 --> 01:07:10.160
In simple text mode, if you enter markdown, will it parse the same way on element iOS,

01:07:10.160 --> 01:07:14.160
Android, and web?

01:07:14.160 --> 01:07:15.760
So I think there's a confusion here.

01:07:15.760 --> 01:07:19.680
You switch on the WYSIWYG editor, then you get the WYSIWYG.

01:07:19.680 --> 01:07:23.000
If you turn it off, you have a simple text mode.

01:07:23.000 --> 01:07:26.640
You can do some markdown, but it's not going to be rendered inside of this.

01:07:26.640 --> 01:07:31.720
It's going to fall back to the existing implementation.

01:07:31.720 --> 01:07:35.880
So therefore, yeah, to answer your question, it's falling back to the existing implementation.

01:07:35.880 --> 01:07:37.600
So no, they will still be incompatible.

01:07:37.600 --> 01:07:44.840
We might switch to use the markdown for roundtripping, because at some point, I think this was the

01:07:44.840 --> 01:07:49.120
previous question, that people are going to want to roundtrip between the markdown implementation

01:07:49.120 --> 01:07:51.520
and the WYSIWYG one.

01:07:51.520 --> 01:07:54.240
And to do that consistently, you're going to want to use the same library.

01:07:54.240 --> 01:07:55.240
You put that in the Rust layer.

01:07:55.240 --> 01:07:59.800
And then finally, we get out to the nightmare of common mark versus GitHub-flavored markdown

01:07:59.800 --> 01:08:03.080
versus whatever random libraries the different element platforms have.

01:08:03.080 --> 01:08:06.720
I think Android is still out of sync with the others.

01:08:06.720 --> 01:08:07.720
One last question.

01:08:07.720 --> 01:08:11.640
Where can we meet you today or maybe later if we have more questions?

01:08:11.640 --> 01:08:13.440
I think we're going to hang around here, right?

01:08:13.440 --> 01:08:14.440
Yeah, for sure.

01:08:14.440 --> 01:08:15.440
We'll be able to stand.

01:08:15.440 --> 01:08:17.800
We have a stand in K1.

01:08:17.800 --> 01:08:20.760
I'm just going to be around here lurking, so just talk to me.

01:08:20.760 --> 01:08:21.760
Yeah, same for me.

01:08:21.760 --> 01:08:22.760
I'm going to be here.

01:08:22.760 --> 01:08:23.760
I'm the guy with that hat.

01:08:23.760 --> 01:08:24.760
All right.

01:08:24.760 --> 01:08:25.760
Thank you very much.

01:08:25.760 --> 01:08:32.760
Thank you.
