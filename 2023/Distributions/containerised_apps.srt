1
0:00:00.000 --> 0:00:09.120
Good morning. Wow. I was not expecting this much of an audience at 9am on Sunday at a

2
0:00:09.120 --> 0:00:16.080
Fostem, so thank you all for coming. Yeah, I'm here to talk about how I was at Fostem

3
0:00:16.080 --> 0:00:20.480
five years ago. I told you all a whole bunch of things, and I was utterly wrong so many

4
0:00:20.480 --> 0:00:27.000
ways it's actually kind of amusing. But who am I? My name's Richard. I've been working

5
0:00:27.000 --> 0:00:33.320
on OpenSUSE since it began. I've been a customer of SUSE's, I've been a contributor, a bit

6
0:00:33.320 --> 0:00:39.280
of everything. QA engineer, I've been working there for 10 years now, or almost 10 years.

7
0:00:39.280 --> 0:00:45.320
These days I am a ridiculous advocate of rolling releases. It's what everybody should be using.

8
0:00:45.320 --> 0:00:50.440
I created the micro OS desktop. My day job is being one of the release engineers for

9
0:00:50.440 --> 0:00:58.520
tumbleweed and micro OS. I also do a bit of consulting and photography. But, yeah, a long

10
0:00:58.520 --> 0:01:03.720
time ago in a room actually just on the other side of this campus, I was here at Fostem

11
0:01:03.720 --> 0:01:11.280
telling everybody that, yeah, containerised applications, so things like Flapback, Snap,

12
0:01:11.280 --> 0:01:17.760
App images, the idea that graphical apps in some portable format are absolutely utterly

13
0:01:17.760 --> 0:01:21.640
terrible and nobody should be ever using them ever, and they were going to eat all of our

14
0:01:21.640 --> 0:01:28.240
users, and, yeah, it's just going to be horribly, horribly wrong. And I even started the presentation

15
0:01:28.240 --> 0:01:32.680
with quippy comments, like, yeah, those who don't remember the past are condemned to repeat

16
0:01:32.680 --> 0:01:42.240
it, and I even made really unflattering comparisons. Like, doing diagrams from Windows architecture

17
0:01:42.240 --> 0:01:46.320
and pointing out, you know, Windows has all these wonderful runtimes where you can have

18
0:01:46.320 --> 0:01:51.120
different environments and run your application on top, and, you know, it was absolutely terrible

19
0:01:51.120 --> 0:01:57.000
in Windows. It's going to be absolutely terrible when we do the same thing in Linux. Giving

20
0:01:57.000 --> 0:02:03.600
the examples of all of the security issues that you see in Windows in this kind of approach,

21
0:02:03.600 --> 0:02:10.960
you know, things like security relevant DLLs lurking in some folder in your Windows machine,

22
0:02:10.960 --> 0:02:14.000
you know, being an absolute nightmare to patch and an absolute nightmare to fix when it goes

23
0:02:14.000 --> 0:02:20.080
wrong, you know, all these horrible update issues, you know, how do you end up getting

24
0:02:20.080 --> 0:02:24.160
an update on your Windows or your Mac machine? Well, you download some EXE or some bundle

25
0:02:24.160 --> 0:02:30.600
and then there's some updater in it, does whatever the heck it wants on its machine.

26
0:02:30.600 --> 0:02:33.720
Licensing issues, especially with open source, you know, how do you mix and match all these

27
0:02:33.720 --> 0:02:38.600
different licenses together in one cohesive thing? And, you know, it's just going to eat

28
0:02:38.600 --> 0:02:46.160
up all of your disk space. And then I went back to this slide again and then started

29
0:02:46.160 --> 0:02:52.320
talking about the various technologies at the time, 2017, were out there doing this

30
0:02:52.320 --> 0:02:58.080
containerized runtime stuff and I would compare this lovely Windows diagram to this lovely

31
0:02:58.080 --> 0:03:03.280
canonical diagram, which looks very, very similar because actually it is. The idea is

32
0:03:03.280 --> 0:03:09.120
similar, the concept is similar, but as you'll see, just because the concept is similar doesn't

33
0:03:09.120 --> 0:03:14.800
necessarily mean the whole idea is bad, execution does matter. And it wasn't just snap, I wasn't

34
0:03:14.800 --> 0:03:22.760
just shifting on Ubuntu because I don't like Ubuntu. I was doing the same with Flatback.

35
0:03:22.760 --> 0:03:28.440
And I was, yeah, basically pointing out that this whole containerized application idea

36
0:03:28.440 --> 0:03:35.440
was repeating the same issue. We were going to be going down this road of security relevant

37
0:03:35.440 --> 0:03:41.320
libraries lurking in all of these snaps in Flatback. Back then we didn't necessarily

38
0:03:41.320 --> 0:03:46.080
have a good story about how are we going to update these things, how are we going to keep

39
0:03:46.080 --> 0:03:53.000
them maintained, who was going to look after all of these base snaps and runtimes in Flatback

40
0:03:53.000 --> 0:03:57.720
and the like. Who was going to look at all of the legal issues and review the possible

41
0:03:57.720 --> 0:04:01.760
licensing issues of bundling these things together and who was going to buy everybody

42
0:04:01.760 --> 0:04:09.040
bigger hard disks. And the kind of main conclusion that I left with, which despite the fact you'll

43
0:04:09.040 --> 0:04:15.120
see I was wrong about a lot of what I said, I still actually hold true, is at the heart

44
0:04:15.120 --> 0:04:20.760
of it, when distributing software, doesn't matter if you're doing it as a container or

45
0:04:20.760 --> 0:04:28.000
as a full blown fat OS distributor or anything in between with any kind of fancy technology,

46
0:04:28.000 --> 0:04:34.680
the responsibilities are the same. App image, Flatback, Snap might make it easier to be the

47
0:04:34.680 --> 0:04:39.840
upstream than giving out your application to the users. That's great. But the responsibilities

48
0:04:39.840 --> 0:04:44.160
are still the same that distributors have been doing in distributions for years. You

49
0:04:44.160 --> 0:04:49.240
have to worry about maintainability, you have to worry about the security, you have to worry

50
0:04:49.240 --> 0:04:53.520
about licensing and all this wonderful stuff. So they're going to have to borrow all of

51
0:04:53.520 --> 0:04:58.880
the same stuff. So five years ago I gave this presentation. There was lots of people in

52
0:04:58.880 --> 0:05:03.880
the audience from App Image, Snap and Flatback. Some of them said very nice things to me,

53
0:05:03.880 --> 0:05:12.120
some of them said very un-nice things to me. Starting with App Image, they took a lot of

54
0:05:12.120 --> 0:05:20.280
what I said surprisingly on board and really ran with it. I said all this stuff in February

55
0:05:20.280 --> 0:05:29.640
2017 and by June 2017 I was saying stuff like this on stage. This was taken at the Open

56
0:05:29.640 --> 0:05:37.760
SUSE conference, this was on the App Image website for, well, longer than I wish it was.

57
0:05:37.760 --> 0:05:44.760
But the reason it was because in that short window, App Images thought they could address

58
0:05:44.760 --> 0:05:51.280
most of my concerns by actually obviously running to the Open SUSE built service and

59
0:05:51.280 --> 0:05:56.560
working with the Open SUSE built service guys and integrating App Image really quite nicely

60
0:05:56.560 --> 0:06:02.840
with it at the time. So the idea being, you know, the App Image wasn't the problem, maybe

61
0:06:02.840 --> 0:06:09.240
the way you build App Image is the problem. If you build them in a nice auditing built

62
0:06:09.240 --> 0:06:13.920
system and have the whole thing tracked with dependencies in a built system and you build

63
0:06:13.920 --> 0:06:19.480
it reproducibly and you do all the licensing reviews there, then OBS could be the solution

64
0:06:19.480 --> 0:06:26.680
to all of the App Images problem. And, yeah, they worked really nicely with it and they

65
0:06:26.680 --> 0:06:32.480
gave all these promises. They'd be encouraging people to be using OBS as the main App Image

66
0:06:32.480 --> 0:06:40.240
building tool and we'd all move on happy in a nice unified way forward. And I even said

67
0:06:40.240 --> 0:06:45.880
things to snapping a flat back, like you're falling behind App Image at this point, saying

68
0:06:45.880 --> 0:06:51.720
App Image had a better build story. And they were working with other people and telling

69
0:06:51.720 --> 0:06:58.200
people to be more like App Image. I still was badgering on, by the way, you can tell

70
0:06:58.200 --> 0:07:02.840
all my old slides because they have this thing at the bottom. So you can see old me compared

71
0:07:02.840 --> 0:07:08.440
to new me. I was still worrying a little bit about dependencies because, as you'll see,

72
0:07:08.440 --> 0:07:17.320
App Image makes some really interesting assumptions. But I was, you know, June 2017 kind of hopeful

73
0:07:17.320 --> 0:07:21.880
that, you know, we'd get to a point where everybody would be working together and we'd

74
0:07:21.880 --> 0:07:28.080
have sort of maybe a new consistent run time and things could move forward. I was also

75
0:07:28.080 --> 0:07:33.240
hopeful that we might have sandboxing finally because, you know, Snap kind of had some with

76
0:07:33.240 --> 0:07:40.160
App Armor. Flatback has Bubble Wrap. You know, maybe App Armor would be the way forward.

77
0:07:40.160 --> 0:07:47.760
How wrong I was. So now, five years later, where are we? And I don't want to go deep

78
0:07:47.760 --> 0:07:53.240
down in technical issues too much because a lot of this isn't just technical. We're

79
0:07:53.240 --> 0:07:58.240
an open source project. Any technical issue can be fixed, right? It is a lot about what

80
0:07:58.240 --> 0:08:02.240
are people actually doing? What do they actually care about? Where are they actually taking

81
0:08:02.240 --> 0:08:08.320
things? What are we actually doing? So let's judge people by their own standards. This

82
0:08:08.320 --> 0:08:14.000
is a screenshot from the current App Image website. And it says, use this to make Linux

83
0:08:14.000 --> 0:08:21.400
apps that run everywhere. But they don't run everywhere. And they say, as a user, it should

84
0:08:21.400 --> 0:08:30.000
be as easy to install as it is on a Mac or Windows machine. But they're not. And they

85
0:08:30.000 --> 0:08:33.720
say you don't have to learn all these distributions with all these different distros doing things

86
0:08:33.720 --> 0:08:38.840
different ways. Technically, that's true. You just need to learn all these different

87
0:08:38.840 --> 0:08:42.640
distributions and doing all the different things and you have to build your own to put

88
0:08:42.640 --> 0:08:52.400
in your App Image. And I'm not just saying this to, you know, call shade on them. I have

89
0:08:52.400 --> 0:08:58.640
users on micro OS who are trying to run App Images. And they can't because App Images

90
0:08:58.640 --> 0:09:04.120
require Fuse 2. I'm a rolling release. I haven't shipped Fuse 2 for like a year. I've been

91
0:09:04.120 --> 0:09:11.240
using Fuse 3. And you can't get an App Image to work with Fuse 2. It has to be Fuse 2.

92
0:09:11.240 --> 0:09:15.880
The portable image format that isn't portable because it makes assumptions about stuff that's

93
0:09:15.880 --> 0:09:23.600
on the base OS. And not just, you know, not just weird stuff like Fuse, but even down

94
0:09:23.600 --> 0:09:29.280
and dirty in the kernel. If you're running Debian and you try to run an Electron app,

95
0:09:29.280 --> 0:09:33.960
it's not going to work properly. Because the kernel in Debian isn't built the way that App

96
0:09:33.960 --> 0:09:40.680
Image is expecting the kernel to be running. So this is great promise. And it's going to

97
0:09:40.680 --> 0:09:45.520
work in some places. But only if you're lucky enough that your distro has the same assumptions

98
0:09:45.520 --> 0:09:51.520
baked into it that App Image has. And this is a recurring issue. Even reading the App

99
0:09:51.520 --> 0:09:58.560
Image documentation for building App Images, you know, it tells you as a developer, think

100
0:09:58.560 --> 0:10:02.800
about all of the distros where you want your App Image to run on. So the whole promise

101
0:10:02.800 --> 0:10:06.520
of not worrying about distros goes away. You have to worry about more of them than you

102
0:10:06.520 --> 0:10:12.640
normally would. And put every single dependency which might not be fulfilled by that distro

103
0:10:12.640 --> 0:10:18.480
in your App Image. So, yeah, avoid distros by building a huge one and putting it in a

104
0:10:18.480 --> 0:10:25.400
big table. It's a lot of work. It's way too much work. I utterly respect anybody using

105
0:10:25.400 --> 0:10:31.360
it because they're probably doing more work than I am doing of rolling release. Especially

106
0:10:31.360 --> 0:10:37.800
when the recommendations for what you put in that giant App Image is the oldest, crustiest

107
0:10:37.800 --> 0:10:44.240
stuff you can find. They don't recommend avoiding using anything new because anything new is

108
0:10:44.240 --> 0:10:50.040
more likely to have compatibility issues with older distros. So literally find the oldest

109
0:10:50.040 --> 0:10:55.120
distro that's still supported and use that as your base for building App Image. Which,

110
0:10:55.120 --> 0:10:58.400
you know, also seems a bit of a problem to me because, you know, if you're always picking

111
0:10:58.400 --> 0:11:03.240
the oldest, the oldest is always the first one to not get maintenance updates. So you're

112
0:11:03.240 --> 0:11:09.080
just always going to be rebasing on some crusty old almost out of day LTS to do what you want

113
0:11:09.080 --> 0:11:15.680
to do with App Image. It doesn't make any sense by their own standards. And they tell

114
0:11:15.680 --> 0:11:22.360
everybody that it's installing just like on a Mac. You know, just download the binary,

115
0:11:22.360 --> 0:11:27.920
put it on your desktop, right click it, make it executable and it will run. Which, you

116
0:11:27.920 --> 0:11:34.440
know, 15 years ago that's true. That's how you run something on a Mac. I own a Mac now.

117
0:11:34.440 --> 0:11:40.240
That's not how you run stuff on a Mac. There's not a single Mac application I've ever installed

118
0:11:40.240 --> 0:11:45.580
that works that way. Even the Apple documentation makes it very, very clear that if you're downloading

119
0:11:45.580 --> 0:11:49.760
something from the Internet and you double clicking it on a Mac, it's going to run an

120
0:11:49.760 --> 0:11:54.480
installer. Which is a terrible thing anyway. But it needs to run an installer. When you're

121
0:11:54.480 --> 0:11:57.840
downloading random stuff from the Internet, there needs to be checks for dependencies.

122
0:11:57.840 --> 0:12:05.200
There needs to be some modification to what's on the host. So every random downloaded Mac

123
0:12:05.200 --> 0:12:11.840
application has an installer just like Windows. Or it's done in an App Store where Apple are

124
0:12:11.840 --> 0:12:17.700
controlling all that kind of things and helping that along. So, yes, I was wrong about App

125
0:12:17.700 --> 0:12:24.000
Image. First thing, it was terrible. Because they did try and make an effort. But then

126
0:12:24.000 --> 0:12:30.120
I was wrong again because it's actually even worse than I said five years ago. You know,

127
0:12:30.120 --> 0:12:36.200
they failed to do everything that they set out to do. They don't do anything to address

128
0:12:36.200 --> 0:12:43.800
the actual problems with software releasing. You know, dependency problems are just hand-waved

129
0:12:43.800 --> 0:12:48.880
worse than anyone else could possibly do. Licensing issues, security, maintenance, good

130
0:12:48.880 --> 0:12:55.480
luck. Just build a new distro and ship it again. This is worse than we do in distros

131
0:12:55.480 --> 0:13:01.800
with all of the faults I will admit distros have on this. So please, do not use App Images.

132
0:13:01.800 --> 0:13:05.680
And also they're not nice people. Because they kept publishing this for like four years

133
0:13:05.680 --> 0:13:10.160
after I told them to take it down and I had to threaten to sue them. So, like, they're

134
0:13:10.160 --> 0:13:16.920
just not nice. Now, Snap. Despite my reservations back in

135
0:13:16.920 --> 0:13:22.880
2017, actually Snap was at the time the one I was most optimistic about. You know, at

136
0:13:22.880 --> 0:13:28.600
the time, Canonical were actively collaborating with other distributions. They even invited

137
0:13:28.600 --> 0:13:35.040
me to a Snap workshop. Trying to get Snap supported in as many Linux distributions as

138
0:13:35.040 --> 0:13:39.120
possible. They had an approach of upstream first. They were promising that all of the

139
0:13:39.120 --> 0:13:42.920
App Armor patches and all of the enablement they had to do was going to end up in the

140
0:13:42.920 --> 0:13:47.880
kernel and going to end up being upstream. At the time in 2017, you could run your own

141
0:13:47.880 --> 0:13:55.400
Snap store. You could have your own repository for downloading Snaps. And, unlike Flatpak,

142
0:13:55.400 --> 0:14:01.560
where it's much more just graphical, they also had a story for non-graphical apps. It's

143
0:14:01.560 --> 0:14:06.440
only five years ago, but back then, everybody wasn't necessarily using containers for server

144
0:14:06.440 --> 0:14:13.640
stuff the way we are now. So, you know, it was interesting on all those levels. But it's

145
0:14:13.640 --> 0:14:22.080
five years later. And all of the promises of Snap confinement working everywhere so

146
0:14:22.080 --> 0:14:30.000
you can have your nice sandboxed Snap application hasn't come true. Snap does not support confinement

147
0:14:30.000 --> 0:14:37.320
on most non-abundant distributions and even some abundant distributions. And, you know,

148
0:14:37.320 --> 0:14:44.120
this was posted on their forums three years ago now. That was the case three years ago.

149
0:14:44.120 --> 0:14:51.000
You know, users still waiting to get any kind of proper sandboxing in security with Snaps.

150
0:14:51.000 --> 0:14:57.960
Still not there. And then this was posted this month. Still promising. It might happen.

151
0:14:57.960 --> 0:15:02.160
But it's been five years. None of the app armor stuff is in the kernel yet. None of

152
0:15:02.160 --> 0:15:08.440
the enablement we need is in the kernel yet. Distros can't easily or really at all, you

153
0:15:08.440 --> 0:15:17.440
know, keep with an upstream kernel and get Snap running in the way Snap should be running.

154
0:15:17.440 --> 0:15:21.880
So if you run a Snap on a non-abundant distribution, you're probably running it in an incredibly

155
0:15:21.880 --> 0:15:27.720
secure way. Do you trust that random software deliverable with access to everything on your

156
0:15:27.720 --> 0:15:36.720
machine? Probably not. At least that random software developer using Snap isn't using

157
0:15:36.720 --> 0:15:42.280
their own Snap store because they can't anymore. You know, 2017 you could. Then they released

158
0:15:42.280 --> 0:15:47.880
a new version of SnapD. So now the only version of the Snap store that works with SnapD is

159
0:15:47.880 --> 0:15:54.720
kimono course. So, you know, it's an open source package format. But it's a closed source

160
0:15:54.720 --> 0:16:00.000
delivery format. You're only going to get that software from kimono call. And if you

161
0:16:00.000 --> 0:16:04.880
read up on it, there's lots of examples where kimono call have done the right thing and

162
0:16:04.880 --> 0:16:10.240
handled snaps that were malicious and got them off quickly. But it's like, how do you

163
0:16:10.240 --> 0:16:14.280
know you're just trusting kimono call that they're always doing the right thing because

164
0:16:14.280 --> 0:16:18.120
you can't see. You can't see what they're putting on there. You can't see how they get

165
0:16:18.120 --> 0:16:26.800
there. You can't do it yourself. If you trust kimono call, that's fine. But I'm much more

166
0:16:26.800 --> 0:16:31.680
open source orientated myself. I'd rather, even if I am trusting somebody else, I'd rather

167
0:16:31.680 --> 0:16:35.840
be able to have a look and see what's going on in there. Maybe run my own. Maybe compare

168
0:16:35.840 --> 0:16:42.240
something alongside. And yes, for most developers or at least most small developers, this is

169
0:16:42.240 --> 0:16:50.360
free so you can build your snap and publish it to the kimono call snap store with no effort.

170
0:16:50.360 --> 0:16:53.880
But as soon as you start getting bigger, as soon as you start becoming a bit of an ISV

171
0:16:53.880 --> 0:16:58.320
or doing stuff with IoT with lots of devices, then kimono call want you to have a brand

172
0:16:58.320 --> 0:17:03.840
store. And this is in the documentation for snap craft where it comes to building. When

173
0:17:03.840 --> 0:17:09.000
you actually have a look at the price list for having a snap store, the price list is

174
0:17:09.000 --> 0:17:16.880
kind of dear. Do you really want to be spending at least 5000 euros just to be able to publish

175
0:17:16.880 --> 0:17:23.560
your application on somebody else's server under your name? But I can understand if people

176
0:17:23.560 --> 0:17:27.080
are buying into this, I can definitely understand why kimono call aren't in a rush to change

177
0:17:27.080 --> 0:17:32.840
it. It's probably making them a good bit of money. On open suited, like I said, at the

178
0:17:32.840 --> 0:17:41.480
time in 2017, they were working with us. Now, not going so well. Snap is the only bit of

179
0:17:41.480 --> 0:17:46.360
software in all of my years doing anything, police manager at open SUSE where it's failed

180
0:17:46.360 --> 0:17:50.960
more than one security order. It's the only bit of software I've had to project it multiple

181
0:17:50.960 --> 0:17:59.480
times. And there was good collaboration going on to get those issues fixed. But since 2019,

182
0:17:59.480 --> 0:18:07.720
it's kind of fizzled out. Haven't seen anything since. So when it comes to snap, you know,

183
0:18:07.720 --> 0:18:15.840
I was wrong. I was really kind of keen on snap back in 2017. And these days, I can't

184
0:18:15.840 --> 0:18:21.480
really say that much nice about it. The upstream first promises have all stalled. It doesn't

185
0:18:21.480 --> 0:18:25.880
seem to be an effort to get it really moving again and on other distributions. So, you

186
0:18:25.880 --> 0:18:30.920
know, it's not a portable format by any stretch of any imagination. There's no open source

187
0:18:30.920 --> 0:18:36.320
delivery option, you know, even if the snap store may always be the best way of doing

188
0:18:36.320 --> 0:18:43.840
it anyway. There's a case to be made for that, even if there was an open source way. And

189
0:18:43.840 --> 0:18:47.800
it's not really a viable alternative for something like flatback until, you know, unless you

190
0:18:47.800 --> 0:18:51.920
use Ubuntu, unless you trust canonical, unless you're willing to give them money to distribute

191
0:18:51.920 --> 0:19:04.440
your stuff. And so, flatback. Now, need to kind of do a little bit of a detour on this.

192
0:19:04.440 --> 0:19:09.000
Because when I was talking five years ago about all of this stuff, one of the things

193
0:19:09.000 --> 0:19:15.760
that I was kind of trying to pitch in the side thing there was this idea that, you know,

194
0:19:15.760 --> 0:19:19.400
well, everybody should be using rolling releases. I really, really believe that. And I still

195
0:19:19.400 --> 0:19:29.040
believe that now. And I really think, you know, in this modern age, to get applications

196
0:19:29.040 --> 0:19:35.600
in the hands of users, you know, a rolling base operating system is the absolute key.

197
0:19:35.600 --> 0:19:42.800
You need to have it all built together, need to have everything integrated, built consistently,

198
0:19:42.800 --> 0:19:47.440
tested consistently, and taking the fair share of the maintenance and security burden and

199
0:19:47.440 --> 0:19:50.720
then shipping it all in a way that the users don't really care that everything's churning

200
0:19:50.720 --> 0:19:57.620
around underneath. You know, it just works. And at SUSE, we've still been working on this.

201
0:19:57.620 --> 0:20:05.640
We have an operating system called OpenSUSE MicroOS. Vanilla MicroOS is much more server-orientated.

202
0:20:05.640 --> 0:20:11.960
It's immutable, like CoreOS and other similar immutable platforms. Can't be modified during

203
0:20:11.960 --> 0:20:17.800
runtime at all. It's rolling, so changing snapshots. It's actually using the same code

204
0:20:17.800 --> 0:20:23.800
base as tumbleweed, so every day almost. It's small, but small enough to do the job that

205
0:20:23.800 --> 0:20:29.880
it's meant to do. And the assumption is, you know, that server is going to do just one

206
0:20:29.880 --> 0:20:35.880
job in a data center, so, you know, a VM running one RPM or a VM running containers and then,

207
0:20:35.880 --> 0:20:40.800
you know, as many containers on top, but, you know, the job is a container from the

208
0:20:40.800 --> 0:20:46.200
operating system point of view. And this is working really quite well. In fact, SUSE also

209
0:20:46.200 --> 0:20:52.400
has commercial products based on this. SLEE Micro is based directly on OpenSUSE MicroOS.

210
0:20:52.400 --> 0:20:57.000
The new SUSE app you might have heard of where we're thinking of doing a whole new ecosystem

211
0:20:57.000 --> 0:21:05.360
of enterprise distros. That's building off what we did with SLEE Micro and OpenSUSE MicroOS.

212
0:21:05.360 --> 0:21:11.000
But me, you know, I'm still a desktop guy. So, you know, doing this with my day job,

213
0:21:11.000 --> 0:21:15.800
I found myself asking, yeah, I found myself asking, okay, so I've got this nice small

214
0:21:15.800 --> 0:21:24.560
OS and it can run just one thing. What if that just one thing with a desktop? And so

215
0:21:24.560 --> 0:21:32.000
I started the MicroOS desktop project sort of alongside regular MicroOS. And, yeah, basically

216
0:21:32.000 --> 0:21:38.280
it's a modern Chromebook-like, silver blue-like environment where you have a nice, minimal

217
0:21:38.280 --> 0:21:43.520
base system. My recommendation would be running the GNOME one after the one that's most maintained

218
0:21:43.520 --> 0:21:50.800
with a desktop environment on top. And the basic configuration tools are, yeah, in there,

219
0:21:50.800 --> 0:21:55.360
but everything else is provided by somewhere else. In fact, everything else is provided

220
0:21:55.360 --> 0:22:00.360
by Flatpak. So this is one of the reasons why I'm doing this presentation. I kind of

221
0:22:00.360 --> 0:22:04.920
have to explain how in five years I went from Flatpak is the devil to Flatpak is the only

222
0:22:04.920 --> 0:22:09.400
thing you should be running on your desktop. Because I talked to some of the people that

223
0:22:09.400 --> 0:22:16.800
I was talking to back then and this is kind of their expression. Because five years ago,

224
0:22:16.800 --> 0:22:23.760
when I was talking about this stuff, I was meanest about Flatpak than all the other ones.

225
0:22:23.760 --> 0:22:28.400
I was even invited to Guardek and I gave the meanest talk I have ever given to anybody

226
0:22:28.400 --> 0:22:36.840
right to the people who were actually developing the thing. And the guys from GNOME, they listened.

227
0:22:36.840 --> 0:22:42.800
I wasn't right. I'm not right about everything. That's the recurring theme of this presentation.

228
0:22:42.800 --> 0:22:51.500
But they challenged my opinions, but they accepted at least the ones that actually mattered.

229
0:22:51.500 --> 0:22:58.380
And Flatpak has changed. Like I was talking about earlier, responsibility is the key issue

230
0:22:58.380 --> 0:23:04.640
when you're talking about delivering software. No matter how you're distributing it, you

231
0:23:04.640 --> 0:23:10.520
need to be thinking about dependencies and licenses and maintenance and security. And

232
0:23:10.520 --> 0:23:15.080
one thing that Flatpak does very, very well is basically take all of that away from the

233
0:23:15.080 --> 0:23:21.960
distribution and make it the package's problem. Not great if you're a package, but they do

234
0:23:21.960 --> 0:23:26.200
it in a way that actually probably lowers the burden for everybody. So that's nice.

235
0:23:26.200 --> 0:23:30.600
Automation and technology is great. But really, you know, dependencies become the issue of

236
0:23:30.600 --> 0:23:35.920
the person making the Flatpak. Licenses become the issue there. Maintenance, security, et

237
0:23:35.920 --> 0:23:42.680
cetera. So distros can stop worrying about it. And Flatpak does this very well with their

238
0:23:42.680 --> 0:23:46.880
runtime concept where, you know, if you're building an application for GNOME, you have

239
0:23:46.880 --> 0:23:53.200
a GNOME runtime. If you're building an application for KDE, you have a KDE runtime. Elementary

240
0:23:53.200 --> 0:23:59.120
have their runtime as well. And then for everything else, there's the generic free desktop runtime,

241
0:23:59.120 --> 0:24:06.320
which is a little bit heavier and clunkier, but gets the job done. And back in 2017, this

242
0:24:06.320 --> 0:24:11.240
terrified me. Not because there was competing distributions, because I'm used to competing

243
0:24:11.240 --> 0:24:15.640
distributions. The question was really, you know, are these mini distributions going to

244
0:24:15.640 --> 0:24:20.840
be maintained anything like the one, you know, every other distro out there? Are these going

245
0:24:20.840 --> 0:24:28.000
to handle CVEs well? Are they going to not have horrific licensing issues? Et cetera,

246
0:24:28.000 --> 0:24:33.360
et cetera. Well, they've been doing this for five years now. These runtimes are very well

247
0:24:33.360 --> 0:24:40.080
maintained. These are snapshots from their various Git trees. They're all updating very,

248
0:24:40.080 --> 0:24:46.680
very quickly, keeping up with their respected upstreams of GTK and QT and what have you.

249
0:24:46.680 --> 0:24:52.200
Building CVEs very, very well. I'll talk more about that later. So basically, they're handling

250
0:24:52.200 --> 0:24:57.040
this just as well as any other distribution does. Maybe even better in some cases, because

251
0:24:57.040 --> 0:25:02.360
they're narrower in scope. They've actually got less work to do themselves than a full-blown

252
0:25:02.360 --> 0:25:09.160
distribution with tens of thousands of packages. So you've got your runtimes and you've got

253
0:25:09.160 --> 0:25:13.880
your Flatpak application on top of that, but what about the Flatpak client? Especially

254
0:25:13.880 --> 0:25:17.920
if you think about what I was just talking about with Snap earlier with all of the issues

255
0:25:17.920 --> 0:25:24.160
with App Armor and custom patches and what have you. Well, as a distribution guy, getting

256
0:25:24.160 --> 0:25:30.360
Flatpak in my distribution is really not that hard at all. You need to have the client on

257
0:25:30.360 --> 0:25:35.140
that, but you're not having to worry about a huge chain of dependencies and a whole bunch

258
0:25:35.140 --> 0:25:40.200
of plumbing to get it running. I don't need to have Fuse2 on my distro. All I need to

259
0:25:40.200 --> 0:25:46.720
have is Bubble Wrap, OS 3, and a couple of XDG packages. And they themselves don't really

260
0:25:46.720 --> 0:25:53.240
pull that much in as well. So it's small, it's simple, it's relatively easy, it's self-contained.

261
0:25:53.240 --> 0:25:57.680
Doesn't cause me huge build chains when I have to rebuild the whole thing in Tumbleweed.

262
0:25:57.680 --> 0:26:04.200
It's a really nice ecosystem to just plop on top of my distro and then all of the applications

263
0:26:04.200 --> 0:26:12.960
come from Flatpak. From a licensing perspective, all the Flatpaks on FlatHub are checked. They

264
0:26:12.960 --> 0:26:20.760
all have to have some kind of license that allows open redistribution or legal redistribution.

265
0:26:20.760 --> 0:26:28.080
Or they do also support proprietary stuff. You can get a Spotify Flatpak. But obviously,

266
0:26:28.080 --> 0:26:35.880
you can't have the source code for the Spotify binary in their get tree. So all of the proprietary

267
0:26:35.880 --> 0:26:43.480
stuff has to be pulled through by discrete declared links. And the Flatpak, specifically

268
0:26:43.480 --> 0:26:51.120
the FlatHub team, are checking that, verifying that things aren't changing there, not letting

269
0:26:51.120 --> 0:26:56.720
nasty things happen and binary flip around. So at the very least, you may not know exactly

270
0:26:56.720 --> 0:27:02.000
what horrible thing is in this sandbox, but it's sandboxed, it's not much of a threat

271
0:27:02.000 --> 0:27:06.360
to your machine anyway. And you know it's the one that was sent at submission time,

272
0:27:06.360 --> 0:27:10.080
you know it was the one that was reviewed, you know it isn't changing unexpectedly. So

273
0:27:10.080 --> 0:27:14.520
basically it's as good or as better as any other distribution out there with their native

274
0:27:14.520 --> 0:27:24.080
packages. When it comes to maintenance, basically the same story. Just like OpenSUSE, FlatHub

275
0:27:24.080 --> 0:27:29.120
doesn't like FlatPaks to have distro specific packages or FlatPak specific packages. They

276
0:27:29.120 --> 0:27:36.040
want as everything upstream as possible. They have an incredibly robust build, test, publish

277
0:27:36.040 --> 0:27:41.120
workflow. They're not using OBS, I wish there was. They're not using OpenQA, I wish there

278
0:27:41.120 --> 0:27:47.680
were. But what they're using is just as good, maybe in some ways it's better, they can actually

279
0:27:47.680 --> 0:27:51.400
give everyone nice test channels for testing their application, which I really think I

280
0:27:51.400 --> 0:27:59.080
want to copy sometime. But yeah, it's maintained, it's easy for maintainers to keep their app

281
0:27:59.080 --> 0:28:07.000
maintained and that is all ticking over nicely. From a security point of view, well FlatPak

282
0:28:07.000 --> 0:28:13.840
is the only one that works everywhere. It's the only one that those applications are sandboxed.

283
0:28:13.840 --> 0:28:21.280
The portal concept where you know basically holes are pegged through the sandbox to give

284
0:28:21.280 --> 0:28:25.400
you things like access to the file picker and other parts of the file system and the

285
0:28:25.400 --> 0:28:33.400
like has proven to be secure enough and expandable enough. It's not perfect, nothing ever is.

286
0:28:33.400 --> 0:28:36.400
But it's doing the job and it's doing the job well and these applications are working

287
0:28:36.400 --> 0:28:44.360
very well. And FlatPak CVEs happen very, very rarely. And when they do happen, they're

288
0:28:44.360 --> 0:28:49.440
not these terrifying, scary things because the thing is architected very, very well.

289
0:28:49.440 --> 0:28:55.640
So the last CVE that I could find was in February 2022. It was a medium score, it was fixed

290
0:28:55.640 --> 0:28:59.560
incredibly quickly. I think every distribution had no problem adding that because again,

291
0:28:59.560 --> 0:29:05.040
like I mentioned earlier, given the client is very well structured, you don't have a

292
0:29:05.040 --> 0:29:11.720
huge dependency chain, even the most ancient of OTSS distros can then just happily get

293
0:29:11.720 --> 0:29:19.000
the patch in, get the thing running. So when I started the microS desktop, I adopted FlatPak

294
0:29:19.000 --> 0:29:23.520
some FlatHub, actually November 2017, so if you put the timeline in there, I did change

295
0:29:23.520 --> 0:29:29.040
my opinion quite a bit from the beginning of February 2017 to the end. But I was using

296
0:29:29.040 --> 0:29:33.400
FlatPak as it was the one that I could work with. I couldn't use Snap, couldn't use App

297
0:29:33.400 --> 0:29:39.760
Image. And I didn't trust it that much at the time. I was thinking, like you've seen

298
0:29:39.760 --> 0:29:44.200
with other distributions of building my own FlatPak and using them rather than trusting

299
0:29:44.200 --> 0:29:48.960
FlatHub or doing like Fedora does with they build their own and then they also give FlatUp

300
0:29:48.960 --> 0:29:53.760
with some kind of filtering. But I didn't really want to mess with that at the beginning

301
0:29:53.760 --> 0:29:59.520
of my project doing all of this, so I just opted for trusting FlatHub first and then

302
0:29:59.520 --> 0:30:05.400
waiting for the problems to surface. And it's five years later and I'm still waiting. Like

303
0:30:05.400 --> 0:30:11.000
we haven't had a single issue with the microS desktop where a FlatHub application really

304
0:30:11.000 --> 0:30:15.120
got in the way and needed us to think, okay, you know, we can't trust these guys, we should

305
0:30:15.120 --> 0:30:19.480
start doing all of them. It just hasn't happened. The few times an application hasn't worked

306
0:30:19.480 --> 0:30:23.880
right, well, we send a patch. We work with them because that's how open source is meant

307
0:30:23.880 --> 0:30:32.280
to work, right? So as a distribution guy, I've realized we don't need to be building

308
0:30:32.280 --> 0:30:39.120
these giant humongous, huge code bases, even though that's still what we do with Tumbleweed.

309
0:30:39.120 --> 0:30:44.680
I don't meet myself. I'm purely a microS person now. All of my servers are microS. My desktop

310
0:30:44.680 --> 0:30:52.800
here is microS. I'm using a tiny 1,000 package fraction of my Tumbleweed code base. And everything

311
0:30:52.800 --> 0:30:57.400
else is coming from containers, some of which are built from that much bigger code base.

312
0:30:57.400 --> 0:31:04.680
All my graphical stuff is coming from Flour. And my life is good and I'm happy. And this

313
0:31:04.680 --> 0:31:11.880
presentation is LibreOffice from Flour. So my final thoughts, which I realized I'm actually

314
0:31:11.880 --> 0:31:16.400
finishing a little bit early, but that's good more time for Q&A. Flatpacks are ready for

315
0:31:16.400 --> 0:31:24.160
prime time. The other ones aren't. Don't use app image. Only use Snap if you trust Canonical.

316
0:31:24.160 --> 0:31:29.160
But we're here at Fostem. Flatpacks are the better way to go for people like you who are

317
0:31:29.160 --> 0:31:38.840
here at Fostem. And my system automatically updated in the background. Yeah. Desktop Linux

318
0:31:38.840 --> 0:31:42.800
distros do not need to package the whole world. If you're a distro builder, think about following

319
0:31:42.800 --> 0:31:47.400
the model we are doing with microS desktop. Think about if not narrowing your scope because

320
0:31:47.400 --> 0:31:50.920
you're building the packages and you don't want to tell maintainers to go away, then

321
0:31:50.920 --> 0:31:57.160
at least just start drawing your focus more on just what you need to be doing. Start testing

322
0:31:57.160 --> 0:32:03.360
that part more. Start telling your users that's the bit you can really, really trust and give

323
0:32:03.360 --> 0:32:13.960
some secondary class to the old fashioned way of doing things. Yes. So you are telling

324
0:32:13.960 --> 0:32:20.160
us that Flatpacks run everywhere. Is that also true for different architectures? That is

325
0:32:20.160 --> 0:32:25.400
true at least for ARM, for Z, probably not. But do you really have that many desktops

326
0:32:25.400 --> 0:32:31.120
in the mainframe? Yes, of course. Yeah. Well, then that's something I'm sure the Flathub

327
0:32:31.120 --> 0:32:35.080
team wouldn't mind. I'm sure we could get that working on Flatpack. If there's a need

328
0:32:35.080 --> 0:32:40.560
there, then... Also thinking about a risk drive, of course, and stuff like that. Yeah.

329
0:32:40.560 --> 0:32:46.400
But then that kind of, you know, point actually nicely draws me to my sort of finishing point,

330
0:32:46.400 --> 0:32:51.960
really. None of this stuff is ever going to be perfect. No technology ever is. That's

331
0:32:51.960 --> 0:32:58.360
why we do this stuff in the open. That's why we do this stuff open source. So when things

332
0:32:58.360 --> 0:33:02.240
aren't perfect and aren't the way they are, aren't covering an architecture that you want

333
0:33:02.240 --> 0:33:08.000
or whatever, you know, isn't it better to go to a project that is already going in that

334
0:33:08.000 --> 0:33:14.000
direction that is trying to be available to everybody that is open to me yelling at them

335
0:33:14.000 --> 0:33:20.840
for months about how terrible they are and then work with them to get it all done rather

336
0:33:20.840 --> 0:33:26.200
than sticking in your own tiny little sandbox, doing it all on your own and then being burdened

337
0:33:26.200 --> 0:33:30.960
with it for decades. Like, if you're doing graphical applications, this is the way we

338
0:33:30.960 --> 0:33:37.480
should be going. It's easier for package maintainers. It's easier for distros. It's easier for everyone

339
0:33:37.480 --> 0:33:41.880
to keep up. It's easier for users, too. Nice little web store. They click on what they

340
0:33:41.880 --> 0:33:46.600
want. They can have the beta version if they publish the beta version. It's a nice way

341
0:33:46.600 --> 0:33:53.160
of getting stuff done. So, yeah. Please, if you're doing anything with graphical apps,

342
0:33:53.160 --> 0:33:57.760
please get it on Flattobe. Please contribute to Flattback. Please put Flattback in your

343
0:33:57.760 --> 0:34:05.160
distro. And is there any other questions? Yes, right at the back there.

344
0:34:05.160 --> 0:34:17.960
You've addressed the outstanding question about CPU architecture, which is a great question.

345
0:34:17.960 --> 0:34:22.880
How do you feel about the fact, and I realize I'm asking the Linux question of a Linux distro

346
0:34:22.880 --> 0:34:27.360
container, but how do you feel about the fact that containers tie everyone in the world

347
0:34:27.360 --> 0:34:34.760
to the Linux kernel interface as their interface, shutting out other open kernel options, like

348
0:34:34.760 --> 0:34:42.200
the BSDs, from participating in that ecosystem? And that the overall drive towards containers

349
0:34:42.200 --> 0:34:49.200
is further orphaning these already minimally represented but very, very strong options

350
0:34:49.200 --> 0:34:59.040
in other kernels. They're strong, but I mean, I guess the recurring

351
0:34:59.040 --> 0:35:05.400
point I get to with all of this kind of thing is, you know, niche players are great for

352
0:35:05.400 --> 0:35:10.640
playing in niches. When you're talking about something that needs to have widespread adoption

353
0:35:10.640 --> 0:35:16.680
and or widespread contribution, some degree of centralization does make sense. It doesn't

354
0:35:16.680 --> 0:35:19.760
make sense for everybody to go make their own kernel. It doesn't make sense for everybody

355
0:35:19.760 --> 0:35:24.760
to make their own distribution. I would say it doesn't make sense for everybody to go

356
0:35:24.760 --> 0:35:29.960
packaging their own graphical applications 20 times over. So as hard as it is to say

357
0:35:29.960 --> 0:35:35.920
to somebody who's clearly passionate about other kernels and BSDs and what have you,

358
0:35:35.920 --> 0:35:42.240
I'm fine with containerization and these technologies dragging everybody to the Linux kernel because

359
0:35:42.240 --> 0:35:48.840
that's where the contributions are. So, you know, and as long as the Linux kernel is open

360
0:35:48.840 --> 0:35:53.280
to contributions and everybody can steer it in a good direction, I'm kind of okay with

361
0:35:53.280 --> 0:36:04.960
that. Thank you for your talk. I was with the presentation

362
0:36:04.960 --> 0:36:10.960
of 2017, so I think it's very nice that you changed the fuse. That year I also watched

363
0:36:10.960 --> 0:36:16.040
the presentation about atomic from Fedora. So it was funny how those things interlapped.

364
0:36:16.040 --> 0:36:21.320
I have a question about how you feel about the base system. You see currently there are

365
0:36:21.320 --> 0:36:30.120
trends like Nix and like SteamOS, which use like an immutable image as a base. How do

366
0:36:30.120 --> 0:36:33.680
you feel about that? So I think immutable distributions are the

367
0:36:33.680 --> 0:36:37.680
way to go. Like I think if you're running Linux, it should be immutable. Immutability

368
0:36:37.680 --> 0:36:46.680
does bring with it a bunch of extra questions. And, you know, and for us as geeks, I think

369
0:36:46.680 --> 0:36:51.560
I can say that without insulting anybody in the room, you know, we are keen to tinker

370
0:36:51.560 --> 0:36:55.600
with our machines and of course, immutability quite often can get in the way of that. If

371
0:36:55.600 --> 0:36:59.160
you can't change your running system, how are you going to install that one little thing

372
0:36:59.160 --> 0:37:08.160
that you want? I think there's a sweet spot. And I don't think some of the other distributions

373
0:37:08.160 --> 0:37:13.360
get it. You know, image-based deployments, you know, you've got a frozen image, you can't

374
0:37:13.360 --> 0:37:17.920
really modify that image, or you have to build a whole new one. That's too much work. I don't

375
0:37:17.920 --> 0:37:23.200
like image-based immutable systems that much. Nix has an interesting way with everything

376
0:37:23.200 --> 0:37:28.120
being declative, but it's a lot of hassle declaring everything. It kind of swings the

377
0:37:28.120 --> 0:37:36.080
other way for me, so I don't necessarily like the Nix way. OSTree has an interesting take

378
0:37:36.080 --> 0:37:42.560
on the whole thing, where both from a user's perspective and the fact it's immutable, it's

379
0:37:42.560 --> 0:37:47.120
nice but then you end up with a million different layers of OSTree and it just gets technically

380
0:37:47.120 --> 0:37:53.240
burdensome. Obviously, I work on microOS, I think we found that sweet spot. In our case,

381
0:37:53.240 --> 0:37:58.480
we're using BTRFS snapshots to do all the magic underneath the hood where your running

382
0:37:58.480 --> 0:38:03.360
system never gets touched, but you can still do traditional package management against

383
0:38:03.360 --> 0:38:06.840
a new snapshot and that becomes your next boot target. So you're never affecting the

384
0:38:06.840 --> 0:38:10.560
running system, but you can do whatever the heck you want with your next boot. And then

385
0:38:10.560 --> 0:38:15.840
if that next boot goes horribly wrong, we just throw the whole snapshot away. So it's

386
0:38:15.840 --> 0:38:20.160
super fast, super easy, avoids all of that. You can still tinker with it, but you're not

387
0:38:20.160 --> 0:38:24.680
... Unfortunately, the downside of that is I do sometimes have to tell people don't tinker

388
0:38:24.680 --> 0:38:28.440
too much. The more you do crazy stuff, the more likely you're going to throw that snapshot

389
0:38:28.440 --> 0:38:35.680
away. But I think that sweet spot is better than super lockdown images or complete freedom

390
0:38:35.680 --> 0:38:40.760
of having to declare everything in a config file.

391
0:38:40.760 --> 0:38:51.440
Okay. Thank you for the presentation. I had never heard of Flatpak. On my Ubuntu, I'm

392
0:38:51.440 --> 0:38:57.600
using Snap to install application. And on my Mac, I'm using Homebrew. What do you think

393
0:38:57.600 --> 0:39:00.800
of Homebrew on Linux?

394
0:39:00.800 --> 0:39:08.720
I don't see the point of Homebrew on Linux. Yeah. It's... Yeah. Why? Like I get it on

395
0:39:08.720 --> 0:39:13.760
my Mac, I've installed a few things on my Mac that I desperately need there. But my

396
0:39:13.760 --> 0:39:21.920
Mac, I use for photography. I don't do anything technical on it. So yeah. Don't see the point.

397
0:39:21.920 --> 0:39:29.320
Okay. Thank you.

398
0:39:29.320 --> 0:39:34.960
How likely is it for the files stored in the home directory, especially the user files,

399
0:39:34.960 --> 0:39:39.040
to be accepted if I roll back a snapshot after a failed upgrade?

400
0:39:39.040 --> 0:39:45.880
So yeah. That's a really like micro specific question. That's cool though. The way we do

401
0:39:45.880 --> 0:39:50.600
it on micro OS is when we talk about the root file system, we're not talking about the root

402
0:39:50.600 --> 0:39:57.360
partition because we're using BTRFS. So BTRFS, you have this concept of sub volumes. We have

403
0:39:57.360 --> 0:40:03.940
a sub volume for literally everything where the data should be changing. So Home, Opt,

404
0:40:03.940 --> 0:40:10.360
because that's third party, so it's not us. User local, because again, that's not us.

405
0:40:10.360 --> 0:40:14.800
Anything that isn't the distro is in a sub volume, and then the distro's root file system

406
0:40:14.800 --> 0:40:19.000
is just that last bit that's left. So that bit's read only. That's the bit that's managed

407
0:40:19.000 --> 0:40:24.880
by the package manager. All the sub volumes are freely available and read write. That

408
0:40:24.880 --> 0:40:28.720
does make ETC a little bit interesting, because that's like the one folder where it's both,

409
0:40:28.720 --> 0:40:34.360
like distro's put stuff in there and that. In micro OS we handle that with overlay FS

410
0:40:34.360 --> 0:40:40.000
right now, where yeah, we're basically taking copies of that, knowing what we put there,

411
0:40:40.000 --> 0:40:43.800
knowing what the user put there, or at least trying to, and then merging everything together

412
0:40:43.800 --> 0:40:51.040
so the thing works. Ideally what we would like is everybody to start using, like most

413
0:40:51.040 --> 0:40:58.040
people already are, user for putting in distribution convicts at USR. It should be in user lib

414
0:40:58.040 --> 0:41:03.600
or user ETC or whatever. Just like you see with system D, where distro's put their distro

415
0:41:03.600 --> 0:41:11.560
config in user lib system D, and then users put their local config in ETC system D. That

416
0:41:11.560 --> 0:41:16.320
way works very, very nicely, but meanwhile ETC's a bit of a mess, but a mess that we

417
0:41:16.320 --> 0:41:30.600
can manage. Thank you for the presentation. Why isn't

418
0:41:30.600 --> 0:41:40.680
flatback suitable for CLIs? Actually it is suitable for CLIs. There's actually a guide

419
0:41:40.680 --> 0:41:50.280
now for how to do that. I think the, so yeah, there are examples of apps where they do that,

420
0:41:50.280 --> 0:41:56.760
where the assumption is always probably going to be that it's graphical, but there's no

421
0:41:56.760 --> 0:42:02.560
reason why a graphical application can't start an X term and run a CLI app. There's actually

422
0:42:02.560 --> 0:42:09.520
examples in the flatback documentation of how to do that. Generally speaking, for apps

423
0:42:09.520 --> 0:42:18.440
that might not fit that kind of model, I think a lot of that kind of CLI or more service-based

424
0:42:18.440 --> 0:42:24.200
command-lining stuff, that's handled so well by OCI containers, Podman, Docker and the

425
0:42:24.200 --> 0:42:30.680
like. Why mess with that? You've got all those containers already out there, you've got everyone

426
0:42:30.680 --> 0:42:38.960
building command-line tooling and server tooling in containers. That does very, very well in

427
0:42:38.960 --> 0:42:44.560
that context. It just sucks on the desktop to have flatback that just handles the desktop

428
0:42:44.560 --> 0:42:50.840
issue. You don't necessarily have to have one thing to do everything. So I think flatback

429
0:42:50.840 --> 0:42:55.760
draws that line quite nicely, where it naturally starts getting painful when you head down

430
0:42:55.760 --> 0:43:09.720
that road. Any more questions? No? Well, hopefully I will see you in a couple of years when I'm

431
0:43:09.720 --> 0:43:26.160
on the game. Thank you very much.

