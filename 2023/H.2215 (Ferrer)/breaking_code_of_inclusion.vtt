WEBVTT

00:00.000 --> 00:15.720
Now is the time for the Yoshimalize.

00:15.720 --> 00:28.760
And he speaks about breaking the code of inclusion, the designing micro materials based on principles

00:28.760 --> 00:31.360
for accessible programming education.

00:31.360 --> 00:33.760
Very difficult title.

00:33.760 --> 00:37.400
So, okay, the stage is yours.

00:37.400 --> 00:38.400
Thank you.

00:38.400 --> 00:39.400
Thank you.

00:39.400 --> 00:41.400
So, my name is Yoshie.

00:41.400 --> 00:43.400
My name is Yoshie.

00:43.400 --> 00:49.000
I'm a PhD student at the Ray University at Bristol.

00:49.000 --> 00:53.080
And today I'll be giving a talk about how we can design more open.

00:53.080 --> 00:55.080
Sorry for that.

00:55.080 --> 01:02.080
Okay, okay, okay, good.

01:02.080 --> 01:08.000
Just, all right.

01:08.000 --> 01:22.080
So, I'm Yoshie and I'll be giving a talk about how we can design more open and inclusive

01:22.080 --> 01:25.840
pedagogical material to teach programming.

01:25.840 --> 01:29.920
I'll first like to start a bit with a small introduction to tell you why we think this

01:29.920 --> 01:31.280
talk is important.

01:31.280 --> 01:36.360
So, I've always been passionate both by programming but also by education.

01:36.360 --> 01:41.640
I joined CoderDojo from a very young age helping kids to learn how to code.

01:41.640 --> 01:46.600
And I also went for an internship abroad in Kenya to build software for schools in less

01:46.600 --> 01:52.040
fortunate areas where I could firsthand experience what technology can do to help education.

01:52.040 --> 01:58.800
Upon graduating, I joined Hack Your Future Belgium for those of you that don't know.

01:58.800 --> 02:04.640
It's a small nonprofit organization in Brussels that organizes coding boot camps for refugees

02:04.640 --> 02:09.000
that are trying to find a job in the tech sector here.

02:09.000 --> 02:15.200
So, before we go on to the meat of the presentation, let's take a look at some of the background

02:15.200 --> 02:17.240
information we need.

02:17.240 --> 02:21.320
I'm pretty sure most of you remember your first programming classes where you had to

02:21.320 --> 02:25.240
install a weird-looking editor with hundreds of buttons.

02:25.240 --> 02:26.960
You had to type in some text.

02:26.960 --> 02:32.680
You tried to press the play button or a compile button, and you would see a weird error message

02:32.680 --> 02:34.960
that you didn't really understand.

02:34.960 --> 02:38.000
This can be very demotivating.

02:38.000 --> 02:43.920
And it's actually even worse when it happens to people from already underrepresented groups

02:43.920 --> 02:48.840
because if they encounter these types of errors, they internalize it, and they feel like it's

02:48.840 --> 02:54.280
a confirmation that, yes, maybe they do not belong in such a classroom, which is, of course,

02:54.280 --> 02:56.880
not the message they want to send.

02:56.880 --> 03:03.840
Now, in the past years, there has been a new methodology of teaching programming that tries

03:03.840 --> 03:07.480
to limit this issue, and it's based called the PRIM principles.

03:07.480 --> 03:12.760
Now, the idea is instead of starting to write your program from scratch from day one, you

03:12.760 --> 03:16.280
basically start with a simple exercise predict.

03:16.280 --> 03:21.200
In this stage, you look at some existing code, you download it, and you're going to try to

03:21.200 --> 03:25.960
predict what will the result be if I run this piece of code.

03:25.960 --> 03:30.800
Then in the next stage, you're actually going to download the code and execute it, and going

03:30.800 --> 03:35.080
to verify whether your prediction is correct or not.

03:35.080 --> 03:40.320
Then in the third stage, we're going to ask you to actually make exercises on the problem.

03:40.320 --> 03:46.040
This can be label all the variables, or can you tell me which variables are updated at

03:46.040 --> 03:47.520
some point in the code.

03:47.520 --> 03:52.640
Now, up until this point, the learner hasn't changed anything about that code itself, and

03:52.640 --> 03:57.600
as such, he also doesn't feel like it's a personal failure if something goes wrong in

03:57.600 --> 03:58.600
the process.

03:58.600 --> 04:03.320
We're going to try to change this in the fourth step, modify, where we're still not going

04:03.320 --> 04:07.320
to ask the student to write code from scratch, but we're going to give them a functioning

04:07.320 --> 04:12.040
program, and we're going to ask them, hey, can you make some small modifications?

04:12.040 --> 04:15.920
Like instead of running this loop three times, run it six times.

04:15.920 --> 04:19.920
It's only in the last stage where we're going to ask them to actually write a new program

04:19.920 --> 04:23.520
from scratch using the same principles he developed earlier.

04:23.520 --> 04:28.520
Now, this is a new methodology in teaching and programming education, but it's based

04:28.520 --> 04:33.480
on a very well-known pedagogical concept called the zone of proximal development, where the

04:33.480 --> 04:34.960
idea is quite simple.

04:34.960 --> 04:39.520
If you're only doing tasks you can do by yourself, you're not actually learning anything, you're

04:39.520 --> 04:41.720
just repeating stuff.

04:41.720 --> 04:47.640
But if I give you a task that you cannot do yourself, even with some help, you're actually

04:47.640 --> 04:52.160
just going to get demotivated and lose all motivation to continue learning.

04:52.160 --> 04:53.520
So that's also not good.

04:53.520 --> 04:58.680
So we should always strive to give exercises in this yellow zone, where the student cannot

04:58.680 --> 05:04.840
easily do it on their own, but with some proper guidance they can get there.

05:04.840 --> 05:06.760
Which brings us to micromaterials.

05:06.760 --> 05:13.640
Now a micromaterial is an open education resource, so anybody can easily include it in their

05:13.640 --> 05:18.760
curriculum, but it should also provide some sort of automated feedback so that even though

05:18.760 --> 05:22.960
the teacher is not there directly to guide the student, they can still get something

05:22.960 --> 05:24.160
away from it.

05:24.160 --> 05:28.880
Ideally, you also want some kind of automatically generated content, because managing all the

05:28.880 --> 05:34.320
content for exercises can be a very time-consuming exercise for teachers.

05:34.320 --> 05:39.000
So now we'll discuss some small examples that we within our lab have built to experiment

05:39.000 --> 05:40.600
with these ideas.

05:40.600 --> 05:47.920
So the first sample we'd like to discuss is an online environment to practice the use

05:47.920 --> 05:48.920
of HTML.

05:48.920 --> 05:53.360
It is designed for engineering students, where we do not really expect to be able to develop

05:53.360 --> 05:58.480
HTML websites on their own, but they should be able to grasp the core concepts of what

05:58.480 --> 06:00.360
the elements are about.

06:00.360 --> 06:06.040
So we have a stepwise progress that they can follow level by level, and we always start

06:06.040 --> 06:11.240
with a small presentation of the core HTML concepts that they need to know.

06:11.240 --> 06:17.360
Now once it's time to actually practice their HTML, we do not just give them an editor,

06:17.360 --> 06:22.200
but instead we make use of Google's Blockly library to show this kind of HTML blocks that

06:22.200 --> 06:26.760
already contain the syntax so they can focus on what the text represents and not on the

06:26.760 --> 06:28.880
syntax itself.

06:28.880 --> 06:35.520
And here we analyze sample HTML code to generate the blocks, so adding new levels is as simple

06:35.520 --> 06:40.000
as providing a new website we want them to recreate.

06:40.000 --> 06:46.200
We also dynamically create links for every element, like hints for every element that

06:46.200 --> 06:49.240
they will need to use in the page.

06:49.240 --> 06:54.880
We have a similar environment for the practice of databases for the same engineering students.

06:54.880 --> 06:59.480
We used to have a lot of problems where they had to install databases locally, database

06:59.480 --> 07:04.080
files could get corrupt and they could turn into issues, so we developed a fully online

07:04.080 --> 07:10.240
environment with the use of SQL.js, which is an open source project based on SQLite

07:10.240 --> 07:13.200
compiled to WebAssembly using Enscriptum.

07:13.200 --> 07:19.280
So in this simple application they would get to see a description of a database, and on

07:19.280 --> 07:22.240
this database they would get to run queries.

07:22.240 --> 07:29.320
The queries would be typed into an online code editor based on atom, so they get syntax

07:29.320 --> 07:33.900
highlighting, they get code completion, and whenever they were to execute the queries

07:33.900 --> 07:38.160
they could see the results directly in their browsers, and this they would use to answer

07:38.160 --> 07:42.080
questions about the data.

07:42.080 --> 07:46.560
Similarly if it was more about inserting or updating the data, we could no longer do with

07:46.560 --> 07:50.920
simply having a simple fill-in-the-answer type of question.

07:50.920 --> 07:56.400
So instead we're going to run checks to see at which step did they fail, so they can stepwise

07:56.400 --> 08:02.680
go back and modify the code until they get it right for all the constraints.

08:02.680 --> 08:06.160
Similarly as well if they want to create new tickets we would also generate test cases

08:06.160 --> 08:08.840
for those.

08:08.840 --> 08:14.240
Another problem that's very often looked at is can the students interpret codes, and

08:14.240 --> 08:17.040
a common tool for these are trace tables.

08:17.040 --> 08:21.520
Now for those of you that don't know, a trace table is just away for example here where

08:21.520 --> 08:27.520
you can look through your program line by line and note down what happens at each line.

08:27.520 --> 08:32.640
For example this trace table is designed to look at which variables are declared or initialized

08:32.640 --> 08:37.440
or updated at certain moments in time.

08:37.440 --> 08:41.440
Different type of trace tables would be the operators trace table which gives the student

08:41.440 --> 08:47.800
a view of which operators are used at which points in the program.

08:47.800 --> 08:53.520
A third one would be these variable values which is basically a way to see which variables

08:53.520 --> 08:58.880
are updated at which point in time, which is a way that we can know is the student actually

08:58.880 --> 09:02.760
reasoning about this code correctly.

09:02.760 --> 09:06.780
Lastly we have a very basic trace table for advanced users where they can just keep track

09:06.780 --> 09:09.240
of the latest state of the program.

09:09.240 --> 09:15.320
Now to this trace table application we added some export functionality so teachers could

09:15.320 --> 09:20.240
import the JSON from the student so we could run some diagnostics to see if students were

09:20.240 --> 09:23.600
understanding the codes correctly.

09:23.600 --> 09:27.720
Then we add more of a social game, a coding card conundrum.

09:27.720 --> 09:31.520
It's basically a kind of card game where there are three types of cards.

09:31.520 --> 09:35.860
We have goal cards that say in a certain condition that needs to be true.

09:35.860 --> 09:40.920
We have environment cards that initialize five variables and we have code cards that

09:40.920 --> 09:48.760
would execute some codes to update the global state of the program.

09:48.760 --> 09:50.560
It's a multiplayer game.

09:50.560 --> 09:54.840
It can be played from one to four people.

09:54.840 --> 10:01.440
We get this field where each player gets a handful of cards and there will be three heaps

10:01.440 --> 10:03.800
in the center.

10:03.800 --> 10:08.040
During their turn students could select a card from their hand and place it on one of

10:08.040 --> 10:09.040
the environments.

10:09.040 --> 10:14.160
If they were doing so they would have to update this state table to reflect the new latest

10:14.160 --> 10:18.160
state after executing the code on their card.

10:18.160 --> 10:21.960
And if they manage to achieve the goal on their goal card they will get awarded some

10:21.960 --> 10:22.960
points for it.

10:22.960 --> 10:26.960
So it's a social game where they can still practice their trace tables.

10:26.960 --> 10:30.600
Then the final one we're going to discuss is King scroll.

10:30.600 --> 10:35.400
Even here we tried to make it a bit more silly, we added like a fantasy theme where the idea

10:35.400 --> 10:40.020
was that we live in a kingdom but the kingdom is going to be attacked by an evil dragon

10:40.020 --> 10:45.440
and it's up to us to find out which of the heroes will be able to stop the dragon.

10:45.440 --> 10:52.000
Now there are 16 heroes randomly generated based on four essential variables of the equipment

10:52.000 --> 10:59.360
they are wearing and two extra variables to increase the inclusiveness of our application.

10:59.360 --> 11:05.680
Students would be shown a scroll that would be randomly generated based on essential JavaScript

11:05.680 --> 11:10.680
features that would update the state of those four variables and it's up to the students

11:10.680 --> 11:16.240
to predict after the program has run which of the heroes matches the final description.

11:16.240 --> 11:21.360
Students were able to automatically select which elements of JavaScript they know or

11:21.360 --> 11:27.680
didn't know so they could always participate even though they hadn't seen everything.

11:27.680 --> 11:31.680
Then we gave them a state table to of course keep track of the state changes as they went

11:31.680 --> 11:34.600
through the scroll.

11:34.600 --> 11:40.480
So those were some of the examples that we developed but now we'd like to take a step

11:40.480 --> 11:44.660
back and look at what did we learn from it and what kind of guidelines can we give you

11:44.660 --> 11:48.520
if you were to try to implement something on your own.

11:48.520 --> 11:53.840
So the first piece of advice we'd like to give you is embrace the themes.

11:53.840 --> 11:59.680
I know it might look silly at first but just having a silly team takes a lot of the stress

11:59.680 --> 12:04.240
away from students and they no longer feel like they can fail doing an exercise because

12:04.240 --> 12:09.680
they're just playing a game in this kind of team world.

12:09.680 --> 12:15.000
But when we want to design those themes we also shouldn't forget the principle of skill

12:15.000 --> 12:20.840
transfer which basically states that the context in which you learn something becomes an important

12:20.840 --> 12:25.400
part of how you will be able to apply those skills in different contexts.

12:25.400 --> 12:31.840
So the closer your environment is to a realistic use case the more useful their skills will

12:31.840 --> 12:36.480
directly be when they need to apply them to a realistic environment.

12:36.480 --> 12:44.760
So it's still good that in your silly team world there is a real life kind of application.

12:44.760 --> 12:47.320
Also definitely invite a social aspect.

12:47.320 --> 12:51.360
One of the main reasons people stop learning how to code is because they don't really feel

12:51.360 --> 12:55.600
like they belong in the world or they feel discouraged and just having this kind of social

12:55.600 --> 13:00.560
aspect it can be slightly competitive but also collaborative really takes away this

13:00.560 --> 13:07.280
barrier and pushes people to continue learning in a welcoming environment.

13:07.280 --> 13:11.360
Also you should strive to keep the setup minimal as possible and I know this sounds really

13:11.360 --> 13:15.400
straightforward but when you're designing an application that needs to be installed

13:15.400 --> 13:20.920
on a desktop and even two out of twenty students are facing issues that takes away at least

13:20.920 --> 13:26.160
five minutes of the teacher's time that they cannot be helping students.

13:26.160 --> 13:33.960
So if at all possible try to make it work just within the browser.

13:33.960 --> 13:39.440
Now we should also make sure that our micro materials only focus on one specific learning

13:39.440 --> 13:40.440
goal.

13:40.440 --> 13:44.720
A lot of content is created like for example the Heidi programming language which there

13:44.720 --> 13:50.440
is a great talk tomorrow and these are all like great tools but they kind of expect you

13:50.440 --> 13:53.040
to focus on them for your whole semester.

13:53.040 --> 13:57.040
A lot of teachers already have a curriculum they need to follow so they do not have the

13:57.040 --> 13:59.940
flexibility to really go with something else.

13:59.940 --> 14:04.640
Your tools should really be something they can introduce and use in one or two of their

14:04.640 --> 14:08.840
lessons without needing to change their overall curriculum.

14:08.840 --> 14:13.720
Otherwise it will just not be adapted.

14:13.720 --> 14:17.560
We also have the expertise reversal principle.

14:17.560 --> 14:22.640
Now the idea here is if you're new to something you really like to be guided and get a lot

14:22.640 --> 14:29.480
of hints on what can I do, what shouldn't I do but as you gain more experience if you

14:29.480 --> 14:34.200
keep having to go to the same guidance it actually becomes a hindrance.

14:34.200 --> 14:39.520
So ideally your application should be designed in such a way that they contain multiple layers

14:39.520 --> 14:44.680
where first at the outer layer there is a lot of help available for your students but

14:44.680 --> 14:50.280
as they move on and become more experienced and become more experts they can take away

14:50.280 --> 14:55.080
those layers and start operating the tool without getting all that extra help that's

14:55.080 --> 14:57.240
getting in the way of learning.

14:57.240 --> 15:03.360
Then also of course try to do something with automatic content generation.

15:03.360 --> 15:08.820
Whenever you try to develop a tool on your own you'll quickly discover that having to

15:08.820 --> 15:13.960
update the content yourself or even asking teachers to create the content themselves

15:13.960 --> 15:16.960
it takes a very long time and they will not do it.

15:16.960 --> 15:22.900
Our idea is to make it easier for teachers to use those tools not to give them more work.

15:22.900 --> 15:29.360
So the final principle is if at all possible try to make things mobile compatible especially

15:29.360 --> 15:31.640
with the adults I've been teaching.

15:31.640 --> 15:33.280
They are very busy work lives.

15:33.280 --> 15:37.140
They're trying to learn programming while still taking care of the families.

15:37.140 --> 15:41.600
If they have a simple tool they can use for example while on public transport that's a

15:41.600 --> 15:44.200
huge quality of life improvement for them.

15:44.200 --> 15:50.660
So let me finish this presentation by telling you all like I know you're all a community

15:50.660 --> 15:55.560
of builders if you think like hey these kind of tools you discussed I can build those feel

15:55.560 --> 16:01.560
free to reach out to any learning environment close to you and try to ask how you can contribute.

16:01.560 --> 16:02.560
Thank you all for listening.

16:02.560 --> 16:10.400
Thank you.
