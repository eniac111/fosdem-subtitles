1
0:00:00.000 --> 0:00:09.160
So, good evening, everyone, and welcome to the last talk in this session.

2
0:00:09.160 --> 0:00:12.320
I hope you still have some energy left.

3
0:00:12.320 --> 0:00:13.680
So my name is Sasha Roloff.

4
0:00:13.680 --> 0:00:19.480
I'm working at the Huawei technology, intelligent cloud technology lab of the Huawei Munich

5
0:00:19.480 --> 0:00:21.240
Research Center.

6
0:00:21.240 --> 0:00:26.780
And today we are going to take a look under the hood of build systems and what common

7
0:00:26.780 --> 0:00:33.760
practices are currently used in basically all of the build systems and why many of them

8
0:00:33.760 --> 0:00:42.440
are suboptimal in certain regards and how they can be improved by a concept called staging.

9
0:00:42.440 --> 0:00:47.760
So in order to explain you the issues with current build systems, I directly jump into

10
0:00:47.760 --> 0:00:49.600
an example.

11
0:00:49.600 --> 0:00:56.040
And I guess many of you have used make once or twice in your open source developments.

12
0:00:56.040 --> 0:00:58.720
So let's start with this classic build system.

13
0:00:58.720 --> 0:01:04.680
So we want to create a build description for a very simple hello world application composed

14
0:01:04.680 --> 0:01:09.360
of a hello binary and a greet library.

15
0:01:09.360 --> 0:01:14.440
And the greeting phrase is hard coded inside the hello binary.

16
0:01:14.440 --> 0:01:20.480
And a greetie can be injected at compile time at the greet library.

17
0:01:20.480 --> 0:01:22.920
So this is a make file.

18
0:01:22.920 --> 0:01:31.160
We have our rules which describe which artifacts are generated by actions based on a set of

19
0:01:31.160 --> 0:01:33.680
input artifacts.

20
0:01:33.680 --> 0:01:40.000
And yeah, so we have different actions actually involved to generate the final binary.

21
0:01:40.000 --> 0:01:45.000
And for example, we have compile actions to generate the object files like the hello.o

22
0:01:45.000 --> 0:01:46.000
or the greet.o.

23
0:01:46.000 --> 0:01:52.840
We have archive action for the greet library and the final linking action to actually generate

24
0:01:52.840 --> 0:01:53.840
the binary.

25
0:01:53.840 --> 0:01:57.720
At the end, we also want to create some sample output.

26
0:01:57.720 --> 0:02:03.680
So we just take the output of the hello world and store it in a text file.

27
0:02:03.680 --> 0:02:07.220
So nothing spectacular right now.

28
0:02:07.220 --> 0:02:12.700
Each artifact is associated with a file on the file system so the actions can directly

29
0:02:12.700 --> 0:02:14.380
operate on it.

30
0:02:14.380 --> 0:02:20.000
If we execute the build, we just see all the actions are executed, everything fine, and

31
0:02:20.000 --> 0:02:23.120
the output is generated.

32
0:02:23.120 --> 0:02:30.120
And yes, now the boss comes into our office and he's unhappy with our result.

33
0:02:30.120 --> 0:02:34.160
He wants to put it basically on a poster and it should be more readable.

34
0:02:34.160 --> 0:02:40.040
Okay, so yeah, then let's add some post processing to the task.

35
0:02:40.040 --> 0:02:45.960
And we just take the output of the hello binary, store it in the intermediate file, and put

36
0:02:45.960 --> 0:02:52.960
this intermediate file into the post processing and translate all letters into, capitalize

37
0:02:52.960 --> 0:02:57.400
all letters basically, and store it into post processed text.

38
0:02:57.400 --> 0:03:02.680
And then finally, put this text into the target sample output.

39
0:03:02.680 --> 0:03:09.640
When we execute this, we see new actions are executed and the result is fine.

40
0:03:09.640 --> 0:03:10.940
Looks much better now.

41
0:03:10.940 --> 0:03:13.880
Hello world and capital letters, great.

42
0:03:13.880 --> 0:03:16.200
But the boss is still unhappy.

43
0:03:16.200 --> 0:03:17.600
He wants to have some localization.

44
0:03:17.600 --> 0:03:20.120
He doesn't want to greet the whole world.

45
0:03:20.120 --> 0:03:23.560
He just wants to greet Munich and Brussels.

46
0:03:23.560 --> 0:03:26.480
And he wants to have it both in a single make file.

47
0:03:26.480 --> 0:03:28.600
So what do we have to do now?

48
0:03:28.600 --> 0:03:33.560
Okay, we have to basically we have two program variants now.

49
0:03:33.560 --> 0:03:39.120
And what should we do in order to reuse most of our rules that we already have?

50
0:03:39.120 --> 0:03:47.200
We can use a for loop over the location dependent targets and interpolate the city name into

51
0:03:47.200 --> 0:03:49.840
the artifact names, as you can see here.

52
0:03:49.840 --> 0:03:56.200
So we have now not only a single hello binary, but two hello binaries with a dot and the

53
0:03:56.200 --> 0:03:58.260
name of the city.

54
0:03:58.260 --> 0:04:03.520
And these are our two program variants.

55
0:04:03.520 --> 0:04:11.080
And as you can see, there is a lot of string interpolation coming into our make file.

56
0:04:11.080 --> 0:04:14.240
And it doesn't make it really readable.

57
0:04:14.240 --> 0:04:19.960
But we have to do it because each artifact is associated with a file on the file system.

58
0:04:19.960 --> 0:04:22.040
And this needs to be a unique name.

59
0:04:22.040 --> 0:04:25.280
So we have to do it basically.

60
0:04:25.280 --> 0:04:30.520
And when we execute it, okay, now we get a bit more actions.

61
0:04:30.520 --> 0:04:32.760
But it's working.

62
0:04:32.760 --> 0:04:37.560
And we see now, okay, the output is as required.

63
0:04:37.560 --> 0:04:40.800
And we greet Munich and Brussels.

64
0:04:40.800 --> 0:04:44.620
But the boss is still, I mean, he's happy now with our output.

65
0:04:44.620 --> 0:04:47.920
But now he's unhappy with our implementation.

66
0:04:47.920 --> 0:04:51.240
He says, ah, that's not maintainable.

67
0:04:51.240 --> 0:04:53.480
Why do we use a build system from the 70s?

68
0:04:53.480 --> 0:04:54.480
Use a modern one.

69
0:04:54.480 --> 0:04:56.440
They are supposed to do much better now.

70
0:04:56.440 --> 0:04:58.300
Well, okay.

71
0:04:58.300 --> 0:05:00.880
Then let's use Bazel.

72
0:05:00.880 --> 0:05:03.920
And this is what it looks like in Bazel.

73
0:05:03.920 --> 0:05:05.760
So the same application.

74
0:05:05.760 --> 0:05:09.080
And as it turns out, they are better.

75
0:05:09.080 --> 0:05:10.760
But not in all regards.

76
0:05:10.760 --> 0:05:16.600
So they introduce high-level concepts like the cc binary and cc library.

77
0:05:16.600 --> 0:05:21.580
We don't have to manually write object file creation and linking.

78
0:05:21.580 --> 0:05:27.960
But everything is wrapped now inside these high-level concept calls.

79
0:05:27.960 --> 0:05:35.560
And also our bash calls are wrapped in these general targets.

80
0:05:35.560 --> 0:05:38.600
But I mean, it looks a bit more readable now.

81
0:05:38.600 --> 0:05:43.280
But still, we have this string interpolation here.

82
0:05:43.280 --> 0:05:46.720
And the for loops over the city names.

83
0:05:46.720 --> 0:05:48.840
And yeah, why is it actually like that?

84
0:05:48.840 --> 0:05:49.840
Why do we need this?

85
0:05:49.840 --> 0:05:51.680
I mean, it's a modern build system.

86
0:05:51.680 --> 0:05:57.920
And the reason is because Bazel also associates each artifact with a file on the file system.

87
0:05:57.920 --> 0:06:07.080
And, yeah, so that's why this basically brings us to an important observation.

88
0:06:07.080 --> 0:06:13.320
And this means even modern build systems, it's required that you have unique names for

89
0:06:13.320 --> 0:06:18.560
your artifacts.

90
0:06:18.560 --> 0:06:24.400
And because they basically follow a design decision implemented by make in the 70s.

91
0:06:24.400 --> 0:06:29.440
And the design decision by make was that each artifact needs to have a fixed location in

92
0:06:29.440 --> 0:06:31.080
the file system.

93
0:06:31.080 --> 0:06:36.280
Well, for make, it was perfectly fine at that time.

94
0:06:36.280 --> 0:06:42.340
Because there was nothing else or not much different to do in order to determine which

95
0:06:42.340 --> 0:06:46.400
part of a program needs to be recomputed.

96
0:06:46.400 --> 0:06:48.640
Basically to compare timestamps.

97
0:06:48.640 --> 0:06:50.680
And for this you need files.

98
0:06:50.680 --> 0:06:52.920
So for make, this was totally fine.

99
0:06:52.920 --> 0:06:57.400
But there is actually no reason anymore to do this in modern build systems.

100
0:06:57.400 --> 0:07:05.400
Because they anyway isolate their actions in order to avoid getting unwanted dependencies

101
0:07:05.400 --> 0:07:07.000
into their builds.

102
0:07:07.000 --> 0:07:13.000
So their actions are executed either in a separate directory or in a container in order

103
0:07:13.000 --> 0:07:16.120
to better control the dependencies.

104
0:07:16.120 --> 0:07:23.000
So when they anyway execute their actions, why don't we allow the targets to specify

105
0:07:23.000 --> 0:07:26.400
where to put the artifacts?

106
0:07:26.400 --> 0:07:29.060
And this is exactly the idea of staging.

107
0:07:29.060 --> 0:07:34.600
So basically there is no technical reason for modern build systems for restriction of

108
0:07:34.600 --> 0:07:38.560
to associate each artifact with a file.

109
0:07:38.560 --> 0:07:45.280
And instead we propose that we should stop following this common practice and apply staging

110
0:07:45.280 --> 0:07:47.280
instead.

111
0:07:47.280 --> 0:07:53.280
And the idea of staging is that an action can freely select the location of input and

112
0:07:53.280 --> 0:07:57.960
output artifacts within its working directory.

113
0:07:57.960 --> 0:08:04.600
And this basically introduces a separation between physical and logical paths.

114
0:08:04.600 --> 0:08:12.240
Inside an action you only work on the logical path and the action can freely decide where

115
0:08:12.240 --> 0:08:19.920
to put a generated artifact or where it wants to read an input artifact.

116
0:08:19.920 --> 0:08:25.600
And so this is basically our proposal to apply staging.

117
0:08:25.600 --> 0:08:29.400
And how could it be looked like if it's implemented in a build system?

118
0:08:29.400 --> 0:08:31.520
So this is basically our project.

119
0:08:31.520 --> 0:08:33.080
It's called Just Build.

120
0:08:33.080 --> 0:08:37.800
And this is a build description that we propose.

121
0:08:37.800 --> 0:08:43.640
So we also have the definitions of our targets here.

122
0:08:43.640 --> 0:08:48.240
We also use the high-level concepts like binaries and libraries.

123
0:08:48.240 --> 0:08:54.600
And in this JSON syntax the type just selects which kind of artifact or which kind of target

124
0:08:54.600 --> 0:08:56.760
it basically is.

125
0:08:56.760 --> 0:09:04.720
And what we can see inside the target definitions, our artifacts are named without string interpolation.

126
0:09:04.720 --> 0:09:09.560
So we don't need to artificially invent unique names for our artifacts.

127
0:09:09.560 --> 0:09:11.800
They are just like they are.

128
0:09:11.800 --> 0:09:19.160
And also, for example, here this use target, we just access the hello binary even though

129
0:09:19.160 --> 0:09:24.200
we will have two of these binaries, but we just write hello.

130
0:09:24.200 --> 0:09:25.200
And we don't care.

131
0:09:25.200 --> 0:09:26.560
I mean, it's staged.

132
0:09:26.560 --> 0:09:36.200
And what is created from the dependency, it's just staging the final result at that location

133
0:09:36.200 --> 0:09:39.880
where we need it.

134
0:09:39.880 --> 0:09:42.040
But still we have the for loop.

135
0:09:42.040 --> 0:09:48.640
This is something that we of course still need to, which basically creates two configurations

136
0:09:48.640 --> 0:09:51.000
which is then propagated.

137
0:09:51.000 --> 0:09:57.080
I mean, this variable that is created here is propagated to all the depending targets.

138
0:09:57.080 --> 0:10:02.520
And it propagates until the grid library which then reads this configuration variable and

139
0:10:02.520 --> 0:10:07.320
injects it into the compile command.

140
0:10:07.320 --> 0:10:12.520
So this is how a description could look like with staging.

141
0:10:12.520 --> 0:10:18.920
And from this description we can also generate a so-called target graph which shows the dependencies

142
0:10:18.920 --> 0:10:20.440
of the targets.

143
0:10:20.440 --> 0:10:22.800
So main depends on all.

144
0:10:22.800 --> 0:10:29.360
All depends on two post process because we have two configure targets.

145
0:10:29.360 --> 0:10:34.440
So the grid library basically is duplicated and this propagates until the post process

146
0:10:34.440 --> 0:10:36.880
target.

147
0:10:36.880 --> 0:10:42.460
And these target graph or targets are basically high level concepts.

148
0:10:42.460 --> 0:10:48.080
If you want to take a look into which actions are actually executed, you can also generate

149
0:10:48.080 --> 0:10:51.800
an action graph which shows a data flow.

150
0:10:51.800 --> 0:10:55.080
That's why the errors are inverted.

151
0:10:55.080 --> 0:10:59.280
And it's a bipartite graph which means so.

152
0:10:59.280 --> 0:11:04.160
The ellipses are the artifacts and the rectangles are the actions.

153
0:11:04.160 --> 0:11:10.360
And yeah, so you can really see the artifact names are basically the same.

154
0:11:10.360 --> 0:11:16.540
So post process dot txt and post process dot txt are the same names in both branches.

155
0:11:16.540 --> 0:11:20.480
But since they are staged in logical paths, there is no problem.

156
0:11:20.480 --> 0:11:22.600
There is no conflict actually.

157
0:11:22.600 --> 0:11:24.160
This would not work in make.

158
0:11:24.160 --> 0:11:27.360
You would have to use unique names.

159
0:11:27.360 --> 0:11:31.480
Okay, so and what happens when we execute it?

160
0:11:31.480 --> 0:11:36.600
So we just select the target that we want to build and there is some output coming here

161
0:11:36.600 --> 0:11:40.320
and it says okay, we have 12 actions, zero cache hits.

162
0:11:40.320 --> 0:11:43.320
Of course we execute, build it the first time.

163
0:11:43.320 --> 0:11:44.320
So you can count it.

164
0:11:44.320 --> 0:11:46.040
12 actions.

165
0:11:46.040 --> 0:11:47.600
And it's just build.

166
0:11:47.600 --> 0:11:49.960
The artifact is somewhere.

167
0:11:49.960 --> 0:11:55.320
I mean it could be in a remote execution and then it's just existing in a remote cache.

168
0:11:55.320 --> 0:12:01.440
If you want to have the artifact in your local folder, then you have to install it.

169
0:12:01.440 --> 0:12:08.240
And when we execute the installation, we now see okay, again 12 actions and also 12 cache

170
0:12:08.240 --> 0:12:11.560
hits because everything is known already.

171
0:12:11.560 --> 0:12:14.920
And then the file is in your local directory actually.

172
0:12:14.920 --> 0:12:18.820
And we see the content is fine.

173
0:12:18.820 --> 0:12:22.200
And we even don't need to store it into our local directory.

174
0:12:22.200 --> 0:12:27.120
We can just print the content of an artifact by the minus P auction.

175
0:12:27.120 --> 0:12:33.880
If we take staging seriously, we have also very nice implications.

176
0:12:33.880 --> 0:12:39.200
And one is for example, assume that you have an external source code that you want to use

177
0:12:39.200 --> 0:12:41.000
in your project.

178
0:12:41.000 --> 0:12:43.800
And you want to apply some patches on it.

179
0:12:43.800 --> 0:12:45.600
And how do you do it?

180
0:12:45.600 --> 0:12:49.040
Normally you would copy it, apply the patch because you don't want to modify the original

181
0:12:49.040 --> 0:12:50.880
source code.

182
0:12:50.880 --> 0:12:56.040
And this results in a lot of maintenance problems.

183
0:12:56.040 --> 0:13:00.000
But with staging, this can be done much easier with logical in-place patching.

184
0:13:00.000 --> 0:13:05.560
You just apply the patch at the logical path.

185
0:13:05.560 --> 0:13:09.620
And then let's take a look how this could look like.

186
0:13:09.620 --> 0:13:16.060
So we have now put our example files in a third-party directory outside of our project.

187
0:13:16.060 --> 0:13:21.180
And a directory with the patches.

188
0:13:21.180 --> 0:13:27.500
And the patch just modifies the hello greeting phrase with a bonjour greeting phrase.

189
0:13:27.500 --> 0:13:35.000
And we just have to add a single block into our build description which points to our

190
0:13:35.000 --> 0:13:37.740
patch and to the file that needs to be patched.

191
0:13:37.740 --> 0:13:40.200
And that's it.

192
0:13:40.200 --> 0:13:46.000
And the resulting target graph just shows, okay, we have now one more target here, the

193
0:13:46.000 --> 0:13:48.480
hello CPP source target.

194
0:13:48.480 --> 0:13:53.520
And the other, the binaries are depending on this extra target now.

195
0:13:53.520 --> 0:13:59.760
And also in the action graph, you can see that there is just a single new action actually

196
0:13:59.760 --> 0:14:05.920
added here to the action graph where earlier was hello CPP is now the patched version of

197
0:14:05.920 --> 0:14:09.480
hello CPP and it's just another input.

198
0:14:09.480 --> 0:14:15.240
And if something is changed in the patch, all dependent targets are executed.

199
0:14:15.240 --> 0:14:22.720
Okay, if we execute it, we see bonjour, Munich, bonjour, Brussels, works well.

200
0:14:22.720 --> 0:14:28.480
Okay, so quickly to summarize my talk, as we have seen, there are some inconvenient habits

201
0:14:28.480 --> 0:14:30.040
in modern build systems.

202
0:14:30.040 --> 0:14:35.020
And we propose to apply staging instead to make build systems better.

203
0:14:35.020 --> 0:14:42.080
And you will have a couple of advantages if you apply staging, which are written here.

204
0:14:42.080 --> 0:14:45.860
And this is not only a concept, it's already implemented.

205
0:14:45.860 --> 0:14:51.920
So if you want to take a look into our project, please come by.

206
0:14:51.920 --> 0:14:54.000
And now the stage is yours.

207
0:14:54.000 --> 0:14:57.000
Thanks for your attention.

208
0:14:57.000 --> 0:15:10.320
So, the question is, are there any questions?

209
0:15:10.320 --> 0:15:11.320
There is a question.

210
0:15:11.320 --> 0:15:14.320
No, I think he will repeat the question.

211
0:15:14.320 --> 0:15:17.320
You had the question?

212
0:15:17.320 --> 0:15:27.000
Yeah, in order to determine what artifact you need to save, you need to connect it to

213
0:15:27.000 --> 0:15:29.000
the correct version of the source code.

214
0:15:29.000 --> 0:15:31.480
Do you do hashing on the source code?

215
0:15:31.480 --> 0:15:32.480
Yeah, exactly.

216
0:15:32.480 --> 0:15:34.280
We do actually content addressable storage.

217
0:15:34.280 --> 0:15:35.840
Repeat that question.

218
0:15:35.840 --> 0:15:36.840
Yes.

219
0:15:36.840 --> 0:15:42.640
Okay, the question was how do we identify which source code we actually need for the

220
0:15:42.640 --> 0:15:43.640
staging.

221
0:15:43.640 --> 0:15:49.520
And we apply content addressable storage, so we determine a hash basically from all

222
0:15:49.520 --> 0:15:56.440
of our source codes and then also we know what has been changed or not.

223
0:15:56.440 --> 0:15:57.440
Any other questions?

224
0:15:57.440 --> 0:15:58.440
Yeah.

225
0:15:58.440 --> 0:16:07.240
So, you are going to use the JSON syntax for the build service?

226
0:16:07.240 --> 0:16:11.800
Yeah, so the question was whether we use the JSON syntax?

227
0:16:11.800 --> 0:16:23.800
Yeah, we decided for JSON and JSON is used as our build description syntax.

228
0:16:23.800 --> 0:16:24.800
Anyone else?

229
0:16:24.800 --> 0:16:27.000
We have time for one last.

230
0:16:27.000 --> 0:16:31.800
How many developers and is it widely used yet?

231
0:16:31.800 --> 0:16:35.080
So how many developers are working on it and is it widely used?

232
0:16:35.080 --> 0:16:36.960
A very good question.

233
0:16:36.960 --> 0:16:43.760
We recently got open sourced and we are in total five developers currently working on

234
0:16:43.760 --> 0:16:45.960
it.

235
0:16:45.960 --> 0:16:52.520
But we really try to implement the new concepts into this build system and make it a really

236
0:16:52.520 --> 0:16:57.440
sound build system compared to other modern build systems.

237
0:16:57.440 --> 0:17:02.680
And yeah, so please just take a look at our project and there is a nice tutorial also

238
0:17:02.680 --> 0:17:07.760
which well, everything explains nicely and hope to see you there.

239
0:17:07.760 --> 0:17:10.640
Okay, thank you for the talk.

240
0:17:10.640 --> 0:17:11.640
Thank you.

241
0:17:11.640 --> 0:17:12.640
Bye bye.

242
0:17:12.640 --> 0:17:13.640
Thank you for the help.

243
0:17:13.640 --> 0:17:14.640
Thank you.

244
0:17:14.640 --> 0:17:38.240
Bye-bye.

