1
0:00:00.000 --> 0:00:09.680
And let's welcome the next show from zero to hero with solid.

2
0:00:09.680 --> 0:00:11.240
Thanks Noel for presenting.

3
0:00:11.240 --> 0:00:13.720
Okay, thank you.

4
0:00:13.720 --> 0:00:20.480
So my name is Noel, I'm from Barcelona.

5
0:00:20.480 --> 0:00:25.280
I'm currently working at Moodle for days a week, but I'm also in the site making solid

6
0:00:25.280 --> 0:00:26.840
apps, site projects.

7
0:00:26.840 --> 0:00:29.680
And that's mostly what I will talk about today.

8
0:00:29.680 --> 0:00:31.320
I usually work in the open.

9
0:00:31.320 --> 0:00:36.400
This means that I journal about my development, so you can follow my work in my website, and

10
0:00:36.400 --> 0:00:38.760
here you have all the socials and everything.

11
0:00:38.760 --> 0:00:42.600
So if you are more interested in something I say, you probably can find more detail in

12
0:00:42.600 --> 0:00:44.400
my website.

13
0:00:44.400 --> 0:00:48.880
So before we start, how many people know what solid is or heard about it?

14
0:00:48.880 --> 0:00:51.200
Well, maybe half the room, okay?

15
0:00:51.200 --> 0:00:52.360
That's nice.

16
0:00:52.360 --> 0:00:57.200
So for those of you who don't know, before I say what solid is, I have to go back to

17
0:00:57.200 --> 0:00:59.120
the creation of the web.

18
0:00:59.120 --> 0:01:04.880
So when the web was created, these technologies were invented like Web Blowser, HTTP, HTML.

19
0:01:04.880 --> 0:01:08.400
I'm sure most of us are familiar with these ones.

20
0:01:08.400 --> 0:01:11.800
But later on, there was something called the semantic web.

21
0:01:11.800 --> 0:01:15.640
And how many people know what the semantic web is or are familiar with that?

22
0:01:15.640 --> 0:01:17.520
Okay, almost the same as solid.

23
0:01:17.520 --> 0:01:18.520
So yeah.

24
0:01:18.520 --> 0:01:24.600
Basically, the semantic web is an idea that in websites, other than human readable content

25
0:01:24.600 --> 0:01:31.560
and linked documents, users can also have linked data, which is machine readable data,

26
0:01:31.560 --> 0:01:33.440
not only human readable.

27
0:01:33.440 --> 0:01:38.760
And like this, some technologies were introduced, like the resource definition framework, JSON

28
0:01:38.760 --> 0:01:40.560
LD, TARTL, et cetera.

29
0:01:40.560 --> 0:01:43.880
We will see more about this later.

30
0:01:43.880 --> 0:01:46.200
And finally, the solid protocol.

31
0:01:46.200 --> 0:01:52.240
It's the next iteration of this idea, and it brings decentralized storage to the web.

32
0:01:52.240 --> 0:01:58.120
The web I see it, and the way they say it, Web 3.0 by the creators of the web.

33
0:01:58.120 --> 0:02:01.760
But it doesn't have to be confused with Web 3, which is blockchain.

34
0:02:01.760 --> 0:02:04.520
As you will see, solid doesn't have anything to do with blockchain.

35
0:02:04.520 --> 0:02:07.800
It's something completely different.

36
0:02:07.800 --> 0:02:14.240
And the basic idea of solid is that users have a pod, and applications and services

37
0:02:14.240 --> 0:02:16.560
store the data in the user pod.

38
0:02:16.560 --> 0:02:22.600
So for example, here on the left, we have the traditional architecture.

39
0:02:22.600 --> 0:02:26.920
Each application you use stores the data in a backend, and that's how most applications

40
0:02:26.920 --> 0:02:27.920
work nowadays.

41
0:02:27.920 --> 0:02:35.400
The idea of solid is that you can use different applications, but these applications can store

42
0:02:35.400 --> 0:02:37.040
data in the same pod.

43
0:02:37.040 --> 0:02:40.640
So it's the user, the one deciding where the data goes.

44
0:02:40.640 --> 0:02:46.520
And it's important for privacy, but also for interoperability and a better user experience.

45
0:02:46.520 --> 0:02:51.240
Because this way, they can share data between different apps seamlessly.

46
0:02:51.240 --> 0:02:52.840
That's the basic idea.

47
0:02:52.840 --> 0:02:57.160
And if you are more interested in the idea of solid in general, more division, you can

48
0:02:57.160 --> 0:03:03.560
watch a talk from 2019 that was given here at Fosdam, and you can see more about that.

49
0:03:03.560 --> 0:03:06.400
This talk will be a bit more technical.

50
0:03:06.400 --> 0:03:10.680
So when you saw the title of this talk, maybe this is what comes to mind.

51
0:03:10.680 --> 0:03:15.480
But before we begin, I want to clarify that there are different types of heroes.

52
0:03:15.480 --> 0:03:18.080
So what type of heroes do I mean?

53
0:03:18.080 --> 0:03:23.000
So there are many ways to use solid, just like there are many ways to make websites.

54
0:03:23.000 --> 0:03:25.720
In this talk, we will focus on making solid apps.

55
0:03:25.720 --> 0:03:30.280
So I will not talk about hosting pods or making solid services.

56
0:03:30.280 --> 0:03:33.160
Mostly I will talk about making solid apps.

57
0:03:33.160 --> 0:03:37.800
And this is because this is what I have been doing for the last four years as site projects.

58
0:03:37.800 --> 0:03:43.260
So I have not worked either in any enterprise level application or anything.

59
0:03:43.260 --> 0:03:48.120
But I don't want to discourage you from learning from this, because my goal with this apps

60
0:03:48.120 --> 0:03:50.680
is to make them usable for people.

61
0:03:50.680 --> 0:03:55.420
It's not only some random site project to try technology.

62
0:03:55.420 --> 0:03:58.680
My end goal is to actually make useful apps.

63
0:03:58.680 --> 0:04:03.600
And also, it will be road strokes, because I cannot get into many of the details.

64
0:04:03.600 --> 0:04:06.520
But we will get into some of the ways.

65
0:04:06.520 --> 0:04:10.280
So the first app I developed was in 2018.

66
0:04:10.280 --> 0:04:12.360
It's called Solid Focus.

67
0:04:12.360 --> 0:04:15.100
And basically, it's a task manager.

68
0:04:15.100 --> 0:04:19.440
So the first application you do, it's always like a to-do app.

69
0:04:19.440 --> 0:04:23.280
So this is what I decided to do with Solid, to learn about it.

70
0:04:23.280 --> 0:04:28.000
So the only thing we care about is that you have tasks, and you can mark them as done

71
0:04:28.000 --> 0:04:29.000
or not done.

72
0:04:29.000 --> 0:04:31.240
That's the basic.

73
0:04:31.240 --> 0:04:35.280
And when you open the application for the first time, this is what you see.

74
0:04:35.280 --> 0:04:41.720
So normally, people are used to register an account with an email and a password, or something

75
0:04:41.720 --> 0:04:42.720
like this.

76
0:04:42.720 --> 0:04:47.000
In Solid, it's different, because what you have to do when you open an account is to

77
0:04:47.000 --> 0:04:48.840
give the solid pod.

78
0:04:48.840 --> 0:04:52.320
And you are telling the app where it should get the data.

79
0:04:52.320 --> 0:04:57.080
In this case, I also added a login offline button, because I know many people are not

80
0:04:57.080 --> 0:04:58.680
familiar with Solid.

81
0:04:58.680 --> 0:05:02.400
And if they only want to try the app, they can do it like this without a pod.

82
0:05:02.400 --> 0:05:07.360
I also think it's very aligned with the vision of Solid, that users decide where to store

83
0:05:07.360 --> 0:05:08.360
data.

84
0:05:08.360 --> 0:05:13.200
So they can decide to store it in their local device without hitting the network.

85
0:05:13.200 --> 0:05:15.400
So this is how it works.

86
0:05:15.400 --> 0:05:19.720
And when you are making a Solid app, there are actually three actors you are interested

87
0:05:19.720 --> 0:05:20.760
in.

88
0:05:20.760 --> 0:05:22.760
One of them is your application.

89
0:05:22.760 --> 0:05:27.560
Another one is your pod, well, the user's pod, where the data will be stored.

90
0:05:27.560 --> 0:05:29.760
But there is also the identity provider.

91
0:05:29.760 --> 0:05:35.800
And actually, when users are authenticating, you are communicating with the identity provider.

92
0:05:35.800 --> 0:05:38.760
It will give you a token.

93
0:05:38.760 --> 0:05:42.520
And it's this token, the one you use to load the data exchange in the pod.

94
0:05:42.520 --> 0:05:46.280
This is the basic architecture of how it works.

95
0:05:46.280 --> 0:05:51.560
But in general, you don't have to care too much about this, because you just use a library,

96
0:05:51.560 --> 0:05:55.880
you give it the URL, and then it gives you the token, and you can make authenticated

97
0:05:55.880 --> 0:05:56.880
requests.

98
0:05:56.880 --> 0:06:01.320
But I think it's important to at least know that before you get into it.

99
0:06:01.320 --> 0:06:06.080
So once you have the token, then you want to create data.

100
0:06:06.080 --> 0:06:10.280
So usually, when you think about the task manager, this is the type of data you will

101
0:06:10.280 --> 0:06:11.280
see.

102
0:06:11.280 --> 0:06:13.360
You have an ID, a description, and add-on.

103
0:06:13.360 --> 0:06:14.360
It's a Boolean.

104
0:06:14.360 --> 0:06:18.880
But when you are working with Solid, this is how you would do it.

105
0:06:18.880 --> 0:06:21.560
Now before, people want to leave the room.

106
0:06:21.560 --> 0:06:26.200
One of my goals with this talk is to actually convince you why this is better.

107
0:06:26.200 --> 0:06:29.720
And in the end, when you get used to it, it's not so different, actually.

108
0:06:29.720 --> 0:06:32.660
So hopefully, I will do it.

109
0:06:32.660 --> 0:06:34.480
So we have a context.

110
0:06:34.480 --> 0:06:38.240
This indicates the vocabulary of this piece of data.

111
0:06:38.240 --> 0:06:42.680
That's important, because if different applications are using the same data, they need to share

112
0:06:42.680 --> 0:06:47.720
an ontology, or they need to be using something that is the same, so that the data can be

113
0:06:47.720 --> 0:06:52.360
shared or understood by different implementations.

114
0:06:52.360 --> 0:06:54.080
The ID, it's a URL.

115
0:06:54.080 --> 0:06:57.000
This is also important, because it's where the data is actually stored.

116
0:06:57.000 --> 0:06:59.760
We will see more about this later.

117
0:06:59.760 --> 0:07:01.040
And then there is the type.

118
0:07:01.040 --> 0:07:05.840
So if you think about object-oriented programming, this would be like the class of the object.

119
0:07:05.840 --> 0:07:11.080
And then you have other properties, which can be just literals, or they can be linked

120
0:07:11.080 --> 0:07:14.680
to other objects or other properties.

121
0:07:14.680 --> 0:07:20.440
So the one before was JSON-LD, which is maybe more familiar for most people, because it's

122
0:07:20.440 --> 0:07:21.440
JSON.

123
0:07:21.440 --> 0:07:26.440
But when you are working with Solid, most of the time, you will be seeing RDF.

124
0:07:26.440 --> 0:07:29.000
And this is a format called Turtle.

125
0:07:29.000 --> 0:07:32.840
And actually, it's not so different from the first JSON I will show you.

126
0:07:32.840 --> 0:07:35.800
It's only that if you are not familiar, at first it may be striking.

127
0:07:35.800 --> 0:07:39.560
But eventually, it's quite similar to use, and it's not so different.

128
0:07:39.560 --> 0:07:43.400
So this is why I think it's not so bad in the end.

129
0:07:43.400 --> 0:07:45.640
I have been talking about the Solid pod.

130
0:07:45.640 --> 0:07:47.480
Like it's only a black box.

131
0:07:47.480 --> 0:07:51.760
But the thing is that inside of the Solid pod, you actually have containers.

132
0:07:51.760 --> 0:07:57.760
You can think of these as folders in a file system, inside of these folders or these containers.

133
0:07:57.760 --> 0:08:01.320
You have the documents, and you can also have binary.

134
0:08:01.320 --> 0:08:05.720
Like for example, you can have a video, an image, a JSON file, whatever.

135
0:08:05.720 --> 0:08:10.840
But this is something that will be not structured using this vocabulary data.

136
0:08:10.840 --> 0:08:14.840
So it's important that what is useful for your app and what you want to be interoperable

137
0:08:14.840 --> 0:08:17.400
is a structure using RDF.

138
0:08:17.400 --> 0:08:21.580
And inside of the documents, you have resources.

139
0:08:21.580 --> 0:08:26.640
So what I mentioned before that the ID says where the data is stored.

140
0:08:26.640 --> 0:08:32.320
If we look at the ID of a task in this example, we can see that the root of the URL is the

141
0:08:32.320 --> 0:08:33.320
Solid pod.

142
0:08:33.320 --> 0:08:37.560
So this tells you where the user is storing its data, right?

143
0:08:37.560 --> 0:08:42.480
The directory tells you the container where the task is stored.

144
0:08:42.480 --> 0:08:48.320
The URL is the document, and the complete URL, including the hash, is the RDF resource.

145
0:08:48.320 --> 0:08:52.440
So this is nice because whenever you see a piece of data installed, you immediately know

146
0:08:52.440 --> 0:08:55.480
its structure and what it is stored.

147
0:08:55.480 --> 0:08:59.440
This is useful as well if you export data and all of this.

148
0:08:59.440 --> 0:09:02.000
So now we have the authentication token.

149
0:09:02.000 --> 0:09:04.600
We have the data, and we know where to put it.

150
0:09:04.600 --> 0:09:08.840
So now this is the easy part, because this is built using web technologies.

151
0:09:08.840 --> 0:09:10.960
You only have to do a post request.

152
0:09:10.960 --> 0:09:16.000
So you do a post request with the document, and you create the document.

153
0:09:16.000 --> 0:09:20.080
And the body of this request will be the data in turtle format.

154
0:09:20.080 --> 0:09:24.480
It can also be in other formats if you want, but most of the time you will be using turtle.

155
0:09:24.480 --> 0:09:27.040
It's the most common, right?

156
0:09:27.040 --> 0:09:31.240
If you want to get the data, you do a request to the document.

157
0:09:31.240 --> 0:09:34.400
If you want to delete the data, you do a delete request.

158
0:09:34.400 --> 0:09:39.560
If you want to get a list of all the tasks, you do a get to the container, and you will

159
0:09:39.560 --> 0:09:42.460
get the list, and so on and so forth.

160
0:09:42.460 --> 0:09:47.280
The basic idea is that it works like the web, because it's built from those technologies,

161
0:09:47.280 --> 0:09:48.280
right?

162
0:09:48.280 --> 0:09:51.680
And actually, the good news is that that's it.

163
0:09:51.680 --> 0:09:54.520
This is how you make solid apps.

164
0:09:54.520 --> 0:09:58.560
And now in this talk, I will go into more things, but these are the basics.

165
0:09:58.560 --> 0:10:03.040
If you understand this, you can already do a lot of things with solid.

166
0:10:03.040 --> 0:10:07.320
And I think that's nice, because it's building up on existing technologies.

167
0:10:07.320 --> 0:10:10.800
So it's always important in that regard.

168
0:10:10.800 --> 0:10:14.760
Here you have some links if you want to get into the weeds with some things.

169
0:10:14.760 --> 0:10:19.560
And here you have my journal when I explain how I learned solid.

170
0:10:19.560 --> 0:10:24.340
This is the first time I saw solid, so it may be more interesting to some of you.

171
0:10:24.340 --> 0:10:25.340
Some takeaways.

172
0:10:25.340 --> 0:10:27.120
We learned the solid basics.

173
0:10:27.120 --> 0:10:31.480
And something that maybe wasn't obvious is that there is no server.

174
0:10:31.480 --> 0:10:36.160
You make the application, and the application works in the frontend, because the data will

175
0:10:36.160 --> 0:10:38.720
be stored in the solid pod, right?

176
0:10:38.720 --> 0:10:44.000
So this is nice, because you don't have to manage any servers, and you are only building

177
0:10:44.000 --> 0:10:47.000
frontend applications, which is static assets.

178
0:10:47.000 --> 0:10:51.960
And these static assets, they can be downloaded in a zip file and put into a computer or whatever.

179
0:10:51.960 --> 0:10:55.520
It's only JavaScript and HTML.

180
0:10:55.520 --> 0:10:57.080
But we also have some challenges.

181
0:10:57.080 --> 0:10:59.800
For example, the onboarding UX is not great.

182
0:10:59.800 --> 0:11:02.120
We have some issues with the page speed.

183
0:11:02.120 --> 0:11:07.120
And also, I didn't get into some of the things important for interoperability.

184
0:11:07.120 --> 0:11:11.040
So the next application I worked on, it's called MediaCracken.

185
0:11:11.040 --> 0:11:13.260
In this case, it's a media tracker.

186
0:11:13.260 --> 0:11:17.200
So the point is that you store all the movies that you have watched and all the movies you

187
0:11:17.200 --> 0:11:20.200
want to watch, and you can keep track of them.

188
0:11:20.200 --> 0:11:23.200
The use case is this, and it's quite simple, right?

189
0:11:23.200 --> 0:11:26.960
You can see how you can filter the movies, et cetera.

190
0:11:26.960 --> 0:11:31.280
So in this case, this is how the login looks like in philosophy.

191
0:11:31.280 --> 0:11:33.400
It's very similar to the other one.

192
0:11:33.400 --> 0:11:36.780
But it improves a little bit, because at least I explained what is solid.

193
0:11:36.780 --> 0:11:41.160
I helped users a little bit if they don't understand what to do.

194
0:11:41.160 --> 0:11:47.000
But also, once you are inside of the application, you can export the data, and it will be exported

195
0:11:47.000 --> 0:11:48.000
as JSON-LD.

196
0:11:48.000 --> 0:11:53.000
Later on, when you log in with your solid account, you can import it.

197
0:11:53.000 --> 0:11:59.040
So in this way, I added one way for people who started using it offline to upgrade to

198
0:11:59.040 --> 0:12:00.040
using solid.

199
0:12:00.040 --> 0:12:06.200
And I think this is also important so that they can make it easy, more easy.

200
0:12:06.200 --> 0:12:11.040
The other issue about the page speed, also maybe this was an obvious, but when you do

201
0:12:11.040 --> 0:12:15.560
a request to the movies container that I mentioned, you can get all the tasks in the previous

202
0:12:15.560 --> 0:12:19.140
example, you get a list of movies, right?

203
0:12:19.140 --> 0:12:22.000
But then you only get the idea of the movie.

204
0:12:22.000 --> 0:12:25.600
You don't get all the metadata, like the name and the image and everything.

205
0:12:25.600 --> 0:12:30.240
So if you want to get the movies, then you need to make another request for each of them.

206
0:12:30.240 --> 0:12:32.120
So in the end, this is not great.

207
0:12:32.120 --> 0:12:35.480
You are doing n plus 1 requests, right?

208
0:12:35.480 --> 0:12:38.680
In case you are wondering, why would you get all the movies?

209
0:12:38.680 --> 0:12:42.640
Like why don't you get just the 10 first movies and you do pagination, right?

210
0:12:42.640 --> 0:12:47.680
The point is that I want my application to be snappy and that you can filter things quickly

211
0:12:47.680 --> 0:12:48.880
and it works.

212
0:12:48.880 --> 0:12:53.760
If you have to do HTTP requests every time you do any interaction, it will be very slow,

213
0:12:53.760 --> 0:12:55.800
not just the page reload.

214
0:12:55.800 --> 0:13:00.160
So that's why I wanted to have all the movies in the front end.

215
0:13:00.160 --> 0:13:05.160
And then what happens doing this is that the first time you open the app, you see this.

216
0:13:05.160 --> 0:13:08.840
And depending on how many movies you have, you will be seeing this for a long time, which

217
0:13:08.840 --> 0:13:10.640
is not great, right?

218
0:13:10.640 --> 0:13:15.960
So what I did is that there is a movie cache of the data using index.db.

219
0:13:15.960 --> 0:13:21.640
And this way, the next time I open the application, I can look at the last modified date of each

220
0:13:21.640 --> 0:13:25.040
one of the documents and only request the new ones.

221
0:13:25.040 --> 0:13:26.800
This is a big improvement.

222
0:13:26.800 --> 0:13:30.120
Compared with solid focus, this makes it more usable.

223
0:13:30.120 --> 0:13:35.600
Still, if you have many movies, for example, I have more than 2000, the first time you

224
0:13:35.600 --> 0:13:38.240
open it in a new device, it's not great.

225
0:13:38.240 --> 0:13:42.520
It can still be improved by a little bit, right?

226
0:13:42.520 --> 0:13:45.760
And finally, the thing I mentioned about interoperability.

227
0:13:45.760 --> 0:13:51.440
I don't have time to get into this a lot, but I wrote a blog post called Interoperables

228
0:13:51.440 --> 0:13:52.440
and DPT.

229
0:13:52.440 --> 0:13:56.000
And I think this is actually the most important point of solid.

230
0:13:56.000 --> 0:14:01.440
In the end, if you are using solid and you are making apps, but they are not interoperable,

231
0:14:01.440 --> 0:14:03.720
you will end up in the same scenario we have now.

232
0:14:03.720 --> 0:14:08.720
The power of solid is that you use different applications and they use your data, right?

233
0:14:08.720 --> 0:14:12.280
So I think this is important to have into account.

234
0:14:12.280 --> 0:14:15.560
So for example, which vocabulary would you use?

235
0:14:15.560 --> 0:14:20.600
There are some websites where you can see the vocabularies that are already used, and

236
0:14:20.600 --> 0:14:22.640
you can see which ones are the most popular.

237
0:14:22.640 --> 0:14:26.520
So they are the most likely to be more useful, right?

238
0:14:26.520 --> 0:14:28.520
You can also create your own vocabulary.

239
0:14:28.520 --> 0:14:33.080
If you are doing a new use case, there's nothing wrong with creating your own vocabulary, and

240
0:14:33.080 --> 0:14:38.120
then other people will be able to use it to make other apps, right?

241
0:14:38.120 --> 0:14:43.320
And finally, at the beginning, I wasn't sure about this, but now that I've learned more,

242
0:14:43.320 --> 0:14:46.800
I think mixing and matching vocabularies is actually okay.

243
0:14:46.800 --> 0:14:52.040
So you shouldn't be taken aback by doing this, right?

244
0:14:52.040 --> 0:14:54.920
And then we have solved which vocabulary to use.

245
0:14:54.920 --> 0:14:57.320
The other thing is where do you store data?

246
0:14:57.320 --> 0:15:02.360
For example, if I am storing movies in slash movies, maybe another app can do it in slash

247
0:15:02.360 --> 0:15:03.360
films.

248
0:15:03.360 --> 0:15:06.160
So they will not work correctly together, right?

249
0:15:06.160 --> 0:15:10.960
So the point is that when you log in and you get the identity of the user, you will get

250
0:15:10.960 --> 0:15:15.360
a document describing all its information, all the public information.

251
0:15:15.360 --> 0:15:19.760
And if you are making the request with an authentication token, you also get the private

252
0:15:19.760 --> 0:15:21.160
information.

253
0:15:21.160 --> 0:15:24.720
And some of this information is something called a type index.

254
0:15:24.720 --> 0:15:30.040
And this type index tells you these users have tasks in this container, movies in this

255
0:15:30.040 --> 0:15:32.040
container, et cetera, right?

256
0:15:32.040 --> 0:15:36.400
So once you do that, then you can already use the proper container without hard coding

257
0:15:36.400 --> 0:15:38.800
anything in your application.

258
0:15:38.800 --> 0:15:44.520
If you are the first one adding movies or whatever to a pod, then you can just create

259
0:15:44.520 --> 0:15:47.400
the type index if it doesn't exist.

260
0:15:47.400 --> 0:15:52.840
I have to mention that right now it's a draft, but you can still use it.

261
0:15:52.840 --> 0:15:57.360
And I have been using it for years because it's a client to client standard.

262
0:15:57.360 --> 0:16:01.760
This means that the clients, so the applications, are the only ones that need to know about

263
0:16:01.760 --> 0:16:03.480
this type index.

264
0:16:03.480 --> 0:16:07.080
From the point of view of the pod is there's a simple document, right?

265
0:16:07.080 --> 0:16:08.680
So this is something you can use today.

266
0:16:08.680 --> 0:16:13.720
There is also something else called the solid application interoperability spec, but this

267
0:16:13.720 --> 0:16:16.080
one is a client to server standard.

268
0:16:16.080 --> 0:16:20.160
So until the servers start implementing this, this will not work.

269
0:16:20.160 --> 0:16:25.400
Just to clarify, in case it's not clear, server is the pod, right?

270
0:16:25.400 --> 0:16:26.400
Okay.

271
0:16:26.400 --> 0:16:32.440
So final thing about this app is that if you have all the data in your pod, you will not

272
0:16:32.440 --> 0:16:35.520
have all the movies in existence in your pod.

273
0:16:35.520 --> 0:16:36.960
So how do you make this work?

274
0:16:36.960 --> 0:16:43.120
To have a good user experience so that people can search and get the movie they want, right?

275
0:16:43.120 --> 0:16:47.560
In this case, something that I think is very important to do with solid apps is to rely

276
0:16:47.560 --> 0:16:49.800
on public information.

277
0:16:49.800 --> 0:16:55.880
So in this case, I am using a website called the movie database, which gives you a database

278
0:16:55.880 --> 0:16:58.520
and a free API to query that.

279
0:16:58.520 --> 0:17:04.120
Depending what type of data you are working on, you can search different APIs.

280
0:17:04.120 --> 0:17:06.880
But this is the basic idea.

281
0:17:06.880 --> 0:17:12.240
And if you want to learn more about how I build this app, you can check it out here.

282
0:17:12.240 --> 0:17:13.240
Some takeaways.

283
0:17:13.240 --> 0:17:14.680
Typing the accesses are nice.

284
0:17:14.680 --> 0:17:16.600
I encourage you to use them.

285
0:17:16.600 --> 0:17:18.520
And also catching is nice.

286
0:17:18.520 --> 0:17:20.440
It improves the performance a lot.

287
0:17:20.440 --> 0:17:24.000
So this is something to keep in mind.

288
0:17:24.000 --> 0:17:27.920
Things will still have to improve on board in UX and page speed.

289
0:17:27.920 --> 0:17:30.520
They are still not great, right?

290
0:17:30.520 --> 0:17:32.640
The next application I build is called to my.

291
0:17:32.640 --> 0:17:36.440
I don't want to scare you with the time frame in this.

292
0:17:36.440 --> 0:17:39.920
The thing is that, as I mentioned, this is a type project.

293
0:17:39.920 --> 0:17:41.560
And I don't only work on solid.

294
0:17:41.560 --> 0:17:44.240
I also experiment with different technologies.

295
0:17:44.240 --> 0:17:48.160
And for this one in particular, I started doing some animation things and all that.

296
0:17:48.160 --> 0:17:53.080
So it was entirely solid what made this take so long.

297
0:17:53.080 --> 0:17:57.120
But in any case, Umay is a recipes manager.

298
0:17:57.120 --> 0:18:00.320
So the point is that you have a collection of recipes.

299
0:18:00.320 --> 0:18:02.000
And you can search them and browse them.

300
0:18:02.000 --> 0:18:05.360
So in spirit, it is quite similar to media cracking.

301
0:18:05.360 --> 0:18:07.320
But instead of movies with recipes, right?

302
0:18:07.320 --> 0:18:10.520
This is the basic idea of the app.

303
0:18:10.520 --> 0:18:15.320
So the onboarding UX, at first sight, it may seem very similar to the other ones.

304
0:18:15.320 --> 0:18:17.120
But I think it's a lot better.

305
0:18:17.120 --> 0:18:18.120
Why?

306
0:18:18.120 --> 0:18:21.040
Because this button here says, create your first recipe.

307
0:18:21.040 --> 0:18:23.760
It doesn't say, use browser storage.

308
0:18:23.760 --> 0:18:28.000
And this is important because for people who don't understand how things work, maybe they

309
0:18:28.000 --> 0:18:31.400
are scared, like, what is browser storage?

310
0:18:31.400 --> 0:18:35.520
But if they just create first recipe, they can just go ahead and do it without worrying

311
0:18:35.520 --> 0:18:39.400
about solid or any technical aspects, right?

312
0:18:39.400 --> 0:18:45.640
Then when they start using the application, they can see the status of their data in here.

313
0:18:45.640 --> 0:18:50.960
And what I'm trying to convey to users is the concept of a cloud.

314
0:18:50.960 --> 0:18:55.880
So I still mention solid when they have to log in and create the account and everything.

315
0:18:55.880 --> 0:19:00.360
But I think this way they understand that they have a cloud where the data is stored,

316
0:19:00.360 --> 0:19:01.800
which is using solid.

317
0:19:01.800 --> 0:19:03.560
But they also have the local data.

318
0:19:03.560 --> 0:19:08.600
And I think this type of concept is something maybe they are already familiar with.

319
0:19:08.600 --> 0:19:12.560
And this got me to the realization that the application is offline first.

320
0:19:12.560 --> 0:19:14.560
So that is quite nice.

321
0:19:14.560 --> 0:19:18.920
But there are some issues or some challenges when you are doing an offline first solid

322
0:19:18.920 --> 0:19:19.920
app.

323
0:19:19.920 --> 0:19:26.520
For example, when you need to authenticate with a solid pod, you shouldn't store the

324
0:19:26.520 --> 0:19:29.000
authentication token in the frontend.

325
0:19:29.000 --> 0:19:32.600
And if you want to see the details why, you can read this forum thread.

326
0:19:32.600 --> 0:19:36.840
And also, every time you open the app, you have to redirect to do the authentication.

327
0:19:36.840 --> 0:19:41.280
This is also something that could be improved in the future, but that's how it currently

328
0:19:41.280 --> 0:19:42.280
works.

329
0:19:42.280 --> 0:19:45.960
So the way I have solved this for now is that I have some settings.

330
0:19:45.960 --> 0:19:50.320
And depending on the device you are using, you can reconnect automatically or not.

331
0:19:50.320 --> 0:19:55.160
For example, in my desktop device, I have this with everything automatic because I have

332
0:19:55.160 --> 0:19:57.320
a stable internet connection.

333
0:19:57.320 --> 0:20:00.360
But in my mobile phone, I don't reconnect automatically.

334
0:20:00.360 --> 0:20:03.320
I only synchronize manually whenever I want to.

335
0:20:03.320 --> 0:20:05.880
This is the basic idea.

336
0:20:05.880 --> 0:20:09.560
And the second thing, this will get a bit into the weeds as well.

337
0:20:09.560 --> 0:20:14.440
But imagine you have this delicious ramen recipe in your pod, right?

338
0:20:14.440 --> 0:20:16.240
And you have it in two devices.

339
0:20:16.240 --> 0:20:18.920
You have it safely stored in your solid pod.

340
0:20:18.920 --> 0:20:23.640
And you have a copy in your mobile phone and another copy in your desktop, right?

341
0:20:23.640 --> 0:20:27.760
You change the title of the recipe in your mobile phone, but it's not connected to the

342
0:20:27.760 --> 0:20:28.760
internet.

343
0:20:28.760 --> 0:20:31.520
So the changes stay local for now.

344
0:20:31.520 --> 0:20:34.060
Then you change the description in your desktop device.

345
0:20:34.060 --> 0:20:36.360
This one is connected to the internet.

346
0:20:36.360 --> 0:20:40.720
So you will synchronize with the pod, and you will push the changes.

347
0:20:40.720 --> 0:20:42.080
But now we have an issue.

348
0:20:42.080 --> 0:20:47.840
When the phone finally synchronizes, you will see that it has been updated because you look

349
0:20:47.840 --> 0:20:52.120
at the timestamp of the last update, but you don't know what has changed.

350
0:20:52.120 --> 0:20:57.480
So now you have to decide if you discard the local data or you discard the remote data.

351
0:20:57.480 --> 0:20:59.400
So this is not ideal.

352
0:20:59.400 --> 0:21:03.780
The way I solved this is using something called CRDTs.

353
0:21:03.780 --> 0:21:06.600
You can also read more about the details here.

354
0:21:06.600 --> 0:21:09.440
And in this case, I had to create a vocab for this.

355
0:21:09.440 --> 0:21:10.440
And that's fine.

356
0:21:10.440 --> 0:21:15.000
And I'm mixing both the recipes vocabulary and the CRDT vocabulary.

357
0:21:15.000 --> 0:21:17.520
So let's go through that again.

358
0:21:17.520 --> 0:21:18.520
You do the same thing.

359
0:21:18.520 --> 0:21:20.760
You modify the name in the mobile device.

360
0:21:20.760 --> 0:21:25.880
But this time, you also store the operation in the data.

361
0:21:25.880 --> 0:21:29.960
So not only the change, but also what happened and what time, right?

362
0:21:29.960 --> 0:21:34.240
You do the same in the desktop, you synchronize, and you push the changes.

363
0:21:34.240 --> 0:21:39.160
And then when you synchronize with the mobile phone, you will see that what changed remotely

364
0:21:39.160 --> 0:21:40.880
was only the description.

365
0:21:40.880 --> 0:21:45.840
So in this way, you can pull the changes, and then you push your change without any

366
0:21:45.840 --> 0:21:46.840
conflicts.

367
0:21:46.840 --> 0:21:48.600
And this is a basic idea.

368
0:21:48.600 --> 0:21:52.120
And when you do all this, then you have everything synchronized.

369
0:21:52.120 --> 0:21:57.560
If your head is spinning right now, don't worry, because this is a bit esoteric.

370
0:21:57.560 --> 0:21:59.840
But not all solid applications have to do this.

371
0:21:59.840 --> 0:22:05.040
It's just this is the way I found to make my user experience how I wanted it to be.

372
0:22:05.040 --> 0:22:10.440
But you don't need to do this if you are getting started or want to see how solid works, right?

373
0:22:10.440 --> 0:22:14.640
So something else, and I think this is one of the most interesting things about this

374
0:22:14.640 --> 0:22:21.040
app, is that before I was saying that for movies, for example, you search an API, right?

375
0:22:21.040 --> 0:22:26.000
But if you have to search an API with all the recipes in the world, it doesn't exist.

376
0:22:26.000 --> 0:22:27.720
How does people search recipes?

377
0:22:27.720 --> 0:22:29.880
Or at least how do I search recipes?

378
0:22:29.880 --> 0:22:33.000
I go to a search engine, and I search for the recipe.

379
0:22:33.000 --> 0:22:36.520
So the point is that the data itself is the web.

380
0:22:36.520 --> 0:22:39.360
It's websites that are already there, right?

381
0:22:39.360 --> 0:22:45.480
So the point is that for recipes, when you make a search, most search engines show you

382
0:22:45.480 --> 0:22:47.760
the results, and they know that they are recipes.

383
0:22:47.760 --> 0:22:49.760
This is not just a website for them.

384
0:22:49.760 --> 0:22:51.600
They know these are recipes.

385
0:22:51.600 --> 0:22:55.520
And if you look under the hood, you inspect the source of these websites.

386
0:22:55.520 --> 0:23:00.360
You will see that in the header, they have some data called application LDJson.

387
0:23:00.360 --> 0:23:03.580
And the nice thing is that this is actually semantic data.

388
0:23:03.580 --> 0:23:06.640
So this is what I mentioned way at the beginning.

389
0:23:06.640 --> 0:23:09.520
And many websites are already using this.

390
0:23:09.520 --> 0:23:13.160
Websites that don't even know that solid exists or anything.

391
0:23:13.160 --> 0:23:17.440
So this is very nice because this is one way to leverage the data that already exists in

392
0:23:17.440 --> 0:23:18.480
the wild.

393
0:23:18.480 --> 0:23:23.040
And I think this is a nice way to showcase what the future could look like if solid was

394
0:23:23.040 --> 0:23:27.720
more used and data were more interconnected, right?

395
0:23:27.720 --> 0:23:29.360
So yeah, you just import.

396
0:23:29.360 --> 0:23:32.640
You just put the URL of the website and you import the data.

397
0:23:32.640 --> 0:23:37.240
Unfortunately, because the application lives in the front end, there are course issues.

398
0:23:37.240 --> 0:23:39.680
So you cannot make HTTP requests.

399
0:23:39.680 --> 0:23:42.480
And the way I've solved it for now is to use a proxy.

400
0:23:42.480 --> 0:23:46.440
But depending on the application you do, this will not be an issue because you can also

401
0:23:46.440 --> 0:23:51.040
use the server where you are hosting the app or something.

402
0:23:51.040 --> 0:23:56.840
So yeah, and finally, the last thing to mention is that in this app, I also implemented the

403
0:23:56.840 --> 0:23:58.720
ability to share things.

404
0:23:58.720 --> 0:24:04.600
So by default, when you create data in a solid pod, you should create it private, right?

405
0:24:04.600 --> 0:24:08.120
But you can also change the permissions and make it public.

406
0:24:08.120 --> 0:24:11.600
And this way, you can share this link with other people.

407
0:24:11.600 --> 0:24:16.600
Then if you share this, you can give the link to someone who doesn't even have a solid account

408
0:24:16.600 --> 0:24:22.520
or doesn't even know what solid is, and they will be able to see the data using the URL

409
0:24:22.520 --> 0:24:24.280
of your document.

410
0:24:24.280 --> 0:24:29.880
And something interesting to realize here is that this is not only a URL of my application.

411
0:24:29.880 --> 0:24:32.120
Like with my app, you can share recipes.

412
0:24:32.120 --> 0:24:38.000
No, you are sharing the document URL in the solid pod.

413
0:24:38.000 --> 0:24:42.920
What this means is that visitors don't need a solid account because it's public.

414
0:24:42.920 --> 0:24:48.720
But also that any of you here in this room and anybody can make an application that already

415
0:24:48.720 --> 0:24:54.520
uses this URL because you only have to read the solid document that is following the solid

416
0:24:54.520 --> 0:24:56.000
protocol, right?

417
0:24:56.000 --> 0:25:03.840
So in this way, you can already see how doing data in this way is useful in the end.

418
0:25:03.840 --> 0:25:08.120
And you can learn more here if you want, more of the details.

419
0:25:08.120 --> 0:25:11.120
You can also read more about how I implemented this application.

420
0:25:11.120 --> 0:25:16.240
And if you are curious why it took me three years, this is where you can see why.

421
0:25:16.240 --> 0:25:19.280
And some takeaways is that offline first is really nice.

422
0:25:19.280 --> 0:25:22.960
I think I'm probably going to do it for most of my apps, at least the ones that follow

423
0:25:22.960 --> 0:25:24.920
this schema.

424
0:25:24.920 --> 0:25:25.920
Sharing is caring.

425
0:25:25.920 --> 0:25:31.680
What I mean with this is that hopefully sharing these recipes or using this type of feature

426
0:25:31.680 --> 0:25:37.120
inside of a solid app will show people why solid is useful.

427
0:25:37.120 --> 0:25:41.720
And maybe without even knowing what solid is, they can realize the power of this.

428
0:25:41.720 --> 0:25:46.200
Like, look, someone shared with me this URL and then I use the same URL in another app

429
0:25:46.200 --> 0:25:47.720
and I can get the data.

430
0:25:47.720 --> 0:25:51.720
I think there are very different interactions that we can see here.

431
0:25:51.720 --> 0:25:52.720
And finally, keep it simple.

432
0:25:52.720 --> 0:25:55.320
This is something I always try to remind myself.

433
0:25:55.320 --> 0:26:00.280
I don't always make it, but I think it's important to keep it in mind, especially with solid

434
0:26:00.280 --> 0:26:03.200
because things can get out of hand.

435
0:26:03.200 --> 0:26:08.760
But as I said at the beginning, the basic things get post RDF.

436
0:26:08.760 --> 0:26:09.760
Those are the basics.

437
0:26:09.760 --> 0:26:15.400
And if you have that in mind, I think you can go a long way with solid.

438
0:26:15.400 --> 0:26:16.920
And I still have some challenges.

439
0:26:16.920 --> 0:26:20.920
I cannot give you a solution because this is where I am right now.

440
0:26:20.920 --> 0:26:25.800
So the onboarding, I think it has improved a lot, but still when people want to connect

441
0:26:25.800 --> 0:26:28.660
to the cloud and they see solid, they don't know what that is.

442
0:26:28.660 --> 0:26:30.680
So this is one of the challenges.

443
0:26:30.680 --> 0:26:35.720
And also the course issue, if I want to make frontend applications, this is very difficult

444
0:26:35.720 --> 0:26:36.840
to get around.

445
0:26:36.840 --> 0:26:41.320
So this is some of the challenges I also haven't solved yet.

446
0:26:41.320 --> 0:26:42.320
And that's it.

447
0:26:42.320 --> 0:26:44.760
You can follow my work and use the apps.

448
0:26:44.760 --> 0:26:47.800
And if you have any questions, let me know.

449
0:26:47.800 --> 0:26:48.800
Okay.

450
0:26:48.800 --> 0:27:02.680
Thank you.

451
0:27:02.680 --> 0:27:04.960
It was a wonderful presentation.

452
0:27:04.960 --> 0:27:12.400
I'm wondering when do you think it will be ready to be used in more mature applications?

453
0:27:12.400 --> 0:27:18.280
Because just for example, one thing is that you are taking full control of the pod, meaning

454
0:27:18.280 --> 0:27:22.760
that I would never share with you my credential of the pod so that you would have access to

455
0:27:22.760 --> 0:27:23.760
everything.

456
0:27:23.760 --> 0:27:29.480
And if you have any thoughts about the timeline for that?

457
0:27:29.480 --> 0:27:30.480
Yeah.

458
0:27:30.480 --> 0:27:34.680
So I cannot speak about the timeline because I'm not part of the specification process.

459
0:27:34.680 --> 0:27:39.680
So the answer to this would be when the specification includes some mechanisms to do that.

460
0:27:39.680 --> 0:27:42.720
And they already have it in mind and they aren't working on it.

461
0:27:42.720 --> 0:27:46.600
But I cannot give you any answers about the timeline because I'm not involved in that

462
0:27:46.600 --> 0:27:47.600
process.

463
0:27:47.600 --> 0:27:52.320
So I can tell you that I know what people who use solid that have these type of concerns,

464
0:27:52.320 --> 0:27:55.240
that you have the, they just have different pods.

465
0:27:55.240 --> 0:27:59.120
Like I have a pod for my private or sensitive information.

466
0:27:59.120 --> 0:28:03.920
And I have another pod for my public information, right?

467
0:28:03.920 --> 0:28:09.120
And this is also nice because you can use the same app with different pods.

468
0:28:09.120 --> 0:28:14.880
Like if you are using something for your professional life and then your personal life, you can have

469
0:28:14.880 --> 0:28:17.440
it in different pods and that's okay.

470
0:28:17.440 --> 0:28:20.200
So yeah, that's my opinion on the topic for now.

471
0:28:20.200 --> 0:28:22.720
It's something still being worked on.

472
0:28:22.720 --> 0:28:23.720
Yeah.

473
0:28:23.720 --> 0:28:26.960
Any more questions?

474
0:28:26.960 --> 0:28:28.560
Okay.

475
0:28:28.560 --> 0:28:32.160
Thank you.

476
0:28:32.160 --> 0:28:37.560
Yeah, thank you.

477
0:28:37.560 --> 0:28:43.000
Well it's a bit of a related question, but it's more specific to the type indices.

478
0:28:43.000 --> 0:28:44.000
So I didn't know about that.

479
0:28:44.000 --> 0:28:45.200
I've never used them.

480
0:28:45.200 --> 0:28:49.960
So you're saying that it's part of the spec or soon to be part of?

481
0:28:49.960 --> 0:28:50.960
The point, okay.

482
0:28:50.960 --> 0:28:55.280
The point about type indexes is that they are a different spec made by people who are

483
0:28:55.280 --> 0:29:00.680
working on solid, but it's a client spec, which means is that from the point of view

484
0:29:00.680 --> 0:29:02.880
of the pod is just a document.

485
0:29:02.880 --> 0:29:07.240
So maybe you can call it more a convention than anything else.

486
0:29:07.240 --> 0:29:11.880
And the point is that if people start using this convention, then it will become more

487
0:29:11.880 --> 0:29:14.440
interoperable in the wild, you know?

488
0:29:14.440 --> 0:29:18.520
But it's a convention, you could say, because the pods don't need to implement anything

489
0:29:18.520 --> 0:29:19.720
for this to work.

490
0:29:19.720 --> 0:29:20.760
Yeah, thank you.

491
0:29:20.760 --> 0:29:24.880
And so my question was, and this is where it relates to the previous question, is it,

492
0:29:24.880 --> 0:29:30.360
so I find it very interesting, but isn't it a bit risky to basically grant the apps to

493
0:29:30.360 --> 0:29:34.720
go and mess with the global type indices?

494
0:29:34.720 --> 0:29:39.840
It means you can maybe mess up the type indices with someone else, or I mean, shouldn't it

495
0:29:39.840 --> 0:29:44.280
be the responsibility of the pod provider to build up that type index?

496
0:29:44.280 --> 0:29:48.840
Maybe when it gets into the spec, yes, for example, the solid application interoperability

497
0:29:48.840 --> 0:29:54.840
spec, which is also a draft, it does this type of thing in the side of the pod.

498
0:29:54.840 --> 0:29:58.760
So yeah, there are the thing about solid, as I said at the beginning, is that there

499
0:29:58.760 --> 0:30:03.240
are many ways to do things, because the building blocks are basic, but you can combine them

500
0:30:03.240 --> 0:30:05.400
in many ways, you know?

501
0:30:05.400 --> 0:30:11.720
And the point is that right now, and that's what I'm thinking about when I do this, if

502
0:30:11.720 --> 0:30:17.160
you have to build a solid application today, the type index is your best choice, because

503
0:30:17.160 --> 0:30:21.800
the solid application interoperability requires implementation in the server, and it's not

504
0:30:21.800 --> 0:30:23.160
happening yet.

505
0:30:23.160 --> 0:30:25.040
So you cannot rely on that.

506
0:30:25.040 --> 0:30:27.880
So type indexes are the best thing we have.

507
0:30:27.880 --> 0:30:33.000
You can also choose not to use type indexes, but then it will be even less interoperable.

508
0:30:33.000 --> 0:30:36.000
And to me, it's very important that an app is interoperable.

509
0:30:36.000 --> 0:30:38.480
Yeah, you're welcome.

510
0:30:38.480 --> 0:30:42.000
Yes, hello.

511
0:30:42.000 --> 0:30:43.320
Yes, here.

512
0:30:43.320 --> 0:30:44.320
Okay.

513
0:30:44.320 --> 0:30:50.880
Yeah, so with MediaKraken, we saw that it can be complicated to fetch a lot of movie,

514
0:30:50.880 --> 0:30:56.040
and also it's the same if you want to fetch from different pods, it can be very complex.

515
0:30:56.040 --> 0:31:02.720
I wanted to know what's your feeling about like speed and all that on solid, or do you

516
0:31:02.720 --> 0:31:06.600
think like solid is doomed to be used with really low data app, or do you think it's

517
0:31:06.600 --> 0:31:09.840
possible to have big data with solid?

518
0:31:09.840 --> 0:31:12.360
I think it depends a lot on the use case of the app.

519
0:31:12.360 --> 0:31:19.320
For example, for my apps, even if I had perfect querying APIs, I think I would still use this,

520
0:31:19.320 --> 0:31:23.480
because I found the offline first approach, and I like it a lot.

521
0:31:23.480 --> 0:31:28.280
But eventually, there is something called Spark UL, which means you can run queries

522
0:31:28.280 --> 0:31:29.800
on linked data.

523
0:31:29.800 --> 0:31:32.960
These type of things could get into the specification.

524
0:31:32.960 --> 0:31:39.160
But again, all of these depends on the specification, and I really don't know when it will happen,

525
0:31:39.160 --> 0:31:40.160
or if.

526
0:31:40.160 --> 0:31:44.360
I mean, I know that people working on the spec, they are aware of these issues, and

527
0:31:44.360 --> 0:31:45.720
they are working on this.

528
0:31:45.720 --> 0:31:48.480
But I don't know the timeline, really.

529
0:31:48.480 --> 0:31:54.280
I just can say that for my apps, at least, this use case, that's what I do, offline first.

530
0:31:54.280 --> 0:32:00.120
And even if I had good querying endpoints, probably I wouldn't use them, but I don't

531
0:32:00.120 --> 0:32:01.120
know.

532
0:32:01.120 --> 0:32:03.120
It depends on the implementation.

533
0:32:03.120 --> 0:32:04.640
Yeah, thanks.

534
0:32:04.640 --> 0:32:05.640
Yeah.

535
0:32:05.640 --> 0:32:06.640
Hi.

536
0:32:06.640 --> 0:32:14.400
If you have that offline first mode with a CRDT, is there a way to do it, or there is,

537
0:32:14.400 --> 0:32:18.320
but have you looked into doing it in such a way that someone doesn't need to bring their

538
0:32:18.320 --> 0:32:24.440
own pod, that they can use their own devices and have their devices sync between each other

539
0:32:24.440 --> 0:32:25.440
directly?

540
0:32:25.440 --> 0:32:26.440
Yeah.

541
0:32:26.440 --> 0:32:31.600
So, technically, it would be very easy and very possible because you just have the operations,

542
0:32:31.600 --> 0:32:33.320
and you just have to do it.

543
0:32:33.320 --> 0:32:40.240
Personally, I have not done it in my apps because I'm interested in having easy experiences

544
0:32:40.240 --> 0:32:46.280
for users, and what I am going to tell them if they have to synchronize two devices.

545
0:32:46.280 --> 0:32:49.440
Maybe I can use WebRTC or something like this.

546
0:32:49.440 --> 0:32:52.280
Yes, but I think they are still devices.

547
0:32:52.280 --> 0:32:57.560
I think what they like is the idea of having a cloud, and everything is safe in the cloud.

548
0:32:57.560 --> 0:33:00.080
And this is also what I personally would do.

549
0:33:00.080 --> 0:33:03.960
I don't know if I would want to have only things in devices.

550
0:33:03.960 --> 0:33:07.200
But to answer your question, yes, it would be very easy to do.

551
0:33:07.200 --> 0:33:11.120
I just haven't done it, but it would be very easy.

552
0:33:11.120 --> 0:33:12.120
Yeah.

553
0:33:12.120 --> 0:33:17.680
And by the way, well, all of this is open source, so you are welcome to fork it or ask

554
0:33:17.680 --> 0:33:19.520
me about the code or anything.

555
0:33:19.520 --> 0:33:26.520
I would be happy to help you if you want.

556
0:33:26.520 --> 0:33:33.520
I'll get my exercise.

557
0:33:33.520 --> 0:33:44.400
LDF and linked data exist for so long, and we don't see a lot of open source project

558
0:33:44.400 --> 0:33:50.880
unleashing the potential of such a system.

559
0:33:50.880 --> 0:33:55.320
Why do you think it's not more mainstream?

560
0:33:55.320 --> 0:34:01.040
And do you think there is enough learning material that are easy to understand for developers?

561
0:34:01.040 --> 0:34:02.040
Yeah.

562
0:34:02.040 --> 0:34:04.800
So I cannot answer for everybody, because I don't know.

563
0:34:04.800 --> 0:34:09.720
But my personal opinion is that in theory, RDF is awesome.

564
0:34:09.720 --> 0:34:10.720
I like it a lot.

565
0:34:10.720 --> 0:34:12.720
And this is why I am working on this.

566
0:34:12.720 --> 0:34:17.360
But in practice, the developer experience is not great.

567
0:34:17.360 --> 0:34:22.720
And people, when they see TARTELL and RDF and all these things, they don't like it.

568
0:34:22.720 --> 0:34:29.040
So my opinion is that it's because of lack of learning materials and the developer experience

569
0:34:29.040 --> 0:34:30.600
to get started.

570
0:34:30.600 --> 0:34:31.600
But I don't know.

571
0:34:31.600 --> 0:34:36.320
I think if you learn the building blocks, because I learned about RDF four years ago

572
0:34:36.320 --> 0:34:37.640
when I learned about Solit.

573
0:34:37.640 --> 0:34:40.520
I didn't even know about the semantic web.

574
0:34:40.520 --> 0:34:45.840
But I learned the basic things, like the specs I linked at the beginning, RDF, and all of

575
0:34:45.840 --> 0:34:46.840
this.

576
0:34:46.840 --> 0:34:52.560
And I think once you understand those basic things, it's very easy to work with, I think.

577
0:34:52.560 --> 0:34:53.560
But I don't know.

578
0:34:53.560 --> 0:34:54.560
It depends on that.

579
0:34:54.560 --> 0:34:58.440
And there are not a lot of learning materials that I know of.

580
0:34:58.440 --> 0:35:03.080
And there is not one framework you can use that is super easy, has a very nice developer

581
0:35:03.080 --> 0:35:04.760
experience.

582
0:35:04.760 --> 0:35:09.220
So I think it's still a thing of tooling and documentation at this point.

583
0:35:09.220 --> 0:35:10.680
But this is my personal opinion.

584
0:35:10.680 --> 0:35:14.040
I can't speak for what people that I don't know.

585
0:35:14.040 --> 0:35:15.040
Yeah.

586
0:35:15.040 --> 0:35:19.080
Can you just tell me about when you stored the pod on a...

587
0:35:19.080 --> 0:35:24.320
I just did a quick read of the actual FAQs on the Solit website.

588
0:35:24.320 --> 0:35:29.800
And it seems to be a lot of the details of how the pod providers store the data up to

589
0:35:29.800 --> 0:35:33.620
the providers so that options such as encryption is left to them.

590
0:35:33.620 --> 0:35:36.200
So that seems to move a lot of the privacy concerns.

591
0:35:36.200 --> 0:35:41.760
We have existing cloud services to the pod providers unless you self-housed on a server

592
0:35:41.760 --> 0:35:43.480
that you encrypt yourself and such.

593
0:35:43.480 --> 0:35:51.000
So do you have any thoughts on that, on how that works with the provider escape at that

594
0:35:51.000 --> 0:35:52.000
moment?

595
0:35:52.000 --> 0:35:53.000
Yeah.

596
0:35:53.000 --> 0:35:59.400
So the point is, so the biggest issue today for someone to start using Solit is which

597
0:35:59.400 --> 0:36:01.280
pod provider to use, basically.

598
0:36:01.280 --> 0:36:06.160
If I have to recommend a friend of mine to use Solit, I don't even know what the provider

599
0:36:06.160 --> 0:36:08.080
that I would recommend them.

600
0:36:08.080 --> 0:36:11.760
But I like the point that users choose.

601
0:36:11.760 --> 0:36:16.760
And if you are super worried about privacy and you want everything super encrypted and

602
0:36:16.760 --> 0:36:21.000
everything, then you choose a pod provider that encrypts everything.

603
0:36:21.000 --> 0:36:23.640
But if you don't care so much, then you don't have to.

604
0:36:23.640 --> 0:36:26.740
You just self-host something in your home.

605
0:36:26.740 --> 0:36:27.740
So I don't know.

606
0:36:27.740 --> 0:36:31.120
I think this is part of the flexibility of Solit.

607
0:36:31.120 --> 0:36:34.960
So it's nice that it's the choice of the user.

608
0:36:34.960 --> 0:36:37.520
But I don't have many thoughts about that.

609
0:36:37.520 --> 0:36:41.760
Personally, I self-host and I don't mind about encryption.

610
0:36:41.760 --> 0:36:42.760
Yeah.

611
0:36:42.760 --> 0:36:47.920
I'd like to ask you how to find vocabularies.

612
0:36:47.920 --> 0:36:53.360
Because I know there are a lot of vocabularies, but it's quite a chaos.

613
0:36:53.360 --> 0:36:57.880
They are very difficult to find and to understand what the world's like.

614
0:36:57.880 --> 0:37:00.960
So at first, I also worried a lot about this.

615
0:37:00.960 --> 0:37:05.360
But now it's like the list of my problems, because really, you just search if there is

616
0:37:05.360 --> 0:37:07.200
one that already exists.

617
0:37:07.200 --> 0:37:12.080
Like in this website I shared, there is a website with a lot of vocabularies.

618
0:37:12.080 --> 0:37:13.240
Just search one.

619
0:37:13.240 --> 0:37:18.240
And if you don't find one that works for you, you create your own.

620
0:37:18.240 --> 0:37:20.000
And it's not so difficult.

621
0:37:20.000 --> 0:37:22.240
I think it's...

622
0:37:22.240 --> 0:37:24.660
At first, I understand how it's confusing.

623
0:37:24.660 --> 0:37:30.000
But once you decide that you can make your own vocabulary, it's not so difficult.

624
0:37:30.000 --> 0:37:34.720
So I recommend a lot this tall guy link called Bag of Chips.

625
0:37:34.720 --> 0:37:37.280
This is the one that changed my mind about this.

626
0:37:37.280 --> 0:37:40.880
That it's fine to mix vocabularies and make your own.

627
0:37:40.880 --> 0:37:43.280
So I recommend watching that.

628
0:37:43.280 --> 0:37:44.280
Yeah.

629
0:37:44.280 --> 0:37:45.280
Someone else?

630
0:37:45.280 --> 0:37:46.280
Yeah.

631
0:37:46.280 --> 0:37:53.560
Given that you've got different pod providers and you can never be sure what the infrastructure

632
0:37:53.560 --> 0:37:55.680
that you're working with is going to be like.

633
0:37:55.680 --> 0:37:58.460
It could be a very slow pod provider or whatever.

634
0:37:58.460 --> 0:38:01.720
Do you have to design your apps quite defensively?

635
0:38:01.720 --> 0:38:05.880
Because you can never be sure that actually the pod provider is actually going to be able

636
0:38:05.880 --> 0:38:09.960
to service the HTTP request that you want to make.

637
0:38:09.960 --> 0:38:11.080
Yeah.

638
0:38:11.080 --> 0:38:15.240
My answer to that is that no, because you just follow the solid protocol.

639
0:38:15.240 --> 0:38:16.240
And that's it.

640
0:38:16.240 --> 0:38:21.280
I mean, if the pod provider is slow, users will be unhappy and they will use another

641
0:38:21.280 --> 0:38:22.600
pod provider.

642
0:38:22.600 --> 0:38:23.760
So I don't worry about that.

643
0:38:23.760 --> 0:38:26.920
I just code to the solid spec.

644
0:38:26.920 --> 0:38:28.760
And I don't mind about that.

645
0:38:28.760 --> 0:38:33.080
The only thing is things that are not in the spec yet and they are drafts and different

646
0:38:33.080 --> 0:38:35.400
pod providers implement differently.

647
0:38:35.400 --> 0:38:40.200
But hopefully when the spec is more stable, this will not be an issue.

648
0:38:40.200 --> 0:38:41.520
Hi.

649
0:38:41.520 --> 0:38:43.680
Thanks for the great presentation.

650
0:38:43.680 --> 0:38:48.240
All your examples were single user applications.

651
0:38:48.240 --> 0:38:53.520
How would you apply the philosophy of solid to, let's say, for example, forum software?

652
0:38:53.520 --> 0:38:54.520
Yeah.

653
0:38:54.520 --> 0:38:58.800
Would you either store all posts from all users in their own pods and somehow get access

654
0:38:58.800 --> 0:38:59.800
to all those pods?

655
0:38:59.800 --> 0:39:05.360
Or would you just not use it for that and just use it, for example, for public information

656
0:39:05.360 --> 0:39:06.360
on the user?

657
0:39:06.360 --> 0:39:07.360
Yeah.

658
0:39:07.360 --> 0:39:08.920
So I haven't done anything about that.

659
0:39:08.920 --> 0:39:11.800
So I'm only going to say what I think about it.

660
0:39:11.800 --> 0:39:15.840
But basically my intuition tells me that it would be something very similar to Activity

661
0:39:15.840 --> 0:39:20.400
Pap, which is the protocol that powers Mastodon and the Freddyverse.

662
0:39:20.400 --> 0:39:23.380
And underneath it, it also uses linked data.

663
0:39:23.380 --> 0:39:27.080
So I think it would be very similar to that, the way it works.

664
0:39:27.080 --> 0:39:28.920
And I don't know exactly how it works.

665
0:39:28.920 --> 0:39:31.840
I have not coded Activity App applications.

666
0:39:31.840 --> 0:39:36.720
But I think the information is duplicated in the servers or something.

667
0:39:36.720 --> 0:39:38.880
I guess it would be something like that.

668
0:39:38.880 --> 0:39:39.880
I don't know.

669
0:39:39.880 --> 0:39:44.400
But I think my answer to thinking about social applications with solid is look at Activity

670
0:39:44.400 --> 0:39:52.160
Pap because it's the same idea, I think, or similar at least.

671
0:39:52.160 --> 0:39:57.400
Just as an FYI, there's also an active discussion going on in the matrix room associated with

672
0:39:57.400 --> 0:39:58.400
the staff room.

673
0:39:58.400 --> 0:39:59.400
So you might want to look there.

674
0:39:59.400 --> 0:40:00.400
There's also the data.

675
0:40:00.400 --> 0:40:02.400
I will take a look and answer.

676
0:40:02.400 --> 0:40:06.080
Also, you guys might want to check it out.

677
0:40:06.080 --> 0:40:07.080
Yeah.

678
0:40:07.080 --> 0:40:08.880
Well, so that's it, I guess.

679
0:40:08.880 --> 0:40:09.880
Thank you, everybody.

680
0:40:09.880 --> 0:40:10.880
Okay.

681
0:40:10.880 --> 0:40:11.880
Come on.

682
0:40:11.880 --> 0:40:27.760
Let me see.

