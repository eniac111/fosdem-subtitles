WEBVTT

00:00.000 --> 00:09.680
And let's welcome the next show from zero to hero with solid.

00:09.680 --> 00:11.240
Thanks Noel for presenting.

00:11.240 --> 00:13.720
Okay, thank you.

00:13.720 --> 00:20.480
So my name is Noel, I'm from Barcelona.

00:20.480 --> 00:25.280
I'm currently working at Moodle for days a week, but I'm also in the site making solid

00:25.280 --> 00:26.840
apps, site projects.

00:26.840 --> 00:29.680
And that's mostly what I will talk about today.

00:29.680 --> 00:31.320
I usually work in the open.

00:31.320 --> 00:36.400
This means that I journal about my development, so you can follow my work in my website, and

00:36.400 --> 00:38.760
here you have all the socials and everything.

00:38.760 --> 00:42.600
So if you are more interested in something I say, you probably can find more detail in

00:42.600 --> 00:44.400
my website.

00:44.400 --> 00:48.880
So before we start, how many people know what solid is or heard about it?

00:48.880 --> 00:51.200
Well, maybe half the room, okay?

00:51.200 --> 00:52.360
That's nice.

00:52.360 --> 00:57.200
So for those of you who don't know, before I say what solid is, I have to go back to

00:57.200 --> 00:59.120
the creation of the web.

00:59.120 --> 01:04.880
So when the web was created, these technologies were invented like Web Blowser, HTTP, HTML.

01:04.880 --> 01:08.400
I'm sure most of us are familiar with these ones.

01:08.400 --> 01:11.800
But later on, there was something called the semantic web.

01:11.800 --> 01:15.640
And how many people know what the semantic web is or are familiar with that?

01:15.640 --> 01:17.520
Okay, almost the same as solid.

01:17.520 --> 01:18.520
So yeah.

01:18.520 --> 01:24.600
Basically, the semantic web is an idea that in websites, other than human readable content

01:24.600 --> 01:31.560
and linked documents, users can also have linked data, which is machine readable data,

01:31.560 --> 01:33.440
not only human readable.

01:33.440 --> 01:38.760
And like this, some technologies were introduced, like the resource definition framework, JSON

01:38.760 --> 01:40.560
LD, TARTL, et cetera.

01:40.560 --> 01:43.880
We will see more about this later.

01:43.880 --> 01:46.200
And finally, the solid protocol.

01:46.200 --> 01:52.240
It's the next iteration of this idea, and it brings decentralized storage to the web.

01:52.240 --> 01:58.120
The web I see it, and the way they say it, Web 3.0 by the creators of the web.

01:58.120 --> 02:01.760
But it doesn't have to be confused with Web 3, which is blockchain.

02:01.760 --> 02:04.520
As you will see, solid doesn't have anything to do with blockchain.

02:04.520 --> 02:07.800
It's something completely different.

02:07.800 --> 02:14.240
And the basic idea of solid is that users have a pod, and applications and services

02:14.240 --> 02:16.560
store the data in the user pod.

02:16.560 --> 02:22.600
So for example, here on the left, we have the traditional architecture.

02:22.600 --> 02:26.920
Each application you use stores the data in a backend, and that's how most applications

02:26.920 --> 02:27.920
work nowadays.

02:27.920 --> 02:35.400
The idea of solid is that you can use different applications, but these applications can store

02:35.400 --> 02:37.040
data in the same pod.

02:37.040 --> 02:40.640
So it's the user, the one deciding where the data goes.

02:40.640 --> 02:46.520
And it's important for privacy, but also for interoperability and a better user experience.

02:46.520 --> 02:51.240
Because this way, they can share data between different apps seamlessly.

02:51.240 --> 02:52.840
That's the basic idea.

02:52.840 --> 02:57.160
And if you are more interested in the idea of solid in general, more division, you can

02:57.160 --> 03:03.560
watch a talk from 2019 that was given here at Fosdam, and you can see more about that.

03:03.560 --> 03:06.400
This talk will be a bit more technical.

03:06.400 --> 03:10.680
So when you saw the title of this talk, maybe this is what comes to mind.

03:10.680 --> 03:15.480
But before we begin, I want to clarify that there are different types of heroes.

03:15.480 --> 03:18.080
So what type of heroes do I mean?

03:18.080 --> 03:23.000
So there are many ways to use solid, just like there are many ways to make websites.

03:23.000 --> 03:25.720
In this talk, we will focus on making solid apps.

03:25.720 --> 03:30.280
So I will not talk about hosting pods or making solid services.

03:30.280 --> 03:33.160
Mostly I will talk about making solid apps.

03:33.160 --> 03:37.800
And this is because this is what I have been doing for the last four years as site projects.

03:37.800 --> 03:43.260
So I have not worked either in any enterprise level application or anything.

03:43.260 --> 03:48.120
But I don't want to discourage you from learning from this, because my goal with this apps

03:48.120 --> 03:50.680
is to make them usable for people.

03:50.680 --> 03:55.420
It's not only some random site project to try technology.

03:55.420 --> 03:58.680
My end goal is to actually make useful apps.

03:58.680 --> 04:03.600
And also, it will be road strokes, because I cannot get into many of the details.

04:03.600 --> 04:06.520
But we will get into some of the ways.

04:06.520 --> 04:10.280
So the first app I developed was in 2018.

04:10.280 --> 04:12.360
It's called Solid Focus.

04:12.360 --> 04:15.100
And basically, it's a task manager.

04:15.100 --> 04:19.440
So the first application you do, it's always like a to-do app.

04:19.440 --> 04:23.280
So this is what I decided to do with Solid, to learn about it.

04:23.280 --> 04:28.000
So the only thing we care about is that you have tasks, and you can mark them as done

04:28.000 --> 04:29.000
or not done.

04:29.000 --> 04:31.240
That's the basic.

04:31.240 --> 04:35.280
And when you open the application for the first time, this is what you see.

04:35.280 --> 04:41.720
So normally, people are used to register an account with an email and a password, or something

04:41.720 --> 04:42.720
like this.

04:42.720 --> 04:47.000
In Solid, it's different, because what you have to do when you open an account is to

04:47.000 --> 04:48.840
give the solid pod.

04:48.840 --> 04:52.320
And you are telling the app where it should get the data.

04:52.320 --> 04:57.080
In this case, I also added a login offline button, because I know many people are not

04:57.080 --> 04:58.680
familiar with Solid.

04:58.680 --> 05:02.400
And if they only want to try the app, they can do it like this without a pod.

05:02.400 --> 05:07.360
I also think it's very aligned with the vision of Solid, that users decide where to store

05:07.360 --> 05:08.360
data.

05:08.360 --> 05:13.200
So they can decide to store it in their local device without hitting the network.

05:13.200 --> 05:15.400
So this is how it works.

05:15.400 --> 05:19.720
And when you are making a Solid app, there are actually three actors you are interested

05:19.720 --> 05:20.760
in.

05:20.760 --> 05:22.760
One of them is your application.

05:22.760 --> 05:27.560
Another one is your pod, well, the user's pod, where the data will be stored.

05:27.560 --> 05:29.760
But there is also the identity provider.

05:29.760 --> 05:35.800
And actually, when users are authenticating, you are communicating with the identity provider.

05:35.800 --> 05:38.760
It will give you a token.

05:38.760 --> 05:42.520
And it's this token, the one you use to load the data exchange in the pod.

05:42.520 --> 05:46.280
This is the basic architecture of how it works.

05:46.280 --> 05:51.560
But in general, you don't have to care too much about this, because you just use a library,

05:51.560 --> 05:55.880
you give it the URL, and then it gives you the token, and you can make authenticated

05:55.880 --> 05:56.880
requests.

05:56.880 --> 06:01.320
But I think it's important to at least know that before you get into it.

06:01.320 --> 06:06.080
So once you have the token, then you want to create data.

06:06.080 --> 06:10.280
So usually, when you think about the task manager, this is the type of data you will

06:10.280 --> 06:11.280
see.

06:11.280 --> 06:13.360
You have an ID, a description, and add-on.

06:13.360 --> 06:14.360
It's a Boolean.

06:14.360 --> 06:18.880
But when you are working with Solid, this is how you would do it.

06:18.880 --> 06:21.560
Now before, people want to leave the room.

06:21.560 --> 06:26.200
One of my goals with this talk is to actually convince you why this is better.

06:26.200 --> 06:29.720
And in the end, when you get used to it, it's not so different, actually.

06:29.720 --> 06:32.660
So hopefully, I will do it.

06:32.660 --> 06:34.480
So we have a context.

06:34.480 --> 06:38.240
This indicates the vocabulary of this piece of data.

06:38.240 --> 06:42.680
That's important, because if different applications are using the same data, they need to share

06:42.680 --> 06:47.720
an ontology, or they need to be using something that is the same, so that the data can be

06:47.720 --> 06:52.360
shared or understood by different implementations.

06:52.360 --> 06:54.080
The ID, it's a URL.

06:54.080 --> 06:57.000
This is also important, because it's where the data is actually stored.

06:57.000 --> 06:59.760
We will see more about this later.

06:59.760 --> 07:01.040
And then there is the type.

07:01.040 --> 07:05.840
So if you think about object-oriented programming, this would be like the class of the object.

07:05.840 --> 07:11.080
And then you have other properties, which can be just literals, or they can be linked

07:11.080 --> 07:14.680
to other objects or other properties.

07:14.680 --> 07:20.440
So the one before was JSON-LD, which is maybe more familiar for most people, because it's

07:20.440 --> 07:21.440
JSON.

07:21.440 --> 07:26.440
But when you are working with Solid, most of the time, you will be seeing RDF.

07:26.440 --> 07:29.000
And this is a format called Turtle.

07:29.000 --> 07:32.840
And actually, it's not so different from the first JSON I will show you.

07:32.840 --> 07:35.800
It's only that if you are not familiar, at first it may be striking.

07:35.800 --> 07:39.560
But eventually, it's quite similar to use, and it's not so different.

07:39.560 --> 07:43.400
So this is why I think it's not so bad in the end.

07:43.400 --> 07:45.640
I have been talking about the Solid pod.

07:45.640 --> 07:47.480
Like it's only a black box.

07:47.480 --> 07:51.760
But the thing is that inside of the Solid pod, you actually have containers.

07:51.760 --> 07:57.760
You can think of these as folders in a file system, inside of these folders or these containers.

07:57.760 --> 08:01.320
You have the documents, and you can also have binary.

08:01.320 --> 08:05.720
Like for example, you can have a video, an image, a JSON file, whatever.

08:05.720 --> 08:10.840
But this is something that will be not structured using this vocabulary data.

08:10.840 --> 08:14.840
So it's important that what is useful for your app and what you want to be interoperable

08:14.840 --> 08:17.400
is a structure using RDF.

08:17.400 --> 08:21.580
And inside of the documents, you have resources.

08:21.580 --> 08:26.640
So what I mentioned before that the ID says where the data is stored.

08:26.640 --> 08:32.320
If we look at the ID of a task in this example, we can see that the root of the URL is the

08:32.320 --> 08:33.320
Solid pod.

08:33.320 --> 08:37.560
So this tells you where the user is storing its data, right?

08:37.560 --> 08:42.480
The directory tells you the container where the task is stored.

08:42.480 --> 08:48.320
The URL is the document, and the complete URL, including the hash, is the RDF resource.

08:48.320 --> 08:52.440
So this is nice because whenever you see a piece of data installed, you immediately know

08:52.440 --> 08:55.480
its structure and what it is stored.

08:55.480 --> 08:59.440
This is useful as well if you export data and all of this.

08:59.440 --> 09:02.000
So now we have the authentication token.

09:02.000 --> 09:04.600
We have the data, and we know where to put it.

09:04.600 --> 09:08.840
So now this is the easy part, because this is built using web technologies.

09:08.840 --> 09:10.960
You only have to do a post request.

09:10.960 --> 09:16.000
So you do a post request with the document, and you create the document.

09:16.000 --> 09:20.080
And the body of this request will be the data in turtle format.

09:20.080 --> 09:24.480
It can also be in other formats if you want, but most of the time you will be using turtle.

09:24.480 --> 09:27.040
It's the most common, right?

09:27.040 --> 09:31.240
If you want to get the data, you do a request to the document.

09:31.240 --> 09:34.400
If you want to delete the data, you do a delete request.

09:34.400 --> 09:39.560
If you want to get a list of all the tasks, you do a get to the container, and you will

09:39.560 --> 09:42.460
get the list, and so on and so forth.

09:42.460 --> 09:47.280
The basic idea is that it works like the web, because it's built from those technologies,

09:47.280 --> 09:48.280
right?

09:48.280 --> 09:51.680
And actually, the good news is that that's it.

09:51.680 --> 09:54.520
This is how you make solid apps.

09:54.520 --> 09:58.560
And now in this talk, I will go into more things, but these are the basics.

09:58.560 --> 10:03.040
If you understand this, you can already do a lot of things with solid.

10:03.040 --> 10:07.320
And I think that's nice, because it's building up on existing technologies.

10:07.320 --> 10:10.800
So it's always important in that regard.

10:10.800 --> 10:14.760
Here you have some links if you want to get into the weeds with some things.

10:14.760 --> 10:19.560
And here you have my journal when I explain how I learned solid.

10:19.560 --> 10:24.340
This is the first time I saw solid, so it may be more interesting to some of you.

10:24.340 --> 10:25.340
Some takeaways.

10:25.340 --> 10:27.120
We learned the solid basics.

10:27.120 --> 10:31.480
And something that maybe wasn't obvious is that there is no server.

10:31.480 --> 10:36.160
You make the application, and the application works in the frontend, because the data will

10:36.160 --> 10:38.720
be stored in the solid pod, right?

10:38.720 --> 10:44.000
So this is nice, because you don't have to manage any servers, and you are only building

10:44.000 --> 10:47.000
frontend applications, which is static assets.

10:47.000 --> 10:51.960
And these static assets, they can be downloaded in a zip file and put into a computer or whatever.

10:51.960 --> 10:55.520
It's only JavaScript and HTML.

10:55.520 --> 10:57.080
But we also have some challenges.

10:57.080 --> 10:59.800
For example, the onboarding UX is not great.

10:59.800 --> 11:02.120
We have some issues with the page speed.

11:02.120 --> 11:07.120
And also, I didn't get into some of the things important for interoperability.

11:07.120 --> 11:11.040
So the next application I worked on, it's called MediaCracken.

11:11.040 --> 11:13.260
In this case, it's a media tracker.

11:13.260 --> 11:17.200
So the point is that you store all the movies that you have watched and all the movies you

11:17.200 --> 11:20.200
want to watch, and you can keep track of them.

11:20.200 --> 11:23.200
The use case is this, and it's quite simple, right?

11:23.200 --> 11:26.960
You can see how you can filter the movies, et cetera.

11:26.960 --> 11:31.280
So in this case, this is how the login looks like in philosophy.

11:31.280 --> 11:33.400
It's very similar to the other one.

11:33.400 --> 11:36.780
But it improves a little bit, because at least I explained what is solid.

11:36.780 --> 11:41.160
I helped users a little bit if they don't understand what to do.

11:41.160 --> 11:47.000
But also, once you are inside of the application, you can export the data, and it will be exported

11:47.000 --> 11:48.000
as JSON-LD.

11:48.000 --> 11:53.000
Later on, when you log in with your solid account, you can import it.

11:53.000 --> 11:59.040
So in this way, I added one way for people who started using it offline to upgrade to

11:59.040 --> 12:00.040
using solid.

12:00.040 --> 12:06.200
And I think this is also important so that they can make it easy, more easy.

12:06.200 --> 12:11.040
The other issue about the page speed, also maybe this was an obvious, but when you do

12:11.040 --> 12:15.560
a request to the movies container that I mentioned, you can get all the tasks in the previous

12:15.560 --> 12:19.140
example, you get a list of movies, right?

12:19.140 --> 12:22.000
But then you only get the idea of the movie.

12:22.000 --> 12:25.600
You don't get all the metadata, like the name and the image and everything.

12:25.600 --> 12:30.240
So if you want to get the movies, then you need to make another request for each of them.

12:30.240 --> 12:32.120
So in the end, this is not great.

12:32.120 --> 12:35.480
You are doing n plus 1 requests, right?

12:35.480 --> 12:38.680
In case you are wondering, why would you get all the movies?

12:38.680 --> 12:42.640
Like why don't you get just the 10 first movies and you do pagination, right?

12:42.640 --> 12:47.680
The point is that I want my application to be snappy and that you can filter things quickly

12:47.680 --> 12:48.880
and it works.

12:48.880 --> 12:53.760
If you have to do HTTP requests every time you do any interaction, it will be very slow,

12:53.760 --> 12:55.800
not just the page reload.

12:55.800 --> 13:00.160
So that's why I wanted to have all the movies in the front end.

13:00.160 --> 13:05.160
And then what happens doing this is that the first time you open the app, you see this.

13:05.160 --> 13:08.840
And depending on how many movies you have, you will be seeing this for a long time, which

13:08.840 --> 13:10.640
is not great, right?

13:10.640 --> 13:15.960
So what I did is that there is a movie cache of the data using index.db.

13:15.960 --> 13:21.640
And this way, the next time I open the application, I can look at the last modified date of each

13:21.640 --> 13:25.040
one of the documents and only request the new ones.

13:25.040 --> 13:26.800
This is a big improvement.

13:26.800 --> 13:30.120
Compared with solid focus, this makes it more usable.

13:30.120 --> 13:35.600
Still, if you have many movies, for example, I have more than 2000, the first time you

13:35.600 --> 13:38.240
open it in a new device, it's not great.

13:38.240 --> 13:42.520
It can still be improved by a little bit, right?

13:42.520 --> 13:45.760
And finally, the thing I mentioned about interoperability.

13:45.760 --> 13:51.440
I don't have time to get into this a lot, but I wrote a blog post called Interoperables

13:51.440 --> 13:52.440
and DPT.

13:52.440 --> 13:56.000
And I think this is actually the most important point of solid.

13:56.000 --> 14:01.440
In the end, if you are using solid and you are making apps, but they are not interoperable,

14:01.440 --> 14:03.720
you will end up in the same scenario we have now.

14:03.720 --> 14:08.720
The power of solid is that you use different applications and they use your data, right?

14:08.720 --> 14:12.280
So I think this is important to have into account.

14:12.280 --> 14:15.560
So for example, which vocabulary would you use?

14:15.560 --> 14:20.600
There are some websites where you can see the vocabularies that are already used, and

14:20.600 --> 14:22.640
you can see which ones are the most popular.

14:22.640 --> 14:26.520
So they are the most likely to be more useful, right?

14:26.520 --> 14:28.520
You can also create your own vocabulary.

14:28.520 --> 14:33.080
If you are doing a new use case, there's nothing wrong with creating your own vocabulary, and

14:33.080 --> 14:38.120
then other people will be able to use it to make other apps, right?

14:38.120 --> 14:43.320
And finally, at the beginning, I wasn't sure about this, but now that I've learned more,

14:43.320 --> 14:46.800
I think mixing and matching vocabularies is actually okay.

14:46.800 --> 14:52.040
So you shouldn't be taken aback by doing this, right?

14:52.040 --> 14:54.920
And then we have solved which vocabulary to use.

14:54.920 --> 14:57.320
The other thing is where do you store data?

14:57.320 --> 15:02.360
For example, if I am storing movies in slash movies, maybe another app can do it in slash

15:02.360 --> 15:03.360
films.

15:03.360 --> 15:06.160
So they will not work correctly together, right?

15:06.160 --> 15:10.960
So the point is that when you log in and you get the identity of the user, you will get

15:10.960 --> 15:15.360
a document describing all its information, all the public information.

15:15.360 --> 15:19.760
And if you are making the request with an authentication token, you also get the private

15:19.760 --> 15:21.160
information.

15:21.160 --> 15:24.720
And some of this information is something called a type index.

15:24.720 --> 15:30.040
And this type index tells you these users have tasks in this container, movies in this

15:30.040 --> 15:32.040
container, et cetera, right?

15:32.040 --> 15:36.400
So once you do that, then you can already use the proper container without hard coding

15:36.400 --> 15:38.800
anything in your application.

15:38.800 --> 15:44.520
If you are the first one adding movies or whatever to a pod, then you can just create

15:44.520 --> 15:47.400
the type index if it doesn't exist.

15:47.400 --> 15:52.840
I have to mention that right now it's a draft, but you can still use it.

15:52.840 --> 15:57.360
And I have been using it for years because it's a client to client standard.

15:57.360 --> 16:01.760
This means that the clients, so the applications, are the only ones that need to know about

16:01.760 --> 16:03.480
this type index.

16:03.480 --> 16:07.080
From the point of view of the pod is there's a simple document, right?

16:07.080 --> 16:08.680
So this is something you can use today.

16:08.680 --> 16:13.720
There is also something else called the solid application interoperability spec, but this

16:13.720 --> 16:16.080
one is a client to server standard.

16:16.080 --> 16:20.160
So until the servers start implementing this, this will not work.

16:20.160 --> 16:25.400
Just to clarify, in case it's not clear, server is the pod, right?

16:25.400 --> 16:26.400
Okay.

16:26.400 --> 16:32.440
So final thing about this app is that if you have all the data in your pod, you will not

16:32.440 --> 16:35.520
have all the movies in existence in your pod.

16:35.520 --> 16:36.960
So how do you make this work?

16:36.960 --> 16:43.120
To have a good user experience so that people can search and get the movie they want, right?

16:43.120 --> 16:47.560
In this case, something that I think is very important to do with solid apps is to rely

16:47.560 --> 16:49.800
on public information.

16:49.800 --> 16:55.880
So in this case, I am using a website called the movie database, which gives you a database

16:55.880 --> 16:58.520
and a free API to query that.

16:58.520 --> 17:04.120
Depending what type of data you are working on, you can search different APIs.

17:04.120 --> 17:06.880
But this is the basic idea.

17:06.880 --> 17:12.240
And if you want to learn more about how I build this app, you can check it out here.

17:12.240 --> 17:13.240
Some takeaways.

17:13.240 --> 17:14.680
Typing the accesses are nice.

17:14.680 --> 17:16.600
I encourage you to use them.

17:16.600 --> 17:18.520
And also catching is nice.

17:18.520 --> 17:20.440
It improves the performance a lot.

17:20.440 --> 17:24.000
So this is something to keep in mind.

17:24.000 --> 17:27.920
Things will still have to improve on board in UX and page speed.

17:27.920 --> 17:30.520
They are still not great, right?

17:30.520 --> 17:32.640
The next application I build is called to my.

17:32.640 --> 17:36.440
I don't want to scare you with the time frame in this.

17:36.440 --> 17:39.920
The thing is that, as I mentioned, this is a type project.

17:39.920 --> 17:41.560
And I don't only work on solid.

17:41.560 --> 17:44.240
I also experiment with different technologies.

17:44.240 --> 17:48.160
And for this one in particular, I started doing some animation things and all that.

17:48.160 --> 17:53.080
So it was entirely solid what made this take so long.

17:53.080 --> 17:57.120
But in any case, Umay is a recipes manager.

17:57.120 --> 18:00.320
So the point is that you have a collection of recipes.

18:00.320 --> 18:02.000
And you can search them and browse them.

18:02.000 --> 18:05.360
So in spirit, it is quite similar to media cracking.

18:05.360 --> 18:07.320
But instead of movies with recipes, right?

18:07.320 --> 18:10.520
This is the basic idea of the app.

18:10.520 --> 18:15.320
So the onboarding UX, at first sight, it may seem very similar to the other ones.

18:15.320 --> 18:17.120
But I think it's a lot better.

18:17.120 --> 18:18.120
Why?

18:18.120 --> 18:21.040
Because this button here says, create your first recipe.

18:21.040 --> 18:23.760
It doesn't say, use browser storage.

18:23.760 --> 18:28.000
And this is important because for people who don't understand how things work, maybe they

18:28.000 --> 18:31.400
are scared, like, what is browser storage?

18:31.400 --> 18:35.520
But if they just create first recipe, they can just go ahead and do it without worrying

18:35.520 --> 18:39.400
about solid or any technical aspects, right?

18:39.400 --> 18:45.640
Then when they start using the application, they can see the status of their data in here.

18:45.640 --> 18:50.960
And what I'm trying to convey to users is the concept of a cloud.

18:50.960 --> 18:55.880
So I still mention solid when they have to log in and create the account and everything.

18:55.880 --> 19:00.360
But I think this way they understand that they have a cloud where the data is stored,

19:00.360 --> 19:01.800
which is using solid.

19:01.800 --> 19:03.560
But they also have the local data.

19:03.560 --> 19:08.600
And I think this type of concept is something maybe they are already familiar with.

19:08.600 --> 19:12.560
And this got me to the realization that the application is offline first.

19:12.560 --> 19:14.560
So that is quite nice.

19:14.560 --> 19:18.920
But there are some issues or some challenges when you are doing an offline first solid

19:18.920 --> 19:19.920
app.

19:19.920 --> 19:26.520
For example, when you need to authenticate with a solid pod, you shouldn't store the

19:26.520 --> 19:29.000
authentication token in the frontend.

19:29.000 --> 19:32.600
And if you want to see the details why, you can read this forum thread.

19:32.600 --> 19:36.840
And also, every time you open the app, you have to redirect to do the authentication.

19:36.840 --> 19:41.280
This is also something that could be improved in the future, but that's how it currently

19:41.280 --> 19:42.280
works.

19:42.280 --> 19:45.960
So the way I have solved this for now is that I have some settings.

19:45.960 --> 19:50.320
And depending on the device you are using, you can reconnect automatically or not.

19:50.320 --> 19:55.160
For example, in my desktop device, I have this with everything automatic because I have

19:55.160 --> 19:57.320
a stable internet connection.

19:57.320 --> 20:00.360
But in my mobile phone, I don't reconnect automatically.

20:00.360 --> 20:03.320
I only synchronize manually whenever I want to.

20:03.320 --> 20:05.880
This is the basic idea.

20:05.880 --> 20:09.560
And the second thing, this will get a bit into the weeds as well.

20:09.560 --> 20:14.440
But imagine you have this delicious ramen recipe in your pod, right?

20:14.440 --> 20:16.240
And you have it in two devices.

20:16.240 --> 20:18.920
You have it safely stored in your solid pod.

20:18.920 --> 20:23.640
And you have a copy in your mobile phone and another copy in your desktop, right?

20:23.640 --> 20:27.760
You change the title of the recipe in your mobile phone, but it's not connected to the

20:27.760 --> 20:28.760
internet.

20:28.760 --> 20:31.520
So the changes stay local for now.

20:31.520 --> 20:34.060
Then you change the description in your desktop device.

20:34.060 --> 20:36.360
This one is connected to the internet.

20:36.360 --> 20:40.720
So you will synchronize with the pod, and you will push the changes.

20:40.720 --> 20:42.080
But now we have an issue.

20:42.080 --> 20:47.840
When the phone finally synchronizes, you will see that it has been updated because you look

20:47.840 --> 20:52.120
at the timestamp of the last update, but you don't know what has changed.

20:52.120 --> 20:57.480
So now you have to decide if you discard the local data or you discard the remote data.

20:57.480 --> 20:59.400
So this is not ideal.

20:59.400 --> 21:03.780
The way I solved this is using something called CRDTs.

21:03.780 --> 21:06.600
You can also read more about the details here.

21:06.600 --> 21:09.440
And in this case, I had to create a vocab for this.

21:09.440 --> 21:10.440
And that's fine.

21:10.440 --> 21:15.000
And I'm mixing both the recipes vocabulary and the CRDT vocabulary.

21:15.000 --> 21:17.520
So let's go through that again.

21:17.520 --> 21:18.520
You do the same thing.

21:18.520 --> 21:20.760
You modify the name in the mobile device.

21:20.760 --> 21:25.880
But this time, you also store the operation in the data.

21:25.880 --> 21:29.960
So not only the change, but also what happened and what time, right?

21:29.960 --> 21:34.240
You do the same in the desktop, you synchronize, and you push the changes.

21:34.240 --> 21:39.160
And then when you synchronize with the mobile phone, you will see that what changed remotely

21:39.160 --> 21:40.880
was only the description.

21:40.880 --> 21:45.840
So in this way, you can pull the changes, and then you push your change without any

21:45.840 --> 21:46.840
conflicts.

21:46.840 --> 21:48.600
And this is a basic idea.

21:48.600 --> 21:52.120
And when you do all this, then you have everything synchronized.

21:52.120 --> 21:57.560
If your head is spinning right now, don't worry, because this is a bit esoteric.

21:57.560 --> 21:59.840
But not all solid applications have to do this.

21:59.840 --> 22:05.040
It's just this is the way I found to make my user experience how I wanted it to be.

22:05.040 --> 22:10.440
But you don't need to do this if you are getting started or want to see how solid works, right?

22:10.440 --> 22:14.640
So something else, and I think this is one of the most interesting things about this

22:14.640 --> 22:21.040
app, is that before I was saying that for movies, for example, you search an API, right?

22:21.040 --> 22:26.000
But if you have to search an API with all the recipes in the world, it doesn't exist.

22:26.000 --> 22:27.720
How does people search recipes?

22:27.720 --> 22:29.880
Or at least how do I search recipes?

22:29.880 --> 22:33.000
I go to a search engine, and I search for the recipe.

22:33.000 --> 22:36.520
So the point is that the data itself is the web.

22:36.520 --> 22:39.360
It's websites that are already there, right?

22:39.360 --> 22:45.480
So the point is that for recipes, when you make a search, most search engines show you

22:45.480 --> 22:47.760
the results, and they know that they are recipes.

22:47.760 --> 22:49.760
This is not just a website for them.

22:49.760 --> 22:51.600
They know these are recipes.

22:51.600 --> 22:55.520
And if you look under the hood, you inspect the source of these websites.

22:55.520 --> 23:00.360
You will see that in the header, they have some data called application LDJson.

23:00.360 --> 23:03.580
And the nice thing is that this is actually semantic data.

23:03.580 --> 23:06.640
So this is what I mentioned way at the beginning.

23:06.640 --> 23:09.520
And many websites are already using this.

23:09.520 --> 23:13.160
Websites that don't even know that solid exists or anything.

23:13.160 --> 23:17.440
So this is very nice because this is one way to leverage the data that already exists in

23:17.440 --> 23:18.480
the wild.

23:18.480 --> 23:23.040
And I think this is a nice way to showcase what the future could look like if solid was

23:23.040 --> 23:27.720
more used and data were more interconnected, right?

23:27.720 --> 23:29.360
So yeah, you just import.

23:29.360 --> 23:32.640
You just put the URL of the website and you import the data.

23:32.640 --> 23:37.240
Unfortunately, because the application lives in the front end, there are course issues.

23:37.240 --> 23:39.680
So you cannot make HTTP requests.

23:39.680 --> 23:42.480
And the way I've solved it for now is to use a proxy.

23:42.480 --> 23:46.440
But depending on the application you do, this will not be an issue because you can also

23:46.440 --> 23:51.040
use the server where you are hosting the app or something.

23:51.040 --> 23:56.840
So yeah, and finally, the last thing to mention is that in this app, I also implemented the

23:56.840 --> 23:58.720
ability to share things.

23:58.720 --> 24:04.600
So by default, when you create data in a solid pod, you should create it private, right?

24:04.600 --> 24:08.120
But you can also change the permissions and make it public.

24:08.120 --> 24:11.600
And this way, you can share this link with other people.

24:11.600 --> 24:16.600
Then if you share this, you can give the link to someone who doesn't even have a solid account

24:16.600 --> 24:22.520
or doesn't even know what solid is, and they will be able to see the data using the URL

24:22.520 --> 24:24.280
of your document.

24:24.280 --> 24:29.880
And something interesting to realize here is that this is not only a URL of my application.

24:29.880 --> 24:32.120
Like with my app, you can share recipes.

24:32.120 --> 24:38.000
No, you are sharing the document URL in the solid pod.

24:38.000 --> 24:42.920
What this means is that visitors don't need a solid account because it's public.

24:42.920 --> 24:48.720
But also that any of you here in this room and anybody can make an application that already

24:48.720 --> 24:54.520
uses this URL because you only have to read the solid document that is following the solid

24:54.520 --> 24:56.000
protocol, right?

24:56.000 --> 25:03.840
So in this way, you can already see how doing data in this way is useful in the end.

25:03.840 --> 25:08.120
And you can learn more here if you want, more of the details.

25:08.120 --> 25:11.120
You can also read more about how I implemented this application.

25:11.120 --> 25:16.240
And if you are curious why it took me three years, this is where you can see why.

25:16.240 --> 25:19.280
And some takeaways is that offline first is really nice.

25:19.280 --> 25:22.960
I think I'm probably going to do it for most of my apps, at least the ones that follow

25:22.960 --> 25:24.920
this schema.

25:24.920 --> 25:25.920
Sharing is caring.

25:25.920 --> 25:31.680
What I mean with this is that hopefully sharing these recipes or using this type of feature

25:31.680 --> 25:37.120
inside of a solid app will show people why solid is useful.

25:37.120 --> 25:41.720
And maybe without even knowing what solid is, they can realize the power of this.

25:41.720 --> 25:46.200
Like, look, someone shared with me this URL and then I use the same URL in another app

25:46.200 --> 25:47.720
and I can get the data.

25:47.720 --> 25:51.720
I think there are very different interactions that we can see here.

25:51.720 --> 25:52.720
And finally, keep it simple.

25:52.720 --> 25:55.320
This is something I always try to remind myself.

25:55.320 --> 26:00.280
I don't always make it, but I think it's important to keep it in mind, especially with solid

26:00.280 --> 26:03.200
because things can get out of hand.

26:03.200 --> 26:08.760
But as I said at the beginning, the basic things get post RDF.

26:08.760 --> 26:09.760
Those are the basics.

26:09.760 --> 26:15.400
And if you have that in mind, I think you can go a long way with solid.

26:15.400 --> 26:16.920
And I still have some challenges.

26:16.920 --> 26:20.920
I cannot give you a solution because this is where I am right now.

26:20.920 --> 26:25.800
So the onboarding, I think it has improved a lot, but still when people want to connect

26:25.800 --> 26:28.660
to the cloud and they see solid, they don't know what that is.

26:28.660 --> 26:30.680
So this is one of the challenges.

26:30.680 --> 26:35.720
And also the course issue, if I want to make frontend applications, this is very difficult

26:35.720 --> 26:36.840
to get around.

26:36.840 --> 26:41.320
So this is some of the challenges I also haven't solved yet.

26:41.320 --> 26:42.320
And that's it.

26:42.320 --> 26:44.760
You can follow my work and use the apps.

26:44.760 --> 26:47.800
And if you have any questions, let me know.

26:47.800 --> 26:48.800
Okay.

26:48.800 --> 27:02.680
Thank you.

27:02.680 --> 27:04.960
It was a wonderful presentation.

27:04.960 --> 27:12.400
I'm wondering when do you think it will be ready to be used in more mature applications?

27:12.400 --> 27:18.280
Because just for example, one thing is that you are taking full control of the pod, meaning

27:18.280 --> 27:22.760
that I would never share with you my credential of the pod so that you would have access to

27:22.760 --> 27:23.760
everything.

27:23.760 --> 27:29.480
And if you have any thoughts about the timeline for that?

27:29.480 --> 27:30.480
Yeah.

27:30.480 --> 27:34.680
So I cannot speak about the timeline because I'm not part of the specification process.

27:34.680 --> 27:39.680
So the answer to this would be when the specification includes some mechanisms to do that.

27:39.680 --> 27:42.720
And they already have it in mind and they aren't working on it.

27:42.720 --> 27:46.600
But I cannot give you any answers about the timeline because I'm not involved in that

27:46.600 --> 27:47.600
process.

27:47.600 --> 27:52.320
So I can tell you that I know what people who use solid that have these type of concerns,

27:52.320 --> 27:55.240
that you have the, they just have different pods.

27:55.240 --> 27:59.120
Like I have a pod for my private or sensitive information.

27:59.120 --> 28:03.920
And I have another pod for my public information, right?

28:03.920 --> 28:09.120
And this is also nice because you can use the same app with different pods.

28:09.120 --> 28:14.880
Like if you are using something for your professional life and then your personal life, you can have

28:14.880 --> 28:17.440
it in different pods and that's okay.

28:17.440 --> 28:20.200
So yeah, that's my opinion on the topic for now.

28:20.200 --> 28:22.720
It's something still being worked on.

28:22.720 --> 28:23.720
Yeah.

28:23.720 --> 28:26.960
Any more questions?

28:26.960 --> 28:28.560
Okay.

28:28.560 --> 28:32.160
Thank you.

28:32.160 --> 28:37.560
Yeah, thank you.

28:37.560 --> 28:43.000
Well it's a bit of a related question, but it's more specific to the type indices.

28:43.000 --> 28:44.000
So I didn't know about that.

28:44.000 --> 28:45.200
I've never used them.

28:45.200 --> 28:49.960
So you're saying that it's part of the spec or soon to be part of?

28:49.960 --> 28:50.960
The point, okay.

28:50.960 --> 28:55.280
The point about type indexes is that they are a different spec made by people who are

28:55.280 --> 29:00.680
working on solid, but it's a client spec, which means is that from the point of view

29:00.680 --> 29:02.880
of the pod is just a document.

29:02.880 --> 29:07.240
So maybe you can call it more a convention than anything else.

29:07.240 --> 29:11.880
And the point is that if people start using this convention, then it will become more

29:11.880 --> 29:14.440
interoperable in the wild, you know?

29:14.440 --> 29:18.520
But it's a convention, you could say, because the pods don't need to implement anything

29:18.520 --> 29:19.720
for this to work.

29:19.720 --> 29:20.760
Yeah, thank you.

29:20.760 --> 29:24.880
And so my question was, and this is where it relates to the previous question, is it,

29:24.880 --> 29:30.360
so I find it very interesting, but isn't it a bit risky to basically grant the apps to

29:30.360 --> 29:34.720
go and mess with the global type indices?

29:34.720 --> 29:39.840
It means you can maybe mess up the type indices with someone else, or I mean, shouldn't it

29:39.840 --> 29:44.280
be the responsibility of the pod provider to build up that type index?

29:44.280 --> 29:48.840
Maybe when it gets into the spec, yes, for example, the solid application interoperability

29:48.840 --> 29:54.840
spec, which is also a draft, it does this type of thing in the side of the pod.

29:54.840 --> 29:58.760
So yeah, there are the thing about solid, as I said at the beginning, is that there

29:58.760 --> 30:03.240
are many ways to do things, because the building blocks are basic, but you can combine them

30:03.240 --> 30:05.400
in many ways, you know?

30:05.400 --> 30:11.720
And the point is that right now, and that's what I'm thinking about when I do this, if

30:11.720 --> 30:17.160
you have to build a solid application today, the type index is your best choice, because

30:17.160 --> 30:21.800
the solid application interoperability requires implementation in the server, and it's not

30:21.800 --> 30:23.160
happening yet.

30:23.160 --> 30:25.040
So you cannot rely on that.

30:25.040 --> 30:27.880
So type indexes are the best thing we have.

30:27.880 --> 30:33.000
You can also choose not to use type indexes, but then it will be even less interoperable.

30:33.000 --> 30:36.000
And to me, it's very important that an app is interoperable.

30:36.000 --> 30:38.480
Yeah, you're welcome.

30:38.480 --> 30:42.000
Yes, hello.

30:42.000 --> 30:43.320
Yes, here.

30:43.320 --> 30:44.320
Okay.

30:44.320 --> 30:50.880
Yeah, so with MediaKraken, we saw that it can be complicated to fetch a lot of movie,

30:50.880 --> 30:56.040
and also it's the same if you want to fetch from different pods, it can be very complex.

30:56.040 --> 31:02.720
I wanted to know what's your feeling about like speed and all that on solid, or do you

31:02.720 --> 31:06.600
think like solid is doomed to be used with really low data app, or do you think it's

31:06.600 --> 31:09.840
possible to have big data with solid?

31:09.840 --> 31:12.360
I think it depends a lot on the use case of the app.

31:12.360 --> 31:19.320
For example, for my apps, even if I had perfect querying APIs, I think I would still use this,

31:19.320 --> 31:23.480
because I found the offline first approach, and I like it a lot.

31:23.480 --> 31:28.280
But eventually, there is something called Spark UL, which means you can run queries

31:28.280 --> 31:29.800
on linked data.

31:29.800 --> 31:32.960
These type of things could get into the specification.

31:32.960 --> 31:39.160
But again, all of these depends on the specification, and I really don't know when it will happen,

31:39.160 --> 31:40.160
or if.

31:40.160 --> 31:44.360
I mean, I know that people working on the spec, they are aware of these issues, and

31:44.360 --> 31:45.720
they are working on this.

31:45.720 --> 31:48.480
But I don't know the timeline, really.

31:48.480 --> 31:54.280
I just can say that for my apps, at least, this use case, that's what I do, offline first.

31:54.280 --> 32:00.120
And even if I had good querying endpoints, probably I wouldn't use them, but I don't

32:00.120 --> 32:01.120
know.

32:01.120 --> 32:03.120
It depends on the implementation.

32:03.120 --> 32:04.640
Yeah, thanks.

32:04.640 --> 32:05.640
Yeah.

32:05.640 --> 32:06.640
Hi.

32:06.640 --> 32:14.400
If you have that offline first mode with a CRDT, is there a way to do it, or there is,

32:14.400 --> 32:18.320
but have you looked into doing it in such a way that someone doesn't need to bring their

32:18.320 --> 32:24.440
own pod, that they can use their own devices and have their devices sync between each other

32:24.440 --> 32:25.440
directly?

32:25.440 --> 32:26.440
Yeah.

32:26.440 --> 32:31.600
So, technically, it would be very easy and very possible because you just have the operations,

32:31.600 --> 32:33.320
and you just have to do it.

32:33.320 --> 32:40.240
Personally, I have not done it in my apps because I'm interested in having easy experiences

32:40.240 --> 32:46.280
for users, and what I am going to tell them if they have to synchronize two devices.

32:46.280 --> 32:49.440
Maybe I can use WebRTC or something like this.

32:49.440 --> 32:52.280
Yes, but I think they are still devices.

32:52.280 --> 32:57.560
I think what they like is the idea of having a cloud, and everything is safe in the cloud.

32:57.560 --> 33:00.080
And this is also what I personally would do.

33:00.080 --> 33:03.960
I don't know if I would want to have only things in devices.

33:03.960 --> 33:07.200
But to answer your question, yes, it would be very easy to do.

33:07.200 --> 33:11.120
I just haven't done it, but it would be very easy.

33:11.120 --> 33:12.120
Yeah.

33:12.120 --> 33:17.680
And by the way, well, all of this is open source, so you are welcome to fork it or ask

33:17.680 --> 33:19.520
me about the code or anything.

33:19.520 --> 33:26.520
I would be happy to help you if you want.

33:26.520 --> 33:33.520
I'll get my exercise.

33:33.520 --> 33:44.400
LDF and linked data exist for so long, and we don't see a lot of open source project

33:44.400 --> 33:50.880
unleashing the potential of such a system.

33:50.880 --> 33:55.320
Why do you think it's not more mainstream?

33:55.320 --> 34:01.040
And do you think there is enough learning material that are easy to understand for developers?

34:01.040 --> 34:02.040
Yeah.

34:02.040 --> 34:04.800
So I cannot answer for everybody, because I don't know.

34:04.800 --> 34:09.720
But my personal opinion is that in theory, RDF is awesome.

34:09.720 --> 34:10.720
I like it a lot.

34:10.720 --> 34:12.720
And this is why I am working on this.

34:12.720 --> 34:17.360
But in practice, the developer experience is not great.

34:17.360 --> 34:22.720
And people, when they see TARTELL and RDF and all these things, they don't like it.

34:22.720 --> 34:29.040
So my opinion is that it's because of lack of learning materials and the developer experience

34:29.040 --> 34:30.600
to get started.

34:30.600 --> 34:31.600
But I don't know.

34:31.600 --> 34:36.320
I think if you learn the building blocks, because I learned about RDF four years ago

34:36.320 --> 34:37.640
when I learned about Solit.

34:37.640 --> 34:40.520
I didn't even know about the semantic web.

34:40.520 --> 34:45.840
But I learned the basic things, like the specs I linked at the beginning, RDF, and all of

34:45.840 --> 34:46.840
this.

34:46.840 --> 34:52.560
And I think once you understand those basic things, it's very easy to work with, I think.

34:52.560 --> 34:53.560
But I don't know.

34:53.560 --> 34:54.560
It depends on that.

34:54.560 --> 34:58.440
And there are not a lot of learning materials that I know of.

34:58.440 --> 35:03.080
And there is not one framework you can use that is super easy, has a very nice developer

35:03.080 --> 35:04.760
experience.

35:04.760 --> 35:09.220
So I think it's still a thing of tooling and documentation at this point.

35:09.220 --> 35:10.680
But this is my personal opinion.

35:10.680 --> 35:14.040
I can't speak for what people that I don't know.

35:14.040 --> 35:15.040
Yeah.

35:15.040 --> 35:19.080
Can you just tell me about when you stored the pod on a...

35:19.080 --> 35:24.320
I just did a quick read of the actual FAQs on the Solit website.

35:24.320 --> 35:29.800
And it seems to be a lot of the details of how the pod providers store the data up to

35:29.800 --> 35:33.620
the providers so that options such as encryption is left to them.

35:33.620 --> 35:36.200
So that seems to move a lot of the privacy concerns.

35:36.200 --> 35:41.760
We have existing cloud services to the pod providers unless you self-housed on a server

35:41.760 --> 35:43.480
that you encrypt yourself and such.

35:43.480 --> 35:51.000
So do you have any thoughts on that, on how that works with the provider escape at that

35:51.000 --> 35:52.000
moment?

35:52.000 --> 35:53.000
Yeah.

35:53.000 --> 35:59.400
So the point is, so the biggest issue today for someone to start using Solit is which

35:59.400 --> 36:01.280
pod provider to use, basically.

36:01.280 --> 36:06.160
If I have to recommend a friend of mine to use Solit, I don't even know what the provider

36:06.160 --> 36:08.080
that I would recommend them.

36:08.080 --> 36:11.760
But I like the point that users choose.

36:11.760 --> 36:16.760
And if you are super worried about privacy and you want everything super encrypted and

36:16.760 --> 36:21.000
everything, then you choose a pod provider that encrypts everything.

36:21.000 --> 36:23.640
But if you don't care so much, then you don't have to.

36:23.640 --> 36:26.740
You just self-host something in your home.

36:26.740 --> 36:27.740
So I don't know.

36:27.740 --> 36:31.120
I think this is part of the flexibility of Solit.

36:31.120 --> 36:34.960
So it's nice that it's the choice of the user.

36:34.960 --> 36:37.520
But I don't have many thoughts about that.

36:37.520 --> 36:41.760
Personally, I self-host and I don't mind about encryption.

36:41.760 --> 36:42.760
Yeah.

36:42.760 --> 36:47.920
I'd like to ask you how to find vocabularies.

36:47.920 --> 36:53.360
Because I know there are a lot of vocabularies, but it's quite a chaos.

36:53.360 --> 36:57.880
They are very difficult to find and to understand what the world's like.

36:57.880 --> 37:00.960
So at first, I also worried a lot about this.

37:00.960 --> 37:05.360
But now it's like the list of my problems, because really, you just search if there is

37:05.360 --> 37:07.200
one that already exists.

37:07.200 --> 37:12.080
Like in this website I shared, there is a website with a lot of vocabularies.

37:12.080 --> 37:13.240
Just search one.

37:13.240 --> 37:18.240
And if you don't find one that works for you, you create your own.

37:18.240 --> 37:20.000
And it's not so difficult.

37:20.000 --> 37:22.240
I think it's...

37:22.240 --> 37:24.660
At first, I understand how it's confusing.

37:24.660 --> 37:30.000
But once you decide that you can make your own vocabulary, it's not so difficult.

37:30.000 --> 37:34.720
So I recommend a lot this tall guy link called Bag of Chips.

37:34.720 --> 37:37.280
This is the one that changed my mind about this.

37:37.280 --> 37:40.880
That it's fine to mix vocabularies and make your own.

37:40.880 --> 37:43.280
So I recommend watching that.

37:43.280 --> 37:44.280
Yeah.

37:44.280 --> 37:45.280
Someone else?

37:45.280 --> 37:46.280
Yeah.

37:46.280 --> 37:53.560
Given that you've got different pod providers and you can never be sure what the infrastructure

37:53.560 --> 37:55.680
that you're working with is going to be like.

37:55.680 --> 37:58.460
It could be a very slow pod provider or whatever.

37:58.460 --> 38:01.720
Do you have to design your apps quite defensively?

38:01.720 --> 38:05.880
Because you can never be sure that actually the pod provider is actually going to be able

38:05.880 --> 38:09.960
to service the HTTP request that you want to make.

38:09.960 --> 38:11.080
Yeah.

38:11.080 --> 38:15.240
My answer to that is that no, because you just follow the solid protocol.

38:15.240 --> 38:16.240
And that's it.

38:16.240 --> 38:21.280
I mean, if the pod provider is slow, users will be unhappy and they will use another

38:21.280 --> 38:22.600
pod provider.

38:22.600 --> 38:23.760
So I don't worry about that.

38:23.760 --> 38:26.920
I just code to the solid spec.

38:26.920 --> 38:28.760
And I don't mind about that.

38:28.760 --> 38:33.080
The only thing is things that are not in the spec yet and they are drafts and different

38:33.080 --> 38:35.400
pod providers implement differently.

38:35.400 --> 38:40.200
But hopefully when the spec is more stable, this will not be an issue.

38:40.200 --> 38:41.520
Hi.

38:41.520 --> 38:43.680
Thanks for the great presentation.

38:43.680 --> 38:48.240
All your examples were single user applications.

38:48.240 --> 38:53.520
How would you apply the philosophy of solid to, let's say, for example, forum software?

38:53.520 --> 38:54.520
Yeah.

38:54.520 --> 38:58.800
Would you either store all posts from all users in their own pods and somehow get access

38:58.800 --> 38:59.800
to all those pods?

38:59.800 --> 39:05.360
Or would you just not use it for that and just use it, for example, for public information

39:05.360 --> 39:06.360
on the user?

39:06.360 --> 39:07.360
Yeah.

39:07.360 --> 39:08.920
So I haven't done anything about that.

39:08.920 --> 39:11.800
So I'm only going to say what I think about it.

39:11.800 --> 39:15.840
But basically my intuition tells me that it would be something very similar to Activity

39:15.840 --> 39:20.400
Pap, which is the protocol that powers Mastodon and the Freddyverse.

39:20.400 --> 39:23.380
And underneath it, it also uses linked data.

39:23.380 --> 39:27.080
So I think it would be very similar to that, the way it works.

39:27.080 --> 39:28.920
And I don't know exactly how it works.

39:28.920 --> 39:31.840
I have not coded Activity App applications.

39:31.840 --> 39:36.720
But I think the information is duplicated in the servers or something.

39:36.720 --> 39:38.880
I guess it would be something like that.

39:38.880 --> 39:39.880
I don't know.

39:39.880 --> 39:44.400
But I think my answer to thinking about social applications with solid is look at Activity

39:44.400 --> 39:52.160
Pap because it's the same idea, I think, or similar at least.

39:52.160 --> 39:57.400
Just as an FYI, there's also an active discussion going on in the matrix room associated with

39:57.400 --> 39:58.400
the staff room.

39:58.400 --> 39:59.400
So you might want to look there.

39:59.400 --> 40:00.400
There's also the data.

40:00.400 --> 40:02.400
I will take a look and answer.

40:02.400 --> 40:06.080
Also, you guys might want to check it out.

40:06.080 --> 40:07.080
Yeah.

40:07.080 --> 40:08.880
Well, so that's it, I guess.

40:08.880 --> 40:09.880
Thank you, everybody.

40:09.880 --> 40:10.880
Okay.

40:10.880 --> 40:11.880
Come on.

40:11.880 --> 40:27.760
Let me see.
