1
0:00:00.000 --> 0:00:08.200
Our next talk is by Stefan.

2
0:00:08.200 --> 0:00:14.280
He's the project leader for LexD, a container manager, former teammate of mine as well.

3
0:00:14.280 --> 0:00:18.400
And he's going to talk about safe containers through system call interception.

4
0:00:18.400 --> 0:00:19.400
Hello.

5
0:00:19.400 --> 0:00:21.120
Is that working well?

6
0:00:21.120 --> 0:00:22.120
Think so.

7
0:00:22.120 --> 0:00:23.120
All right.

8
0:00:23.120 --> 0:00:24.360
So you kind of did the intro.

9
0:00:24.360 --> 0:00:25.360
I'm Stefan.

10
0:00:25.360 --> 0:00:26.360
I work at Canonical.

11
0:00:26.360 --> 0:00:31.960
I'm the project leader for LexD, LexC, LexCFS and a bunch of other stuff that we do.

12
0:00:31.960 --> 0:00:33.960
Effectively, system container guy.

13
0:00:33.960 --> 0:00:37.960
And yeah, we're going to be talking about system call interception today.

14
0:00:37.960 --> 0:00:42.880
First, just a tiny bit of going back to the basics.

15
0:00:42.880 --> 0:00:47.120
We kind of need to explain what we're trying to achieve.

16
0:00:47.120 --> 0:00:49.280
So there are two main kind of containers out there.

17
0:00:49.280 --> 0:00:52.480
We've got privileged containers and unprivileged containers.

18
0:00:52.480 --> 0:00:55.560
The ones you want are the unprivileged kind.

19
0:00:55.560 --> 0:00:56.560
Privileged is bad.

20
0:00:56.560 --> 0:01:02.920
And just to clarify there, too, we don't mean privileged as in dash dash privileged in Docker.

21
0:01:02.920 --> 0:01:05.040
That's extra, extra bad.

22
0:01:05.040 --> 0:01:06.880
Docker by default is privileged.

23
0:01:06.880 --> 0:01:11.120
And the definition of privileged is whether you're using a user namespace or not.

24
0:01:11.120 --> 0:01:15.560
So in the case of LexD, which is a container manager that I'm working on these days, we

25
0:01:15.560 --> 0:01:17.840
default to unprivileged containers.

26
0:01:17.840 --> 0:01:18.840
That's great.

27
0:01:18.840 --> 0:01:20.920
It means that root in the container is not root on the host.

28
0:01:20.920 --> 0:01:25.480
If there's a container escape of any kind, you don't you get as much permission as nobody

29
0:01:25.480 --> 0:01:27.120
uses on the system.

30
0:01:27.120 --> 0:01:28.400
That's great.

31
0:01:28.400 --> 0:01:35.040
Problem is not being real root also means you don't get to do stuff that real root can

32
0:01:35.040 --> 0:01:36.040
do.

33
0:01:36.040 --> 0:01:40.400
A lot of stuff have been enabled now inside the user namespace that you can do yourself.

34
0:01:40.400 --> 0:01:41.600
You can create a lot of devices.

35
0:01:41.600 --> 0:01:43.200
You can reconfigure a lot of stuff.

36
0:01:43.200 --> 0:01:44.200
It's great.

37
0:01:44.200 --> 0:01:45.920
But there are still things you can't do.

38
0:01:45.920 --> 0:01:49.760
You can't change your process priority to something higher than what you would be allowed

39
0:01:49.760 --> 0:01:51.760
to do as a normal user on the system.

40
0:01:51.760 --> 0:01:56.360
Anyone can create a new user namespace, go in it and bump their process priority to whatever

41
0:01:56.360 --> 0:02:00.360
they want and bypass all kind of settings on the system.

42
0:02:00.360 --> 0:02:04.000
So there's a lot of things that are not quite possible.

43
0:02:04.000 --> 0:02:08.000
In general, we want to eradicate privileged containers because having real root is very,

44
0:02:08.000 --> 0:02:09.000
very bad.

45
0:02:09.000 --> 0:02:14.920
And it's kind of a game of, like, whack-a-mole as far as trying to prevent nasty things from

46
0:02:14.920 --> 0:02:15.920
happening.

47
0:02:15.920 --> 0:02:19.060
We've got Appama, we've got SecComp, we've got a whole bunch of things that are all trying

48
0:02:19.060 --> 0:02:23.080
to prevent you from doing bad things, but that's done by us thinking about what all

49
0:02:23.080 --> 0:02:25.600
the bad things are and trying to block them.

50
0:02:25.600 --> 0:02:29.040
And someone just needs to find another bad thing we didn't think of, and then there goes

51
0:02:29.040 --> 0:02:30.040
the entire system.

52
0:02:30.040 --> 0:02:31.040
So we don't want those.

53
0:02:31.040 --> 0:02:33.440
We'd like to get rid of them completely.

54
0:02:33.440 --> 0:02:38.400
But for that, we need to find ways to allow for unprivileged environments to do things

55
0:02:38.400 --> 0:02:43.440
that are normally only allowed to be done by privileged environments in a way that's

56
0:02:43.440 --> 0:02:45.440
still safe.

57
0:02:45.440 --> 0:02:47.720
All right.

58
0:02:47.720 --> 0:02:53.720
All I'm going to be talking about today relies on SecComp, which is the system code interception

59
0:02:53.720 --> 0:02:55.880
mechanism in Linux.

60
0:02:55.880 --> 0:02:59.520
It lets you do a bunch of nice policies.

61
0:02:59.520 --> 0:03:03.480
You can just put policies for, like, this system code with those arguments, just deny

62
0:03:03.480 --> 0:03:11.000
them or return this return code or return, yeah, this particular error number, for example.

63
0:03:11.000 --> 0:03:18.440
But it also grew the ability with Linux 5.0 in 2019, it grew the ability to notify userspace

64
0:03:18.440 --> 0:03:19.440
instead.

65
0:03:19.440 --> 0:03:26.440
So you can put a policy in SecComp that says if this is code and the arguments are so and

66
0:03:26.440 --> 0:03:34.080
so, instead of taking an action right now, go and notify the spider descriptor that something

67
0:03:34.080 --> 0:03:35.080
happened.

68
0:03:35.080 --> 0:03:40.120
And then the whole system can have a privileged daemon monitoring that notification mechanism

69
0:03:40.120 --> 0:03:42.120
and take actions.

70
0:03:42.120 --> 0:03:47.800
There is some complexity around security that I'm going to get into very shortly because

71
0:03:47.800 --> 0:03:50.360
you can do very, very bad things with that.

72
0:03:50.360 --> 0:03:56.880
But if you do it correctly, it lets you run a more privileged action on behalf of a less

73
0:03:56.880 --> 0:04:02.640
privileged container after going through some kind of analysis or that kind of logic on

74
0:04:02.640 --> 0:04:07.320
the host to make sure that this is actually fine.

75
0:04:07.320 --> 0:04:15.120
Now for the nasty issues, time of check, time of use is a very, very common issue in security.

76
0:04:15.120 --> 0:04:20.680
And this mechanism has definitely got some issues around that.

77
0:04:20.680 --> 0:04:24.400
Userspace gets notified that a system code was made.

78
0:04:24.400 --> 0:04:30.480
The system code can have pointers to a bunch of different arguments and structures.

79
0:04:30.480 --> 0:04:35.160
And there's nothing preventing the caller from technically changing the value at those

80
0:04:35.160 --> 0:04:36.160
pointers.

81
0:04:36.160 --> 0:04:38.960
So you need to be a bit careful when you're processing those messages.

82
0:04:38.960 --> 0:04:43.400
You effectively need to start by copying everything, evaluating it.

83
0:04:43.400 --> 0:04:45.640
If everything looks good, then you can take actions.

84
0:04:45.640 --> 0:04:50.160
But by taking actions, we mean you can run the thing on behalf of the user with the original

85
0:04:50.160 --> 0:04:55.800
arguments, never putting them again because otherwise they could change.

86
0:04:55.800 --> 0:05:00.080
Or you could just say, I don't want this reject.

87
0:05:00.080 --> 0:05:05.320
What you shouldn't do is say, oh, based on those arguments, it seems fine.

88
0:05:05.320 --> 0:05:06.920
And it continues.

89
0:05:06.920 --> 0:05:10.560
Because there's absolutely nothing that prevents the caller process from just racing you and

90
0:05:10.560 --> 0:05:14.120
immediately changing the arguments to something else before it goes back to the kernel and

91
0:05:14.120 --> 0:05:17.800
then running with a value you would not have allowed.

92
0:05:17.800 --> 0:05:21.280
So you need to be careful in your design so that this doesn't happen.

93
0:05:21.280 --> 0:05:25.960
Otherwise you're literally allowing people to run stuff as full-root privilege inside

94
0:05:25.960 --> 0:05:29.720
of continuous containers, which would be very bad.

95
0:05:29.720 --> 0:05:34.640
So what do we actually do with this stuff?

96
0:05:34.640 --> 0:05:36.400
So far we've implemented quite a few things.

97
0:05:36.400 --> 0:05:40.240
And I'm going to go into more details about each of those.

98
0:05:40.240 --> 0:05:44.680
The first thing we implemented actually, I don't know if you're on the right order.

99
0:05:44.680 --> 0:05:48.480
One of the first things we implemented is make node.

100
0:05:48.480 --> 0:05:51.760
Then we followed that, which is useful for save device node creation.

101
0:05:51.760 --> 0:05:54.200
I'm going to go into more detail shortly.

102
0:05:54.200 --> 0:05:57.360
SetXAdder we also added pretty early on.

103
0:05:57.360 --> 0:06:02.040
We've got support for eBPF so we can allow some specific eBPF programs.

104
0:06:02.040 --> 0:06:07.600
We've got support for set scheduler, which is used to change some of the process priorities.

105
0:06:07.600 --> 0:06:11.840
We've got support for mount, which was a real pain in the ass to implement, but we've got

106
0:06:11.840 --> 0:06:12.840
support for mount.

107
0:06:12.840 --> 0:06:19.800
And we've got support for sysinfo, which was also reasonably fun to implement.

108
0:06:19.800 --> 0:06:26.160
Now kind of going over those things directly, make nodes, what do we use that for?

109
0:06:26.160 --> 0:06:32.320
Well, one of the things we wanted to enable is for running docker inside of LexD containers.

110
0:06:32.320 --> 0:06:35.640
I said LexD containers are on privilege, they are nice and safe.

111
0:06:35.640 --> 0:06:38.720
Docker by and large not safe.

112
0:06:38.720 --> 0:06:42.560
But docker running inside of a privilege LexD container safe.

113
0:06:42.560 --> 0:06:44.760
So we figured we'd try and make that work.

114
0:06:44.760 --> 0:06:47.160
And we did manage to get it working.

115
0:06:47.160 --> 0:06:50.640
The main driver at the time was Travis CI.

116
0:06:50.640 --> 0:06:57.920
The Travis CI platform was using LexD containers on M64, IBM, Z series, as well as IBM power

117
0:06:57.920 --> 0:06:59.320
at the time.

118
0:06:59.320 --> 0:07:03.200
And they wanted the same behavior as they were getting on Intel.

119
0:07:03.200 --> 0:07:08.200
And on Intel, they were using full VMs that you could do whatever you wanted.

120
0:07:08.200 --> 0:07:10.600
So we wanted to make sure that docker worked properly in there.

121
0:07:10.600 --> 0:07:15.400
And what we noticed is that docker layers, especially the directory whiteout files and

122
0:07:15.400 --> 0:07:24.240
five whiteout files, rely on either I think it's C 00 device nodes, or they rely on specific

123
0:07:24.240 --> 0:07:29.200
excellent attributes that just say that this is like a directory that was removed effectively

124
0:07:29.200 --> 0:07:32.600
in D&L A using that as whiteout.

125
0:07:32.600 --> 0:07:34.400
Both cases, those things were not allowed.

126
0:07:34.400 --> 0:07:37.680
Device creation in a container is a big, big, big no-go usually.

127
0:07:37.680 --> 0:07:42.480
Because if you can create, say, the device node for DevSDA, then there's nothing preventing

128
0:07:42.480 --> 0:07:46.520
your previous container from rewriting your disk, which would be bad.

129
0:07:46.520 --> 0:07:48.160
So that's usually not allowed.

130
0:07:48.160 --> 0:07:50.720
But some specific device nodes are fine.

131
0:07:50.720 --> 0:07:55.600
And the work we did there also allows for things like creating a new dev null device

132
0:07:55.600 --> 0:08:01.160
or new dev zero device or those kind of devices which are inherently safe.

133
0:08:01.160 --> 0:08:05.000
And making that possible means that you can now do things like running the bootstrap or

134
0:08:05.000 --> 0:08:08.200
similar tools inside of an unprivileged container.

135
0:08:08.200 --> 0:08:12.720
Those are the few devices that are needed to be created as part of an image creation

136
0:08:12.720 --> 0:08:15.680
process are safe devices, and this allows it.

137
0:08:15.680 --> 0:08:20.080
We generally consider this particular interception to be safe, as in you can pretty much turn

138
0:08:20.080 --> 0:08:26.600
it on on any LexD container without having to think too much about who's in that container,

139
0:08:26.600 --> 0:08:30.280
like do we actually trust the workloads and all that kind of stuff.

140
0:08:30.280 --> 0:08:36.360
The other piece to that puzzle was SetX

141
0:08:36.360 --> 0:08:38.360
other.

142
0:08:38.360 --> 0:08:41.080
It does not allow all of SetX other.

143
0:08:41.080 --> 0:08:46.560
It just allows very safe namespaces of extended attributes.

144
0:08:46.560 --> 0:08:50.640
It will not let you do things like setting a security attribute, because that would let

145
0:08:50.640 --> 0:08:53.520
you do some really, really bad things, for example.

146
0:08:53.520 --> 0:08:57.920
And this is similarly considered to be safe on our side.

147
0:08:57.920 --> 0:09:02.760
Then go to the pretty interesting one, mount.

148
0:09:02.760 --> 0:09:10.320
So again, mount is a bit of a problem, because usually, well, for the whole, usually it relies

149
0:09:10.320 --> 0:09:11.520
on having a block device.

150
0:09:11.520 --> 0:09:16.120
You kind of need to have that allowed in the container, which is already a bit fishy in

151
0:09:16.120 --> 0:09:17.120
many cases.

152
0:09:17.120 --> 0:09:21.440
You've got to be careful that any block device you expose to the container you consider as

153
0:09:21.440 --> 0:09:25.560
untrusted from that point on, and you never mount it as real roots somewhere else, or

154
0:09:25.560 --> 0:09:27.280
they could try and attack you.

155
0:09:27.280 --> 0:09:33.440
And by attack you, what I mean is the kernel has a superblock parser that will process

156
0:09:33.440 --> 0:09:38.560
a new device as it gets mounted, and this is not guaranteed to be bug free.

157
0:09:38.560 --> 0:09:45.440
So a user that can craft a very specific block device might be able to trick something like

158
0:09:45.440 --> 0:09:51.000
X4, XFS, BarFS, or any of the other file systems into either crashing into your system or doing

159
0:09:51.000 --> 0:09:53.000
arbitrary code execution in the kernel.

160
0:09:53.000 --> 0:09:55.760
Both cases not very good.

161
0:09:55.760 --> 0:09:59.640
But we still enable support for that.

162
0:09:59.640 --> 0:10:05.120
If you have a container that you trust, that you don't want to give full access for everything,

163
0:10:05.120 --> 0:10:15.240
but that you still trust, you can technically do this, and it will let you mount inside

164
0:10:15.240 --> 0:10:16.480
of the container.

165
0:10:16.480 --> 0:10:20.800
We added an extra layer on top of that, which lets us do a shift.

166
0:10:20.800 --> 0:10:25.080
Because if you do the mount, the ownership information on that device is probably not

167
0:10:25.080 --> 0:10:26.560
landing at your container.

168
0:10:26.560 --> 0:10:33.240
So we allow stacking shiftFS, which is hopefully lying soon, but that we implemented for Ubuntu

169
0:10:33.240 --> 0:10:36.320
on Ubuntu that we can stack on top and that fixes the permissions.

170
0:10:36.320 --> 0:10:38.200
So we support that as well.

171
0:10:38.200 --> 0:10:42.840
The really cool thing with this stuff is we also support redirecting to fuse instead,

172
0:10:42.840 --> 0:10:44.560
which then becomes safe.

173
0:10:44.560 --> 0:10:50.080
So what we can do is say, any attempt at mounting ext4 inside of the container, call the fuse2fs

174
0:10:50.080 --> 0:10:51.800
binary instead.

175
0:10:51.800 --> 0:10:56.480
And yeah, that's safe, that actually does work pretty well.

176
0:10:56.480 --> 0:10:59.240
And I'll show that in just a tiny bit.

177
0:10:59.240 --> 0:11:04.400
And then we worked on the BPF, not allowing all of the BPF programs, but specifically allowing

178
0:11:04.400 --> 0:11:09.400
those that we need to do nested containers and doing device permission management through

179
0:11:09.400 --> 0:11:10.400
that.

180
0:11:10.400 --> 0:11:13.880
So we can review what the program is, if it matches what we expect, then we load it.

181
0:11:13.880 --> 0:11:15.680
Otherwise, we just reject entirely.

182
0:11:15.680 --> 0:11:18.520
And it's also considered to be safe.

183
0:11:18.520 --> 0:11:23.480
Then for an unsafe one, a sched set scheduler is not super duper safe because it lets you

184
0:11:23.480 --> 0:11:25.440
reconfigure scheduler options.

185
0:11:25.440 --> 0:11:45.520
It was needed to be able to run Android inside of a Np

186
0:11:45.520 --> 0:11:50.360
or a Lp, by enabling this thing, but there's definitely some ability to affect the entire

187
0:11:50.360 --> 0:11:52.480
system.

188
0:11:52.480 --> 0:11:53.480
And then we had sysinfo.

189
0:11:53.480 --> 0:11:59.220
That was kind of led by Alpine deciding not to use ProkMEM info to figure out the memory

190
0:11:59.220 --> 0:12:01.600
usage in the free command.

191
0:12:01.600 --> 0:12:05.180
So you would run a container with a limit of, like, a gig of RAM and run free.

192
0:12:05.180 --> 0:12:09.180
And you would see 128 gigs, because it will just show you the host value directly.

193
0:12:09.180 --> 0:12:13.040
And that's because the ones you look, like CFS, which is another project we ran, that

194
0:12:13.040 --> 0:12:15.780
overlays on top of proc to show the right values,

195
0:12:15.780 --> 0:12:17.740
they don't work because they were not reading

196
0:12:17.740 --> 0:12:19.540
the file system, they were going straight to the kernel

197
0:12:19.540 --> 0:12:22.180
with a system call using CS info.

198
0:12:22.180 --> 0:12:23.940
So we've implemented Interception for that

199
0:12:23.940 --> 0:12:25.580
and we've fitted with the same values

200
0:12:25.580 --> 0:12:27.820
as you would be getting from Lex CFS

201
0:12:27.820 --> 0:12:29.620
and that gets us the right behavior.

202
0:12:31.140 --> 0:12:34.780
And so just switching to the demo,

203
0:12:34.780 --> 0:12:38.460
also just rechecking something here real quick.

204
0:12:41.500 --> 0:12:42.920
Okay, just making sure that Christian was wrong

205
0:12:42.920 --> 0:12:44.820
with the time, it's good.

206
0:12:44.820 --> 0:12:47.420
I've got until three, you showed me at 10 minutes.

207
0:12:47.420 --> 0:12:52.420
All right, so let's just move here to the terminal

208
0:12:56.720 --> 0:12:59.700
and the first thing I'll do is play with make node.

209
0:12:59.700 --> 0:13:02.780
So, and that should be, yep, looks all right.

210
0:13:03.820 --> 0:13:08.500
Just launching a new container Ubuntu 22.04

211
0:13:08.500 --> 0:13:13.500
and let's try make node,

212
0:13:15.060 --> 0:13:16.500
just remember the other of the arguments,

213
0:13:16.500 --> 0:13:18.100
I'm sure I'm getting those wrong again

214
0:13:18.100 --> 0:13:19.600
because I always get them wrong.

215
0:13:22.500 --> 0:13:24.860
Make node named and type, yeah.

216
0:13:24.860 --> 0:13:26.900
Depending on the kernel, this might work.

217
0:13:28.380 --> 0:13:29.980
Yeah, it actually does work now.

218
0:13:30.940 --> 0:13:34.500
Let me figure out dev no, this one shouldn't work.

219
0:13:34.500 --> 0:13:35.340
One is three.

220
0:13:35.340 --> 0:13:36.500
C5 one.

221
0:13:36.500 --> 0:13:38.740
Yeah, C1 three, for example, for dev no,

222
0:13:38.740 --> 0:13:40.740
does not work out of the box.

223
0:13:40.740 --> 0:13:43.300
But if we stop this,

224
0:13:47.380 --> 0:13:52.380
then set demo make node security calls,

225
0:13:54.700 --> 0:13:57.260
intercept make node true.

226
0:13:58.660 --> 0:14:00.340
In this case, we do need to restart the container

227
0:14:00.340 --> 0:14:02.500
because the entire second policy needs to change.

228
0:14:02.500 --> 0:14:04.140
For smaller changes, we don't need to,

229
0:14:04.140 --> 0:14:06.620
for that we do, and now that works properly.

230
0:14:09.180 --> 0:14:11.460
So that's the make node piece.

231
0:14:11.460 --> 0:14:12.660
Then we've got docker.

232
0:14:12.660 --> 0:14:14.900
For that one, I did prepare ahead a tiny bit

233
0:14:14.900 --> 0:14:17.400
because I did not feel like downloading docker

234
0:14:17.400 --> 0:14:18.740
on the wifi here.

235
0:14:18.740 --> 0:14:20.380
I mean, actually I did, but it took an hour,

236
0:14:20.380 --> 0:14:22.380
so I'm happy I didn't do it during the talk.

237
0:14:23.740 --> 0:14:26.980
So for docker, actually let me show you the config first.

238
0:14:26.980 --> 0:14:30.460
So the container here has security nesting enabled,

239
0:14:30.460 --> 0:14:32.540
which allows for running containers in containers,

240
0:14:32.540 --> 0:14:35.460
and it has intercept of both make node and setXR

241
0:14:35.460 --> 0:14:38.020
that are set up.

242
0:14:38.020 --> 0:14:43.020
And in there, that part does use the network,

243
0:14:43.140 --> 0:14:45.180
so I'm just hoping that's tiny enough.

244
0:14:45.180 --> 0:14:46.540
There we go.

245
0:14:46.540 --> 0:14:48.220
So that works properly.

246
0:14:48.220 --> 0:14:50.260
And the issue before was that unpacking the layers

247
0:14:50.260 --> 0:14:51.260
would just blow up.

248
0:14:52.980 --> 0:14:55.340
All right, so that was docker.

249
0:14:55.340 --> 0:15:00.340
Then to the more, to the fancier one,

250
0:15:00.340 --> 0:15:02.060
which is mount.

251
0:15:03.940 --> 0:15:08.460
All right, so for mount, launch the container here.

252
0:15:08.460 --> 0:15:10.860
I'm gonna go and pass it a block device,

253
0:15:10.860 --> 0:15:13.220
so I'm passing it dev loop 11 on my system

254
0:15:13.220 --> 0:15:15.100
as dev sda inside of the container.

255
0:15:17.540 --> 0:15:19.140
Yeah, your signs are still wrong.

256
0:15:20.500 --> 0:15:21.340
I've got 15.

257
0:15:22.540 --> 0:15:24.180
I mean, it's until three.

258
0:15:25.020 --> 0:15:25.860
Okay.

259
0:15:25.860 --> 0:15:30.860
So demo mount, makefs, ext4, and dev sda.

260
0:15:36.060 --> 0:15:37.340
Is it capital F?

261
0:15:37.340 --> 0:15:38.460
Yes, okay.

262
0:15:38.460 --> 0:15:40.620
So just formatting, that you can always do.

263
0:15:40.620 --> 0:15:42.460
There's nothing preventing you from creating a file system.

264
0:15:42.460 --> 0:15:44.220
Normally, that works just fine.

265
0:15:44.220 --> 0:15:46.340
What doesn't work is this.

266
0:15:46.340 --> 0:15:47.620
You're not allowed to actually mount it

267
0:15:47.620 --> 0:15:49.460
inside of a container.

268
0:15:49.460 --> 0:15:52.500
But now we can make that work, actually.

269
0:15:52.500 --> 0:15:54.620
So what we're gonna be doing here

270
0:15:54.620 --> 0:15:58.540
is turning on mount interception.

271
0:15:59.980 --> 0:16:03.580
And then we need to set an extra one,

272
0:16:03.580 --> 0:16:05.540
which is the one allowing specific file systems.

273
0:16:05.540 --> 0:16:07.860
So in this case, ext4.

274
0:16:07.860 --> 0:16:11.340
And then restarting the container here.

275
0:16:12.780 --> 0:16:14.380
Okay.

276
0:16:14.380 --> 0:16:17.140
Exec back in there and try mounting again.

277
0:16:17.140 --> 0:16:17.980
And that works.

278
0:16:19.180 --> 0:16:23.020
And if we look at, oops, just nls,

279
0:16:23.020 --> 0:16:24.780
and we look at the F, it's mounted.

280
0:16:24.780 --> 0:16:26.580
Normally, it's fine.

281
0:16:26.580 --> 0:16:28.380
Other than it actually did this at real root,

282
0:16:28.380 --> 0:16:30.460
and I could have done very nasty things

283
0:16:30.460 --> 0:16:33.020
by crafting that particular device ahead of time.

284
0:16:33.020 --> 0:16:34.300
It works as expected.

285
0:16:35.820 --> 0:16:38.780
Now, what we can do to make things

286
0:16:38.780 --> 0:16:41.140
a bit more interesting here,

287
0:16:41.140 --> 0:16:43.420
actually, let me get back in there.

288
0:16:43.420 --> 0:16:48.300
Let's unmount it and then install fuse2fs.

289
0:16:48.300 --> 0:16:53.300
That's a fuse implementation of ext2.3.4.

290
0:16:53.380 --> 0:16:55.500
That's pretty readily available.

291
0:16:55.500 --> 0:16:57.180
You can install that.

292
0:16:57.180 --> 0:17:00.100
And then what we need to do is remove the config key

293
0:17:00.100 --> 0:17:03.580
that allowed straight up mounting of ext4.

294
0:17:03.580 --> 0:17:05.020
And we place it in another config key

295
0:17:05.020 --> 0:17:08.020
that instead says ext4 is fuse2fs.

296
0:17:09.140 --> 0:17:11.740
So we put that in there.

297
0:17:12.900 --> 0:17:14.740
Go back in.

298
0:17:14.740 --> 0:17:17.660
And then do it as the back to mnt.

299
0:17:17.660 --> 0:17:20.300
And the funny thing is that you won't actually notice

300
0:17:20.300 --> 0:17:23.420
any difference whatsoever.

301
0:17:23.420 --> 0:17:25.540
It actually looks completely identical.

302
0:17:25.540 --> 0:17:27.860
Unless you go look at proc mounts,

303
0:17:27.860 --> 0:17:29.100
at which point you're gonna notice

304
0:17:29.100 --> 0:17:31.180
that the file system here is not the ext4,

305
0:17:31.180 --> 0:17:33.020
it's fuse.txt4.

306
0:17:34.060 --> 0:17:35.380
And if you look at the process list,

307
0:17:35.380 --> 0:17:36.860
you're gonna notice that there's an extra process

308
0:17:36.860 --> 0:17:38.300
running in your container now.

309
0:17:39.780 --> 0:17:41.180
So that's pretty sweet because it means

310
0:17:41.180 --> 0:17:46.180
we can literally forward any file system to fuse.

311
0:17:46.180 --> 0:17:48.860
Because it's done at the Cisco layer,

312
0:17:48.860 --> 0:17:51.460
the container doesn't really need to be aware of it.

313
0:17:51.460 --> 0:17:53.540
Like it is not doing anything to the mount commands.

314
0:17:53.540 --> 0:17:55.700
You can just call the mount Cisco at any point

315
0:17:55.700 --> 0:17:57.700
and it will just forward it to fuse

316
0:17:57.700 --> 0:17:59.260
and do the right thing for you.

317
0:17:59.260 --> 0:18:01.420
Which means no change to your workloads whatsoever.

318
0:18:01.420 --> 0:18:02.380
It just works.

319
0:18:03.260 --> 0:18:04.380
So that is pretty cool.

320
0:18:05.900 --> 0:18:09.100
And the last thing I wanted to show in the demo

321
0:18:09.100 --> 0:18:14.100
is if I launch a Alpine Edge container.

322
0:18:14.100 --> 0:18:16.260
So that's gonna be the most info.

323
0:18:16.260 --> 0:18:19.700
And I'm gonna set a memory limit of one gig.

324
0:18:24.100 --> 0:18:25.900
So if I go in there now,

325
0:18:27.020 --> 0:18:28.340
and I look at the free memory,

326
0:18:28.340 --> 0:18:29.660
we can see I've got 16 gigs,

327
0:18:29.660 --> 0:18:32.220
which is considerably more than one gig.

328
0:18:32.220 --> 0:18:34.380
The enforcement is in place.

329
0:18:34.380 --> 0:18:35.980
So that's where problems happen,

330
0:18:35.980 --> 0:18:37.580
is that the enforcement is in place.

331
0:18:37.580 --> 0:18:39.940
Now if you run something that will look

332
0:18:39.940 --> 0:18:41.900
at the free memory output to figure out

333
0:18:41.900 --> 0:18:44.620
how much memory it can claim, it's gonna claim

334
0:18:44.620 --> 0:18:46.500
the wrong amount of memory and it will get killed

335
0:18:46.500 --> 0:18:48.180
by the out of memory killer.

336
0:18:48.180 --> 0:18:49.260
So that's a problem.

337
0:18:50.740 --> 0:18:53.980
Which is why we did the work to fix that

338
0:18:53.980 --> 0:18:55.900
through system co-interception.

339
0:18:55.900 --> 0:19:00.900
So you can do security, Cisco, intercept, sys, info,

340
0:19:00.900 --> 0:19:17.900
sure, and then bounce that container.

341
0:19:17.900 --> 0:19:18.740
Okay.

342
0:19:19.780 --> 0:19:21.540
And if I go in there and I look at free,

343
0:19:21.540 --> 0:19:22.780
and we've got a gig.

344
0:19:22.780 --> 0:19:24.860
So that actually works properly.

345
0:19:24.860 --> 0:19:26.620
It also fixes a bunch of other things.

346
0:19:26.620 --> 0:19:27.940
It doesn't just do the memory,

347
0:19:27.940 --> 0:19:30.580
but also does CPU load, uptime,

348
0:19:30.580 --> 0:19:31.420
and a bunch of other things.

349
0:19:31.420 --> 0:19:32.900
Like the entire struct, sys, info,

350
0:19:32.900 --> 0:19:34.540
is not properly handled.

351
0:19:34.540 --> 0:19:38.260
It's just the easiest use case we have is free on Alpine,

352
0:19:38.260 --> 0:19:40.180
because we know that this command has been changed

353
0:19:40.180 --> 0:19:42.220
to use sys, info instead of the five system.

354
0:19:42.220 --> 0:19:45.500
So it's a very easy one to just prove the concept works.

355
0:19:45.500 --> 0:19:47.100
But that's, that particular piece of work

356
0:19:47.100 --> 0:19:48.340
fixed a whole lot of other things.

357
0:19:48.340 --> 0:19:50.940
I think it also improved Java was using

358
0:19:50.940 --> 0:19:52.580
the wrong interface and the wrong amount

359
0:19:52.580 --> 0:19:54.540
of memory sometimes, so that fixed that.

360
0:19:54.540 --> 0:19:56.140
It fixed a bunch of other stuff.

361
0:19:56.140 --> 0:20:01.140
That was pretty good to have.

362
0:20:01.140 --> 0:20:03.980
All right.

363
0:20:03.980 --> 0:20:04.980
Yeah.

364
0:20:04.980 --> 0:20:08.540
So looking forward, where do we want to take this?

365
0:20:08.540 --> 0:20:12.900
I mean, we've got most of what we wanted covered, really.

366
0:20:12.900 --> 0:20:17.540
Like the big items that are really problematic

367
0:20:17.540 --> 0:20:18.460
have been resolved.

368
0:20:18.460 --> 0:20:21.100
Like Docker was a big one that we really wanted to solve,

369
0:20:21.100 --> 0:20:23.660
and it's working fine.

370
0:20:23.660 --> 0:20:25.260
Alpine behaving, that's really nice.

371
0:20:25.260 --> 0:20:26.260
We're happy with it.

372
0:20:26.260 --> 0:20:26.900
It's good.

373
0:20:26.900 --> 0:20:29.740
The man interception allows for a lot of different stuff now.

374
0:20:29.740 --> 0:20:31.820
It's possible to do things like image building instead

375
0:20:31.820 --> 0:20:32.980
of on previous containers.

376
0:20:32.980 --> 0:20:34.980
You can really do a lot.

377
0:20:34.980 --> 0:20:36.700
And Android seems to be happy, too,

378
0:20:36.700 --> 0:20:40.380
with the tiny bit of stuff we added for that.

379
0:20:40.380 --> 0:20:45.300
The things we'd like to add now are kind of weird stuff, really.

380
0:20:45.300 --> 0:20:48.380
The one I've got in mind, mostly for the sake of it,

381
0:20:48.380 --> 0:20:50.460
but also because I'm sure we found a use case for it,

382
0:20:50.460 --> 0:20:53.780
is to implement init module and finit module.

383
0:20:53.780 --> 0:20:56.020
So the ability to do kernel module loading

384
0:20:56.020 --> 0:20:58.820
from inside of an previous container, which

385
0:20:58.820 --> 0:21:00.900
is as terrifying as it sounds.

386
0:21:00.900 --> 0:21:04.460
But the idea there is that we would not actually

387
0:21:04.460 --> 0:21:07.660
allow for the container to feed us the actual object file

388
0:21:07.660 --> 0:21:09.220
that we would then store at the kernel.

389
0:21:09.220 --> 0:21:11.620
What we would do is we would receive that object file.

390
0:21:11.620 --> 0:21:13.820
We'd look at what the kernel module name is,

391
0:21:13.820 --> 0:21:16.940
look against an allow list that we have of kernel modules that

392
0:21:16.940 --> 0:21:19.060
are fine to dynamically load on the system.

393
0:21:19.060 --> 0:21:20.380
And if it's in that list, then we'll

394
0:21:20.380 --> 0:21:24.580
do the loading using the module from the host system

395
0:21:24.580 --> 0:21:26.700
that we know is correct.

396
0:21:26.700 --> 0:21:28.540
This might help quite a bit with things

397
0:21:28.540 --> 0:21:29.980
like firewalls in containers that

398
0:21:29.980 --> 0:21:33.820
might need to load custom IP tables or a NetFilter modules,

399
0:21:33.820 --> 0:21:35.820
and potentially some other things like file systems

400
0:21:35.820 --> 0:21:37.460
and other things.

401
0:21:37.460 --> 0:21:40.940
So that would be an interesting one to implement.

402
0:21:40.940 --> 0:21:43.220
And I'm sure we're going to have to explain to a lot of people

403
0:21:43.220 --> 0:21:45.140
exactly how it is that we're doing it, because otherwise

404
0:21:45.140 --> 0:21:48.900
they're going to be absolutely terrified.

405
0:21:48.900 --> 0:21:50.660
More EBPF program handling, I think,

406
0:21:50.660 --> 0:21:53.620
is also kind of in our plans.

407
0:21:53.620 --> 0:21:56.580
As I said, we're currently on the intercept of the EBPF

408
0:21:56.580 --> 0:22:00.820
program that's used for device management,

409
0:22:00.820 --> 0:22:04.420
so for allowing device creation, device mapping,

410
0:22:04.420 --> 0:22:06.380
that kind of stuff within containers.

411
0:22:06.380 --> 0:22:11.420
That's because C group 2 removed the devices C group's file

412
0:22:11.420 --> 0:22:13.580
interface and moved to EBPF instead.

413
0:22:13.580 --> 0:22:16.060
So we implemented it that way.

414
0:22:16.060 --> 0:22:18.100
We seem to have some interest for other programs,

415
0:22:18.100 --> 0:22:21.620
like I think SystemD and some other pretty common pieces

416
0:22:21.620 --> 0:22:24.420
of software, now generate a BPF hook

417
0:22:24.420 --> 0:22:27.260
that they hook either globally or on two specific kind

418
0:22:27.260 --> 0:22:28.380
interfaces.

419
0:22:28.380 --> 0:22:30.300
And some of those should be safe.

420
0:22:30.300 --> 0:22:33.100
That should be things that we can effectively pull,

421
0:22:33.100 --> 0:22:35.820
validate that they match the expected pattern.

422
0:22:35.820 --> 0:22:40.340
And if they do, then show that to the kernel, this is fine.

423
0:22:40.340 --> 0:22:43.500
And that should actually make a lot more newer software

424
0:22:43.500 --> 0:22:47.660
that make use of a lot of BPF stuff to just start working.

425
0:22:47.660 --> 0:22:49.820
I don't think we're anywhere near getting something

426
0:22:49.820 --> 0:22:52.620
like a BPF trace working safely inside a container.

427
0:22:52.620 --> 0:22:54.460
That's absolutely terrifying, because it's

428
0:22:54.460 --> 0:22:56.180
got access to all of the kernel constructs,

429
0:22:56.180 --> 0:22:59.100
and that's not something we do.

430
0:22:59.100 --> 0:23:01.740
But some subset of those interfaces

431
0:23:01.740 --> 0:23:04.140
should definitely be fine.

432
0:23:04.140 --> 0:23:08.460
Signed BPF will solve a lot of those problems, probably,

433
0:23:08.460 --> 0:23:10.620
because then you can load unprivileged programs.

434
0:23:13.380 --> 0:23:17.340
And the other thing that I've had in mind for a while,

435
0:23:17.340 --> 0:23:19.620
it's mostly a cool thing, and not something

436
0:23:19.620 --> 0:23:23.500
I've actually had a use case for yet.

437
0:23:23.500 --> 0:23:25.540
Second comp has an interesting property

438
0:23:25.540 --> 0:23:28.140
in that it runs extremely early.

439
0:23:28.140 --> 0:23:33.860
It runs in the system called entry time in the kernel.

440
0:23:33.860 --> 0:23:36.180
Before the system code is resolved,

441
0:23:36.180 --> 0:23:39.700
that means we can intercept system calls that don't exist.

442
0:23:39.700 --> 0:23:42.380
So we can intercept system code numbers that have not yet

443
0:23:42.380 --> 0:23:44.700
been allocated, and that means we

444
0:23:44.700 --> 0:23:47.740
get to actually implement new system calls purely

445
0:23:47.740 --> 0:23:50.260
in user space that you can access

446
0:23:50.260 --> 0:23:53.540
through the normal kernel system code API.

447
0:23:53.540 --> 0:23:54.900
That's super interesting, because it

448
0:23:54.900 --> 0:23:57.660
has to do very easy prototype and testing

449
0:23:57.660 --> 0:23:59.460
of potential system calls.

450
0:23:59.460 --> 0:24:01.220
If you want to try specific interfaces,

451
0:24:01.220 --> 0:24:03.660
see how they look, the layout, what kind of arguments

452
0:24:03.660 --> 0:24:06.540
you want, you can pretty quickly implement system

453
0:24:06.540 --> 0:24:10.380
calls through that, and already show user space software

454
0:24:10.380 --> 0:24:13.280
at it until you're happy with it, at which point you go back

455
0:24:13.280 --> 0:24:15.420
and you do the actual kernel implementation of the system

456
0:24:15.420 --> 0:24:16.500
code.

457
0:24:16.500 --> 0:24:18.060
So that might be pretty interesting.

458
0:24:18.060 --> 0:24:20.060
I don't think anyone has actually done that yet,

459
0:24:20.060 --> 0:24:24.060
but that's a nice property of how second comp works,

460
0:24:24.060 --> 0:24:27.140
that it works before any kind of resolution, any kind of validity

461
0:24:27.140 --> 0:24:28.660
of the system call number.

462
0:24:28.660 --> 0:24:30.780
All that second comp tells us is actually

463
0:24:30.780 --> 0:24:33.820
a system call number, and all of the pointers to the arguments.

464
0:24:33.820 --> 0:24:36.140
It doesn't care whether the thing exists or not,

465
0:24:36.140 --> 0:24:38.020
so it means we get to actually intercept things

466
0:24:38.020 --> 0:24:39.380
that don't exist.

467
0:24:39.380 --> 0:24:42.900
And that's it.

468
0:24:42.900 --> 0:24:45.340
So we can start getting a few questions.

469
0:24:45.340 --> 0:24:46.980
Also on your way out, if you're interested,

470
0:24:46.980 --> 0:24:49.140
we do have AlexD stickers on the table over there,

471
0:24:49.140 --> 0:24:50.940
so feel free to help yourself.

472
0:24:50.940 --> 0:24:52.820
There's a question over there.

473
0:24:52.820 --> 0:24:54.500
I think he's worth the first.

474
0:24:54.500 --> 0:24:56.340
Yeah, there's one here, one there.

475
0:24:59.740 --> 0:25:04.020
When will we see the system call being intercepted by default

476
0:25:04.020 --> 0:25:07.780
on AlexD or other distribution?

477
0:25:07.780 --> 0:25:09.460
Sorry.

478
0:25:09.460 --> 0:25:13.060
When will we see this info calls being default intercepted?

479
0:25:13.060 --> 0:25:15.380
This is going to roll out?

480
0:25:15.380 --> 0:25:19.140
Yeah, we've currently not decided to do any of that by default.

481
0:25:19.140 --> 0:25:23.220
Please leave quietly while we are answering questions.

482
0:25:23.220 --> 0:25:27.060
Yeah, so we've not decided to intercept anything by default

483
0:25:27.060 --> 0:25:28.700
yet.

484
0:25:28.700 --> 0:25:30.340
We consider it to be safe.

485
0:25:30.340 --> 0:25:32.860
The main problem we have is it depends on the kernel version

486
0:25:32.860 --> 0:25:34.140
that you're running, whether it's

487
0:25:34.140 --> 0:25:35.660
going to be working or not.

488
0:25:35.660 --> 0:25:38.460
And it's still recent enough, even though it's 5.1,

489
0:25:38.460 --> 0:25:40.020
which has been around a while now,

490
0:25:40.020 --> 0:25:42.140
it's still recent enough that a bunch of distros

491
0:25:42.140 --> 0:25:43.860
would not work properly.

492
0:25:43.860 --> 0:25:46.100
So we want to wait until we can truly

493
0:25:46.100 --> 0:25:48.500
assume that all of the distros that are like all the long term

494
0:25:48.500 --> 0:25:51.740
support releases are still supported before we can start

495
0:25:51.740 --> 0:25:54.300
doing that kind of stuff by default.

496
0:25:54.300 --> 0:25:56.740
Please keep it down while we are answering questions.

497
0:25:56.740 --> 0:25:59.020
Thank you.

498
0:25:59.020 --> 0:25:59.540
Hello.

499
0:25:59.540 --> 0:26:00.540
Thanks for the great talk.

500
0:26:00.540 --> 0:26:01.860
So I have two questions.

501
0:26:01.860 --> 0:26:03.660
First of all, we have a question.

502
0:26:03.660 --> 0:26:05.780
So I have two questions.

503
0:26:05.780 --> 0:26:07.940
First of all, you said there is this time of check

504
0:26:07.940 --> 0:26:10.780
versus time of use issue.

505
0:26:10.780 --> 0:26:11.980
And so how do you solve it?

506
0:26:11.980 --> 0:26:14.180
I'm trying to give a question, but I can't hear anything.

507
0:26:14.180 --> 0:26:16.140
Hold on.

508
0:26:16.140 --> 0:26:18.940
So first of all, how do you fix this time of check

509
0:26:18.940 --> 0:26:22.740
versus time of use issue, where you call a syscall?

510
0:26:22.740 --> 0:26:25.180
The syscall gets notified.

511
0:26:25.180 --> 0:26:28.020
And you can, well, raise it with another thread

512
0:26:28.020 --> 0:26:30.660
and change some arguments, right?

513
0:26:30.660 --> 0:26:31.660
I didn't really get that.

514
0:26:31.660 --> 0:26:33.780
But if Christian did, you can answer instead,

515
0:26:33.780 --> 0:26:35.060
because you probably know it.

516
0:26:42.300 --> 0:26:45.660
It's extremely noisy.

517
0:26:45.660 --> 0:26:47.700
OK, I'm going to try this.

518
0:26:47.700 --> 0:26:52.500
Stefan, how do you fix the time of check, time of use issue?

519
0:26:52.500 --> 0:26:54.500
OK, so the time of check, time of use issue,

520
0:26:54.500 --> 0:26:59.260
you fix it by never letting the kernel execute after the check.

521
0:26:59.260 --> 0:27:03.900
So you never continue a system call after the check,

522
0:27:03.900 --> 0:27:04.400
effectively.

523
0:27:04.400 --> 0:27:06.780
If you want to intercept a system call,

524
0:27:06.780 --> 0:27:09.620
you are now in charge of running it.

525
0:27:09.620 --> 0:27:12.100
And so you copy the arguments as they are.

526
0:27:12.100 --> 0:27:14.420
You do the check on your copy of them.

527
0:27:14.420 --> 0:27:18.260
You never ever reuse the pointer that the user gave you.

528
0:27:18.260 --> 0:27:20.380
And you go with your own copy of it.

529
0:27:20.380 --> 0:27:22.300
And that's perfectly safe.

530
0:27:22.300 --> 0:27:24.500
But if the argument is a pointer to a string,

531
0:27:24.500 --> 0:27:25.740
you need to copy the string.

532
0:27:25.740 --> 0:27:27.180
And when you're copying the string,

533
0:27:27.180 --> 0:27:28.740
it may be changed under the hood.

534
0:27:28.740 --> 0:27:30.580
So are you actually freezing the process

535
0:27:30.580 --> 0:27:33.980
with something like the cgroup, the freezer cgroup,

536
0:27:33.980 --> 0:27:35.140
for example?

537
0:27:35.140 --> 0:27:38.180
So technically, the calling thread is frozen by the kernel.

538
0:27:38.180 --> 0:27:40.580
But it doesn't prevent another parallel thread

539
0:27:40.580 --> 0:27:43.180
to modify it, which is why we effectively

540
0:27:43.180 --> 0:27:45.020
map the memory of the process.

541
0:27:45.020 --> 0:27:48.140
We copy the entire thing that we care about.

542
0:27:48.140 --> 0:27:49.940
The entire, like if there's pointer or pointers,

543
0:27:49.940 --> 0:27:50.900
we just travel start.

544
0:27:50.900 --> 0:27:52.020
We copy it.

545
0:27:52.020 --> 0:27:55.700
Once we've copied that, that's what we check policy against.

546
0:27:55.700 --> 0:27:57.900
And those are the arguments we're

547
0:27:57.900 --> 0:28:00.580
going to be passing to the actual kernel.

548
0:28:00.580 --> 0:28:04.220
And we just never look back at what came from the process,

549
0:28:04.220 --> 0:28:06.460
which means if they try to erase us at that point,

550
0:28:06.460 --> 0:28:07.660
it doesn't matter.

551
0:28:07.660 --> 0:28:08.980
We create full copies.

552
0:28:08.980 --> 0:28:10.460
We create full copies of everything.

553
0:28:10.460 --> 0:28:12.060
We never continue the system call,

554
0:28:12.060 --> 0:28:14.460
although that's an ability that I added a while back.

555
0:28:14.460 --> 0:28:19.060
So you can even say, continue the system call

556
0:28:19.060 --> 0:28:21.460
if I come to the conclusion that it's fine to do so.

557
0:28:21.460 --> 0:28:24.100
But if you do that, then the kernel

558
0:28:24.100 --> 0:28:29.100
needs to guarantee you that it's safe.

559
0:28:29.100 --> 0:28:32.740
For example, continuing the make-not system call

560
0:28:32.740 --> 0:28:34.740
after you inspected the arguments is safe

561
0:28:34.740 --> 0:28:36.860
because the kernel will just allow the creation

562
0:28:36.860 --> 0:28:38.340
of any device.

563
0:28:42.020 --> 0:28:45.060
So I have another question.

564
0:28:45.060 --> 0:28:50.220
Because you said about MKNOT that if you MKNOT

565
0:28:50.220 --> 0:28:54.500
like this device, that nothing protects you against reading

566
0:28:54.500 --> 0:28:57.460
or writing into this, right?

567
0:28:57.460 --> 0:28:59.820
But there is this devices C group

568
0:28:59.820 --> 0:29:03.820
where you can actually protect this device from being

569
0:29:03.820 --> 0:29:05.100
written to or read from.

570
0:29:05.100 --> 0:29:07.980
And this is what Docker does, for example.

571
0:29:07.980 --> 0:29:11.340
So are you doing this in legacy?

572
0:29:11.340 --> 0:29:13.780
I'm sorry, I only get about 20% of what you're saying.

573
0:29:13.780 --> 0:29:16.300
Well, of times what we'll do is that I'm going to be outside

574
0:29:16.300 --> 0:29:18.940
and we can just talk because you also have questions.

575
0:29:18.940 --> 0:29:20.420
So just follow me and we'll talk.

576
0:29:20.420 --> 0:29:21.940
It's going to be easier.

577
0:29:21.940 --> 0:29:50.900
Thank you very much.

