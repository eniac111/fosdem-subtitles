WEBVTT

00:00.000 --> 00:08.200
Our next talk is by Stefan.

00:08.200 --> 00:14.280
He's the project leader for LexD, a container manager, former teammate of mine as well.

00:14.280 --> 00:18.400
And he's going to talk about safe containers through system call interception.

00:18.400 --> 00:19.400
Hello.

00:19.400 --> 00:21.120
Is that working well?

00:21.120 --> 00:22.120
Think so.

00:22.120 --> 00:23.120
All right.

00:23.120 --> 00:24.360
So you kind of did the intro.

00:24.360 --> 00:25.360
I'm Stefan.

00:25.360 --> 00:26.360
I work at Canonical.

00:26.360 --> 00:31.960
I'm the project leader for LexD, LexC, LexCFS and a bunch of other stuff that we do.

00:31.960 --> 00:33.960
Effectively, system container guy.

00:33.960 --> 00:37.960
And yeah, we're going to be talking about system call interception today.

00:37.960 --> 00:42.880
First, just a tiny bit of going back to the basics.

00:42.880 --> 00:47.120
We kind of need to explain what we're trying to achieve.

00:47.120 --> 00:49.280
So there are two main kind of containers out there.

00:49.280 --> 00:52.480
We've got privileged containers and unprivileged containers.

00:52.480 --> 00:55.560
The ones you want are the unprivileged kind.

00:55.560 --> 00:56.560
Privileged is bad.

00:56.560 --> 01:02.920
And just to clarify there, too, we don't mean privileged as in dash dash privileged in Docker.

01:02.920 --> 01:05.040
That's extra, extra bad.

01:05.040 --> 01:06.880
Docker by default is privileged.

01:06.880 --> 01:11.120
And the definition of privileged is whether you're using a user namespace or not.

01:11.120 --> 01:15.560
So in the case of LexD, which is a container manager that I'm working on these days, we

01:15.560 --> 01:17.840
default to unprivileged containers.

01:17.840 --> 01:18.840
That's great.

01:18.840 --> 01:20.920
It means that root in the container is not root on the host.

01:20.920 --> 01:25.480
If there's a container escape of any kind, you don't you get as much permission as nobody

01:25.480 --> 01:27.120
uses on the system.

01:27.120 --> 01:28.400
That's great.

01:28.400 --> 01:35.040
Problem is not being real root also means you don't get to do stuff that real root can

01:35.040 --> 01:36.040
do.

01:36.040 --> 01:40.400
A lot of stuff have been enabled now inside the user namespace that you can do yourself.

01:40.400 --> 01:41.600
You can create a lot of devices.

01:41.600 --> 01:43.200
You can reconfigure a lot of stuff.

01:43.200 --> 01:44.200
It's great.

01:44.200 --> 01:45.920
But there are still things you can't do.

01:45.920 --> 01:49.760
You can't change your process priority to something higher than what you would be allowed

01:49.760 --> 01:51.760
to do as a normal user on the system.

01:51.760 --> 01:56.360
Anyone can create a new user namespace, go in it and bump their process priority to whatever

01:56.360 --> 02:00.360
they want and bypass all kind of settings on the system.

02:00.360 --> 02:04.000
So there's a lot of things that are not quite possible.

02:04.000 --> 02:08.000
In general, we want to eradicate privileged containers because having real root is very,

02:08.000 --> 02:09.000
very bad.

02:09.000 --> 02:14.920
And it's kind of a game of, like, whack-a-mole as far as trying to prevent nasty things from

02:14.920 --> 02:15.920
happening.

02:15.920 --> 02:19.060
We've got Appama, we've got SecComp, we've got a whole bunch of things that are all trying

02:19.060 --> 02:23.080
to prevent you from doing bad things, but that's done by us thinking about what all

02:23.080 --> 02:25.600
the bad things are and trying to block them.

02:25.600 --> 02:29.040
And someone just needs to find another bad thing we didn't think of, and then there goes

02:29.040 --> 02:30.040
the entire system.

02:30.040 --> 02:31.040
So we don't want those.

02:31.040 --> 02:33.440
We'd like to get rid of them completely.

02:33.440 --> 02:38.400
But for that, we need to find ways to allow for unprivileged environments to do things

02:38.400 --> 02:43.440
that are normally only allowed to be done by privileged environments in a way that's

02:43.440 --> 02:45.440
still safe.

02:45.440 --> 02:47.720
All right.

02:47.720 --> 02:53.720
All I'm going to be talking about today relies on SecComp, which is the system code interception

02:53.720 --> 02:55.880
mechanism in Linux.

02:55.880 --> 02:59.520
It lets you do a bunch of nice policies.

02:59.520 --> 03:03.480
You can just put policies for, like, this system code with those arguments, just deny

03:03.480 --> 03:11.000
them or return this return code or return, yeah, this particular error number, for example.

03:11.000 --> 03:18.440
But it also grew the ability with Linux 5.0 in 2019, it grew the ability to notify userspace

03:18.440 --> 03:19.440
instead.

03:19.440 --> 03:26.440
So you can put a policy in SecComp that says if this is code and the arguments are so and

03:26.440 --> 03:34.080
so, instead of taking an action right now, go and notify the spider descriptor that something

03:34.080 --> 03:35.080
happened.

03:35.080 --> 03:40.120
And then the whole system can have a privileged daemon monitoring that notification mechanism

03:40.120 --> 03:42.120
and take actions.

03:42.120 --> 03:47.800
There is some complexity around security that I'm going to get into very shortly because

03:47.800 --> 03:50.360
you can do very, very bad things with that.

03:50.360 --> 03:56.880
But if you do it correctly, it lets you run a more privileged action on behalf of a less

03:56.880 --> 04:02.640
privileged container after going through some kind of analysis or that kind of logic on

04:02.640 --> 04:07.320
the host to make sure that this is actually fine.

04:07.320 --> 04:15.120
Now for the nasty issues, time of check, time of use is a very, very common issue in security.

04:15.120 --> 04:20.680
And this mechanism has definitely got some issues around that.

04:20.680 --> 04:24.400
Userspace gets notified that a system code was made.

04:24.400 --> 04:30.480
The system code can have pointers to a bunch of different arguments and structures.

04:30.480 --> 04:35.160
And there's nothing preventing the caller from technically changing the value at those

04:35.160 --> 04:36.160
pointers.

04:36.160 --> 04:38.960
So you need to be a bit careful when you're processing those messages.

04:38.960 --> 04:43.400
You effectively need to start by copying everything, evaluating it.

04:43.400 --> 04:45.640
If everything looks good, then you can take actions.

04:45.640 --> 04:50.160
But by taking actions, we mean you can run the thing on behalf of the user with the original

04:50.160 --> 04:55.800
arguments, never putting them again because otherwise they could change.

04:55.800 --> 05:00.080
Or you could just say, I don't want this reject.

05:00.080 --> 05:05.320
What you shouldn't do is say, oh, based on those arguments, it seems fine.

05:05.320 --> 05:06.920
And it continues.

05:06.920 --> 05:10.560
Because there's absolutely nothing that prevents the caller process from just racing you and

05:10.560 --> 05:14.120
immediately changing the arguments to something else before it goes back to the kernel and

05:14.120 --> 05:17.800
then running with a value you would not have allowed.

05:17.800 --> 05:21.280
So you need to be careful in your design so that this doesn't happen.

05:21.280 --> 05:25.960
Otherwise you're literally allowing people to run stuff as full-root privilege inside

05:25.960 --> 05:29.720
of continuous containers, which would be very bad.

05:29.720 --> 05:34.640
So what do we actually do with this stuff?

05:34.640 --> 05:36.400
So far we've implemented quite a few things.

05:36.400 --> 05:40.240
And I'm going to go into more details about each of those.

05:40.240 --> 05:44.680
The first thing we implemented actually, I don't know if you're on the right order.

05:44.680 --> 05:48.480
One of the first things we implemented is make node.

05:48.480 --> 05:51.760
Then we followed that, which is useful for save device node creation.

05:51.760 --> 05:54.200
I'm going to go into more detail shortly.

05:54.200 --> 05:57.360
SetXAdder we also added pretty early on.

05:57.360 --> 06:02.040
We've got support for eBPF so we can allow some specific eBPF programs.

06:02.040 --> 06:07.600
We've got support for set scheduler, which is used to change some of the process priorities.

06:07.600 --> 06:11.840
We've got support for mount, which was a real pain in the ass to implement, but we've got

06:11.840 --> 06:12.840
support for mount.

06:12.840 --> 06:19.800
And we've got support for sysinfo, which was also reasonably fun to implement.

06:19.800 --> 06:26.160
Now kind of going over those things directly, make nodes, what do we use that for?

06:26.160 --> 06:32.320
Well, one of the things we wanted to enable is for running docker inside of LexD containers.

06:32.320 --> 06:35.640
I said LexD containers are on privilege, they are nice and safe.

06:35.640 --> 06:38.720
Docker by and large not safe.

06:38.720 --> 06:42.560
But docker running inside of a privilege LexD container safe.

06:42.560 --> 06:44.760
So we figured we'd try and make that work.

06:44.760 --> 06:47.160
And we did manage to get it working.

06:47.160 --> 06:50.640
The main driver at the time was Travis CI.

06:50.640 --> 06:57.920
The Travis CI platform was using LexD containers on M64, IBM, Z series, as well as IBM power

06:57.920 --> 06:59.320
at the time.

06:59.320 --> 07:03.200
And they wanted the same behavior as they were getting on Intel.

07:03.200 --> 07:08.200
And on Intel, they were using full VMs that you could do whatever you wanted.

07:08.200 --> 07:10.600
So we wanted to make sure that docker worked properly in there.

07:10.600 --> 07:15.400
And what we noticed is that docker layers, especially the directory whiteout files and

07:15.400 --> 07:24.240
five whiteout files, rely on either I think it's C 00 device nodes, or they rely on specific

07:24.240 --> 07:29.200
excellent attributes that just say that this is like a directory that was removed effectively

07:29.200 --> 07:32.600
in D&L A using that as whiteout.

07:32.600 --> 07:34.400
Both cases, those things were not allowed.

07:34.400 --> 07:37.680
Device creation in a container is a big, big, big no-go usually.

07:37.680 --> 07:42.480
Because if you can create, say, the device node for DevSDA, then there's nothing preventing

07:42.480 --> 07:46.520
your previous container from rewriting your disk, which would be bad.

07:46.520 --> 07:48.160
So that's usually not allowed.

07:48.160 --> 07:50.720
But some specific device nodes are fine.

07:50.720 --> 07:55.600
And the work we did there also allows for things like creating a new dev null device

07:55.600 --> 08:01.160
or new dev zero device or those kind of devices which are inherently safe.

08:01.160 --> 08:05.000
And making that possible means that you can now do things like running the bootstrap or

08:05.000 --> 08:08.200
similar tools inside of an unprivileged container.

08:08.200 --> 08:12.720
Those are the few devices that are needed to be created as part of an image creation

08:12.720 --> 08:15.680
process are safe devices, and this allows it.

08:15.680 --> 08:20.080
We generally consider this particular interception to be safe, as in you can pretty much turn

08:20.080 --> 08:26.600
it on on any LexD container without having to think too much about who's in that container,

08:26.600 --> 08:30.280
like do we actually trust the workloads and all that kind of stuff.

08:30.280 --> 08:36.360
The other piece to that puzzle was SetX

08:36.360 --> 08:38.360
other.

08:38.360 --> 08:41.080
It does not allow all of SetX other.

08:41.080 --> 08:46.560
It just allows very safe namespaces of extended attributes.

08:46.560 --> 08:50.640
It will not let you do things like setting a security attribute, because that would let

08:50.640 --> 08:53.520
you do some really, really bad things, for example.

08:53.520 --> 08:57.920
And this is similarly considered to be safe on our side.

08:57.920 --> 09:02.760
Then go to the pretty interesting one, mount.

09:02.760 --> 09:10.320
So again, mount is a bit of a problem, because usually, well, for the whole, usually it relies

09:10.320 --> 09:11.520
on having a block device.

09:11.520 --> 09:16.120
You kind of need to have that allowed in the container, which is already a bit fishy in

09:16.120 --> 09:17.120
many cases.

09:17.120 --> 09:21.440
You've got to be careful that any block device you expose to the container you consider as

09:21.440 --> 09:25.560
untrusted from that point on, and you never mount it as real roots somewhere else, or

09:25.560 --> 09:27.280
they could try and attack you.

09:27.280 --> 09:33.440
And by attack you, what I mean is the kernel has a superblock parser that will process

09:33.440 --> 09:38.560
a new device as it gets mounted, and this is not guaranteed to be bug free.

09:38.560 --> 09:45.440
So a user that can craft a very specific block device might be able to trick something like

09:45.440 --> 09:51.000
X4, XFS, BarFS, or any of the other file systems into either crashing into your system or doing

09:51.000 --> 09:53.000
arbitrary code execution in the kernel.

09:53.000 --> 09:55.760
Both cases not very good.

09:55.760 --> 09:59.640
But we still enable support for that.

09:59.640 --> 10:05.120
If you have a container that you trust, that you don't want to give full access for everything,

10:05.120 --> 10:15.240
but that you still trust, you can technically do this, and it will let you mount inside

10:15.240 --> 10:16.480
of the container.

10:16.480 --> 10:20.800
We added an extra layer on top of that, which lets us do a shift.

10:20.800 --> 10:25.080
Because if you do the mount, the ownership information on that device is probably not

10:25.080 --> 10:26.560
landing at your container.

10:26.560 --> 10:33.240
So we allow stacking shiftFS, which is hopefully lying soon, but that we implemented for Ubuntu

10:33.240 --> 10:36.320
on Ubuntu that we can stack on top and that fixes the permissions.

10:36.320 --> 10:38.200
So we support that as well.

10:38.200 --> 10:42.840
The really cool thing with this stuff is we also support redirecting to fuse instead,

10:42.840 --> 10:44.560
which then becomes safe.

10:44.560 --> 10:50.080
So what we can do is say, any attempt at mounting ext4 inside of the container, call the fuse2fs

10:50.080 --> 10:51.800
binary instead.

10:51.800 --> 10:56.480
And yeah, that's safe, that actually does work pretty well.

10:56.480 --> 10:59.240
And I'll show that in just a tiny bit.

10:59.240 --> 11:04.400
And then we worked on the BPF, not allowing all of the BPF programs, but specifically allowing

11:04.400 --> 11:09.400
those that we need to do nested containers and doing device permission management through

11:09.400 --> 11:10.400
that.

11:10.400 --> 11:13.880
So we can review what the program is, if it matches what we expect, then we load it.

11:13.880 --> 11:15.680
Otherwise, we just reject entirely.

11:15.680 --> 11:18.520
And it's also considered to be safe.

11:18.520 --> 11:23.480
Then for an unsafe one, a sched set scheduler is not super duper safe because it lets you

11:23.480 --> 11:25.440
reconfigure scheduler options.

11:25.440 --> 11:45.520
It was needed to be able to run Android inside of a Np

11:45.520 --> 11:50.360
or a Lp, by enabling this thing, but there's definitely some ability to affect the entire

11:50.360 --> 11:52.480
system.

11:52.480 --> 11:53.480
And then we had sysinfo.

11:53.480 --> 11:59.220
That was kind of led by Alpine deciding not to use ProkMEM info to figure out the memory

11:59.220 --> 12:01.600
usage in the free command.

12:01.600 --> 12:05.180
So you would run a container with a limit of, like, a gig of RAM and run free.

12:05.180 --> 12:09.180
And you would see 128 gigs, because it will just show you the host value directly.

12:09.180 --> 12:13.040
And that's because the ones you look, like CFS, which is another project we ran, that

12:13.040 --> 12:15.780
overlays on top of proc to show the right values,

12:15.780 --> 12:17.740
they don't work because they were not reading

12:17.740 --> 12:19.540
the file system, they were going straight to the kernel

12:19.540 --> 12:22.180
with a system call using CS info.

12:22.180 --> 12:23.940
So we've implemented Interception for that

12:23.940 --> 12:25.580
and we've fitted with the same values

12:25.580 --> 12:27.820
as you would be getting from Lex CFS

12:27.820 --> 12:29.620
and that gets us the right behavior.

12:31.140 --> 12:34.780
And so just switching to the demo,

12:34.780 --> 12:38.460
also just rechecking something here real quick.

12:41.500 --> 12:42.920
Okay, just making sure that Christian was wrong

12:42.920 --> 12:44.820
with the time, it's good.

12:44.820 --> 12:47.420
I've got until three, you showed me at 10 minutes.

12:47.420 --> 12:52.420
All right, so let's just move here to the terminal

12:56.720 --> 12:59.700
and the first thing I'll do is play with make node.

12:59.700 --> 13:02.780
So, and that should be, yep, looks all right.

13:03.820 --> 13:08.500
Just launching a new container Ubuntu 22.04

13:08.500 --> 13:13.500
and let's try make node,

13:15.060 --> 13:16.500
just remember the other of the arguments,

13:16.500 --> 13:18.100
I'm sure I'm getting those wrong again

13:18.100 --> 13:19.600
because I always get them wrong.

13:22.500 --> 13:24.860
Make node named and type, yeah.

13:24.860 --> 13:26.900
Depending on the kernel, this might work.

13:28.380 --> 13:29.980
Yeah, it actually does work now.

13:30.940 --> 13:34.500
Let me figure out dev no, this one shouldn't work.

13:34.500 --> 13:35.340
One is three.

13:35.340 --> 13:36.500
C5 one.

13:36.500 --> 13:38.740
Yeah, C1 three, for example, for dev no,

13:38.740 --> 13:40.740
does not work out of the box.

13:40.740 --> 13:43.300
But if we stop this,

13:47.380 --> 13:52.380
then set demo make node security calls,

13:54.700 --> 13:57.260
intercept make node true.

13:58.660 --> 14:00.340
In this case, we do need to restart the container

14:00.340 --> 14:02.500
because the entire second policy needs to change.

14:02.500 --> 14:04.140
For smaller changes, we don't need to,

14:04.140 --> 14:06.620
for that we do, and now that works properly.

14:09.180 --> 14:11.460
So that's the make node piece.

14:11.460 --> 14:12.660
Then we've got docker.

14:12.660 --> 14:14.900
For that one, I did prepare ahead a tiny bit

14:14.900 --> 14:17.400
because I did not feel like downloading docker

14:17.400 --> 14:18.740
on the wifi here.

14:18.740 --> 14:20.380
I mean, actually I did, but it took an hour,

14:20.380 --> 14:22.380
so I'm happy I didn't do it during the talk.

14:23.740 --> 14:26.980
So for docker, actually let me show you the config first.

14:26.980 --> 14:30.460
So the container here has security nesting enabled,

14:30.460 --> 14:32.540
which allows for running containers in containers,

14:32.540 --> 14:35.460
and it has intercept of both make node and setXR

14:35.460 --> 14:38.020
that are set up.

14:38.020 --> 14:43.020
And in there, that part does use the network,

14:43.140 --> 14:45.180
so I'm just hoping that's tiny enough.

14:45.180 --> 14:46.540
There we go.

14:46.540 --> 14:48.220
So that works properly.

14:48.220 --> 14:50.260
And the issue before was that unpacking the layers

14:50.260 --> 14:51.260
would just blow up.

14:52.980 --> 14:55.340
All right, so that was docker.

14:55.340 --> 15:00.340
Then to the more, to the fancier one,

15:00.340 --> 15:02.060
which is mount.

15:03.940 --> 15:08.460
All right, so for mount, launch the container here.

15:08.460 --> 15:10.860
I'm gonna go and pass it a block device,

15:10.860 --> 15:13.220
so I'm passing it dev loop 11 on my system

15:13.220 --> 15:15.100
as dev sda inside of the container.

15:17.540 --> 15:19.140
Yeah, your signs are still wrong.

15:20.500 --> 15:21.340
I've got 15.

15:22.540 --> 15:24.180
I mean, it's until three.

15:25.020 --> 15:25.860
Okay.

15:25.860 --> 15:30.860
So demo mount, makefs, ext4, and dev sda.

15:36.060 --> 15:37.340
Is it capital F?

15:37.340 --> 15:38.460
Yes, okay.

15:38.460 --> 15:40.620
So just formatting, that you can always do.

15:40.620 --> 15:42.460
There's nothing preventing you from creating a file system.

15:42.460 --> 15:44.220
Normally, that works just fine.

15:44.220 --> 15:46.340
What doesn't work is this.

15:46.340 --> 15:47.620
You're not allowed to actually mount it

15:47.620 --> 15:49.460
inside of a container.

15:49.460 --> 15:52.500
But now we can make that work, actually.

15:52.500 --> 15:54.620
So what we're gonna be doing here

15:54.620 --> 15:58.540
is turning on mount interception.

15:59.980 --> 16:03.580
And then we need to set an extra one,

16:03.580 --> 16:05.540
which is the one allowing specific file systems.

16:05.540 --> 16:07.860
So in this case, ext4.

16:07.860 --> 16:11.340
And then restarting the container here.

16:12.780 --> 16:14.380
Okay.

16:14.380 --> 16:17.140
Exec back in there and try mounting again.

16:17.140 --> 16:17.980
And that works.

16:19.180 --> 16:23.020
And if we look at, oops, just nls,

16:23.020 --> 16:24.780
and we look at the F, it's mounted.

16:24.780 --> 16:26.580
Normally, it's fine.

16:26.580 --> 16:28.380
Other than it actually did this at real root,

16:28.380 --> 16:30.460
and I could have done very nasty things

16:30.460 --> 16:33.020
by crafting that particular device ahead of time.

16:33.020 --> 16:34.300
It works as expected.

16:35.820 --> 16:38.780
Now, what we can do to make things

16:38.780 --> 16:41.140
a bit more interesting here,

16:41.140 --> 16:43.420
actually, let me get back in there.

16:43.420 --> 16:48.300
Let's unmount it and then install fuse2fs.

16:48.300 --> 16:53.300
That's a fuse implementation of ext2.3.4.

16:53.380 --> 16:55.500
That's pretty readily available.

16:55.500 --> 16:57.180
You can install that.

16:57.180 --> 17:00.100
And then what we need to do is remove the config key

17:00.100 --> 17:03.580
that allowed straight up mounting of ext4.

17:03.580 --> 17:05.020
And we place it in another config key

17:05.020 --> 17:08.020
that instead says ext4 is fuse2fs.

17:09.140 --> 17:11.740
So we put that in there.

17:12.900 --> 17:14.740
Go back in.

17:14.740 --> 17:17.660
And then do it as the back to mnt.

17:17.660 --> 17:20.300
And the funny thing is that you won't actually notice

17:20.300 --> 17:23.420
any difference whatsoever.

17:23.420 --> 17:25.540
It actually looks completely identical.

17:25.540 --> 17:27.860
Unless you go look at proc mounts,

17:27.860 --> 17:29.100
at which point you're gonna notice

17:29.100 --> 17:31.180
that the file system here is not the ext4,

17:31.180 --> 17:33.020
it's fuse.txt4.

17:34.060 --> 17:35.380
And if you look at the process list,

17:35.380 --> 17:36.860
you're gonna notice that there's an extra process

17:36.860 --> 17:38.300
running in your container now.

17:39.780 --> 17:41.180
So that's pretty sweet because it means

17:41.180 --> 17:46.180
we can literally forward any file system to fuse.

17:46.180 --> 17:48.860
Because it's done at the Cisco layer,

17:48.860 --> 17:51.460
the container doesn't really need to be aware of it.

17:51.460 --> 17:53.540
Like it is not doing anything to the mount commands.

17:53.540 --> 17:55.700
You can just call the mount Cisco at any point

17:55.700 --> 17:57.700
and it will just forward it to fuse

17:57.700 --> 17:59.260
and do the right thing for you.

17:59.260 --> 18:01.420
Which means no change to your workloads whatsoever.

18:01.420 --> 18:02.380
It just works.

18:03.260 --> 18:04.380
So that is pretty cool.

18:05.900 --> 18:09.100
And the last thing I wanted to show in the demo

18:09.100 --> 18:14.100
is if I launch a Alpine Edge container.

18:14.100 --> 18:16.260
So that's gonna be the most info.

18:16.260 --> 18:19.700
And I'm gonna set a memory limit of one gig.

18:24.100 --> 18:25.900
So if I go in there now,

18:27.020 --> 18:28.340
and I look at the free memory,

18:28.340 --> 18:29.660
we can see I've got 16 gigs,

18:29.660 --> 18:32.220
which is considerably more than one gig.

18:32.220 --> 18:34.380
The enforcement is in place.

18:34.380 --> 18:35.980
So that's where problems happen,

18:35.980 --> 18:37.580
is that the enforcement is in place.

18:37.580 --> 18:39.940
Now if you run something that will look

18:39.940 --> 18:41.900
at the free memory output to figure out

18:41.900 --> 18:44.620
how much memory it can claim, it's gonna claim

18:44.620 --> 18:46.500
the wrong amount of memory and it will get killed

18:46.500 --> 18:48.180
by the out of memory killer.

18:48.180 --> 18:49.260
So that's a problem.

18:50.740 --> 18:53.980
Which is why we did the work to fix that

18:53.980 --> 18:55.900
through system co-interception.

18:55.900 --> 19:00.900
So you can do security, Cisco, intercept, sys, info,

19:00.900 --> 19:17.900
sure, and then bounce that container.

19:17.900 --> 19:18.740
Okay.

19:19.780 --> 19:21.540
And if I go in there and I look at free,

19:21.540 --> 19:22.780
and we've got a gig.

19:22.780 --> 19:24.860
So that actually works properly.

19:24.860 --> 19:26.620
It also fixes a bunch of other things.

19:26.620 --> 19:27.940
It doesn't just do the memory,

19:27.940 --> 19:30.580
but also does CPU load, uptime,

19:30.580 --> 19:31.420
and a bunch of other things.

19:31.420 --> 19:32.900
Like the entire struct, sys, info,

19:32.900 --> 19:34.540
is not properly handled.

19:34.540 --> 19:38.260
It's just the easiest use case we have is free on Alpine,

19:38.260 --> 19:40.180
because we know that this command has been changed

19:40.180 --> 19:42.220
to use sys, info instead of the five system.

19:42.220 --> 19:45.500
So it's a very easy one to just prove the concept works.

19:45.500 --> 19:47.100
But that's, that particular piece of work

19:47.100 --> 19:48.340
fixed a whole lot of other things.

19:48.340 --> 19:50.940
I think it also improved Java was using

19:50.940 --> 19:52.580
the wrong interface and the wrong amount

19:52.580 --> 19:54.540
of memory sometimes, so that fixed that.

19:54.540 --> 19:56.140
It fixed a bunch of other stuff.

19:56.140 --> 20:01.140
That was pretty good to have.

20:01.140 --> 20:03.980
All right.

20:03.980 --> 20:04.980
Yeah.

20:04.980 --> 20:08.540
So looking forward, where do we want to take this?

20:08.540 --> 20:12.900
I mean, we've got most of what we wanted covered, really.

20:12.900 --> 20:17.540
Like the big items that are really problematic

20:17.540 --> 20:18.460
have been resolved.

20:18.460 --> 20:21.100
Like Docker was a big one that we really wanted to solve,

20:21.100 --> 20:23.660
and it's working fine.

20:23.660 --> 20:25.260
Alpine behaving, that's really nice.

20:25.260 --> 20:26.260
We're happy with it.

20:26.260 --> 20:26.900
It's good.

20:26.900 --> 20:29.740
The man interception allows for a lot of different stuff now.

20:29.740 --> 20:31.820
It's possible to do things like image building instead

20:31.820 --> 20:32.980
of on previous containers.

20:32.980 --> 20:34.980
You can really do a lot.

20:34.980 --> 20:36.700
And Android seems to be happy, too,

20:36.700 --> 20:40.380
with the tiny bit of stuff we added for that.

20:40.380 --> 20:45.300
The things we'd like to add now are kind of weird stuff, really.

20:45.300 --> 20:48.380
The one I've got in mind, mostly for the sake of it,

20:48.380 --> 20:50.460
but also because I'm sure we found a use case for it,

20:50.460 --> 20:53.780
is to implement init module and finit module.

20:53.780 --> 20:56.020
So the ability to do kernel module loading

20:56.020 --> 20:58.820
from inside of an previous container, which

20:58.820 --> 21:00.900
is as terrifying as it sounds.

21:00.900 --> 21:04.460
But the idea there is that we would not actually

21:04.460 --> 21:07.660
allow for the container to feed us the actual object file

21:07.660 --> 21:09.220
that we would then store at the kernel.

21:09.220 --> 21:11.620
What we would do is we would receive that object file.

21:11.620 --> 21:13.820
We'd look at what the kernel module name is,

21:13.820 --> 21:16.940
look against an allow list that we have of kernel modules that

21:16.940 --> 21:19.060
are fine to dynamically load on the system.

21:19.060 --> 21:20.380
And if it's in that list, then we'll

21:20.380 --> 21:24.580
do the loading using the module from the host system

21:24.580 --> 21:26.700
that we know is correct.

21:26.700 --> 21:28.540
This might help quite a bit with things

21:28.540 --> 21:29.980
like firewalls in containers that

21:29.980 --> 21:33.820
might need to load custom IP tables or a NetFilter modules,

21:33.820 --> 21:35.820
and potentially some other things like file systems

21:35.820 --> 21:37.460
and other things.

21:37.460 --> 21:40.940
So that would be an interesting one to implement.

21:40.940 --> 21:43.220
And I'm sure we're going to have to explain to a lot of people

21:43.220 --> 21:45.140
exactly how it is that we're doing it, because otherwise

21:45.140 --> 21:48.900
they're going to be absolutely terrified.

21:48.900 --> 21:50.660
More EBPF program handling, I think,

21:50.660 --> 21:53.620
is also kind of in our plans.

21:53.620 --> 21:56.580
As I said, we're currently on the intercept of the EBPF

21:56.580 --> 22:00.820
program that's used for device management,

22:00.820 --> 22:04.420
so for allowing device creation, device mapping,

22:04.420 --> 22:06.380
that kind of stuff within containers.

22:06.380 --> 22:11.420
That's because C group 2 removed the devices C group's file

22:11.420 --> 22:13.580
interface and moved to EBPF instead.

22:13.580 --> 22:16.060
So we implemented it that way.

22:16.060 --> 22:18.100
We seem to have some interest for other programs,

22:18.100 --> 22:21.620
like I think SystemD and some other pretty common pieces

22:21.620 --> 22:24.420
of software, now generate a BPF hook

22:24.420 --> 22:27.260
that they hook either globally or on two specific kind

22:27.260 --> 22:28.380
interfaces.

22:28.380 --> 22:30.300
And some of those should be safe.

22:30.300 --> 22:33.100
That should be things that we can effectively pull,

22:33.100 --> 22:35.820
validate that they match the expected pattern.

22:35.820 --> 22:40.340
And if they do, then show that to the kernel, this is fine.

22:40.340 --> 22:43.500
And that should actually make a lot more newer software

22:43.500 --> 22:47.660
that make use of a lot of BPF stuff to just start working.

22:47.660 --> 22:49.820
I don't think we're anywhere near getting something

22:49.820 --> 22:52.620
like a BPF trace working safely inside a container.

22:52.620 --> 22:54.460
That's absolutely terrifying, because it's

22:54.460 --> 22:56.180
got access to all of the kernel constructs,

22:56.180 --> 22:59.100
and that's not something we do.

22:59.100 --> 23:01.740
But some subset of those interfaces

23:01.740 --> 23:04.140
should definitely be fine.

23:04.140 --> 23:08.460
Signed BPF will solve a lot of those problems, probably,

23:08.460 --> 23:10.620
because then you can load unprivileged programs.

23:13.380 --> 23:17.340
And the other thing that I've had in mind for a while,

23:17.340 --> 23:19.620
it's mostly a cool thing, and not something

23:19.620 --> 23:23.500
I've actually had a use case for yet.

23:23.500 --> 23:25.540
Second comp has an interesting property

23:25.540 --> 23:28.140
in that it runs extremely early.

23:28.140 --> 23:33.860
It runs in the system called entry time in the kernel.

23:33.860 --> 23:36.180
Before the system code is resolved,

23:36.180 --> 23:39.700
that means we can intercept system calls that don't exist.

23:39.700 --> 23:42.380
So we can intercept system code numbers that have not yet

23:42.380 --> 23:44.700
been allocated, and that means we

23:44.700 --> 23:47.740
get to actually implement new system calls purely

23:47.740 --> 23:50.260
in user space that you can access

23:50.260 --> 23:53.540
through the normal kernel system code API.

23:53.540 --> 23:54.900
That's super interesting, because it

23:54.900 --> 23:57.660
has to do very easy prototype and testing

23:57.660 --> 23:59.460
of potential system calls.

23:59.460 --> 24:01.220
If you want to try specific interfaces,

24:01.220 --> 24:03.660
see how they look, the layout, what kind of arguments

24:03.660 --> 24:06.540
you want, you can pretty quickly implement system

24:06.540 --> 24:10.380
calls through that, and already show user space software

24:10.380 --> 24:13.280
at it until you're happy with it, at which point you go back

24:13.280 --> 24:15.420
and you do the actual kernel implementation of the system

24:15.420 --> 24:16.500
code.

24:16.500 --> 24:18.060
So that might be pretty interesting.

24:18.060 --> 24:20.060
I don't think anyone has actually done that yet,

24:20.060 --> 24:24.060
but that's a nice property of how second comp works,

24:24.060 --> 24:27.140
that it works before any kind of resolution, any kind of validity

24:27.140 --> 24:28.660
of the system call number.

24:28.660 --> 24:30.780
All that second comp tells us is actually

24:30.780 --> 24:33.820
a system call number, and all of the pointers to the arguments.

24:33.820 --> 24:36.140
It doesn't care whether the thing exists or not,

24:36.140 --> 24:38.020
so it means we get to actually intercept things

24:38.020 --> 24:39.380
that don't exist.

24:39.380 --> 24:42.900
And that's it.

24:42.900 --> 24:45.340
So we can start getting a few questions.

24:45.340 --> 24:46.980
Also on your way out, if you're interested,

24:46.980 --> 24:49.140
we do have AlexD stickers on the table over there,

24:49.140 --> 24:50.940
so feel free to help yourself.

24:50.940 --> 24:52.820
There's a question over there.

24:52.820 --> 24:54.500
I think he's worth the first.

24:54.500 --> 24:56.340
Yeah, there's one here, one there.

24:59.740 --> 25:04.020
When will we see the system call being intercepted by default

25:04.020 --> 25:07.780
on AlexD or other distribution?

25:07.780 --> 25:09.460
Sorry.

25:09.460 --> 25:13.060
When will we see this info calls being default intercepted?

25:13.060 --> 25:15.380
This is going to roll out?

25:15.380 --> 25:19.140
Yeah, we've currently not decided to do any of that by default.

25:19.140 --> 25:23.220
Please leave quietly while we are answering questions.

25:23.220 --> 25:27.060
Yeah, so we've not decided to intercept anything by default

25:27.060 --> 25:28.700
yet.

25:28.700 --> 25:30.340
We consider it to be safe.

25:30.340 --> 25:32.860
The main problem we have is it depends on the kernel version

25:32.860 --> 25:34.140
that you're running, whether it's

25:34.140 --> 25:35.660
going to be working or not.

25:35.660 --> 25:38.460
And it's still recent enough, even though it's 5.1,

25:38.460 --> 25:40.020
which has been around a while now,

25:40.020 --> 25:42.140
it's still recent enough that a bunch of distros

25:42.140 --> 25:43.860
would not work properly.

25:43.860 --> 25:46.100
So we want to wait until we can truly

25:46.100 --> 25:48.500
assume that all of the distros that are like all the long term

25:48.500 --> 25:51.740
support releases are still supported before we can start

25:51.740 --> 25:54.300
doing that kind of stuff by default.

25:54.300 --> 25:56.740
Please keep it down while we are answering questions.

25:56.740 --> 25:59.020
Thank you.

25:59.020 --> 25:59.540
Hello.

25:59.540 --> 26:00.540
Thanks for the great talk.

26:00.540 --> 26:01.860
So I have two questions.

26:01.860 --> 26:03.660
First of all, we have a question.

26:03.660 --> 26:05.780
So I have two questions.

26:05.780 --> 26:07.940
First of all, you said there is this time of check

26:07.940 --> 26:10.780
versus time of use issue.

26:10.780 --> 26:11.980
And so how do you solve it?

26:11.980 --> 26:14.180
I'm trying to give a question, but I can't hear anything.

26:14.180 --> 26:16.140
Hold on.

26:16.140 --> 26:18.940
So first of all, how do you fix this time of check

26:18.940 --> 26:22.740
versus time of use issue, where you call a syscall?

26:22.740 --> 26:25.180
The syscall gets notified.

26:25.180 --> 26:28.020
And you can, well, raise it with another thread

26:28.020 --> 26:30.660
and change some arguments, right?

26:30.660 --> 26:31.660
I didn't really get that.

26:31.660 --> 26:33.780
But if Christian did, you can answer instead,

26:33.780 --> 26:35.060
because you probably know it.

26:42.300 --> 26:45.660
It's extremely noisy.

26:45.660 --> 26:47.700
OK, I'm going to try this.

26:47.700 --> 26:52.500
Stefan, how do you fix the time of check, time of use issue?

26:52.500 --> 26:54.500
OK, so the time of check, time of use issue,

26:54.500 --> 26:59.260
you fix it by never letting the kernel execute after the check.

26:59.260 --> 27:03.900
So you never continue a system call after the check,

27:03.900 --> 27:04.400
effectively.

27:04.400 --> 27:06.780
If you want to intercept a system call,

27:06.780 --> 27:09.620
you are now in charge of running it.

27:09.620 --> 27:12.100
And so you copy the arguments as they are.

27:12.100 --> 27:14.420
You do the check on your copy of them.

27:14.420 --> 27:18.260
You never ever reuse the pointer that the user gave you.

27:18.260 --> 27:20.380
And you go with your own copy of it.

27:20.380 --> 27:22.300
And that's perfectly safe.

27:22.300 --> 27:24.500
But if the argument is a pointer to a string,

27:24.500 --> 27:25.740
you need to copy the string.

27:25.740 --> 27:27.180
And when you're copying the string,

27:27.180 --> 27:28.740
it may be changed under the hood.

27:28.740 --> 27:30.580
So are you actually freezing the process

27:30.580 --> 27:33.980
with something like the cgroup, the freezer cgroup,

27:33.980 --> 27:35.140
for example?

27:35.140 --> 27:38.180
So technically, the calling thread is frozen by the kernel.

27:38.180 --> 27:40.580
But it doesn't prevent another parallel thread

27:40.580 --> 27:43.180
to modify it, which is why we effectively

27:43.180 --> 27:45.020
map the memory of the process.

27:45.020 --> 27:48.140
We copy the entire thing that we care about.

27:48.140 --> 27:49.940
The entire, like if there's pointer or pointers,

27:49.940 --> 27:50.900
we just travel start.

27:50.900 --> 27:52.020
We copy it.

27:52.020 --> 27:55.700
Once we've copied that, that's what we check policy against.

27:55.700 --> 27:57.900
And those are the arguments we're

27:57.900 --> 28:00.580
going to be passing to the actual kernel.

28:00.580 --> 28:04.220
And we just never look back at what came from the process,

28:04.220 --> 28:06.460
which means if they try to erase us at that point,

28:06.460 --> 28:07.660
it doesn't matter.

28:07.660 --> 28:08.980
We create full copies.

28:08.980 --> 28:10.460
We create full copies of everything.

28:10.460 --> 28:12.060
We never continue the system call,

28:12.060 --> 28:14.460
although that's an ability that I added a while back.

28:14.460 --> 28:19.060
So you can even say, continue the system call

28:19.060 --> 28:21.460
if I come to the conclusion that it's fine to do so.

28:21.460 --> 28:24.100
But if you do that, then the kernel

28:24.100 --> 28:29.100
needs to guarantee you that it's safe.

28:29.100 --> 28:32.740
For example, continuing the make-not system call

28:32.740 --> 28:34.740
after you inspected the arguments is safe

28:34.740 --> 28:36.860
because the kernel will just allow the creation

28:36.860 --> 28:38.340
of any device.

28:42.020 --> 28:45.060
So I have another question.

28:45.060 --> 28:50.220
Because you said about MKNOT that if you MKNOT

28:50.220 --> 28:54.500
like this device, that nothing protects you against reading

28:54.500 --> 28:57.460
or writing into this, right?

28:57.460 --> 28:59.820
But there is this devices C group

28:59.820 --> 29:03.820
where you can actually protect this device from being

29:03.820 --> 29:05.100
written to or read from.

29:05.100 --> 29:07.980
And this is what Docker does, for example.

29:07.980 --> 29:11.340
So are you doing this in legacy?

29:11.340 --> 29:13.780
I'm sorry, I only get about 20% of what you're saying.

29:13.780 --> 29:16.300
Well, of times what we'll do is that I'm going to be outside

29:16.300 --> 29:18.940
and we can just talk because you also have questions.

29:18.940 --> 29:20.420
So just follow me and we'll talk.

29:20.420 --> 29:21.940
It's going to be easier.

29:21.940 --> 29:50.900
Thank you very much.
