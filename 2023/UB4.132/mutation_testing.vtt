WEBVTT

00:00.000 --> 00:11.060
No problem. Hello. How's it going, everybody? A lot of people in this room didn't really

00:11.060 --> 00:15.600
expect so many. This is wonderful. Thank you for coming to see us. Just want to say that

00:15.600 --> 00:19.640
we want to talk today about mutation testing. That's what we're here for. If you like this

00:19.640 --> 00:27.480
penguin, does anyone not like this penguin? Just you. Okay. Personal vendetta noted. So

00:27.480 --> 00:33.240
this is a penguin generated by Dolly. Hopefully it's friendly enough because this is going

00:33.240 --> 00:36.680
to be part of our talk. We're going to see a lot of penguins in this talk. If anyone

00:36.680 --> 00:40.680
has a personal objective of penguins, please speak now. Otherwise, if you like penguins,

00:40.680 --> 00:44.280
can I get a hand up just to see? Are we cool with that? Awesome. I've never seen so many

00:44.280 --> 00:47.880
people want to put their hands up but not really be sure. I absolutely love the energy

00:47.880 --> 00:55.040
in this room. My name's Max. I'm this guy. As you can tell, I'm also this guy. But I'm

00:55.040 --> 00:58.920
here to talk to you about mutation testing. I work for a company called Vonage and I'm

00:58.920 --> 01:04.480
a Python developer advocate there. What that means is that I maintain our Python tooling.

01:04.480 --> 01:08.640
I'm here to talk about mutation testing because I've just went through this process myself

01:08.640 --> 01:12.280
of understanding all this stuff and applying it to my own work. I want to show you how

01:12.280 --> 01:17.240
that went. But with me, not only do I have the tallest person in the room. Stand up straight.

01:17.240 --> 01:25.480
I don't know. This person is 196 centimeters tall. I'm 177. I'm not sure. I'm average in

01:25.480 --> 01:29.320
Britain. In this place, right? This person knows a lot more about mutation testing than

01:29.320 --> 01:33.720
me. I'm really not the expert here but I just want to say this is Parko.

01:33.720 --> 01:39.400
I'm Parko. I work for Opavaleo, a small consulting company in the Netherlands. I got into mutation

01:39.400 --> 01:44.960
testing via my thesis. When I wrote my thesis on test effectiveness, I wanted to learn more

01:44.960 --> 01:49.240
about mutation. After that, I got into speaking at conferences and spreading the word about

01:49.240 --> 01:54.640
this awesome tool. I hope at the end of the tool you have another cool tool in your toolbox

01:54.640 --> 02:00.720
to write better code. Awesome. If we're cool with that, we do have

02:00.720 --> 02:03.960
to do the obligatory. These companies paid for us to come here and pay for our flights

02:03.960 --> 02:09.240
and stuff. What my company does, I'll just quickly tell you. We do communications APIs

02:09.240 --> 02:14.640
as a service basically. Things like SMS, voice calls, video chats, two-factor authentication,

02:14.640 --> 02:19.640
all via API. That's what we do. That's really just what I want to say. It is relevant because

02:19.640 --> 02:24.160
I'll show you what I actually applied this to which was one of our SDKs.

02:24.160 --> 02:27.960
For me, we don't actually have a product to sell. Also, definitely didn't fly here from

02:27.960 --> 02:34.880
the Netherlands just to make sure. It's just a two-hour car drive. We're here just a consultancy

02:34.880 --> 02:38.840
company and we really like to share knowledge. That's mostly the reason why I'm here to tell

02:38.840 --> 02:43.640
you more and teach you more. Quite simple. He doesn't have the funding crush that I

02:43.640 --> 02:49.040
do unfortunately. Luckily, we're all good. There's two of us on this talk. There's two

02:49.040 --> 02:52.960
of us here. Actually, there is a third person in this talk. We've seen a hint about this

02:52.960 --> 02:57.400
person already. This person's really the thing that's going to tie this whole talk together

02:57.400 --> 03:01.120
and it's going to get us all feeling good about mutation testing. This person's very

03:01.120 --> 03:09.480
important. Say hello to Henry. This is Henry. Look at his little face. Heck yeah. Hands

03:09.480 --> 03:14.840
up if you think Henry's a cute AF penguin. That's frick. Thank you very much. Yes, I'm

03:14.840 --> 03:19.520
glad we agree. I'm glad we're on the same page. Now, just some quick audience participation

03:19.520 --> 03:24.000
because if you can't tell, we're quite big on audience participation. Quick question

03:24.000 --> 03:28.200
here. Who has heard of this stock photo but more importantly, who's heard of testing?

03:28.200 --> 03:32.120
This is just a check to see if we found the room. Thank you very much. Great stuff. Okay.

03:32.120 --> 03:36.480
Who's heard about code coverage? A lot of people, maybe not everybody and that's okay

03:36.480 --> 03:41.160
if you haven't. We're going to talk about code coverage. Please don't worry if you haven't.

03:41.160 --> 03:45.080
It's awesome to know that some people have. That's a good starting point too. Okay. Final

03:45.080 --> 03:49.960
one. I'm going to say other than via knowing about this talk, who's heard of mutation testing?

03:49.960 --> 03:56.320
Oh, quite a few. Yeah. Quick break in. Who actually was already using mutates testing?

03:56.320 --> 04:03.480
Ah, nice. There are enough quick wins here. Hopefully, you have some good experiences.

04:03.480 --> 04:08.000
Yeah. Really nice to see that people are familiar with the concept. If you're not, it's also

04:08.000 --> 04:11.200
okay because we're going to go through this like you don't know anything at all. When

04:11.200 --> 04:15.200
I started doing this a few months ago, I didn't know anything at all. I want to take you through

04:15.200 --> 04:19.560
that journey as well. That's what we're going to do. Before that, what I want to do first

04:19.560 --> 04:23.200
is give us some background. What I actually really want to do is pass the Paco who knows

04:23.200 --> 04:27.480
a lot more about this than me. I'm going to pass to you right now. This is going to be

04:27.480 --> 04:34.120
some improvising. Good luck. I'm going to drink water with this. I'll feed you. Nice. Great.

04:34.120 --> 04:38.120
So yeah, we're first going to talk a bit about testing in general. And then we're going to

04:38.120 --> 04:43.160
more specifically talk about unit testing. So just a quick check. Does anybody know what

04:43.160 --> 04:47.960
a unit test is? That's great. I don't have to explain that part. For those who don't

04:47.960 --> 04:52.040
know, it's the smallest possible test you can write in your code base. Just in one method

04:52.040 --> 04:56.280
and you write one test for it to test the outcome of the method. Now, there are many

04:56.280 --> 05:01.920
different reasons why we're writing unit tests. And I think one of them, my favorite or the

05:01.920 --> 05:06.800
most used one is for maintenance. Rewrite tests because we want to be confident in the

05:06.800 --> 05:10.600
changes we make to our code base. So whenever we make a small change, we add a new field

05:10.600 --> 05:15.120
to some endpoint that we know that we didn't completely break the database integration

05:15.120 --> 05:23.760
because it can happen at times. So yeah, that's very important. Maintenance regression testing.

05:23.760 --> 05:28.800
But there are more reasons. One I like also a lot is tests can actually serve documentation

05:28.800 --> 05:35.960
purposes as documentation. You can use tests to describe certain scenarios in your code

05:35.960 --> 05:40.160
base that when you have a specific test for that, it already makes clear this is intended

05:40.160 --> 05:45.720
behavior. And I have some example. I have an example for this, which is I worked for

05:45.720 --> 05:51.160
a company where we had an endpoint that returned warehouses. And these warehouses, just the

05:51.160 --> 05:55.400
domain object, had a soft delete. So there was a flag in there that indicated whether

05:55.400 --> 06:01.800
it was deleted or not. And at some point, so this endpoint returned both deleted and

06:01.800 --> 06:06.680
non-deleted warehouses. And at some point over time, as we were working on it, a new

06:06.680 --> 06:11.360
guy came in and looked at it and said, hmm, that's strange. Why are we returning deleted

06:11.360 --> 06:16.480
warehouses? Why would you want that? It was a fair question because we also forgot. And

06:16.480 --> 06:20.880
there was only one test which tested the success flow. And you can already kind of guess here

06:20.880 --> 06:24.760
a bit. So the success flow in this case, I mean, they only returned non-deleted warehouses

06:24.760 --> 06:29.960
in the test. So he made the changes. And we all thought, oh, this makes sense. It looks

06:29.960 --> 06:33.840
broken. Of course, didn't check with product management. The product team deployed it.

06:33.840 --> 06:38.760
And then you can guess, of course, this was broken. So we had to revert it. And the whole

06:38.760 --> 06:43.800
lesson here was just one test which also included a negative scenario with tests with warehouses

06:43.800 --> 06:47.160
that were deleted could have already been a trigger to think like, hey, this behavior

06:47.160 --> 06:53.640
is intended. And that's where tests can serve as sort of a documentation purpose. Also very

06:53.640 --> 06:57.440
useful in getting to learn a new code base. So whenever you're on a new code base, you

06:57.440 --> 07:01.920
have this very complicated method. A test can help you step through the method to sort

07:01.920 --> 07:07.120
of explain what's going on, for example, while debugging it.

07:07.120 --> 07:13.240
Another one, this one is here for the consultant. So who here works as a consultant? Oh, not

07:13.240 --> 07:19.360
that many. Wow. Because we're sort of the root of all evil always. We tend to run to

07:19.360 --> 07:24.720
the next project. And we don't have to maintain our own code often, not always. And so I have

07:24.720 --> 07:32.560
this nice quote that's mostly also for us. Keep in mind that you're not doing this only

07:32.560 --> 07:39.360
for yourself. I had a colleague who once told me, keep in mind that you always have this

07:39.360 --> 07:42.680
point in your development process where you think, OK, should I write a unit test for

07:42.680 --> 07:46.200
this? It's going to be a painful unit test. I know that it works. Do we really have to

07:46.200 --> 07:51.360
document it? We all know how it works. Yeah, sure. We all know how it works. But we also

07:51.360 --> 07:56.520
leave the project and then go on and go to another project. We as in consultants. And

07:56.520 --> 08:01.520
I was speaking to myself, what would I do if I would be the next person? So what would

08:01.520 --> 08:05.240
what would I do if I were the next John or Jane Doe working on this project? So tests

08:05.240 --> 08:09.560
are not there just for you, but also for the next person working.

08:09.560 --> 08:13.960
I would like to jump in here because I've been that person. Thank you. I've been the

08:13.960 --> 08:18.360
person who works on a project after someone's left that. And honestly, if you have good

08:18.360 --> 08:21.800
documentation or if you don't have that, if you have good testing, thank you, you do your

08:21.800 --> 08:26.400
water break. So if you have good testing, it can really help you understand what a project

08:26.400 --> 08:31.280
does. And so when I came to a certain project recently, I didn't have necessarily the kind

08:31.280 --> 08:35.280
of testing that I would have liked to really document my code that well. And so, like,

08:35.280 --> 08:38.080
honestly, if I had someone like Parker, who actually was a bit more conscientious with

08:38.080 --> 08:41.240
what they tested, that would have really helped me get on board with the project quickly.

08:41.240 --> 08:45.080
But as it was, this was a real problem for me. And it was something that we want to hopefully

08:45.080 --> 08:48.800
avoid other people having to deal with as well. Like quick question, actually, has anybody

08:48.800 --> 08:52.880
ever taken over a code base that they may be look at and go, what the heck is this?

08:52.880 --> 08:56.960
Okay. So you know what the point of this is of this slide, right? You know why we're saying

08:56.960 --> 09:00.120
this. We know this is important. Now let's stop that from happening to the next generation

09:00.120 --> 09:03.160
of very pain developers, right? Let's stop that happening.

09:03.160 --> 09:09.360
Yes. So write tests. And so if all these reasons haven't convinced you, there's often maybe

09:09.360 --> 09:14.000
a team lead or a boss or somebody else who's telling you to write tests. In most cases,

09:14.000 --> 09:21.160
there's always, of course, exceptions. Ah, okay. Wow. This is annoying. So at the end

09:21.160 --> 09:26.240
of the day, we're all writing tests. If it's not for ourselves, then it's for someone else.

09:26.240 --> 09:29.640
And as we're, even though we're now sort of happily all adding tests, we also have to

09:29.640 --> 09:35.240
sort of sketch a problem scenario here. And this problem is that as projects evolve and

09:35.240 --> 09:41.360
grow, our tests also evolve and grow. But the problem is that we do refactor a lot and

09:41.360 --> 09:45.120
we spend a lot of time on keeping our production code clean and well monitored. We have lots

09:45.120 --> 09:49.520
of metrics. Where, on the other hand, for tests, what you can see on long-living projects

09:49.520 --> 09:53.000
is that sometimes you just get tests where nothing more than a blank set up and tear

09:53.000 --> 09:59.800
down and some mocking going on because the functionality already moved long ago. Which

09:59.800 --> 10:04.880
means to the point that test code is often not monitored. Test code is sort of the kid

10:04.880 --> 10:10.920
that didn't get all the attention it needed. So there is still one metric for testing.

10:10.920 --> 10:17.600
What do you think is the most used metric for test code? Yes. Yeah. We sort of gave

10:17.600 --> 10:21.840
it away already in the intro. But yes. Yes. Code coverage. Code coverage tells you how

10:21.840 --> 10:26.600
much of the code is executed when you run the test suite. And I personally really like

10:26.600 --> 10:30.640
code coverage because it already helps you write more and better tests. And I want to

10:30.640 --> 10:37.320
go through a simple example here to show you how it can already help you. So here we have

10:37.320 --> 10:43.320
a submit method. So this is the Python guy. I'm the Java guy. Yeah. He said simple example.

10:43.320 --> 10:49.120
But I don't speak that much. Yeah. So the context is you're at a conference and you

10:49.120 --> 10:55.480
have a service where you can submit proposals. You can only have you can't have more than

10:55.480 --> 11:02.280
three or more proposals and you can submit after the deadline. If you do that there will

11:02.280 --> 11:06.840
be a failure and otherwise you will get success. So quite a simple method with everything as

11:06.840 --> 11:11.080
a parameter just to make it easy to explain. So if you would take method coverage. Method

11:11.080 --> 11:15.280
coverage is the simplest coverage metric we can get which checks is this method coverage

11:15.280 --> 11:23.080
as a no. We can add one simple test called a test X which submits a proposal. There are

11:23.080 --> 11:30.040
no open proposals which is good. We have a deadline that's 999 seconds in the future.

11:30.040 --> 11:33.440
So great. Now we can get a step further. We can get into statement coverage. And with

11:33.440 --> 11:39.040
statement coverage we check if each statement was executed. And now we see hey we didn't

11:39.040 --> 11:45.640
cover our unhappy flow. So we need to add another test. In this case we add another

11:45.640 --> 11:51.320
test which has five open proposals which means this check evaluates to true and we have a

11:51.320 --> 11:57.040
negative scenario. And we can even go one step further through for example condition

11:57.040 --> 12:03.240
coverage. And with condition coverage we check if each Boolean subexpression has been evaluated

12:03.240 --> 12:07.880
to both true and false. Because what we don't know now is whether our deadline check is

12:07.880 --> 12:12.440
actually working. We just know that it returns false but we haven't seen it return true yet.

12:12.440 --> 12:19.520
So we add one more test now with a deadline that is 999 seconds in the past. And now we

12:19.520 --> 12:23.320
have three tests. And this is already why I like code coverage so much. Because it really

12:23.320 --> 12:28.760
helps you write proper tests. Proper it helps you write tests because let me get on to the

12:28.760 --> 12:34.400
good part here. As I said write better and more tests. Code coverage is really easy and

12:34.400 --> 12:38.280
cheap to measure. In most I think most of languages it's just a matter of instrumenting

12:38.280 --> 12:42.920
the code. You run the test suite and you get a nice report out of it that everybody can

12:42.920 --> 12:50.000
quickly see and you can quickly see the pain points of where you're lacking in testing.

12:50.000 --> 12:54.280
But to get a bit further so it guarantees as I mentioned it shows you what you didn't

12:54.280 --> 12:59.200
test. But the only guarantee and I'm going to get to the bad parts next is that the only

12:59.200 --> 13:03.960
thing that shows you what you did test didn't crash. It doesn't guarantee anything actually

13:03.960 --> 13:10.040
about the functionality. Because code coverage can actually be quite misleading. It doesn't

13:10.040 --> 13:16.040
guarantee any test quality. So if I take this method for example this is a valid unit test.

13:16.040 --> 13:21.120
This test generates coverage. It calls a method. But there is no assertion on the result which

13:21.120 --> 13:26.400
makes this test for example generate 80% coverage. Yet the test actually only guarantees it's

13:26.400 --> 13:32.480
that the method doesn't crash. It doesn't tell us whether it's true or false or anything.

13:32.480 --> 13:37.480
And this is the pain point of code coverage which brings us to something nice which Max

13:37.480 --> 13:41.080
told me about which is called the good hot slow. So can you maybe explain a bit about

13:41.080 --> 13:52.240
that? Can I grab your clicker? Can I explain about good hot slow? No, sorry. Just kidding.

13:52.240 --> 13:57.520
So when a metric becomes a target it ceases to be a good metric. So quick question. Has

13:57.520 --> 14:02.720
anyone ever written a unit test just to get coverage up rather than because the test was

14:02.720 --> 14:08.720
useful? Come on, let's be honest. This is the safe space. Okay. Microphone. Okay. Hello

14:08.720 --> 14:15.720
everybody. Welcome to the live stream. This is our radio announcer voice. Right. So this

14:15.720 --> 14:19.200
is something I'll be honest I've done this. We now know a lot of people in the room have

14:19.200 --> 14:22.520
done this. But what we don't want to have is with code coverage. It's supposed to tell

14:22.520 --> 14:26.240
us something about our code. But if instead we turn that into a target that can really

14:26.240 --> 14:30.120
limit what we actually, you know, what the kind of useful tests that we actually create.

14:30.120 --> 14:33.480
And that leads to a few quite big questions that we do genuinely care about. So I'll wait

14:33.480 --> 14:40.320
for that photo if you. Cool. Sorry, I'm very audience participation. I'm very sorry. So

14:40.320 --> 14:43.480
the next question that we ask there is how do we know if our tests are high quality?

14:43.480 --> 14:49.440
How do we know if these tests are actually good quality tests? We test them. Great. Great

14:49.440 --> 14:53.520
answer. I've got a further follow up question for you. How can we understand what our tests

14:53.520 --> 15:03.560
are really doing? Same answer. If anyone I see a hand. I literally had a code base where

15:03.560 --> 15:08.560
I could delete half the tests and nothing changed. And they all yeah. So I'm in delete

15:08.560 --> 15:28.720
half the code. Hello. Yes. So I'm just for the livestream. I'll just repeat that because

15:28.720 --> 15:31.560
that's a really good point. I won't repeat this wearing, but I do understand and appreciate

15:31.560 --> 15:36.600
that, you know, that emotion behind it. If you end up, you know, shipping some code that

15:36.600 --> 15:40.400
does not do what it's supposed to do. You end up with users getting very angry at you

15:40.400 --> 15:44.480
and yeah, that's a problem. That's going to be an issue. And that is a way of finding

15:44.480 --> 15:48.440
out. But I guess the real question we're asking here is how do we know if we can trust our

15:48.440 --> 15:54.800
tests? That's really the crux of this problem. And so as it turns out, the very famous Roman

15:54.800 --> 16:01.160
poet, Juvanal, actually in 100 AD after he had a few drinks, he was able to summarise

16:01.160 --> 16:04.160
this in such a beautiful way. And this was something that maybe wasn't appreciated at

16:04.160 --> 16:08.440
the time because, you know, obviously he was talking about mutation testing 2000 years

16:08.440 --> 16:14.600
before it was relevant. But I will mention it here. It's who watches the watches, right?

16:14.600 --> 16:18.440
And this is the question. Who's testing our tests? Who cares about that? How do we actually

16:18.440 --> 16:21.760
gain trustworthiness for our tests? And I see there's people in production who's having

16:21.760 --> 16:26.560
bugs. There's people who understand here that this is a really big deal. Luckily, we have

16:26.560 --> 16:33.880
a two word answer for you, which is the reason we're all in this room. Mutation testing. So

16:33.880 --> 16:39.240
put the odd one out. You might see here, that's Henry. He's having a great time. But maybe

16:39.240 --> 16:43.000
he shouldn't be still in a row of pigeons. But more importantly right now, I'll just

16:43.000 --> 16:46.480
explain the basic premise and then Paco here will explain in a little more detail how it's

16:46.480 --> 16:50.640
actually kind of done. So first of all, mutation testing. This is a really quick summary. What

16:50.640 --> 16:54.000
you do is you introduce some faults in your code. So just a few little things that you

16:54.000 --> 16:59.400
change. And for each of those little changes, that's a mutant version of your code. Once

16:59.400 --> 17:03.600
you've got that, you run your test suite against those mutant versions of your code. And if

17:03.600 --> 17:11.680
they fail, awesome. Because that means that your tests have actually picked up that change.

17:11.680 --> 17:16.000
And that's a good thing. That's good. We want those tests to fail if our code changes. But

17:16.000 --> 17:21.600
if they don't fail, that's a bad time. Because that means those tests didn't test that change.

17:21.600 --> 17:26.080
It didn't test for that. And so that's something that could have made it to production. So

17:26.080 --> 17:30.560
what mutation testing kind of gives you is a way to evaluate that test quality. But this

17:30.560 --> 17:34.880
is very abstract. So let's look at penguins. I like penguins. So Henry here, he's a great

17:34.880 --> 17:39.280
example. And he's going to bring all this home. So I was kind of unfamiliar to the topic.

17:39.280 --> 17:42.440
So I kind of created some analogies with penguins that really helped me. So I'll share those

17:42.440 --> 17:46.800
with you. So the way I kind of imagined my software is we do lots of stuff with messaging.

17:46.800 --> 17:51.360
And so I imagine software that works properly to be like a pigeon or a dove, like a bird

17:51.360 --> 17:54.920
that can fly. I've used a dove here because Paco has a deadly fear of pigeons. He's terrified

17:54.920 --> 18:00.200
of them. Not fear. Vendetta. He has a personal vendetta against pigeons. Sorry. He doesn't

18:00.200 --> 18:04.000
like them. So I've used a dove here. But ideally we want something that I can tie a message

18:04.000 --> 18:08.640
to the bird's leg and it can go and deliver that message for me. So it can go do something

18:08.640 --> 18:14.360
like that. So one of the key features of penguins is that they're not very good at flying.

18:14.360 --> 18:18.880
Can we all agree that that's probably not the best? If you want to tie a message to

18:18.880 --> 18:22.540
a bird's leg and get it to deliver it, a penguin might not be the bird you choose unless you

18:22.540 --> 18:26.920
may be delivering something underwater. So this is the kind of example here where we've

18:26.920 --> 18:31.040
got a bird, but it's not the kind of thing that performs the way we expect it to. And

18:31.040 --> 18:33.720
this would cause some serious problems if we tried to use this kind of thing in production.

18:33.720 --> 18:37.520
If we wanted to send a message via a penguin, we're going to have a tough time, right? So

18:37.520 --> 18:41.240
Paco, I'd like you, if possible, to explain this in a way that makes more sense than what

18:41.240 --> 18:48.160
I just did. Good luck. We only have one mic. It's a bit stiffly.

18:48.160 --> 18:52.400
Yeah. So let's get into the process of mutation testing. The first step of mutation testing.

18:52.400 --> 18:58.960
So what Max just taught you is about introducing faults. So you can introduce faults manually,

18:58.960 --> 19:02.040
but this is a process that's, well, manually, and that means it's a lot of work and it's

19:02.040 --> 19:05.880
usually also not that reproducible. You don't want to do it manually. We want to do this

19:05.880 --> 19:11.520
in an automated manner. This is where mutates testing comes in. In the first step of mutation

19:11.520 --> 19:15.880
testing, we're going to generate mutants. And each mutant is just a very tiny version

19:15.880 --> 19:20.840
of the production code. Mutates testing works with the concept of mutators, and mutators

19:20.840 --> 19:25.480
are the ones that are making these very small changes.

19:25.480 --> 19:31.400
So what we have in this case, we have a perfectly fine DOV, which is the production code. And

19:31.400 --> 19:36.840
then at the end of it, we have a mutator which generates, makes a tiny change, which kind

19:36.840 --> 19:41.040
of transforms this into Henry, our penguin who can fly, and we want our software to fly.

19:41.040 --> 19:45.960
So this would be a bad thing. So how does it look? Because this is still a bit abstract.

19:45.960 --> 19:52.040
I'm going to give you some examples. This would be an example here. So for the Dutch,

19:52.040 --> 19:55.640
and I think for other countries as well, you have to be 17 years in order to apply for

19:55.640 --> 20:00.760
driving license. This could be code that's in your code base, which will fly, which is

20:00.760 --> 20:07.240
good. Now, the mutant would be the entire code base stays the same, and just this little

20:07.240 --> 20:10.800
piece change. So here we inverted the logic. This is, of course, a bug. This is something

20:10.800 --> 20:16.720
we don't want to manage and get into production. And actually, just from this single line,

20:16.720 --> 20:22.680
we can already generate quite some mutants, because we can not only avert the conditional

20:22.680 --> 20:27.800
operator, we can also change the conditional boundaries. So this means that we now have

20:27.800 --> 20:33.640
age larger than 17, which is a very nice bug that would force us to test the edge cases,

20:33.640 --> 20:39.960
the famous off by one errors, whether we forgot our equal operation in our conditional check.

20:39.960 --> 20:43.960
This will help you find that one. But it can also just return always true or false. We

20:43.960 --> 20:48.640
can generate quite some mutants for this, and we can do the same for, for example, mathematical

20:48.640 --> 20:54.880
operations. We can make each plus into a minus, each multiplication into a division, et cetera.

20:54.880 --> 20:59.880
And there are more. We also have the ability to remove statements. So in this case, we

20:59.880 --> 21:04.880
have a method that adds a published date to some object. And we can also just remove the

21:04.880 --> 21:08.640
whole setter. And now this means that we have a bug in which we don't set this attribute

21:08.640 --> 21:15.000
anymore, which is something that, of course, we don't want to make to production. What's

21:15.000 --> 21:18.960
important to note here is that with mutates testing, it's always important that the code

21:18.960 --> 21:22.920
actually compiles, because we're not testing the compiler. We're testing the code. The

21:22.920 --> 21:28.000
compiler is definitely out of scope here. Now at the end of step one, we have a lot

21:28.000 --> 21:37.880
of Henry's. We have a lot of mutants. And now Henry is going to try to fly. So he already

21:37.880 --> 21:42.520
got his wings ready to try to fly. And now for each Henry, we're going to run the test

21:42.520 --> 21:47.840
suite. And if this test suite fails, as Max already mentioned, then we have, then we,

21:47.840 --> 21:51.040
then it's good because then we expose Henry 40s, which is just a penguin, something that

21:51.040 --> 21:56.760
can't fly. So this is great. The not so happy scenario is where the test passed, which means

21:56.760 --> 22:01.720
that Henry made it into production. And as we know, well, assuming that it also got through

22:01.720 --> 22:07.360
the PR, of course, we have more than just tests. Is that a problem? Because Henry is

22:07.360 --> 22:11.640
not supposed to fly. And now we have a bug into production. So this is something that

22:11.640 --> 22:18.320
you don't want. So this is the theory of mutates testing. And now, Max, you can tell a bit

22:18.320 --> 22:23.680
more about the frameworks. Sure. It works for me.

22:23.680 --> 22:28.440
Alrighty. So first of all, I just want to say I'm so proud of this prompt. I don't know

22:28.440 --> 22:33.200
why Dali chose this, but I'm really happy. Like I think I typed in penguin trying to

22:33.200 --> 22:39.120
be a pigeon and it came up with this and I'm very happy. Okay. So moving on, yeah, frameworks.

22:39.120 --> 22:43.480
So this is going to get a little bit more specific to, you know, to actually implementing

22:43.480 --> 22:50.440
this stuff. So anyone here who is a Python developer? Heck yeah. Alright. Awesome. So

22:50.440 --> 22:54.800
I'm going to show you what I did in Python. So as you can see, you know, Parker is a Java

22:54.800 --> 22:58.280
developer. He'll explain Java in a sec. But I'll just show you the kind of basic concepts

22:58.280 --> 23:03.840
but using my code and using what I did. So there's two kind of main supported packages

23:03.840 --> 23:07.080
that you can use in Python. It's not like in Java there's an enterprise thing you can

23:07.080 --> 23:12.720
get. In Python it's very community supported. So you're not going to get big products. But

23:12.720 --> 23:18.560
what we do have are these nice supported reposts for mutates testing which have these packages.

23:18.560 --> 23:22.800
So I am not a professional. In this I'm not a doctor, I'm not a lawyer, I'm not a professional

23:22.800 --> 23:27.720
financial advisor. I'm just a person who has a certain opinion. And so my opinion of those

23:27.720 --> 23:33.120
two frameworks I showed you, there's mutmut and cosmic ray. And personally I prefer mutmut.

23:33.120 --> 23:38.400
Because it's easier to get going. Oh, angry face, shaken hairs. You don't like mutmut.

23:38.400 --> 23:51.120
We will talk later. So if we have time, we'll have a third presenter very shortly. So for

23:51.120 --> 23:57.160
now while I've still got the mic, while I'm still here, we'll talk about mutmut. And so

23:57.160 --> 24:02.000
this framework is quite simple to use. The reason I kind of like it is because it's very

24:02.000 --> 24:06.200
much you install it and you run it. There's a bit of config you can do. But really it's

24:06.200 --> 24:09.960
quite simple just to get an idea of your code base and what's going on. So I want to show

24:09.960 --> 24:14.920
you this slide. This is the SDK that I maintain. And I'm showing you this because it's what

24:14.920 --> 24:19.120
I've applied my mutation testing to. So it's where I'm showing my examples. But basically

24:19.120 --> 24:25.320
what we do is when we go here, I had this locally first of all. So I installed mutmut

24:25.320 --> 24:29.000
with pip install. It's that simple. It's a Python package. It's what we do. If you went

24:29.000 --> 24:34.920
to my talk a mile earlier, you know why that's a bad idea. But I did it. So after we do that,

24:34.920 --> 24:39.720
we've got mutmutrun which just runs those tests for you. So when we do that, I'll show

24:39.720 --> 24:43.440
you what my output was. So when I ran this myself, I actually got a whole lot of this

24:43.440 --> 24:47.720
output. But really what's important here is that first of all, it ran my entire test suite.

24:47.720 --> 24:51.320
And the reason it ran my entire test suite is just to check how long that's supposed

24:51.320 --> 24:55.140
to take and just to make sure everything does work as expected. Because there's various types

24:55.140 --> 24:59.800
of mutants to do with timeouts as well that we might want to consider. After it's done

24:59.800 --> 25:04.560
that, what it will do is it will generate mutants based on the lines of code in my code

25:04.560 --> 25:09.560
base. That's what it will do. And once it's done that, it will run my tests against those.

25:09.560 --> 25:13.320
So there's a few different types. And it can characterize them like this. So the first

25:13.320 --> 25:16.880
type is mutants that we've caught, not killed. We never kill a penguin. We love penguins.

25:16.880 --> 25:22.480
We catch them. We've caught them and put them back into the zoo. In this case, we've managed

25:22.480 --> 25:26.920
to say, yep, our test failed. That's great. But it could be the case where the mutant's

25:26.920 --> 25:31.360
timed out. So it's taken way too long for this code to run. Or it's taken enough time

25:31.360 --> 25:36.000
that we feel like we're not so feeling great about that code. Alternatively, we might end

25:36.000 --> 25:40.200
up in a situation where the mutant survived and made it through our test code. In that

25:40.200 --> 25:44.780
case, it corresponds to a bug that might make it to production. So when I ran this on my

25:44.780 --> 25:50.920
particular SDK, what I saw was that we checked the stuff. I created 682 mutants, versions

25:50.920 --> 25:56.280
of my code with changes in them. And it managed to catch 512 of those, but it managed to miss

25:56.280 --> 26:02.920
170 of them. Now, if that's a good number or a bad number, we'll talk about later. But

26:02.920 --> 26:07.880
what's important now is let's just look at some of those mutants. So first of all, the

26:07.880 --> 26:11.240
ones that we actually did catch, here's a couple of examples. So here's a line where

26:11.240 --> 26:15.160
basically we say here are some valid message channels. So for our messages API, here's

26:15.160 --> 26:19.840
some valid message ways you can send, right? But what's important here is that this basically

26:19.840 --> 26:24.880
removed the ability to send an SMS. And so when I tried to test that, it failed, which

26:24.880 --> 26:30.160
is what we want to see. Here's another one. Again, this is Python. So if you're a Java

26:30.160 --> 26:35.520
dev, don't worry, we'll look after you soon. And here's another one. We've got a decorator

26:35.520 --> 26:40.360
here which basically runs this method. And we can see when we remove that, that will

26:40.360 --> 26:44.340
never happen. This is actually through pedantic if anyone has used that before. But basically

26:44.340 --> 26:48.800
it means that we're not going to round a number anymore. And so when we test for that, a number

26:48.800 --> 26:54.600
doesn't get rounded and we catch that. But that is not really very interesting. That

26:54.600 --> 26:57.120
doesn't tell us anything. That tells us about this much, right? It doesn't tell us much

26:57.120 --> 27:02.360
at all. And the reason for that is that we kind of know that our test work for that.

27:02.360 --> 27:06.560
Thank you very much. I'll do the M&M thing. So we kind of know that our test worked for

27:06.560 --> 27:11.480
that. And so what's kind of useful is to see if we do much show, we can see the mutants

27:11.480 --> 27:19.480
that we didn't catch. We can also do HTML which shows us essentially an HTML coverage

27:19.480 --> 27:24.360
output as well so we can see in a list all of the mutants that we didn't catch. So with

27:24.360 --> 27:28.840
much show on that code base that I just showed you, we can see the 170 meters that survived.

27:28.840 --> 27:32.400
It shows you the indices of these. And then we can manually specify the ones we want to

27:32.400 --> 27:38.820
look at. So here we can see, for example, that we changed the authentication method

27:38.820 --> 27:42.280
to fail. And we can see in this case we caught that because we did a test for authentication

27:42.280 --> 27:47.960
and it failed so that's great. But more importantly, though, is you get this HTML output which

27:47.960 --> 27:52.600
you can then explore. You can explore every method, every sort of module that you have.

27:52.600 --> 27:56.480
You can explore all the methods inside of there and which ones were and were caught.

27:56.480 --> 28:02.000
And you do that with the HTML command. So to do that, I'll just show you this is a mutant

28:02.000 --> 28:05.240
that we did not catch. And I want to show you why we didn't catch it and what it's going

28:05.240 --> 28:08.480
to do. And I'll just do that for a few just so you get some context if that's cool. So

28:08.480 --> 28:14.080
first of all, what this mutant did was it renamed the logger. Now, I think logging is

28:14.080 --> 28:17.680
out of scope of my test code. So personally, I don't care too much about anything related

28:17.680 --> 28:25.040
to logging. So I don't mind if I don't get a pass here. Here's another one. In this case,

28:25.040 --> 28:29.320
what we do is we've slightly changed the value of a constant. This is just part of a function

28:29.320 --> 28:32.080
signature. And we don't, again, we don't care about this that much. This isn't something

28:32.080 --> 28:38.440
that I really mind about. What's more important, though, is this mutant here. Because this

28:38.440 --> 28:42.880
is from a client class where we instantiate all of our different API classes. And you

28:42.880 --> 28:47.560
can see we actually set voice to none. So we completely remove that instantiation and

28:47.560 --> 28:53.320
our tests are still passing. So the reason that actually still works, our test code still

28:53.320 --> 28:58.000
works, even though this isn't testing that case, is because our tests actually, they

28:58.000 --> 29:01.800
test the voice API separately. They call it manually. But if our clients are calling it

29:01.800 --> 29:05.440
like this, maybe we should have a test for this as well. So this tells me, hey, maybe

29:05.440 --> 29:10.080
my test suite does need to be expanded. Does that make sense? I'm seeing some very, very

29:10.080 --> 29:14.840
like, yeah, yeah, that makes sense. I like it. Awesome. Okay. So if you are a Python dev,

29:14.840 --> 29:17.640
this isn't the end of the talk, by the way. We've got some more context and we'll show

29:17.640 --> 29:22.020
you about CI. But if you are interested, feel free to scan this. You've got four seconds

29:22.020 --> 29:27.880
before I move slides. And as I move slides, in slow motion, I'll be passing over this

29:27.880 --> 29:34.880
microphone. This was just Python, of course. I think there are more non-Python devs here.

29:34.880 --> 29:42.320
Not Python. We, of course, have more frameworks. I think there are more languages out there,

29:42.320 --> 29:46.800
but I think they're the most important ones that I like personally. And pretty much the

29:46.800 --> 29:52.240
only really good one for Java is PyTest. And we also have Striker. And Striker is one that

29:52.240 --> 29:57.080
supports quite some languages. It supports JavaScript, C sharp, Scala. Of course, it doesn't

29:57.080 --> 30:03.800
do this in one to each one has their own dependencies, because you can't have one solution for all.

30:03.800 --> 30:07.800
But what you particularly like about it is that it supports JavaScript. And this brings

30:07.800 --> 30:13.680
this kind of back-end heavy tool. Testing is usually mostly, I think, in front-end can

30:13.680 --> 30:18.920
use some law when it comes to testing often. This also brings the testing frameworks and

30:18.920 --> 30:22.440
the testing quality more to the front-end. So that's what I really like.

30:22.440 --> 30:28.400
But we wanted to discuss a bit more. Mike's already sort of introduced it. So what is

30:28.400 --> 30:35.440
a good mutation score? We had the Goodhart's law where we sort of saw that code coverage

30:35.440 --> 30:41.520
can also lead to people implementing tests just to improve coverage, not just sort of

30:41.520 --> 30:45.440
defeats the purpose. You're doing it just for the metric, not for the actual purpose.

30:45.440 --> 30:51.880
And how does this work with mutation score? Now, first, here's a picture of how PyTest

30:51.880 --> 30:58.560
report looks. So not to bash on Python, but much prettier and much clearer. Because now,

30:58.560 --> 31:01.840
particularly what is interesting about this one, it shows you both the line coverage and

31:01.840 --> 31:06.080
the mutation coverage. We can ignore the test train. And this shows us the sweet spots in

31:06.080 --> 31:10.880
a report. Because at the end, we have generated a lot of mutants. We have a lot of classes.

31:10.880 --> 31:13.800
And we only have very little time. So where are we going to look and investigate this

31:13.800 --> 31:18.240
report and see where the strains are? And the one that's the least interesting here

31:18.240 --> 31:22.960
is the notification service. The notification service also doesn't have any coverage. And

31:22.960 --> 31:25.920
if there's no coverage, then the mutants are also not interesting because you have a bigger

31:25.920 --> 31:30.880
problem here, which is you don't have tests at all for this. Then you have a choice. You

31:30.880 --> 31:34.280
have the proposal service and proposed service too. Now, the fact that they are named equally

31:34.280 --> 31:39.440
is because they're from another example. But proposed service too is the one that has 100%

31:39.440 --> 31:43.200
coverage, and yet it didn't kill a single mutant. And this is the sweet spot. Because

31:43.200 --> 31:48.080
this means that we have code that is well tested, or at least there's tests that covering

31:48.080 --> 31:52.120
this piece of code. But there's no single bug that was caught. So this deserves some

31:52.120 --> 31:56.440
attention because it means that we didn't fully test this. So these are the hotspots

31:56.440 --> 32:00.840
where you open a report. The ones with high line coverage and low mutation coverage, those

32:00.840 --> 32:04.600
are the ones you really want to go through. Those are the ones that give you the findings

32:04.600 --> 32:08.760
to go through a team and say, hey, see, we need mutation testing. Because here, just

32:08.760 --> 32:14.160
these two classes alone already, it showed me that we need to improve our quality.

32:14.160 --> 32:22.440
And now back to the score. So the example we had, we managed to kill 512 out of 682

32:22.440 --> 32:29.840
mutant, which is about a 75% score. Now, the question is, is this a good score?

32:29.840 --> 32:32.280
Is this a good score?

32:32.280 --> 32:40.880
Yes, yes. The golden answer. It depends. I love that answer. We already saw that 100%

32:40.880 --> 32:45.120
doesn't make sense. Things like logging, and there are more things like generated code,

32:45.120 --> 32:49.600
et cetera, things that you don't necessarily want to test, even though there are mutates

32:49.600 --> 32:53.440
generators for it. There are a couple things you can, of course, do. You can also, depending

32:53.440 --> 32:57.720
on the language and the framework you use, you can tweak the mutation testing framework

32:57.720 --> 33:02.200
quite a bit. For example, the PyTest version actually out of the box already ignores and

33:02.200 --> 33:08.040
doesn't mutate any logging lines. And all the big frameworks are known to the tool.

33:08.040 --> 33:12.120
So anything that goes to SLF4J, it doesn't mutate it. So it also doesn't appear in your

33:12.120 --> 33:17.240
report, which is quite nice. And you can easily add things. Like if you have a custom metrics

33:17.240 --> 33:20.760
facade somewhere, also typically something you don't want to cover in unit tests, you

33:20.760 --> 33:26.360
can add that as well. So the thing here is that mutates testing is not really a score

33:26.360 --> 33:30.360
you want to achieve. It's more that the report can be interesting to look at and gives you

33:30.360 --> 33:34.600
sort of the nice spots. And once you completely set it up nice and you're familiar with the

33:34.600 --> 33:38.240
report, you can maybe start looking at the score, but definitely it shouldn't become

33:38.240 --> 33:43.200
an 80% goal or something like it was with code coverage. It's just there, it goes through

33:43.200 --> 33:52.720
the report instead. So now we've sort of discussed all the tools you need. We have discussed

33:52.720 --> 34:02.000
the frameworks. We have discussed the technology. And now it's time, of course, for you to fly.

34:02.000 --> 34:07.520
So how would you get started on this? And the thing that's important here is if you

34:07.520 --> 34:12.040
want to start, so you now think, oh, this is a great talk. I want to start with mutates

34:12.040 --> 34:17.200
testing. Depending on the size of your project, it might be wise to just start with just a

34:17.200 --> 34:22.280
single package. I've done this on projects that are a couple of, say, thousand lines

34:22.280 --> 34:27.040
big. And even though in Max's example we had 682 mutants, this can also, depending on the

34:27.040 --> 34:31.360
kind of code you have, easily grow to tens of thousands of mutants, which can be quite

34:31.360 --> 34:34.440
slow. It can also be that there's something weird in your code base that doesn't really

34:34.440 --> 34:39.680
work well with mutation testing or something that's just extremely slow. An example that

34:39.680 --> 34:46.720
I had was that we had, so what's good to keep in mind is actually just to take a side step,

34:46.720 --> 34:52.200
the mutates testing framework also measures in the beginning for each individual test

34:52.200 --> 34:57.480
which code it covers. So there's a nice graph from code, production code, to the tests.

34:57.480 --> 35:02.080
It helps us optimize because if we want to run the entire test suite, all the tests for

35:02.080 --> 35:06.200
every single mutant is going to take endless. Instead, because we know the coverage, we

35:06.200 --> 35:10.120
can also see if we mutate this one line, we know which tests to discover, so we only need

35:10.120 --> 35:15.320
to execute those few tests. But what if you have tests that actually cover half your code

35:15.320 --> 35:20.240
base? For example, one of the things you can do in Java is if you're doing things with

35:20.240 --> 35:23.560
Spring is you can actually boot up the entire Spring application and start doing acceptance

35:23.560 --> 35:29.560
tests from your unit tests, which is typically not necessarily the worst thing to do, but

35:29.560 --> 35:33.760
you now have a very slow test that does cover half your code base that will be executed

35:33.760 --> 35:37.520
for each single mutant. So these are things you want to get rid of. You want to exclude

35:37.520 --> 35:43.520
this acceptance test because otherwise you're going to be waiting endlessly. So my point

35:43.520 --> 35:47.200
about starting locally and starting small was start just with one package. Start with

35:47.200 --> 35:51.040
the utility package to see if it works, see if the report works for you, and then from

35:51.040 --> 35:56.040
there you can expand, add more packages, and also you can see, oh, now it's taking ten

35:56.040 --> 36:02.440
times as long. Why is this? And you can find the painful packages there. So as I mentioned,

36:02.440 --> 36:06.920
you can exclude some tests, and also there are often candidates, certain pieces of code

36:06.920 --> 36:12.040
you might want to exclude. For example, there's no use in testing generated code, but also

36:12.040 --> 36:17.840
it might be that you have certain domain packages that contain just all your domain objects,

36:17.840 --> 36:23.040
your POJOs, which just setters and getters, something that you also typically want to

36:23.040 --> 36:27.520
exclude to your coverage report. You might also want to exclude this from code mutation,

36:27.520 --> 36:35.000
some of it from mutation testing. And now that's done. So we talked about running it

36:35.000 --> 36:39.880
on your machine. We also can do this in the cloud, of course.

36:39.880 --> 36:46.040
Thank you. So as you can see, there's a pigeon on this slide, and Paco, as we've said, has

36:46.040 --> 36:51.740
a personal vendetta, so I've taken over this section. So here we can see that we're going

36:51.740 --> 36:55.520
to run off our machine. So why would you want to run off your machine rather than on your

36:55.520 --> 36:57.520
machine? Any questions? Any ideas?

36:57.520 --> 37:00.520
What happens in the background?

37:00.520 --> 37:03.560
Yes. So what happens in the background is what we said there. Any other reason you might

37:03.560 --> 37:09.120
want to run non-locally? No. I've got a couple. Oh, oh, hand.

37:09.120 --> 37:10.120
CI.

37:10.120 --> 37:12.740
CI. Yeah, you might want to end your CI system. In fact, that's what we'll be showing you.

37:12.740 --> 37:19.260
So foreshadowing. I like it. So yeah, it takes some time. And if you're using a CI system,

37:19.260 --> 37:23.080
you get to use those cloud resources. And also what's important is that you can, if

37:23.080 --> 37:26.920
you've got code which is maybe dependent on different OSes, might behave differently,

37:26.920 --> 37:31.400
you can specify different versions and platforms to run on as well.

37:31.400 --> 37:35.680
So stop talking. I hear you cry. Well, I'm afraid this is what we're here for, but unfortunately,

37:35.680 --> 37:39.360
I will be keeping talking, but what I will do is show it a bit of an example.

37:39.360 --> 37:44.560
So I applied this to my code base, my own code base myself, into my CI system. So you

37:44.560 --> 37:49.040
can see here, this is GitHub actions. And I've got a piece of YAML, essentially. I've

37:49.040 --> 37:54.980
got this mutation test.YAML file. And what that does is sets up an action for me to use.

37:54.980 --> 37:59.360
So this is something that I manually run. And I can do this here. So I manually run

37:59.360 --> 38:03.240
that. And what it will do is do the mutation test non-locally, and it will produce some

38:03.240 --> 38:08.400
HTML output for me to look at. Now, that seems, you know, I'll go a little bit into what that

38:08.400 --> 38:12.120
YAML does, but it seems like something that should be able for everyone to do themselves

38:12.120 --> 38:15.880
if they want to. So GitHub actions, the reason I show that partly is because what we use,

38:15.880 --> 38:19.600
but also, you know, it's free for open source projects. So, you know, it's been useful for

38:19.600 --> 38:22.680
me because I've not had to pay for it. So, you know, just a heads up.

38:22.680 --> 38:26.280
So, yeah, I'll be showing you this with GitHub actions really quickly. And I'll show you

38:26.280 --> 38:29.760
the YAML. I'll show you what I did. Hopefully by the end of this, the next couple of slides,

38:29.760 --> 38:34.320
you will see how easy it is actually to do this and why actually this is all good and

38:34.320 --> 38:40.000
maybe you want to try this yourself when you get home. So here's some YAML. First of all,

38:40.000 --> 38:43.320
this is our mutation test YAML. It's got one job. It's pretty simple. All we're doing,

38:43.320 --> 38:47.960
we're running on Ubuntu. Running one specific Python version to do this. Depending on what

38:47.960 --> 38:54.800
your test base is, oh, they run a great time in there. Or there is thunder. So basically,

38:54.800 --> 38:58.160
we have, yeah, we're testing on one version for me because my code doesn't vary enough

38:58.160 --> 39:03.160
between versions and OSes, so for me, it's not relevant to do that. But if we look at

39:03.160 --> 39:07.320
this next slide, I'll show you the workflow that goes through when I actually run this

39:07.320 --> 39:11.840
action. So first of all, we check out the code. Then we set up a version of Python with

39:11.840 --> 39:16.640
it. Once we've done that, we actually install our dependencies, including our mutmut as well

39:16.640 --> 39:20.400
as our regular dependencies. So now we've got the new mutation testing framework installed

39:20.400 --> 39:25.520
here as well on this kind of test runner. Then what we do is we run a mutation test.

39:25.520 --> 39:28.960
So we do that with mutmutrun. But because we're running in a CI system, we don't want

39:28.960 --> 39:32.880
insanely long logs and due to how it's outputted, we want a no progress flag there just to show

39:32.880 --> 39:36.680
that we're not seeing every line of output, we just see the important parts. We also have

39:36.680 --> 39:40.960
the CI flag, which is one of my only contributions to actual open source. But I added that and

39:40.960 --> 39:47.560
I'm kind of proud of myself. So that basically means that you get a good sensible output,

39:47.560 --> 39:51.520
like return code, when you run in a CI system. Because the default for mutmut is depending

39:51.520 --> 39:55.600
on the type of mutants that we call, it will give you a different exit code that is non-zero.

39:55.600 --> 39:59.520
So you kind of need to consider that or to suppress that with some scary, scary bash.

39:59.520 --> 40:05.240
That's what I did at first. That's why I wrote the flag. Once we've done that, we save it

40:05.240 --> 40:09.160
as HTML and we upload it so you can access that yourself as well.

40:09.160 --> 40:12.280
So that's it. That's the whole piece of YAML. It's 35 lines. And that set up the entire

40:12.280 --> 40:15.800
mutation test for my suite. So you can see, hopefully, does this seem kind of easy? I

40:15.800 --> 40:20.280
think it seems pretty gentle to do, at least in this sort of scope. If you're a Java dev

40:20.280 --> 40:23.840
with a 20,000 line project, you might want to be a bit more careful. But if you've got

40:23.840 --> 40:26.280
a Python hobby thing, try it out, right? Try it out.

40:26.280 --> 40:32.680
What I would say, there are some more concerns. So first of all, I chose to run this manually

40:32.680 --> 40:38.160
when I want to run it. I chose not to run this on push or PR. I chose to run this manually.

40:38.160 --> 40:41.720
And the reason for that is that I don't expect my code base to sufficiently change between

40:41.720 --> 40:46.440
like small commits. And what I want to do is really not use mutation tests as that kind

40:46.440 --> 40:50.560
of score, that 75%. I don't want that to be a metric for me that I've just turned into

40:50.560 --> 40:55.000
a target. I want it to stay as just a good idea, an indicator of what my tests are doing

40:55.000 --> 40:58.600
and what I could be doing better. So for me, I don't want to run every time, partly because

40:58.600 --> 41:03.320
it takes a blooming long time, especially if I'm using multiple versions, which we also

41:03.320 --> 41:07.360
have to factor in. So you might want to do that. So I didn't. I just ran on Ubuntu and

41:07.360 --> 41:10.240
that was fine for me. But yeah, it depends on what your code is. You might want to run

41:10.240 --> 41:13.440
on different platforms, right? So do factor that in. And that will help you a lot if you're

41:13.440 --> 41:16.160
in a CI system.

41:16.160 --> 41:19.280
So the other question there is, should we run on push or PR? My opinion is no. I think

41:19.280 --> 41:22.520
there will be people in this room who disagree with me. Maybe say on a PR you should run

41:22.520 --> 41:26.000
that or maybe there's some kind of metric you want to associate with score that you

41:26.000 --> 41:29.880
then want to look at in some way. For me, that's not how I use mutation testing. And

41:29.880 --> 41:34.000
I think what I want to get out of this is we don't want a situation where mutation

41:34.000 --> 41:36.840
testing becomes a new target. We've got to get a certain score. Because then we're just

41:36.840 --> 41:40.520
kind of abstracting that problem of code coverage targets. We're just doing that all over again,

41:40.520 --> 41:43.560
right? So we're trying to avoid that.

41:43.560 --> 41:47.960
So the final question here is one I'll ask of Paco to explain. Paco, do you think I should

41:47.960 --> 41:51.960
use mutation testing in my role as an audience member right now? What do you reckon?

41:51.960 --> 41:59.400
Yes. Well, so it was there already. It depends. There are some things you can ask yourself.

41:59.400 --> 42:05.480
Because it needs a question. So mutation testing is, of course, definitely not a silver bullet.

42:05.480 --> 42:09.480
It's something that the reports take quite some time to go through. And of course, it's

42:09.480 --> 42:14.080
quite computationally expensive to run the process.

42:14.080 --> 42:21.240
So the couple of questions that you can ask yourself that are quite obvious are for projects

42:21.240 --> 42:26.080
which have a really high quality goal. When people die or when a lot of money is lost

42:26.080 --> 42:30.320
or a combination of those two. So just to check, how many of you are working on a project

42:30.320 --> 42:32.040
that fits in these three?

42:32.040 --> 42:36.880
Okay, then you need this yesterday.

42:36.880 --> 42:42.040
Yes. But for the rest of the room, including me, there are some other questions we can

42:42.040 --> 42:46.440
ask ourselves. And I think one of the important ones is are you using code coverage? Because

42:46.440 --> 42:51.360
if you're not using code coverage, let's start with that. And let's first get coverage and

42:51.360 --> 42:53.360
get to see how many tests you have.

42:53.360 --> 42:58.240
Then the next question is, is how much value do you put into this? How much value do you

42:58.240 --> 43:03.080
get out of this code coverage? And what I mean with that is, do you make decisions based

43:03.080 --> 43:08.360
on it? Is like a definition of done on your sprint or is it with a built fail if there's

43:08.360 --> 43:14.440
80% coverage or also in the case of due diligence, you're selling a company, not something we

43:14.440 --> 43:19.160
also would do, but you would also want to know how well is the software I'm buying or

43:19.160 --> 43:22.000
how well is the software I'm working on?

43:22.000 --> 43:25.640
So here I would say, if you're using code coverage and you're making decisions based

43:25.640 --> 43:29.680
on that code coverage, then yes, you should at least have a look at mutation testing to

43:29.680 --> 43:34.520
see what the state is. You don't have to do this always. You don't have to put it in CI.

43:34.520 --> 43:39.000
Just once a year or go home rather than your computer once just to see what the current

43:39.000 --> 43:41.640
state of your team is. Because it's going to very well be that you're on a high performing

43:41.640 --> 43:46.240
team which already has their PRs and everything so well and set up that it's not worth the

43:46.240 --> 43:51.800
time maybe. Because apparently the mutation testing report might even confirm that, the

43:51.800 --> 43:54.920
fact that you killed all the mutants. So that would be great.

43:54.920 --> 44:00.840
And there's another question that I like. What's the cost of fixing a bug? And I have

44:00.840 --> 44:05.360
two stories for this. My first example is, and it's the first company I worked for, this

44:05.360 --> 44:10.520
was an enterprise company that built software that was running on premise at the customer

44:10.520 --> 44:16.800
and the customer was often in government. And then you're in the line with all these

44:16.800 --> 44:20.880
big integrators which means you have feature freezes and moments where you can actually

44:20.880 --> 44:24.560
go to the customer and deploy your software. Which is quite expensive. Which also means

44:24.560 --> 44:31.040
that if you get a bug after this feature freezer, after this upgrade window, you have a serious

44:31.040 --> 44:34.880
issue because you need to go to the customer. You need to explain what went wrong. It's

44:34.880 --> 44:39.840
a very costly thing. A very costly issue. So here definitely, again, mutation testing

44:39.840 --> 44:44.040
can be quite interesting because a lot of money can be involved in reputation.

44:44.040 --> 44:50.000
The other example that I had was more of a greenfield project which had more of the start-up

44:50.000 --> 44:54.760
vibes where it was really of a fill fast and fix fast mentality. So this was a project

44:54.760 --> 45:00.480
where rather than focusing on getting our quality monitoring up to speed, we were mostly

45:00.480 --> 45:07.160
focusing on making sure that we could very quickly fix bugs as well. It was of course

45:07.160 --> 45:11.480
running on-premises in the cloud so we could control it. And the most important goal was

45:11.480 --> 45:15.720
there to just click a button and be in production again in 10 minutes and have active monitoring

45:15.720 --> 45:20.200
to see if anything goes wrong. Here the cost of fixing a bug is already a lot lower which

45:20.200 --> 45:25.800
means that the reason to consider it might be a bit less. Especially if you're again

45:25.800 --> 45:30.280
in a, for example, a high-performing team which all work into each other. You know what

45:30.280 --> 45:35.760
you're doing. You know you can trust each other because you're really, you're all professionals.

45:35.760 --> 45:39.400
Maybe it's not worth to also spend half a day going through a mutatist report if you

45:39.400 --> 45:43.240
already know what the outcome is probably going to be. Again still do it once. These

45:43.240 --> 45:47.120
are two things you could consider in when to use it. So those are the things I want

45:47.120 --> 45:51.920
to give away with you is don't go into it blindly. Just ask yourself should I really

45:51.920 --> 45:55.080
use it? And then for the last part.

45:55.080 --> 46:01.040
For the last part I'd just like to sum up. So I think hopefully if we've gotten here

46:01.040 --> 46:05.440
we've kind of shown you what mutation testing is, why you might want to consider using it

46:05.440 --> 46:09.360
and how you could possibly get going starting with running that and also why you should.

46:09.360 --> 46:12.600
So if we're here I just want to summarize first of all I'm sorry I used this penguin

46:12.600 --> 46:17.360
as an evil penguin earlier. It is adorable. I just like that Dali when I asked it to give

46:17.360 --> 46:20.600
it some fake wings it gave it three. It gave it this extra flipper here. I'm not sure what

46:20.600 --> 46:25.040
that was for. But what I'd like to do is just quickly summarize what we've talked about

46:25.040 --> 46:32.840
today. First of all mutation testing is a way to test your tests. It helps you to beat

46:32.840 --> 46:37.160
the problem where you're using good hot slow for coverage. It saves you from trying to

46:37.160 --> 46:41.560
turn coverage into a metric that you don't have as a target. You don't want to have code

46:41.560 --> 46:45.320
coverage. It's got to be above this threshold or we don't merge. That's not where we want

46:45.320 --> 46:52.080
to be. What we want to do is write good tests. So if you are going to do this yourself an

46:52.080 --> 46:56.360
important part is to start small. So start locally on your machine. If you've got a big

46:56.360 --> 47:00.440
code base then what you need to do really is run on a subset of that code base. If you've

47:00.440 --> 47:06.960
got a smaller code base like me you're probably okay. Either way start locally on your machine.

47:06.960 --> 47:10.840
You also want to run if you can. If you want asynchronous reports, if you want to use the

47:10.840 --> 47:15.280
resources available on a CI system you can run mutation testing there. So do consider

47:15.280 --> 47:20.720
that if your stuff is in CI. And finally I just want to say that mutants hopefully we've

47:20.720 --> 47:25.040
demonstrated that mutants are like adorable penguins. They're valuable and they are wonderful.

47:25.040 --> 47:28.240
They're really great to use. They can tell you so much about your code. They're extremely

47:28.240 --> 47:35.240
useful. So don't fear them because you should love them. Thank you very much.

47:35.240 --> 47:49.240
If there are any questions, comments, objections, love mail, hate mail, anything? Shout at me.

47:49.240 --> 48:06.440
So the question there was just if we can give some more examples of the kind of range of

48:06.440 --> 48:10.880
things that are possible to mutate. So essentially the short answer is anything that will still

48:10.880 --> 48:16.240
make the code run. So in the Java case the code compiled, in my case the code run. So

48:16.240 --> 48:21.120
in this situation things like I'll give you some Python examples. For example, changing

48:21.120 --> 48:24.680
a variable from a certain type to another so you might type pass something. You might

48:24.680 --> 48:28.520
with a mathematical expression you might add extra terms to that expression. You might

48:28.520 --> 48:34.320
change return types, error types. You might set things to none at any given time. You

48:34.320 --> 48:38.440
might call something and you have removed parts of it. Set things to zero. There's other

48:38.440 --> 48:42.120
stuff. Paco can you think of any mutation testing job?

48:42.120 --> 48:47.600
So I think the examples you gave for that, it depends on the mutators you use. Of each

48:47.600 --> 48:50.560
framework you can also go through the list of mutators to see what kind of mutators are

48:50.560 --> 48:55.760
out there. What's good to keep in mind is that it does use some basic fundamental strategies

48:55.760 --> 49:00.120
to determine if it can be mutated. Because for example if you have a stream and in this

49:00.120 --> 49:04.960
stream you do some operations which you could in theory cut out, you're still using the

49:04.960 --> 49:10.200
return value which means that the mutatistic framework thinks okay let's keep that intact.

49:10.200 --> 49:14.400
The same goes for if you're using the Spring Reactor framework. You could do lots and lots

49:14.400 --> 49:19.760
of smart mutations in there but it's not really there yet. It's really the fundamental things,

49:19.760 --> 49:24.680
the conditional logic, the mathematical logic I think are the two main things you'll see.

49:24.680 --> 49:32.280
And actually also account for often the most typical programming errors I would say.

49:32.280 --> 49:36.640
Awesome. I mean anything you'd like to mutate? Because I guess a lot of these things are

49:36.640 --> 49:40.160
open source. Anything that you might be good if it did exist? Any ideas?

49:40.160 --> 49:41.160
Question? Answer?

49:41.160 --> 49:47.160
Question? So two questions. The first one, could you comment some framework for C and

49:47.160 --> 49:56.160
C++? And the second, what do you think about the idea to force developers or to require

49:56.160 --> 50:06.160
developers to run those mutation tests as a gate hook before pushing only for the duty

50:06.160 --> 50:13.160
of the tests associated with the code which they have actually changed? Just to save

50:13.160 --> 50:21.160
the computational power on the entire machine. Okay, so the question there just for the livestream

50:21.160 --> 50:26.160
was two things. One is are there any mutation testing frameworks for C or C++? I will say

50:26.160 --> 50:30.160
personally I don't know. I haven't used C++ since my physics degree so I couldn't tell

50:30.160 --> 50:33.160
you. I don't know if you know anything about that, Paco.

50:33.160 --> 50:40.160
I just did a quick Google search. That's all. So I see there are some frames available.

50:40.160 --> 50:48.160
I just want to say there is a project by the University of Luxembourg which is called FAQAS.

50:48.160 --> 50:49.160
FAQAS.

50:49.160 --> 50:52.160
And it's not there quite yet.

50:52.160 --> 50:58.160
So based on the search I see there is something for C and also for a bit more for C++. Regarding

50:58.160 --> 51:03.160
your other question by the way, so should you do it as a gate hook? Given that it's

51:03.160 --> 51:04.160
right, that was the question?

51:04.160 --> 51:10.160
The idea was basically to require developers to run those mutation tests but not the whole

51:10.160 --> 51:18.160
set. The only mutation tests which are touching, which are testing the duty tests, which are

51:18.160 --> 51:20.160
tested in code which was modified in this project.

51:20.160 --> 51:24.160
Yeah, so actually there are some, depending on the framework, some have features which

51:24.160 --> 51:28.160
are incremental reports. So where they can just store the last state, then you can do

51:28.160 --> 51:34.160
a diff and use the results from your last execution to not execute all mutants and not

51:34.160 --> 51:37.160
generate all mutants because it knows I only change these production lines so I only need

51:37.160 --> 51:42.160
to generate mutants for these and I only change these tests so I only need to rerun the tests

51:42.160 --> 51:45.160
for these mutants which can tremendously speed it up.

51:45.160 --> 51:51.160
But still using it as a gate hook, I'm not sure. You can, by the way, use the same logic

51:51.160 --> 51:55.160
in the NCI as well to use the incremental reporting that saves a bit despite an also

51:55.160 --> 51:56.160
supports, I think.

51:56.160 --> 52:01.160
Yeah, so with what you have, you have caching, so you can cache those tests that you've done

52:01.160 --> 52:05.160
already and if those cases aren't touched, then you're sort of good if the changes to

52:05.160 --> 52:11.160
your code don't affect that. So that is an option. I would say, yeah, I, thank you, my

52:11.160 --> 52:16.160
opinion is again that maybe you don't want to explicitly mandate this on every run and

52:16.160 --> 52:20.160
the reason for that is it's kind of like it can then become kind of a metric that you

52:20.160 --> 52:23.160
can try and optimize for or something to look at whereas really I think the nice way to

52:23.160 --> 52:27.160
use it is every now and then is how I would say so. I think if you've got a super critical

52:27.160 --> 52:30.160
project where, you know, if that's really important, you may want to run it like that.

52:30.160 --> 52:35.160
For me, I don't need to but I think that's really up to you, up to you as an implementer,

52:35.160 --> 52:38.160
what you want to do and I think there's definitely a use case to do it in that way if that was

52:38.160 --> 52:41.160
important to you.

52:41.160 --> 52:43.160
Hand over here, hello.

52:43.160 --> 52:56.160
Yes, yes, short answer is yes. Long answer is depending on the actual framework, it might

52:56.160 --> 53:01.160
be that you had a comment to ignore it. Alternatively, there is a config file set up as well in

53:01.160 --> 53:06.160
Python where you can say only mutate these paths, only do these things. So what language

53:06.160 --> 53:07.160
do you use?

53:07.160 --> 53:13.160
That's a striker.

53:13.160 --> 53:17.160
I would say yes, I haven't looked that much at the striker but I think there are some

53:17.160 --> 53:22.160
nice stuff, it's quite generic for all frameworks. Exclude code for mutation, definitely yes.

53:22.160 --> 53:27.160
And depending on the framework, some even have nice things like exclude, do not mutate

53:27.160 --> 53:31.160
any calls to these classes which is interesting for the logging, for example, do not mutate

53:31.160 --> 53:36.160
any calls to this logging class but same you can do for packages, class paths, et cetera.

53:36.160 --> 53:40.160
I would say with striker as well, one of my colleagues uses striker because he maintains

53:40.160 --> 53:45.160
.NET SDK and he's also got mutation testing there in striker and it does seem very performant,

53:45.160 --> 53:49.160
it seems like it does have a lot of those features as well. If you're interested in

53:49.160 --> 53:51.160
TypeScript, I think there is something for you there.

53:51.160 --> 53:52.160
Cool.

53:52.160 --> 53:55.160
I think it might be free on open source reposers. Another question?

53:55.160 --> 54:10.160
Are there specific communities that are reproducible for debugging path process?

54:10.160 --> 54:12.160
Actually not a lot of...

54:12.160 --> 54:13.160
Question?

54:13.160 --> 54:18.160
Oh yeah, so the question is how reproducible are the mutants? So if you find one and the

54:18.160 --> 54:22.160
next one, is it still there? So as far as I know, there shouldn't be any randomness

54:22.160 --> 54:26.160
in these mutant generations. It just goes over the code, any condition that it finds

54:26.160 --> 54:30.160
that it can mutate, it will mutate. So the next time you run it, the same mutant should

54:30.160 --> 54:35.160
be there at the same place. So you could also see whether you killed it the next time. So

54:35.160 --> 54:37.160
yes, it's reproducible.

54:37.160 --> 54:55.160
A hand there. I think this person was first.

54:55.160 --> 55:14.160
That's a good question. I'll repeat that one. That's a good one. So the question there

55:14.160 --> 55:18.160
was, so mutation testing, we've talked all the big game. We've come up here and been

55:18.160 --> 55:21.160
like, hey, look, this is important, right? That's what we've talked about. And the question,

55:21.160 --> 55:24.160
which is a very valid question, is hey, if it's so important, why is no one supporting

55:24.160 --> 55:27.160
this question? Why is this all open source stuff? And you know what? I agree. That's

55:27.160 --> 55:31.160
a really good question. It's one I asked as well, to be honest. So now I totally support

55:31.160 --> 55:35.160
the question. And the question I'll probably say is, yeah, why aren't employers supporting

55:35.160 --> 55:41.160
this? The short answer I think is to do with ROI, unfortunately. And that sucks, honestly,

55:41.160 --> 55:45.160
because I would like us to invest more time in certain things. And I think it's just to

55:45.160 --> 55:50.160
do with company priorities, right? So I would like to spend more time. Honestly, I had

55:50.160 --> 55:53.160
quite a lot of fun adding the one feature I did get to add. I'd quite like to do some

55:53.160 --> 55:58.160
more. But again, I've got this API to implement. So do I have time? Well, no one's funding

55:58.160 --> 56:02.160
me to do it. So unfortunately, it really is like, unless there's an obvious ROI, this

56:02.160 --> 56:06.160
just seems to be the way things go. Unfortunately, that's the way we've kind of structured our

56:06.160 --> 56:11.160
platforms and so on. So I gave a talk earlier on PyPy and malware. And there was actually

56:11.160 --> 56:17.160
the reason that that kind of is so prevalent and so possible on PyPy is because PyPy haven't

56:17.160 --> 56:22.160
really implemented many ways to actually protect against malware being uploaded. So currently,

56:22.160 --> 56:26.160
I've uploaded some malware to PyPy that you can get yourself. And actually, the reason

56:26.160 --> 56:32.160
that they, it's not real malware, to be clear, it's a rick roll. But basically, what I'm

56:32.160 --> 56:36.160
trying to say here is that that project kind of didn't really get off the ground in terms

56:36.160 --> 56:39.160
of protecting users, just because I think originally Facebook were funding it and they

56:39.160 --> 56:43.160
stopped funding and that just didn't then continue. So unfortunately, yeah, this is just

56:43.160 --> 56:46.160
kind of the way that things are in open source right now. And yeah, I do feel your pain. I

56:46.160 --> 56:49.160
do understand. But that's all I can really say, I'm afraid.

56:49.160 --> 56:54.160
Yeah, I would quickly add to this, by the way, Striker, for example, is actually funded,

56:54.160 --> 56:59.160
is backed by a company who, for example, let's work in terms work on it as well. So some

56:59.160 --> 57:03.160
frameworks actually are backed and there are people already investing it. So it's not always

57:03.160 --> 57:05.160
bad, but sorry, let's go to that side.

57:05.160 --> 57:09.160
So you showed some HDMI reports for the results of the mutagenet test.

57:09.160 --> 57:10.160
Yes.

57:10.160 --> 57:15.160
We all know all managers and pretty teams loves your KPIs. So I'm wondering, is there

57:15.160 --> 57:36.160
any integration or bringing to export the mutagenet test result in Sona

57:36.160 --> 57:46.160
or anything that's going to happen over the next year?

57:46.160 --> 57:53.160
Yeah, so let's also ask, you were the maintainer of the other framework. So how does it go

57:53.160 --> 57:56.160
for the other by the framework?

57:56.160 --> 57:59.160
So, okay. So I talked about mut-mut not having that facility that feature.

57:59.160 --> 58:01.160
in cosmic rays that.

58:01.160 --> 58:02.160
Well, not really.

58:02.160 --> 58:05.160
In cosmic ray, the moment is kind of a bit unmaintained.

58:05.160 --> 58:07.160
And so the same kind of supplies.

58:07.160 --> 58:11.160
I don't want to say names, but there is a very, very large

58:11.160 --> 58:14.160
450 maybe vendor that uses it.

58:14.160 --> 58:16.160
And we asked them, can you fund development?

58:16.160 --> 58:19.160
They said, you know, no.

58:19.160 --> 58:22.160
They have shown this around at large events, like in front of

58:22.160 --> 58:25.160
thousands and thousands of people.

58:25.160 --> 58:28.160
But yeah, they're like, OK, we keep all the changes for itself

58:28.160 --> 58:31.160
and find it as it is.

58:31.160 --> 58:32.160
So for the Python frameworks.

58:32.160 --> 58:35.160
So we talk about time and balance and effort that you

58:35.160 --> 58:39.160
need to put in to develop all these features and functionalities.

58:39.160 --> 58:43.160
So the core team doesn't have this.

58:43.160 --> 58:45.160
Yeah, so for the Python frameworks, there's not really

58:45.160 --> 58:46.160
CI plugin support.

58:46.160 --> 58:49.160
I do know that, for example, PyTest, there is support for

58:49.160 --> 58:51.160
Jenkins and Sonar.

58:51.160 --> 58:53.160
And I'm not sure about Striker, but I know it's there.

58:53.160 --> 58:57.160
And usually these things are relatively easy to build

58:57.160 --> 58:59.160
yourself with here as well, because all you have to do is,

58:59.160 --> 59:02.160
if there is a report in some JSON file, you can quite easily

59:02.160 --> 59:05.160
parse it and make a nice HTML form about this.

59:05.160 --> 59:08.160
Because again, they're all open for contributions.

59:08.160 --> 59:10.160
Do we have time for one last?

59:10.160 --> 59:13.160
I want to just add to that a little bit.

59:13.160 --> 59:16.160
OK, really quickly, first of all, with your question, yeah,

59:16.160 --> 59:19.160
when I originally implemented my movement thing, I did do it

59:19.160 --> 59:22.160
on PR, and in that case I got an action that would comment my

59:22.160 --> 59:23.160
coverage in a nice, metric-y way.

59:23.160 --> 59:25.160
And so you can, it's quite simple to do.

59:25.160 --> 59:28.160
So about Cosmic Query, first of all, that sucks, and I'm

59:28.160 --> 59:31.160
sorry, that's blooming awful.

59:31.160 --> 59:34.160
Yeah, sadly, it does seem that a lot of what we've kind of

59:34.160 --> 59:36.160
been discussing on the side of the room is just like, man,

59:36.160 --> 59:38.160
it would be good if some, you know, we all agree this is

59:38.160 --> 59:40.160
important, right, and it's useful for a lot of things.

59:40.160 --> 59:41.160
It would be great if someone funded it.

59:41.160 --> 59:44.160
So I think, unfortunately, with Python, that is the state of

59:44.160 --> 59:45.160
play, and it does suck.

59:45.160 --> 59:47.160
But yes, I get you.

59:47.160 --> 59:49.160
Any other questions, finally?

59:49.160 --> 59:50.160
Yes, hello.

59:50.160 --> 59:55.160
Can you write custom notation to motivate your code, you know,

59:55.160 --> 59:56.160
custom logic?

59:56.160 --> 59:58.160
That's a really good question.

59:58.160 --> 01:00:00.160
So, sorry?

01:00:00.160 --> 01:00:01.160
Repeat it.

01:00:01.160 --> 01:00:03.160
That's, I will now repeat your really good question.

01:00:03.160 --> 01:00:07.160
The question was, so the question was, if I have a

01:00:07.160 --> 01:00:10.160
certain type of mutant that I want to make, can I do that?

01:00:10.160 --> 01:00:14.160
So I would say, with the stuff that I used in Python, the

01:00:14.160 --> 01:00:18.160
answer is you need to actually, you know, use the version you've

01:00:18.160 --> 01:00:19.160
downloaded, edit it yourself, and add that stuff.

01:00:19.160 --> 01:00:21.160
So sadly, there's not an easy customizable way.

01:00:21.160 --> 01:00:23.160
That would be an awesome enhancement, though, that I would

01:00:23.160 --> 01:00:24.160
like to see.

01:00:24.160 --> 01:00:26.160
You know, that would be cool.

01:00:26.160 --> 01:00:28.160
In other platforms, Paco, any other?

01:00:28.160 --> 01:00:30.160
I do know that I think Python does have some extension points,

01:00:30.160 --> 01:00:32.160
so it really depends.

01:00:32.160 --> 01:00:35.160
I know that the company I work for currently called Picnic,

01:00:35.160 --> 01:00:37.160
they're also working on extending it, for example, for

01:00:37.160 --> 01:00:38.160
reactive code.

01:00:38.160 --> 01:00:41.160
So there are some extension points often.

01:00:41.160 --> 01:00:47.160
So, in short, it depends on the framework and how easy it is.

01:00:47.160 --> 01:00:48.160
Are we done?

01:00:48.160 --> 01:00:49.160
Okay, we're at time.

01:00:49.160 --> 01:00:50.160
Thank you so much.

01:00:50.160 --> 01:00:51.160
This has been a really nice discussion as well, so thank you

01:00:51.160 --> 01:00:52.160
for sharing yours.

01:00:52.160 --> 01:01:18.160
Thank you.
