1
0:00:00.000 --> 0:00:11.060
No problem. Hello. How's it going, everybody? A lot of people in this room didn't really

2
0:00:11.060 --> 0:00:15.600
expect so many. This is wonderful. Thank you for coming to see us. Just want to say that

3
0:00:15.600 --> 0:00:19.640
we want to talk today about mutation testing. That's what we're here for. If you like this

4
0:00:19.640 --> 0:00:27.480
penguin, does anyone not like this penguin? Just you. Okay. Personal vendetta noted. So

5
0:00:27.480 --> 0:00:33.240
this is a penguin generated by Dolly. Hopefully it's friendly enough because this is going

6
0:00:33.240 --> 0:00:36.680
to be part of our talk. We're going to see a lot of penguins in this talk. If anyone

7
0:00:36.680 --> 0:00:40.680
has a personal objective of penguins, please speak now. Otherwise, if you like penguins,

8
0:00:40.680 --> 0:00:44.280
can I get a hand up just to see? Are we cool with that? Awesome. I've never seen so many

9
0:00:44.280 --> 0:00:47.880
people want to put their hands up but not really be sure. I absolutely love the energy

10
0:00:47.880 --> 0:00:55.040
in this room. My name's Max. I'm this guy. As you can tell, I'm also this guy. But I'm

11
0:00:55.040 --> 0:00:58.920
here to talk to you about mutation testing. I work for a company called Vonage and I'm

12
0:00:58.920 --> 0:01:04.480
a Python developer advocate there. What that means is that I maintain our Python tooling.

13
0:01:04.480 --> 0:01:08.640
I'm here to talk about mutation testing because I've just went through this process myself

14
0:01:08.640 --> 0:01:12.280
of understanding all this stuff and applying it to my own work. I want to show you how

15
0:01:12.280 --> 0:01:17.240
that went. But with me, not only do I have the tallest person in the room. Stand up straight.

16
0:01:17.240 --> 0:01:25.480
I don't know. This person is 196 centimeters tall. I'm 177. I'm not sure. I'm average in

17
0:01:25.480 --> 0:01:29.320
Britain. In this place, right? This person knows a lot more about mutation testing than

18
0:01:29.320 --> 0:01:33.720
me. I'm really not the expert here but I just want to say this is Parko.

19
0:01:33.720 --> 0:01:39.400
I'm Parko. I work for Opavaleo, a small consulting company in the Netherlands. I got into mutation

20
0:01:39.400 --> 0:01:44.960
testing via my thesis. When I wrote my thesis on test effectiveness, I wanted to learn more

21
0:01:44.960 --> 0:01:49.240
about mutation. After that, I got into speaking at conferences and spreading the word about

22
0:01:49.240 --> 0:01:54.640
this awesome tool. I hope at the end of the tool you have another cool tool in your toolbox

23
0:01:54.640 --> 0:02:00.720
to write better code. Awesome. If we're cool with that, we do have

24
0:02:00.720 --> 0:02:03.960
to do the obligatory. These companies paid for us to come here and pay for our flights

25
0:02:03.960 --> 0:02:09.240
and stuff. What my company does, I'll just quickly tell you. We do communications APIs

26
0:02:09.240 --> 0:02:14.640
as a service basically. Things like SMS, voice calls, video chats, two-factor authentication,

27
0:02:14.640 --> 0:02:19.640
all via API. That's what we do. That's really just what I want to say. It is relevant because

28
0:02:19.640 --> 0:02:24.160
I'll show you what I actually applied this to which was one of our SDKs.

29
0:02:24.160 --> 0:02:27.960
For me, we don't actually have a product to sell. Also, definitely didn't fly here from

30
0:02:27.960 --> 0:02:34.880
the Netherlands just to make sure. It's just a two-hour car drive. We're here just a consultancy

31
0:02:34.880 --> 0:02:38.840
company and we really like to share knowledge. That's mostly the reason why I'm here to tell

32
0:02:38.840 --> 0:02:43.640
you more and teach you more. Quite simple. He doesn't have the funding crush that I

33
0:02:43.640 --> 0:02:49.040
do unfortunately. Luckily, we're all good. There's two of us on this talk. There's two

34
0:02:49.040 --> 0:02:52.960
of us here. Actually, there is a third person in this talk. We've seen a hint about this

35
0:02:52.960 --> 0:02:57.400
person already. This person's really the thing that's going to tie this whole talk together

36
0:02:57.400 --> 0:03:01.120
and it's going to get us all feeling good about mutation testing. This person's very

37
0:03:01.120 --> 0:03:09.480
important. Say hello to Henry. This is Henry. Look at his little face. Heck yeah. Hands

38
0:03:09.480 --> 0:03:14.840
up if you think Henry's a cute AF penguin. That's frick. Thank you very much. Yes, I'm

39
0:03:14.840 --> 0:03:19.520
glad we agree. I'm glad we're on the same page. Now, just some quick audience participation

40
0:03:19.520 --> 0:03:24.000
because if you can't tell, we're quite big on audience participation. Quick question

41
0:03:24.000 --> 0:03:28.200
here. Who has heard of this stock photo but more importantly, who's heard of testing?

42
0:03:28.200 --> 0:03:32.120
This is just a check to see if we found the room. Thank you very much. Great stuff. Okay.

43
0:03:32.120 --> 0:03:36.480
Who's heard about code coverage? A lot of people, maybe not everybody and that's okay

44
0:03:36.480 --> 0:03:41.160
if you haven't. We're going to talk about code coverage. Please don't worry if you haven't.

45
0:03:41.160 --> 0:03:45.080
It's awesome to know that some people have. That's a good starting point too. Okay. Final

46
0:03:45.080 --> 0:03:49.960
one. I'm going to say other than via knowing about this talk, who's heard of mutation testing?

47
0:03:49.960 --> 0:03:56.320
Oh, quite a few. Yeah. Quick break in. Who actually was already using mutates testing?

48
0:03:56.320 --> 0:04:03.480
Ah, nice. There are enough quick wins here. Hopefully, you have some good experiences.

49
0:04:03.480 --> 0:04:08.000
Yeah. Really nice to see that people are familiar with the concept. If you're not, it's also

50
0:04:08.000 --> 0:04:11.200
okay because we're going to go through this like you don't know anything at all. When

51
0:04:11.200 --> 0:04:15.200
I started doing this a few months ago, I didn't know anything at all. I want to take you through

52
0:04:15.200 --> 0:04:19.560
that journey as well. That's what we're going to do. Before that, what I want to do first

53
0:04:19.560 --> 0:04:23.200
is give us some background. What I actually really want to do is pass the Paco who knows

54
0:04:23.200 --> 0:04:27.480
a lot more about this than me. I'm going to pass to you right now. This is going to be

55
0:04:27.480 --> 0:04:34.120
some improvising. Good luck. I'm going to drink water with this. I'll feed you. Nice. Great.

56
0:04:34.120 --> 0:04:38.120
So yeah, we're first going to talk a bit about testing in general. And then we're going to

57
0:04:38.120 --> 0:04:43.160
more specifically talk about unit testing. So just a quick check. Does anybody know what

58
0:04:43.160 --> 0:04:47.960
a unit test is? That's great. I don't have to explain that part. For those who don't

59
0:04:47.960 --> 0:04:52.040
know, it's the smallest possible test you can write in your code base. Just in one method

60
0:04:52.040 --> 0:04:56.280
and you write one test for it to test the outcome of the method. Now, there are many

61
0:04:56.280 --> 0:05:01.920
different reasons why we're writing unit tests. And I think one of them, my favorite or the

62
0:05:01.920 --> 0:05:06.800
most used one is for maintenance. Rewrite tests because we want to be confident in the

63
0:05:06.800 --> 0:05:10.600
changes we make to our code base. So whenever we make a small change, we add a new field

64
0:05:10.600 --> 0:05:15.120
to some endpoint that we know that we didn't completely break the database integration

65
0:05:15.120 --> 0:05:23.760
because it can happen at times. So yeah, that's very important. Maintenance regression testing.

66
0:05:23.760 --> 0:05:28.800
But there are more reasons. One I like also a lot is tests can actually serve documentation

67
0:05:28.800 --> 0:05:35.960
purposes as documentation. You can use tests to describe certain scenarios in your code

68
0:05:35.960 --> 0:05:40.160
base that when you have a specific test for that, it already makes clear this is intended

69
0:05:40.160 --> 0:05:45.720
behavior. And I have some example. I have an example for this, which is I worked for

70
0:05:45.720 --> 0:05:51.160
a company where we had an endpoint that returned warehouses. And these warehouses, just the

71
0:05:51.160 --> 0:05:55.400
domain object, had a soft delete. So there was a flag in there that indicated whether

72
0:05:55.400 --> 0:06:01.800
it was deleted or not. And at some point, so this endpoint returned both deleted and

73
0:06:01.800 --> 0:06:06.680
non-deleted warehouses. And at some point over time, as we were working on it, a new

74
0:06:06.680 --> 0:06:11.360
guy came in and looked at it and said, hmm, that's strange. Why are we returning deleted

75
0:06:11.360 --> 0:06:16.480
warehouses? Why would you want that? It was a fair question because we also forgot. And

76
0:06:16.480 --> 0:06:20.880
there was only one test which tested the success flow. And you can already kind of guess here

77
0:06:20.880 --> 0:06:24.760
a bit. So the success flow in this case, I mean, they only returned non-deleted warehouses

78
0:06:24.760 --> 0:06:29.960
in the test. So he made the changes. And we all thought, oh, this makes sense. It looks

79
0:06:29.960 --> 0:06:33.840
broken. Of course, didn't check with product management. The product team deployed it.

80
0:06:33.840 --> 0:06:38.760
And then you can guess, of course, this was broken. So we had to revert it. And the whole

81
0:06:38.760 --> 0:06:43.800
lesson here was just one test which also included a negative scenario with tests with warehouses

82
0:06:43.800 --> 0:06:47.160
that were deleted could have already been a trigger to think like, hey, this behavior

83
0:06:47.160 --> 0:06:53.640
is intended. And that's where tests can serve as sort of a documentation purpose. Also very

84
0:06:53.640 --> 0:06:57.440
useful in getting to learn a new code base. So whenever you're on a new code base, you

85
0:06:57.440 --> 0:07:01.920
have this very complicated method. A test can help you step through the method to sort

86
0:07:01.920 --> 0:07:07.120
of explain what's going on, for example, while debugging it.

87
0:07:07.120 --> 0:07:13.240
Another one, this one is here for the consultant. So who here works as a consultant? Oh, not

88
0:07:13.240 --> 0:07:19.360
that many. Wow. Because we're sort of the root of all evil always. We tend to run to

89
0:07:19.360 --> 0:07:24.720
the next project. And we don't have to maintain our own code often, not always. And so I have

90
0:07:24.720 --> 0:07:32.560
this nice quote that's mostly also for us. Keep in mind that you're not doing this only

91
0:07:32.560 --> 0:07:39.360
for yourself. I had a colleague who once told me, keep in mind that you always have this

92
0:07:39.360 --> 0:07:42.680
point in your development process where you think, OK, should I write a unit test for

93
0:07:42.680 --> 0:07:46.200
this? It's going to be a painful unit test. I know that it works. Do we really have to

94
0:07:46.200 --> 0:07:51.360
document it? We all know how it works. Yeah, sure. We all know how it works. But we also

95
0:07:51.360 --> 0:07:56.520
leave the project and then go on and go to another project. We as in consultants. And

96
0:07:56.520 --> 0:08:01.520
I was speaking to myself, what would I do if I would be the next person? So what would

97
0:08:01.520 --> 0:08:05.240
what would I do if I were the next John or Jane Doe working on this project? So tests

98
0:08:05.240 --> 0:08:09.560
are not there just for you, but also for the next person working.

99
0:08:09.560 --> 0:08:13.960
I would like to jump in here because I've been that person. Thank you. I've been the

100
0:08:13.960 --> 0:08:18.360
person who works on a project after someone's left that. And honestly, if you have good

101
0:08:18.360 --> 0:08:21.800
documentation or if you don't have that, if you have good testing, thank you, you do your

102
0:08:21.800 --> 0:08:26.400
water break. So if you have good testing, it can really help you understand what a project

103
0:08:26.400 --> 0:08:31.280
does. And so when I came to a certain project recently, I didn't have necessarily the kind

104
0:08:31.280 --> 0:08:35.280
of testing that I would have liked to really document my code that well. And so, like,

105
0:08:35.280 --> 0:08:38.080
honestly, if I had someone like Parker, who actually was a bit more conscientious with

106
0:08:38.080 --> 0:08:41.240
what they tested, that would have really helped me get on board with the project quickly.

107
0:08:41.240 --> 0:08:45.080
But as it was, this was a real problem for me. And it was something that we want to hopefully

108
0:08:45.080 --> 0:08:48.800
avoid other people having to deal with as well. Like quick question, actually, has anybody

109
0:08:48.800 --> 0:08:52.880
ever taken over a code base that they may be look at and go, what the heck is this?

110
0:08:52.880 --> 0:08:56.960
Okay. So you know what the point of this is of this slide, right? You know why we're saying

111
0:08:56.960 --> 0:09:00.120
this. We know this is important. Now let's stop that from happening to the next generation

112
0:09:00.120 --> 0:09:03.160
of very pain developers, right? Let's stop that happening.

113
0:09:03.160 --> 0:09:09.360
Yes. So write tests. And so if all these reasons haven't convinced you, there's often maybe

114
0:09:09.360 --> 0:09:14.000
a team lead or a boss or somebody else who's telling you to write tests. In most cases,

115
0:09:14.000 --> 0:09:21.160
there's always, of course, exceptions. Ah, okay. Wow. This is annoying. So at the end

116
0:09:21.160 --> 0:09:26.240
of the day, we're all writing tests. If it's not for ourselves, then it's for someone else.

117
0:09:26.240 --> 0:09:29.640
And as we're, even though we're now sort of happily all adding tests, we also have to

118
0:09:29.640 --> 0:09:35.240
sort of sketch a problem scenario here. And this problem is that as projects evolve and

119
0:09:35.240 --> 0:09:41.360
grow, our tests also evolve and grow. But the problem is that we do refactor a lot and

120
0:09:41.360 --> 0:09:45.120
we spend a lot of time on keeping our production code clean and well monitored. We have lots

121
0:09:45.120 --> 0:09:49.520
of metrics. Where, on the other hand, for tests, what you can see on long-living projects

122
0:09:49.520 --> 0:09:53.000
is that sometimes you just get tests where nothing more than a blank set up and tear

123
0:09:53.000 --> 0:09:59.800
down and some mocking going on because the functionality already moved long ago. Which

124
0:09:59.800 --> 0:10:04.880
means to the point that test code is often not monitored. Test code is sort of the kid

125
0:10:04.880 --> 0:10:10.920
that didn't get all the attention it needed. So there is still one metric for testing.

126
0:10:10.920 --> 0:10:17.600
What do you think is the most used metric for test code? Yes. Yeah. We sort of gave

127
0:10:17.600 --> 0:10:21.840
it away already in the intro. But yes. Yes. Code coverage. Code coverage tells you how

128
0:10:21.840 --> 0:10:26.600
much of the code is executed when you run the test suite. And I personally really like

129
0:10:26.600 --> 0:10:30.640
code coverage because it already helps you write more and better tests. And I want to

130
0:10:30.640 --> 0:10:37.320
go through a simple example here to show you how it can already help you. So here we have

131
0:10:37.320 --> 0:10:43.320
a submit method. So this is the Python guy. I'm the Java guy. Yeah. He said simple example.

132
0:10:43.320 --> 0:10:49.120
But I don't speak that much. Yeah. So the context is you're at a conference and you

133
0:10:49.120 --> 0:10:55.480
have a service where you can submit proposals. You can only have you can't have more than

134
0:10:55.480 --> 0:11:02.280
three or more proposals and you can submit after the deadline. If you do that there will

135
0:11:02.280 --> 0:11:06.840
be a failure and otherwise you will get success. So quite a simple method with everything as

136
0:11:06.840 --> 0:11:11.080
a parameter just to make it easy to explain. So if you would take method coverage. Method

137
0:11:11.080 --> 0:11:15.280
coverage is the simplest coverage metric we can get which checks is this method coverage

138
0:11:15.280 --> 0:11:23.080
as a no. We can add one simple test called a test X which submits a proposal. There are

139
0:11:23.080 --> 0:11:30.040
no open proposals which is good. We have a deadline that's 999 seconds in the future.

140
0:11:30.040 --> 0:11:33.440
So great. Now we can get a step further. We can get into statement coverage. And with

141
0:11:33.440 --> 0:11:39.040
statement coverage we check if each statement was executed. And now we see hey we didn't

142
0:11:39.040 --> 0:11:45.640
cover our unhappy flow. So we need to add another test. In this case we add another

143
0:11:45.640 --> 0:11:51.320
test which has five open proposals which means this check evaluates to true and we have a

144
0:11:51.320 --> 0:11:57.040
negative scenario. And we can even go one step further through for example condition

145
0:11:57.040 --> 0:12:03.240
coverage. And with condition coverage we check if each Boolean subexpression has been evaluated

146
0:12:03.240 --> 0:12:07.880
to both true and false. Because what we don't know now is whether our deadline check is

147
0:12:07.880 --> 0:12:12.440
actually working. We just know that it returns false but we haven't seen it return true yet.

148
0:12:12.440 --> 0:12:19.520
So we add one more test now with a deadline that is 999 seconds in the past. And now we

149
0:12:19.520 --> 0:12:23.320
have three tests. And this is already why I like code coverage so much. Because it really

150
0:12:23.320 --> 0:12:28.760
helps you write proper tests. Proper it helps you write tests because let me get on to the

151
0:12:28.760 --> 0:12:34.400
good part here. As I said write better and more tests. Code coverage is really easy and

152
0:12:34.400 --> 0:12:38.280
cheap to measure. In most I think most of languages it's just a matter of instrumenting

153
0:12:38.280 --> 0:12:42.920
the code. You run the test suite and you get a nice report out of it that everybody can

154
0:12:42.920 --> 0:12:50.000
quickly see and you can quickly see the pain points of where you're lacking in testing.

155
0:12:50.000 --> 0:12:54.280
But to get a bit further so it guarantees as I mentioned it shows you what you didn't

156
0:12:54.280 --> 0:12:59.200
test. But the only guarantee and I'm going to get to the bad parts next is that the only

157
0:12:59.200 --> 0:13:03.960
thing that shows you what you did test didn't crash. It doesn't guarantee anything actually

158
0:13:03.960 --> 0:13:10.040
about the functionality. Because code coverage can actually be quite misleading. It doesn't

159
0:13:10.040 --> 0:13:16.040
guarantee any test quality. So if I take this method for example this is a valid unit test.

160
0:13:16.040 --> 0:13:21.120
This test generates coverage. It calls a method. But there is no assertion on the result which

161
0:13:21.120 --> 0:13:26.400
makes this test for example generate 80% coverage. Yet the test actually only guarantees it's

162
0:13:26.400 --> 0:13:32.480
that the method doesn't crash. It doesn't tell us whether it's true or false or anything.

163
0:13:32.480 --> 0:13:37.480
And this is the pain point of code coverage which brings us to something nice which Max

164
0:13:37.480 --> 0:13:41.080
told me about which is called the good hot slow. So can you maybe explain a bit about

165
0:13:41.080 --> 0:13:52.240
that? Can I grab your clicker? Can I explain about good hot slow? No, sorry. Just kidding.

166
0:13:52.240 --> 0:13:57.520
So when a metric becomes a target it ceases to be a good metric. So quick question. Has

167
0:13:57.520 --> 0:14:02.720
anyone ever written a unit test just to get coverage up rather than because the test was

168
0:14:02.720 --> 0:14:08.720
useful? Come on, let's be honest. This is the safe space. Okay. Microphone. Okay. Hello

169
0:14:08.720 --> 0:14:15.720
everybody. Welcome to the live stream. This is our radio announcer voice. Right. So this

170
0:14:15.720 --> 0:14:19.200
is something I'll be honest I've done this. We now know a lot of people in the room have

171
0:14:19.200 --> 0:14:22.520
done this. But what we don't want to have is with code coverage. It's supposed to tell

172
0:14:22.520 --> 0:14:26.240
us something about our code. But if instead we turn that into a target that can really

173
0:14:26.240 --> 0:14:30.120
limit what we actually, you know, what the kind of useful tests that we actually create.

174
0:14:30.120 --> 0:14:33.480
And that leads to a few quite big questions that we do genuinely care about. So I'll wait

175
0:14:33.480 --> 0:14:40.320
for that photo if you. Cool. Sorry, I'm very audience participation. I'm very sorry. So

176
0:14:40.320 --> 0:14:43.480
the next question that we ask there is how do we know if our tests are high quality?

177
0:14:43.480 --> 0:14:49.440
How do we know if these tests are actually good quality tests? We test them. Great. Great

178
0:14:49.440 --> 0:14:53.520
answer. I've got a further follow up question for you. How can we understand what our tests

179
0:14:53.520 --> 0:15:03.560
are really doing? Same answer. If anyone I see a hand. I literally had a code base where

180
0:15:03.560 --> 0:15:08.560
I could delete half the tests and nothing changed. And they all yeah. So I'm in delete

181
0:15:08.560 --> 0:15:28.720
half the code. Hello. Yes. So I'm just for the livestream. I'll just repeat that because

182
0:15:28.720 --> 0:15:31.560
that's a really good point. I won't repeat this wearing, but I do understand and appreciate

183
0:15:31.560 --> 0:15:36.600
that, you know, that emotion behind it. If you end up, you know, shipping some code that

184
0:15:36.600 --> 0:15:40.400
does not do what it's supposed to do. You end up with users getting very angry at you

185
0:15:40.400 --> 0:15:44.480
and yeah, that's a problem. That's going to be an issue. And that is a way of finding

186
0:15:44.480 --> 0:15:48.440
out. But I guess the real question we're asking here is how do we know if we can trust our

187
0:15:48.440 --> 0:15:54.800
tests? That's really the crux of this problem. And so as it turns out, the very famous Roman

188
0:15:54.800 --> 0:16:01.160
poet, Juvanal, actually in 100 AD after he had a few drinks, he was able to summarise

189
0:16:01.160 --> 0:16:04.160
this in such a beautiful way. And this was something that maybe wasn't appreciated at

190
0:16:04.160 --> 0:16:08.440
the time because, you know, obviously he was talking about mutation testing 2000 years

191
0:16:08.440 --> 0:16:14.600
before it was relevant. But I will mention it here. It's who watches the watches, right?

192
0:16:14.600 --> 0:16:18.440
And this is the question. Who's testing our tests? Who cares about that? How do we actually

193
0:16:18.440 --> 0:16:21.760
gain trustworthiness for our tests? And I see there's people in production who's having

194
0:16:21.760 --> 0:16:26.560
bugs. There's people who understand here that this is a really big deal. Luckily, we have

195
0:16:26.560 --> 0:16:33.880
a two word answer for you, which is the reason we're all in this room. Mutation testing. So

196
0:16:33.880 --> 0:16:39.240
put the odd one out. You might see here, that's Henry. He's having a great time. But maybe

197
0:16:39.240 --> 0:16:43.000
he shouldn't be still in a row of pigeons. But more importantly right now, I'll just

198
0:16:43.000 --> 0:16:46.480
explain the basic premise and then Paco here will explain in a little more detail how it's

199
0:16:46.480 --> 0:16:50.640
actually kind of done. So first of all, mutation testing. This is a really quick summary. What

200
0:16:50.640 --> 0:16:54.000
you do is you introduce some faults in your code. So just a few little things that you

201
0:16:54.000 --> 0:16:59.400
change. And for each of those little changes, that's a mutant version of your code. Once

202
0:16:59.400 --> 0:17:03.600
you've got that, you run your test suite against those mutant versions of your code. And if

203
0:17:03.600 --> 0:17:11.680
they fail, awesome. Because that means that your tests have actually picked up that change.

204
0:17:11.680 --> 0:17:16.000
And that's a good thing. That's good. We want those tests to fail if our code changes. But

205
0:17:16.000 --> 0:17:21.600
if they don't fail, that's a bad time. Because that means those tests didn't test that change.

206
0:17:21.600 --> 0:17:26.080
It didn't test for that. And so that's something that could have made it to production. So

207
0:17:26.080 --> 0:17:30.560
what mutation testing kind of gives you is a way to evaluate that test quality. But this

208
0:17:30.560 --> 0:17:34.880
is very abstract. So let's look at penguins. I like penguins. So Henry here, he's a great

209
0:17:34.880 --> 0:17:39.280
example. And he's going to bring all this home. So I was kind of unfamiliar to the topic.

210
0:17:39.280 --> 0:17:42.440
So I kind of created some analogies with penguins that really helped me. So I'll share those

211
0:17:42.440 --> 0:17:46.800
with you. So the way I kind of imagined my software is we do lots of stuff with messaging.

212
0:17:46.800 --> 0:17:51.360
And so I imagine software that works properly to be like a pigeon or a dove, like a bird

213
0:17:51.360 --> 0:17:54.920
that can fly. I've used a dove here because Paco has a deadly fear of pigeons. He's terrified

214
0:17:54.920 --> 0:18:00.200
of them. Not fear. Vendetta. He has a personal vendetta against pigeons. Sorry. He doesn't

215
0:18:00.200 --> 0:18:04.000
like them. So I've used a dove here. But ideally we want something that I can tie a message

216
0:18:04.000 --> 0:18:08.640
to the bird's leg and it can go and deliver that message for me. So it can go do something

217
0:18:08.640 --> 0:18:14.360
like that. So one of the key features of penguins is that they're not very good at flying.

218
0:18:14.360 --> 0:18:18.880
Can we all agree that that's probably not the best? If you want to tie a message to

219
0:18:18.880 --> 0:18:22.540
a bird's leg and get it to deliver it, a penguin might not be the bird you choose unless you

220
0:18:22.540 --> 0:18:26.920
may be delivering something underwater. So this is the kind of example here where we've

221
0:18:26.920 --> 0:18:31.040
got a bird, but it's not the kind of thing that performs the way we expect it to. And

222
0:18:31.040 --> 0:18:33.720
this would cause some serious problems if we tried to use this kind of thing in production.

223
0:18:33.720 --> 0:18:37.520
If we wanted to send a message via a penguin, we're going to have a tough time, right? So

224
0:18:37.520 --> 0:18:41.240
Paco, I'd like you, if possible, to explain this in a way that makes more sense than what

225
0:18:41.240 --> 0:18:48.160
I just did. Good luck. We only have one mic. It's a bit stiffly.

226
0:18:48.160 --> 0:18:52.400
Yeah. So let's get into the process of mutation testing. The first step of mutation testing.

227
0:18:52.400 --> 0:18:58.960
So what Max just taught you is about introducing faults. So you can introduce faults manually,

228
0:18:58.960 --> 0:19:02.040
but this is a process that's, well, manually, and that means it's a lot of work and it's

229
0:19:02.040 --> 0:19:05.880
usually also not that reproducible. You don't want to do it manually. We want to do this

230
0:19:05.880 --> 0:19:11.520
in an automated manner. This is where mutates testing comes in. In the first step of mutation

231
0:19:11.520 --> 0:19:15.880
testing, we're going to generate mutants. And each mutant is just a very tiny version

232
0:19:15.880 --> 0:19:20.840
of the production code. Mutates testing works with the concept of mutators, and mutators

233
0:19:20.840 --> 0:19:25.480
are the ones that are making these very small changes.

234
0:19:25.480 --> 0:19:31.400
So what we have in this case, we have a perfectly fine DOV, which is the production code. And

235
0:19:31.400 --> 0:19:36.840
then at the end of it, we have a mutator which generates, makes a tiny change, which kind

236
0:19:36.840 --> 0:19:41.040
of transforms this into Henry, our penguin who can fly, and we want our software to fly.

237
0:19:41.040 --> 0:19:45.960
So this would be a bad thing. So how does it look? Because this is still a bit abstract.

238
0:19:45.960 --> 0:19:52.040
I'm going to give you some examples. This would be an example here. So for the Dutch,

239
0:19:52.040 --> 0:19:55.640
and I think for other countries as well, you have to be 17 years in order to apply for

240
0:19:55.640 --> 0:20:00.760
driving license. This could be code that's in your code base, which will fly, which is

241
0:20:00.760 --> 0:20:07.240
good. Now, the mutant would be the entire code base stays the same, and just this little

242
0:20:07.240 --> 0:20:10.800
piece change. So here we inverted the logic. This is, of course, a bug. This is something

243
0:20:10.800 --> 0:20:16.720
we don't want to manage and get into production. And actually, just from this single line,

244
0:20:16.720 --> 0:20:22.680
we can already generate quite some mutants, because we can not only avert the conditional

245
0:20:22.680 --> 0:20:27.800
operator, we can also change the conditional boundaries. So this means that we now have

246
0:20:27.800 --> 0:20:33.640
age larger than 17, which is a very nice bug that would force us to test the edge cases,

247
0:20:33.640 --> 0:20:39.960
the famous off by one errors, whether we forgot our equal operation in our conditional check.

248
0:20:39.960 --> 0:20:43.960
This will help you find that one. But it can also just return always true or false. We

249
0:20:43.960 --> 0:20:48.640
can generate quite some mutants for this, and we can do the same for, for example, mathematical

250
0:20:48.640 --> 0:20:54.880
operations. We can make each plus into a minus, each multiplication into a division, et cetera.

251
0:20:54.880 --> 0:20:59.880
And there are more. We also have the ability to remove statements. So in this case, we

252
0:20:59.880 --> 0:21:04.880
have a method that adds a published date to some object. And we can also just remove the

253
0:21:04.880 --> 0:21:08.640
whole setter. And now this means that we have a bug in which we don't set this attribute

254
0:21:08.640 --> 0:21:15.000
anymore, which is something that, of course, we don't want to make to production. What's

255
0:21:15.000 --> 0:21:18.960
important to note here is that with mutates testing, it's always important that the code

256
0:21:18.960 --> 0:21:22.920
actually compiles, because we're not testing the compiler. We're testing the code. The

257
0:21:22.920 --> 0:21:28.000
compiler is definitely out of scope here. Now at the end of step one, we have a lot

258
0:21:28.000 --> 0:21:37.880
of Henry's. We have a lot of mutants. And now Henry is going to try to fly. So he already

259
0:21:37.880 --> 0:21:42.520
got his wings ready to try to fly. And now for each Henry, we're going to run the test

260
0:21:42.520 --> 0:21:47.840
suite. And if this test suite fails, as Max already mentioned, then we have, then we,

261
0:21:47.840 --> 0:21:51.040
then it's good because then we expose Henry 40s, which is just a penguin, something that

262
0:21:51.040 --> 0:21:56.760
can't fly. So this is great. The not so happy scenario is where the test passed, which means

263
0:21:56.760 --> 0:22:01.720
that Henry made it into production. And as we know, well, assuming that it also got through

264
0:22:01.720 --> 0:22:07.360
the PR, of course, we have more than just tests. Is that a problem? Because Henry is

265
0:22:07.360 --> 0:22:11.640
not supposed to fly. And now we have a bug into production. So this is something that

266
0:22:11.640 --> 0:22:18.320
you don't want. So this is the theory of mutates testing. And now, Max, you can tell a bit

267
0:22:18.320 --> 0:22:23.680
more about the frameworks. Sure. It works for me.

268
0:22:23.680 --> 0:22:28.440
Alrighty. So first of all, I just want to say I'm so proud of this prompt. I don't know

269
0:22:28.440 --> 0:22:33.200
why Dali chose this, but I'm really happy. Like I think I typed in penguin trying to

270
0:22:33.200 --> 0:22:39.120
be a pigeon and it came up with this and I'm very happy. Okay. So moving on, yeah, frameworks.

271
0:22:39.120 --> 0:22:43.480
So this is going to get a little bit more specific to, you know, to actually implementing

272
0:22:43.480 --> 0:22:50.440
this stuff. So anyone here who is a Python developer? Heck yeah. Alright. Awesome. So

273
0:22:50.440 --> 0:22:54.800
I'm going to show you what I did in Python. So as you can see, you know, Parker is a Java

274
0:22:54.800 --> 0:22:58.280
developer. He'll explain Java in a sec. But I'll just show you the kind of basic concepts

275
0:22:58.280 --> 0:23:03.840
but using my code and using what I did. So there's two kind of main supported packages

276
0:23:03.840 --> 0:23:07.080
that you can use in Python. It's not like in Java there's an enterprise thing you can

277
0:23:07.080 --> 0:23:12.720
get. In Python it's very community supported. So you're not going to get big products. But

278
0:23:12.720 --> 0:23:18.560
what we do have are these nice supported reposts for mutates testing which have these packages.

279
0:23:18.560 --> 0:23:22.800
So I am not a professional. In this I'm not a doctor, I'm not a lawyer, I'm not a professional

280
0:23:22.800 --> 0:23:27.720
financial advisor. I'm just a person who has a certain opinion. And so my opinion of those

281
0:23:27.720 --> 0:23:33.120
two frameworks I showed you, there's mutmut and cosmic ray. And personally I prefer mutmut.

282
0:23:33.120 --> 0:23:38.400
Because it's easier to get going. Oh, angry face, shaken hairs. You don't like mutmut.

283
0:23:38.400 --> 0:23:51.120
We will talk later. So if we have time, we'll have a third presenter very shortly. So for

284
0:23:51.120 --> 0:23:57.160
now while I've still got the mic, while I'm still here, we'll talk about mutmut. And so

285
0:23:57.160 --> 0:24:02.000
this framework is quite simple to use. The reason I kind of like it is because it's very

286
0:24:02.000 --> 0:24:06.200
much you install it and you run it. There's a bit of config you can do. But really it's

287
0:24:06.200 --> 0:24:09.960
quite simple just to get an idea of your code base and what's going on. So I want to show

288
0:24:09.960 --> 0:24:14.920
you this slide. This is the SDK that I maintain. And I'm showing you this because it's what

289
0:24:14.920 --> 0:24:19.120
I've applied my mutation testing to. So it's where I'm showing my examples. But basically

290
0:24:19.120 --> 0:24:25.320
what we do is when we go here, I had this locally first of all. So I installed mutmut

291
0:24:25.320 --> 0:24:29.000
with pip install. It's that simple. It's a Python package. It's what we do. If you went

292
0:24:29.000 --> 0:24:34.920
to my talk a mile earlier, you know why that's a bad idea. But I did it. So after we do that,

293
0:24:34.920 --> 0:24:39.720
we've got mutmutrun which just runs those tests for you. So when we do that, I'll show

294
0:24:39.720 --> 0:24:43.440
you what my output was. So when I ran this myself, I actually got a whole lot of this

295
0:24:43.440 --> 0:24:47.720
output. But really what's important here is that first of all, it ran my entire test suite.

296
0:24:47.720 --> 0:24:51.320
And the reason it ran my entire test suite is just to check how long that's supposed

297
0:24:51.320 --> 0:24:55.140
to take and just to make sure everything does work as expected. Because there's various types

298
0:24:55.140 --> 0:24:59.800
of mutants to do with timeouts as well that we might want to consider. After it's done

299
0:24:59.800 --> 0:25:04.560
that, what it will do is it will generate mutants based on the lines of code in my code

300
0:25:04.560 --> 0:25:09.560
base. That's what it will do. And once it's done that, it will run my tests against those.

301
0:25:09.560 --> 0:25:13.320
So there's a few different types. And it can characterize them like this. So the first

302
0:25:13.320 --> 0:25:16.880
type is mutants that we've caught, not killed. We never kill a penguin. We love penguins.

303
0:25:16.880 --> 0:25:22.480
We catch them. We've caught them and put them back into the zoo. In this case, we've managed

304
0:25:22.480 --> 0:25:26.920
to say, yep, our test failed. That's great. But it could be the case where the mutant's

305
0:25:26.920 --> 0:25:31.360
timed out. So it's taken way too long for this code to run. Or it's taken enough time

306
0:25:31.360 --> 0:25:36.000
that we feel like we're not so feeling great about that code. Alternatively, we might end

307
0:25:36.000 --> 0:25:40.200
up in a situation where the mutant survived and made it through our test code. In that

308
0:25:40.200 --> 0:25:44.780
case, it corresponds to a bug that might make it to production. So when I ran this on my

309
0:25:44.780 --> 0:25:50.920
particular SDK, what I saw was that we checked the stuff. I created 682 mutants, versions

310
0:25:50.920 --> 0:25:56.280
of my code with changes in them. And it managed to catch 512 of those, but it managed to miss

311
0:25:56.280 --> 0:26:02.920
170 of them. Now, if that's a good number or a bad number, we'll talk about later. But

312
0:26:02.920 --> 0:26:07.880
what's important now is let's just look at some of those mutants. So first of all, the

313
0:26:07.880 --> 0:26:11.240
ones that we actually did catch, here's a couple of examples. So here's a line where

314
0:26:11.240 --> 0:26:15.160
basically we say here are some valid message channels. So for our messages API, here's

315
0:26:15.160 --> 0:26:19.840
some valid message ways you can send, right? But what's important here is that this basically

316
0:26:19.840 --> 0:26:24.880
removed the ability to send an SMS. And so when I tried to test that, it failed, which

317
0:26:24.880 --> 0:26:30.160
is what we want to see. Here's another one. Again, this is Python. So if you're a Java

318
0:26:30.160 --> 0:26:35.520
dev, don't worry, we'll look after you soon. And here's another one. We've got a decorator

319
0:26:35.520 --> 0:26:40.360
here which basically runs this method. And we can see when we remove that, that will

320
0:26:40.360 --> 0:26:44.340
never happen. This is actually through pedantic if anyone has used that before. But basically

321
0:26:44.340 --> 0:26:48.800
it means that we're not going to round a number anymore. And so when we test for that, a number

322
0:26:48.800 --> 0:26:54.600
doesn't get rounded and we catch that. But that is not really very interesting. That

323
0:26:54.600 --> 0:26:57.120
doesn't tell us anything. That tells us about this much, right? It doesn't tell us much

324
0:26:57.120 --> 0:27:02.360
at all. And the reason for that is that we kind of know that our test work for that.

325
0:27:02.360 --> 0:27:06.560
Thank you very much. I'll do the M&M thing. So we kind of know that our test worked for

326
0:27:06.560 --> 0:27:11.480
that. And so what's kind of useful is to see if we do much show, we can see the mutants

327
0:27:11.480 --> 0:27:19.480
that we didn't catch. We can also do HTML which shows us essentially an HTML coverage

328
0:27:19.480 --> 0:27:24.360
output as well so we can see in a list all of the mutants that we didn't catch. So with

329
0:27:24.360 --> 0:27:28.840
much show on that code base that I just showed you, we can see the 170 meters that survived.

330
0:27:28.840 --> 0:27:32.400
It shows you the indices of these. And then we can manually specify the ones we want to

331
0:27:32.400 --> 0:27:38.820
look at. So here we can see, for example, that we changed the authentication method

332
0:27:38.820 --> 0:27:42.280
to fail. And we can see in this case we caught that because we did a test for authentication

333
0:27:42.280 --> 0:27:47.960
and it failed so that's great. But more importantly, though, is you get this HTML output which

334
0:27:47.960 --> 0:27:52.600
you can then explore. You can explore every method, every sort of module that you have.

335
0:27:52.600 --> 0:27:56.480
You can explore all the methods inside of there and which ones were and were caught.

336
0:27:56.480 --> 0:28:02.000
And you do that with the HTML command. So to do that, I'll just show you this is a mutant

337
0:28:02.000 --> 0:28:05.240
that we did not catch. And I want to show you why we didn't catch it and what it's going

338
0:28:05.240 --> 0:28:08.480
to do. And I'll just do that for a few just so you get some context if that's cool. So

339
0:28:08.480 --> 0:28:14.080
first of all, what this mutant did was it renamed the logger. Now, I think logging is

340
0:28:14.080 --> 0:28:17.680
out of scope of my test code. So personally, I don't care too much about anything related

341
0:28:17.680 --> 0:28:25.040
to logging. So I don't mind if I don't get a pass here. Here's another one. In this case,

342
0:28:25.040 --> 0:28:29.320
what we do is we've slightly changed the value of a constant. This is just part of a function

343
0:28:29.320 --> 0:28:32.080
signature. And we don't, again, we don't care about this that much. This isn't something

344
0:28:32.080 --> 0:28:38.440
that I really mind about. What's more important, though, is this mutant here. Because this

345
0:28:38.440 --> 0:28:42.880
is from a client class where we instantiate all of our different API classes. And you

346
0:28:42.880 --> 0:28:47.560
can see we actually set voice to none. So we completely remove that instantiation and

347
0:28:47.560 --> 0:28:53.320
our tests are still passing. So the reason that actually still works, our test code still

348
0:28:53.320 --> 0:28:58.000
works, even though this isn't testing that case, is because our tests actually, they

349
0:28:58.000 --> 0:29:01.800
test the voice API separately. They call it manually. But if our clients are calling it

350
0:29:01.800 --> 0:29:05.440
like this, maybe we should have a test for this as well. So this tells me, hey, maybe

351
0:29:05.440 --> 0:29:10.080
my test suite does need to be expanded. Does that make sense? I'm seeing some very, very

352
0:29:10.080 --> 0:29:14.840
like, yeah, yeah, that makes sense. I like it. Awesome. Okay. So if you are a Python dev,

353
0:29:14.840 --> 0:29:17.640
this isn't the end of the talk, by the way. We've got some more context and we'll show

354
0:29:17.640 --> 0:29:22.020
you about CI. But if you are interested, feel free to scan this. You've got four seconds

355
0:29:22.020 --> 0:29:27.880
before I move slides. And as I move slides, in slow motion, I'll be passing over this

356
0:29:27.880 --> 0:29:34.880
microphone. This was just Python, of course. I think there are more non-Python devs here.

357
0:29:34.880 --> 0:29:42.320
Not Python. We, of course, have more frameworks. I think there are more languages out there,

358
0:29:42.320 --> 0:29:46.800
but I think they're the most important ones that I like personally. And pretty much the

359
0:29:46.800 --> 0:29:52.240
only really good one for Java is PyTest. And we also have Striker. And Striker is one that

360
0:29:52.240 --> 0:29:57.080
supports quite some languages. It supports JavaScript, C sharp, Scala. Of course, it doesn't

361
0:29:57.080 --> 0:30:03.800
do this in one to each one has their own dependencies, because you can't have one solution for all.

362
0:30:03.800 --> 0:30:07.800
But what you particularly like about it is that it supports JavaScript. And this brings

363
0:30:07.800 --> 0:30:13.680
this kind of back-end heavy tool. Testing is usually mostly, I think, in front-end can

364
0:30:13.680 --> 0:30:18.920
use some law when it comes to testing often. This also brings the testing frameworks and

365
0:30:18.920 --> 0:30:22.440
the testing quality more to the front-end. So that's what I really like.

366
0:30:22.440 --> 0:30:28.400
But we wanted to discuss a bit more. Mike's already sort of introduced it. So what is

367
0:30:28.400 --> 0:30:35.440
a good mutation score? We had the Goodhart's law where we sort of saw that code coverage

368
0:30:35.440 --> 0:30:41.520
can also lead to people implementing tests just to improve coverage, not just sort of

369
0:30:41.520 --> 0:30:45.440
defeats the purpose. You're doing it just for the metric, not for the actual purpose.

370
0:30:45.440 --> 0:30:51.880
And how does this work with mutation score? Now, first, here's a picture of how PyTest

371
0:30:51.880 --> 0:30:58.560
report looks. So not to bash on Python, but much prettier and much clearer. Because now,

372
0:30:58.560 --> 0:31:01.840
particularly what is interesting about this one, it shows you both the line coverage and

373
0:31:01.840 --> 0:31:06.080
the mutation coverage. We can ignore the test train. And this shows us the sweet spots in

374
0:31:06.080 --> 0:31:10.880
a report. Because at the end, we have generated a lot of mutants. We have a lot of classes.

375
0:31:10.880 --> 0:31:13.800
And we only have very little time. So where are we going to look and investigate this

376
0:31:13.800 --> 0:31:18.240
report and see where the strains are? And the one that's the least interesting here

377
0:31:18.240 --> 0:31:22.960
is the notification service. The notification service also doesn't have any coverage. And

378
0:31:22.960 --> 0:31:25.920
if there's no coverage, then the mutants are also not interesting because you have a bigger

379
0:31:25.920 --> 0:31:30.880
problem here, which is you don't have tests at all for this. Then you have a choice. You

380
0:31:30.880 --> 0:31:34.280
have the proposal service and proposed service too. Now, the fact that they are named equally

381
0:31:34.280 --> 0:31:39.440
is because they're from another example. But proposed service too is the one that has 100%

382
0:31:39.440 --> 0:31:43.200
coverage, and yet it didn't kill a single mutant. And this is the sweet spot. Because

383
0:31:43.200 --> 0:31:48.080
this means that we have code that is well tested, or at least there's tests that covering

384
0:31:48.080 --> 0:31:52.120
this piece of code. But there's no single bug that was caught. So this deserves some

385
0:31:52.120 --> 0:31:56.440
attention because it means that we didn't fully test this. So these are the hotspots

386
0:31:56.440 --> 0:32:00.840
where you open a report. The ones with high line coverage and low mutation coverage, those

387
0:32:00.840 --> 0:32:04.600
are the ones you really want to go through. Those are the ones that give you the findings

388
0:32:04.600 --> 0:32:08.760
to go through a team and say, hey, see, we need mutation testing. Because here, just

389
0:32:08.760 --> 0:32:14.160
these two classes alone already, it showed me that we need to improve our quality.

390
0:32:14.160 --> 0:32:22.440
And now back to the score. So the example we had, we managed to kill 512 out of 682

391
0:32:22.440 --> 0:32:29.840
mutant, which is about a 75% score. Now, the question is, is this a good score?

392
0:32:29.840 --> 0:32:32.280
Is this a good score?

393
0:32:32.280 --> 0:32:40.880
Yes, yes. The golden answer. It depends. I love that answer. We already saw that 100%

394
0:32:40.880 --> 0:32:45.120
doesn't make sense. Things like logging, and there are more things like generated code,

395
0:32:45.120 --> 0:32:49.600
et cetera, things that you don't necessarily want to test, even though there are mutates

396
0:32:49.600 --> 0:32:53.440
generators for it. There are a couple things you can, of course, do. You can also, depending

397
0:32:53.440 --> 0:32:57.720
on the language and the framework you use, you can tweak the mutation testing framework

398
0:32:57.720 --> 0:33:02.200
quite a bit. For example, the PyTest version actually out of the box already ignores and

399
0:33:02.200 --> 0:33:08.040
doesn't mutate any logging lines. And all the big frameworks are known to the tool.

400
0:33:08.040 --> 0:33:12.120
So anything that goes to SLF4J, it doesn't mutate it. So it also doesn't appear in your

401
0:33:12.120 --> 0:33:17.240
report, which is quite nice. And you can easily add things. Like if you have a custom metrics

402
0:33:17.240 --> 0:33:20.760
facade somewhere, also typically something you don't want to cover in unit tests, you

403
0:33:20.760 --> 0:33:26.360
can add that as well. So the thing here is that mutates testing is not really a score

404
0:33:26.360 --> 0:33:30.360
you want to achieve. It's more that the report can be interesting to look at and gives you

405
0:33:30.360 --> 0:33:34.600
sort of the nice spots. And once you completely set it up nice and you're familiar with the

406
0:33:34.600 --> 0:33:38.240
report, you can maybe start looking at the score, but definitely it shouldn't become

407
0:33:38.240 --> 0:33:43.200
an 80% goal or something like it was with code coverage. It's just there, it goes through

408
0:33:43.200 --> 0:33:52.720
the report instead. So now we've sort of discussed all the tools you need. We have discussed

409
0:33:52.720 --> 0:34:02.000
the frameworks. We have discussed the technology. And now it's time, of course, for you to fly.

410
0:34:02.000 --> 0:34:07.520
So how would you get started on this? And the thing that's important here is if you

411
0:34:07.520 --> 0:34:12.040
want to start, so you now think, oh, this is a great talk. I want to start with mutates

412
0:34:12.040 --> 0:34:17.200
testing. Depending on the size of your project, it might be wise to just start with just a

413
0:34:17.200 --> 0:34:22.280
single package. I've done this on projects that are a couple of, say, thousand lines

414
0:34:22.280 --> 0:34:27.040
big. And even though in Max's example we had 682 mutants, this can also, depending on the

415
0:34:27.040 --> 0:34:31.360
kind of code you have, easily grow to tens of thousands of mutants, which can be quite

416
0:34:31.360 --> 0:34:34.440
slow. It can also be that there's something weird in your code base that doesn't really

417
0:34:34.440 --> 0:34:39.680
work well with mutation testing or something that's just extremely slow. An example that

418
0:34:39.680 --> 0:34:46.720
I had was that we had, so what's good to keep in mind is actually just to take a side step,

419
0:34:46.720 --> 0:34:52.200
the mutates testing framework also measures in the beginning for each individual test

420
0:34:52.200 --> 0:34:57.480
which code it covers. So there's a nice graph from code, production code, to the tests.

421
0:34:57.480 --> 0:35:02.080
It helps us optimize because if we want to run the entire test suite, all the tests for

422
0:35:02.080 --> 0:35:06.200
every single mutant is going to take endless. Instead, because we know the coverage, we

423
0:35:06.200 --> 0:35:10.120
can also see if we mutate this one line, we know which tests to discover, so we only need

424
0:35:10.120 --> 0:35:15.320
to execute those few tests. But what if you have tests that actually cover half your code

425
0:35:15.320 --> 0:35:20.240
base? For example, one of the things you can do in Java is if you're doing things with

426
0:35:20.240 --> 0:35:23.560
Spring is you can actually boot up the entire Spring application and start doing acceptance

427
0:35:23.560 --> 0:35:29.560
tests from your unit tests, which is typically not necessarily the worst thing to do, but

428
0:35:29.560 --> 0:35:33.760
you now have a very slow test that does cover half your code base that will be executed

429
0:35:33.760 --> 0:35:37.520
for each single mutant. So these are things you want to get rid of. You want to exclude

430
0:35:37.520 --> 0:35:43.520
this acceptance test because otherwise you're going to be waiting endlessly. So my point

431
0:35:43.520 --> 0:35:47.200
about starting locally and starting small was start just with one package. Start with

432
0:35:47.200 --> 0:35:51.040
the utility package to see if it works, see if the report works for you, and then from

433
0:35:51.040 --> 0:35:56.040
there you can expand, add more packages, and also you can see, oh, now it's taking ten

434
0:35:56.040 --> 0:36:02.440
times as long. Why is this? And you can find the painful packages there. So as I mentioned,

435
0:36:02.440 --> 0:36:06.920
you can exclude some tests, and also there are often candidates, certain pieces of code

436
0:36:06.920 --> 0:36:12.040
you might want to exclude. For example, there's no use in testing generated code, but also

437
0:36:12.040 --> 0:36:17.840
it might be that you have certain domain packages that contain just all your domain objects,

438
0:36:17.840 --> 0:36:23.040
your POJOs, which just setters and getters, something that you also typically want to

439
0:36:23.040 --> 0:36:27.520
exclude to your coverage report. You might also want to exclude this from code mutation,

440
0:36:27.520 --> 0:36:35.000
some of it from mutation testing. And now that's done. So we talked about running it

441
0:36:35.000 --> 0:36:39.880
on your machine. We also can do this in the cloud, of course.

442
0:36:39.880 --> 0:36:46.040
Thank you. So as you can see, there's a pigeon on this slide, and Paco, as we've said, has

443
0:36:46.040 --> 0:36:51.740
a personal vendetta, so I've taken over this section. So here we can see that we're going

444
0:36:51.740 --> 0:36:55.520
to run off our machine. So why would you want to run off your machine rather than on your

445
0:36:55.520 --> 0:36:57.520
machine? Any questions? Any ideas?

446
0:36:57.520 --> 0:37:00.520
What happens in the background?

447
0:37:00.520 --> 0:37:03.560
Yes. So what happens in the background is what we said there. Any other reason you might

448
0:37:03.560 --> 0:37:09.120
want to run non-locally? No. I've got a couple. Oh, oh, hand.

449
0:37:09.120 --> 0:37:10.120
CI.

450
0:37:10.120 --> 0:37:12.740
CI. Yeah, you might want to end your CI system. In fact, that's what we'll be showing you.

451
0:37:12.740 --> 0:37:19.260
So foreshadowing. I like it. So yeah, it takes some time. And if you're using a CI system,

452
0:37:19.260 --> 0:37:23.080
you get to use those cloud resources. And also what's important is that you can, if

453
0:37:23.080 --> 0:37:26.920
you've got code which is maybe dependent on different OSes, might behave differently,

454
0:37:26.920 --> 0:37:31.400
you can specify different versions and platforms to run on as well.

455
0:37:31.400 --> 0:37:35.680
So stop talking. I hear you cry. Well, I'm afraid this is what we're here for, but unfortunately,

456
0:37:35.680 --> 0:37:39.360
I will be keeping talking, but what I will do is show it a bit of an example.

457
0:37:39.360 --> 0:37:44.560
So I applied this to my code base, my own code base myself, into my CI system. So you

458
0:37:44.560 --> 0:37:49.040
can see here, this is GitHub actions. And I've got a piece of YAML, essentially. I've

459
0:37:49.040 --> 0:37:54.980
got this mutation test.YAML file. And what that does is sets up an action for me to use.

460
0:37:54.980 --> 0:37:59.360
So this is something that I manually run. And I can do this here. So I manually run

461
0:37:59.360 --> 0:38:03.240
that. And what it will do is do the mutation test non-locally, and it will produce some

462
0:38:03.240 --> 0:38:08.400
HTML output for me to look at. Now, that seems, you know, I'll go a little bit into what that

463
0:38:08.400 --> 0:38:12.120
YAML does, but it seems like something that should be able for everyone to do themselves

464
0:38:12.120 --> 0:38:15.880
if they want to. So GitHub actions, the reason I show that partly is because what we use,

465
0:38:15.880 --> 0:38:19.600
but also, you know, it's free for open source projects. So, you know, it's been useful for

466
0:38:19.600 --> 0:38:22.680
me because I've not had to pay for it. So, you know, just a heads up.

467
0:38:22.680 --> 0:38:26.280
So, yeah, I'll be showing you this with GitHub actions really quickly. And I'll show you

468
0:38:26.280 --> 0:38:29.760
the YAML. I'll show you what I did. Hopefully by the end of this, the next couple of slides,

469
0:38:29.760 --> 0:38:34.320
you will see how easy it is actually to do this and why actually this is all good and

470
0:38:34.320 --> 0:38:40.000
maybe you want to try this yourself when you get home. So here's some YAML. First of all,

471
0:38:40.000 --> 0:38:43.320
this is our mutation test YAML. It's got one job. It's pretty simple. All we're doing,

472
0:38:43.320 --> 0:38:47.960
we're running on Ubuntu. Running one specific Python version to do this. Depending on what

473
0:38:47.960 --> 0:38:54.800
your test base is, oh, they run a great time in there. Or there is thunder. So basically,

474
0:38:54.800 --> 0:38:58.160
we have, yeah, we're testing on one version for me because my code doesn't vary enough

475
0:38:58.160 --> 0:39:03.160
between versions and OSes, so for me, it's not relevant to do that. But if we look at

476
0:39:03.160 --> 0:39:07.320
this next slide, I'll show you the workflow that goes through when I actually run this

477
0:39:07.320 --> 0:39:11.840
action. So first of all, we check out the code. Then we set up a version of Python with

478
0:39:11.840 --> 0:39:16.640
it. Once we've done that, we actually install our dependencies, including our mutmut as well

479
0:39:16.640 --> 0:39:20.400
as our regular dependencies. So now we've got the new mutation testing framework installed

480
0:39:20.400 --> 0:39:25.520
here as well on this kind of test runner. Then what we do is we run a mutation test.

481
0:39:25.520 --> 0:39:28.960
So we do that with mutmutrun. But because we're running in a CI system, we don't want

482
0:39:28.960 --> 0:39:32.880
insanely long logs and due to how it's outputted, we want a no progress flag there just to show

483
0:39:32.880 --> 0:39:36.680
that we're not seeing every line of output, we just see the important parts. We also have

484
0:39:36.680 --> 0:39:40.960
the CI flag, which is one of my only contributions to actual open source. But I added that and

485
0:39:40.960 --> 0:39:47.560
I'm kind of proud of myself. So that basically means that you get a good sensible output,

486
0:39:47.560 --> 0:39:51.520
like return code, when you run in a CI system. Because the default for mutmut is depending

487
0:39:51.520 --> 0:39:55.600
on the type of mutants that we call, it will give you a different exit code that is non-zero.

488
0:39:55.600 --> 0:39:59.520
So you kind of need to consider that or to suppress that with some scary, scary bash.

489
0:39:59.520 --> 0:40:05.240
That's what I did at first. That's why I wrote the flag. Once we've done that, we save it

490
0:40:05.240 --> 0:40:09.160
as HTML and we upload it so you can access that yourself as well.

491
0:40:09.160 --> 0:40:12.280
So that's it. That's the whole piece of YAML. It's 35 lines. And that set up the entire

492
0:40:12.280 --> 0:40:15.800
mutation test for my suite. So you can see, hopefully, does this seem kind of easy? I

493
0:40:15.800 --> 0:40:20.280
think it seems pretty gentle to do, at least in this sort of scope. If you're a Java dev

494
0:40:20.280 --> 0:40:23.840
with a 20,000 line project, you might want to be a bit more careful. But if you've got

495
0:40:23.840 --> 0:40:26.280
a Python hobby thing, try it out, right? Try it out.

496
0:40:26.280 --> 0:40:32.680
What I would say, there are some more concerns. So first of all, I chose to run this manually

497
0:40:32.680 --> 0:40:38.160
when I want to run it. I chose not to run this on push or PR. I chose to run this manually.

498
0:40:38.160 --> 0:40:41.720
And the reason for that is that I don't expect my code base to sufficiently change between

499
0:40:41.720 --> 0:40:46.440
like small commits. And what I want to do is really not use mutation tests as that kind

500
0:40:46.440 --> 0:40:50.560
of score, that 75%. I don't want that to be a metric for me that I've just turned into

501
0:40:50.560 --> 0:40:55.000
a target. I want it to stay as just a good idea, an indicator of what my tests are doing

502
0:40:55.000 --> 0:40:58.600
and what I could be doing better. So for me, I don't want to run every time, partly because

503
0:40:58.600 --> 0:41:03.320
it takes a blooming long time, especially if I'm using multiple versions, which we also

504
0:41:03.320 --> 0:41:07.360
have to factor in. So you might want to do that. So I didn't. I just ran on Ubuntu and

505
0:41:07.360 --> 0:41:10.240
that was fine for me. But yeah, it depends on what your code is. You might want to run

506
0:41:10.240 --> 0:41:13.440
on different platforms, right? So do factor that in. And that will help you a lot if you're

507
0:41:13.440 --> 0:41:16.160
in a CI system.

508
0:41:16.160 --> 0:41:19.280
So the other question there is, should we run on push or PR? My opinion is no. I think

509
0:41:19.280 --> 0:41:22.520
there will be people in this room who disagree with me. Maybe say on a PR you should run

510
0:41:22.520 --> 0:41:26.000
that or maybe there's some kind of metric you want to associate with score that you

511
0:41:26.000 --> 0:41:29.880
then want to look at in some way. For me, that's not how I use mutation testing. And

512
0:41:29.880 --> 0:41:34.000
I think what I want to get out of this is we don't want a situation where mutation

513
0:41:34.000 --> 0:41:36.840
testing becomes a new target. We've got to get a certain score. Because then we're just

514
0:41:36.840 --> 0:41:40.520
kind of abstracting that problem of code coverage targets. We're just doing that all over again,

515
0:41:40.520 --> 0:41:43.560
right? So we're trying to avoid that.

516
0:41:43.560 --> 0:41:47.960
So the final question here is one I'll ask of Paco to explain. Paco, do you think I should

517
0:41:47.960 --> 0:41:51.960
use mutation testing in my role as an audience member right now? What do you reckon?

518
0:41:51.960 --> 0:41:59.400
Yes. Well, so it was there already. It depends. There are some things you can ask yourself.

519
0:41:59.400 --> 0:42:05.480
Because it needs a question. So mutation testing is, of course, definitely not a silver bullet.

520
0:42:05.480 --> 0:42:09.480
It's something that the reports take quite some time to go through. And of course, it's

521
0:42:09.480 --> 0:42:14.080
quite computationally expensive to run the process.

522
0:42:14.080 --> 0:42:21.240
So the couple of questions that you can ask yourself that are quite obvious are for projects

523
0:42:21.240 --> 0:42:26.080
which have a really high quality goal. When people die or when a lot of money is lost

524
0:42:26.080 --> 0:42:30.320
or a combination of those two. So just to check, how many of you are working on a project

525
0:42:30.320 --> 0:42:32.040
that fits in these three?

526
0:42:32.040 --> 0:42:36.880
Okay, then you need this yesterday.

527
0:42:36.880 --> 0:42:42.040
Yes. But for the rest of the room, including me, there are some other questions we can

528
0:42:42.040 --> 0:42:46.440
ask ourselves. And I think one of the important ones is are you using code coverage? Because

529
0:42:46.440 --> 0:42:51.360
if you're not using code coverage, let's start with that. And let's first get coverage and

530
0:42:51.360 --> 0:42:53.360
get to see how many tests you have.

531
0:42:53.360 --> 0:42:58.240
Then the next question is, is how much value do you put into this? How much value do you

532
0:42:58.240 --> 0:43:03.080
get out of this code coverage? And what I mean with that is, do you make decisions based

533
0:43:03.080 --> 0:43:08.360
on it? Is like a definition of done on your sprint or is it with a built fail if there's

534
0:43:08.360 --> 0:43:14.440
80% coverage or also in the case of due diligence, you're selling a company, not something we

535
0:43:14.440 --> 0:43:19.160
also would do, but you would also want to know how well is the software I'm buying or

536
0:43:19.160 --> 0:43:22.000
how well is the software I'm working on?

537
0:43:22.000 --> 0:43:25.640
So here I would say, if you're using code coverage and you're making decisions based

538
0:43:25.640 --> 0:43:29.680
on that code coverage, then yes, you should at least have a look at mutation testing to

539
0:43:29.680 --> 0:43:34.520
see what the state is. You don't have to do this always. You don't have to put it in CI.

540
0:43:34.520 --> 0:43:39.000
Just once a year or go home rather than your computer once just to see what the current

541
0:43:39.000 --> 0:43:41.640
state of your team is. Because it's going to very well be that you're on a high performing

542
0:43:41.640 --> 0:43:46.240
team which already has their PRs and everything so well and set up that it's not worth the

543
0:43:46.240 --> 0:43:51.800
time maybe. Because apparently the mutation testing report might even confirm that, the

544
0:43:51.800 --> 0:43:54.920
fact that you killed all the mutants. So that would be great.

545
0:43:54.920 --> 0:44:00.840
And there's another question that I like. What's the cost of fixing a bug? And I have

546
0:44:00.840 --> 0:44:05.360
two stories for this. My first example is, and it's the first company I worked for, this

547
0:44:05.360 --> 0:44:10.520
was an enterprise company that built software that was running on premise at the customer

548
0:44:10.520 --> 0:44:16.800
and the customer was often in government. And then you're in the line with all these

549
0:44:16.800 --> 0:44:20.880
big integrators which means you have feature freezes and moments where you can actually

550
0:44:20.880 --> 0:44:24.560
go to the customer and deploy your software. Which is quite expensive. Which also means

551
0:44:24.560 --> 0:44:31.040
that if you get a bug after this feature freezer, after this upgrade window, you have a serious

552
0:44:31.040 --> 0:44:34.880
issue because you need to go to the customer. You need to explain what went wrong. It's

553
0:44:34.880 --> 0:44:39.840
a very costly thing. A very costly issue. So here definitely, again, mutation testing

554
0:44:39.840 --> 0:44:44.040
can be quite interesting because a lot of money can be involved in reputation.

555
0:44:44.040 --> 0:44:50.000
The other example that I had was more of a greenfield project which had more of the start-up

556
0:44:50.000 --> 0:44:54.760
vibes where it was really of a fill fast and fix fast mentality. So this was a project

557
0:44:54.760 --> 0:45:00.480
where rather than focusing on getting our quality monitoring up to speed, we were mostly

558
0:45:00.480 --> 0:45:07.160
focusing on making sure that we could very quickly fix bugs as well. It was of course

559
0:45:07.160 --> 0:45:11.480
running on-premises in the cloud so we could control it. And the most important goal was

560
0:45:11.480 --> 0:45:15.720
there to just click a button and be in production again in 10 minutes and have active monitoring

561
0:45:15.720 --> 0:45:20.200
to see if anything goes wrong. Here the cost of fixing a bug is already a lot lower which

562
0:45:20.200 --> 0:45:25.800
means that the reason to consider it might be a bit less. Especially if you're again

563
0:45:25.800 --> 0:45:30.280
in a, for example, a high-performing team which all work into each other. You know what

564
0:45:30.280 --> 0:45:35.760
you're doing. You know you can trust each other because you're really, you're all professionals.

565
0:45:35.760 --> 0:45:39.400
Maybe it's not worth to also spend half a day going through a mutatist report if you

566
0:45:39.400 --> 0:45:43.240
already know what the outcome is probably going to be. Again still do it once. These

567
0:45:43.240 --> 0:45:47.120
are two things you could consider in when to use it. So those are the things I want

568
0:45:47.120 --> 0:45:51.920
to give away with you is don't go into it blindly. Just ask yourself should I really

569
0:45:51.920 --> 0:45:55.080
use it? And then for the last part.

570
0:45:55.080 --> 0:46:01.040
For the last part I'd just like to sum up. So I think hopefully if we've gotten here

571
0:46:01.040 --> 0:46:05.440
we've kind of shown you what mutation testing is, why you might want to consider using it

572
0:46:05.440 --> 0:46:09.360
and how you could possibly get going starting with running that and also why you should.

573
0:46:09.360 --> 0:46:12.600
So if we're here I just want to summarize first of all I'm sorry I used this penguin

574
0:46:12.600 --> 0:46:17.360
as an evil penguin earlier. It is adorable. I just like that Dali when I asked it to give

575
0:46:17.360 --> 0:46:20.600
it some fake wings it gave it three. It gave it this extra flipper here. I'm not sure what

576
0:46:20.600 --> 0:46:25.040
that was for. But what I'd like to do is just quickly summarize what we've talked about

577
0:46:25.040 --> 0:46:32.840
today. First of all mutation testing is a way to test your tests. It helps you to beat

578
0:46:32.840 --> 0:46:37.160
the problem where you're using good hot slow for coverage. It saves you from trying to

579
0:46:37.160 --> 0:46:41.560
turn coverage into a metric that you don't have as a target. You don't want to have code

580
0:46:41.560 --> 0:46:45.320
coverage. It's got to be above this threshold or we don't merge. That's not where we want

581
0:46:45.320 --> 0:46:52.080
to be. What we want to do is write good tests. So if you are going to do this yourself an

582
0:46:52.080 --> 0:46:56.360
important part is to start small. So start locally on your machine. If you've got a big

583
0:46:56.360 --> 0:47:00.440
code base then what you need to do really is run on a subset of that code base. If you've

584
0:47:00.440 --> 0:47:06.960
got a smaller code base like me you're probably okay. Either way start locally on your machine.

585
0:47:06.960 --> 0:47:10.840
You also want to run if you can. If you want asynchronous reports, if you want to use the

586
0:47:10.840 --> 0:47:15.280
resources available on a CI system you can run mutation testing there. So do consider

587
0:47:15.280 --> 0:47:20.720
that if your stuff is in CI. And finally I just want to say that mutants hopefully we've

588
0:47:20.720 --> 0:47:25.040
demonstrated that mutants are like adorable penguins. They're valuable and they are wonderful.

589
0:47:25.040 --> 0:47:28.240
They're really great to use. They can tell you so much about your code. They're extremely

590
0:47:28.240 --> 0:47:35.240
useful. So don't fear them because you should love them. Thank you very much.

591
0:47:35.240 --> 0:47:49.240
If there are any questions, comments, objections, love mail, hate mail, anything? Shout at me.

592
0:47:49.240 --> 0:48:06.440
So the question there was just if we can give some more examples of the kind of range of

593
0:48:06.440 --> 0:48:10.880
things that are possible to mutate. So essentially the short answer is anything that will still

594
0:48:10.880 --> 0:48:16.240
make the code run. So in the Java case the code compiled, in my case the code run. So

595
0:48:16.240 --> 0:48:21.120
in this situation things like I'll give you some Python examples. For example, changing

596
0:48:21.120 --> 0:48:24.680
a variable from a certain type to another so you might type pass something. You might

597
0:48:24.680 --> 0:48:28.520
with a mathematical expression you might add extra terms to that expression. You might

598
0:48:28.520 --> 0:48:34.320
change return types, error types. You might set things to none at any given time. You

599
0:48:34.320 --> 0:48:38.440
might call something and you have removed parts of it. Set things to zero. There's other

600
0:48:38.440 --> 0:48:42.120
stuff. Paco can you think of any mutation testing job?

601
0:48:42.120 --> 0:48:47.600
So I think the examples you gave for that, it depends on the mutators you use. Of each

602
0:48:47.600 --> 0:48:50.560
framework you can also go through the list of mutators to see what kind of mutators are

603
0:48:50.560 --> 0:48:55.760
out there. What's good to keep in mind is that it does use some basic fundamental strategies

604
0:48:55.760 --> 0:49:00.120
to determine if it can be mutated. Because for example if you have a stream and in this

605
0:49:00.120 --> 0:49:04.960
stream you do some operations which you could in theory cut out, you're still using the

606
0:49:04.960 --> 0:49:10.200
return value which means that the mutatistic framework thinks okay let's keep that intact.

607
0:49:10.200 --> 0:49:14.400
The same goes for if you're using the Spring Reactor framework. You could do lots and lots

608
0:49:14.400 --> 0:49:19.760
of smart mutations in there but it's not really there yet. It's really the fundamental things,

609
0:49:19.760 --> 0:49:24.680
the conditional logic, the mathematical logic I think are the two main things you'll see.

610
0:49:24.680 --> 0:49:32.280
And actually also account for often the most typical programming errors I would say.

611
0:49:32.280 --> 0:49:36.640
Awesome. I mean anything you'd like to mutate? Because I guess a lot of these things are

612
0:49:36.640 --> 0:49:40.160
open source. Anything that you might be good if it did exist? Any ideas?

613
0:49:40.160 --> 0:49:41.160
Question? Answer?

614
0:49:41.160 --> 0:49:47.160
Question? So two questions. The first one, could you comment some framework for C and

615
0:49:47.160 --> 0:49:56.160
C++? And the second, what do you think about the idea to force developers or to require

616
0:49:56.160 --> 0:50:06.160
developers to run those mutation tests as a gate hook before pushing only for the duty

617
0:50:06.160 --> 0:50:13.160
of the tests associated with the code which they have actually changed? Just to save

618
0:50:13.160 --> 0:50:21.160
the computational power on the entire machine. Okay, so the question there just for the livestream

619
0:50:21.160 --> 0:50:26.160
was two things. One is are there any mutation testing frameworks for C or C++? I will say

620
0:50:26.160 --> 0:50:30.160
personally I don't know. I haven't used C++ since my physics degree so I couldn't tell

621
0:50:30.160 --> 0:50:33.160
you. I don't know if you know anything about that, Paco.

622
0:50:33.160 --> 0:50:40.160
I just did a quick Google search. That's all. So I see there are some frames available.

623
0:50:40.160 --> 0:50:48.160
I just want to say there is a project by the University of Luxembourg which is called FAQAS.

624
0:50:48.160 --> 0:50:49.160
FAQAS.

625
0:50:49.160 --> 0:50:52.160
And it's not there quite yet.

626
0:50:52.160 --> 0:50:58.160
So based on the search I see there is something for C and also for a bit more for C++. Regarding

627
0:50:58.160 --> 0:51:03.160
your other question by the way, so should you do it as a gate hook? Given that it's

628
0:51:03.160 --> 0:51:04.160
right, that was the question?

629
0:51:04.160 --> 0:51:10.160
The idea was basically to require developers to run those mutation tests but not the whole

630
0:51:10.160 --> 0:51:18.160
set. The only mutation tests which are touching, which are testing the duty tests, which are

631
0:51:18.160 --> 0:51:20.160
tested in code which was modified in this project.

632
0:51:20.160 --> 0:51:24.160
Yeah, so actually there are some, depending on the framework, some have features which

633
0:51:24.160 --> 0:51:28.160
are incremental reports. So where they can just store the last state, then you can do

634
0:51:28.160 --> 0:51:34.160
a diff and use the results from your last execution to not execute all mutants and not

635
0:51:34.160 --> 0:51:37.160
generate all mutants because it knows I only change these production lines so I only need

636
0:51:37.160 --> 0:51:42.160
to generate mutants for these and I only change these tests so I only need to rerun the tests

637
0:51:42.160 --> 0:51:45.160
for these mutants which can tremendously speed it up.

638
0:51:45.160 --> 0:51:51.160
But still using it as a gate hook, I'm not sure. You can, by the way, use the same logic

639
0:51:51.160 --> 0:51:55.160
in the NCI as well to use the incremental reporting that saves a bit despite an also

640
0:51:55.160 --> 0:51:56.160
supports, I think.

641
0:51:56.160 --> 0:52:01.160
Yeah, so with what you have, you have caching, so you can cache those tests that you've done

642
0:52:01.160 --> 0:52:05.160
already and if those cases aren't touched, then you're sort of good if the changes to

643
0:52:05.160 --> 0:52:11.160
your code don't affect that. So that is an option. I would say, yeah, I, thank you, my

644
0:52:11.160 --> 0:52:16.160
opinion is again that maybe you don't want to explicitly mandate this on every run and

645
0:52:16.160 --> 0:52:20.160
the reason for that is it's kind of like it can then become kind of a metric that you

646
0:52:20.160 --> 0:52:23.160
can try and optimize for or something to look at whereas really I think the nice way to

647
0:52:23.160 --> 0:52:27.160
use it is every now and then is how I would say so. I think if you've got a super critical

648
0:52:27.160 --> 0:52:30.160
project where, you know, if that's really important, you may want to run it like that.

649
0:52:30.160 --> 0:52:35.160
For me, I don't need to but I think that's really up to you, up to you as an implementer,

650
0:52:35.160 --> 0:52:38.160
what you want to do and I think there's definitely a use case to do it in that way if that was

651
0:52:38.160 --> 0:52:41.160
important to you.

652
0:52:41.160 --> 0:52:43.160
Hand over here, hello.

653
0:52:43.160 --> 0:52:56.160
Yes, yes, short answer is yes. Long answer is depending on the actual framework, it might

654
0:52:56.160 --> 0:53:01.160
be that you had a comment to ignore it. Alternatively, there is a config file set up as well in

655
0:53:01.160 --> 0:53:06.160
Python where you can say only mutate these paths, only do these things. So what language

656
0:53:06.160 --> 0:53:07.160
do you use?

657
0:53:07.160 --> 0:53:13.160
That's a striker.

658
0:53:13.160 --> 0:53:17.160
I would say yes, I haven't looked that much at the striker but I think there are some

659
0:53:17.160 --> 0:53:22.160
nice stuff, it's quite generic for all frameworks. Exclude code for mutation, definitely yes.

660
0:53:22.160 --> 0:53:27.160
And depending on the framework, some even have nice things like exclude, do not mutate

661
0:53:27.160 --> 0:53:31.160
any calls to these classes which is interesting for the logging, for example, do not mutate

662
0:53:31.160 --> 0:53:36.160
any calls to this logging class but same you can do for packages, class paths, et cetera.

663
0:53:36.160 --> 0:53:40.160
I would say with striker as well, one of my colleagues uses striker because he maintains

664
0:53:40.160 --> 0:53:45.160
.NET SDK and he's also got mutation testing there in striker and it does seem very performant,

665
0:53:45.160 --> 0:53:49.160
it seems like it does have a lot of those features as well. If you're interested in

666
0:53:49.160 --> 0:53:51.160
TypeScript, I think there is something for you there.

667
0:53:51.160 --> 0:53:52.160
Cool.

668
0:53:52.160 --> 0:53:55.160
I think it might be free on open source reposers. Another question?

669
0:53:55.160 --> 0:54:10.160
Are there specific communities that are reproducible for debugging path process?

670
0:54:10.160 --> 0:54:12.160
Actually not a lot of...

671
0:54:12.160 --> 0:54:13.160
Question?

672
0:54:13.160 --> 0:54:18.160
Oh yeah, so the question is how reproducible are the mutants? So if you find one and the

673
0:54:18.160 --> 0:54:22.160
next one, is it still there? So as far as I know, there shouldn't be any randomness

674
0:54:22.160 --> 0:54:26.160
in these mutant generations. It just goes over the code, any condition that it finds

675
0:54:26.160 --> 0:54:30.160
that it can mutate, it will mutate. So the next time you run it, the same mutant should

676
0:54:30.160 --> 0:54:35.160
be there at the same place. So you could also see whether you killed it the next time. So

677
0:54:35.160 --> 0:54:37.160
yes, it's reproducible.

678
0:54:37.160 --> 0:54:55.160
A hand there. I think this person was first.

679
0:54:55.160 --> 0:55:14.160
That's a good question. I'll repeat that one. That's a good one. So the question there

680
0:55:14.160 --> 0:55:18.160
was, so mutation testing, we've talked all the big game. We've come up here and been

681
0:55:18.160 --> 0:55:21.160
like, hey, look, this is important, right? That's what we've talked about. And the question,

682
0:55:21.160 --> 0:55:24.160
which is a very valid question, is hey, if it's so important, why is no one supporting

683
0:55:24.160 --> 0:55:27.160
this question? Why is this all open source stuff? And you know what? I agree. That's

684
0:55:27.160 --> 0:55:31.160
a really good question. It's one I asked as well, to be honest. So now I totally support

685
0:55:31.160 --> 0:55:35.160
the question. And the question I'll probably say is, yeah, why aren't employers supporting

686
0:55:35.160 --> 0:55:41.160
this? The short answer I think is to do with ROI, unfortunately. And that sucks, honestly,

687
0:55:41.160 --> 0:55:45.160
because I would like us to invest more time in certain things. And I think it's just to

688
0:55:45.160 --> 0:55:50.160
do with company priorities, right? So I would like to spend more time. Honestly, I had

689
0:55:50.160 --> 0:55:53.160
quite a lot of fun adding the one feature I did get to add. I'd quite like to do some

690
0:55:53.160 --> 0:55:58.160
more. But again, I've got this API to implement. So do I have time? Well, no one's funding

691
0:55:58.160 --> 0:56:02.160
me to do it. So unfortunately, it really is like, unless there's an obvious ROI, this

692
0:56:02.160 --> 0:56:06.160
just seems to be the way things go. Unfortunately, that's the way we've kind of structured our

693
0:56:06.160 --> 0:56:11.160
platforms and so on. So I gave a talk earlier on PyPy and malware. And there was actually

694
0:56:11.160 --> 0:56:17.160
the reason that that kind of is so prevalent and so possible on PyPy is because PyPy haven't

695
0:56:17.160 --> 0:56:22.160
really implemented many ways to actually protect against malware being uploaded. So currently,

696
0:56:22.160 --> 0:56:26.160
I've uploaded some malware to PyPy that you can get yourself. And actually, the reason

697
0:56:26.160 --> 0:56:32.160
that they, it's not real malware, to be clear, it's a rick roll. But basically, what I'm

698
0:56:32.160 --> 0:56:36.160
trying to say here is that that project kind of didn't really get off the ground in terms

699
0:56:36.160 --> 0:56:39.160
of protecting users, just because I think originally Facebook were funding it and they

700
0:56:39.160 --> 0:56:43.160
stopped funding and that just didn't then continue. So unfortunately, yeah, this is just

701
0:56:43.160 --> 0:56:46.160
kind of the way that things are in open source right now. And yeah, I do feel your pain. I

702
0:56:46.160 --> 0:56:49.160
do understand. But that's all I can really say, I'm afraid.

703
0:56:49.160 --> 0:56:54.160
Yeah, I would quickly add to this, by the way, Striker, for example, is actually funded,

704
0:56:54.160 --> 0:56:59.160
is backed by a company who, for example, let's work in terms work on it as well. So some

705
0:56:59.160 --> 0:57:03.160
frameworks actually are backed and there are people already investing it. So it's not always

706
0:57:03.160 --> 0:57:05.160
bad, but sorry, let's go to that side.

707
0:57:05.160 --> 0:57:09.160
So you showed some HDMI reports for the results of the mutagenet test.

708
0:57:09.160 --> 0:57:10.160
Yes.

709
0:57:10.160 --> 0:57:15.160
We all know all managers and pretty teams loves your KPIs. So I'm wondering, is there

710
0:57:15.160 --> 0:57:36.160
any integration or bringing to export the mutagenet test result in Sona

711
0:57:36.160 --> 0:57:46.160
or anything that's going to happen over the next year?

712
0:57:46.160 --> 0:57:53.160
Yeah, so let's also ask, you were the maintainer of the other framework. So how does it go

713
0:57:53.160 --> 0:57:56.160
for the other by the framework?

714
0:57:56.160 --> 0:57:59.160
So, okay. So I talked about mut-mut not having that facility that feature.

715
0:57:59.160 --> 0:58:01.160
in cosmic rays that.

716
0:58:01.160 --> 0:58:02.160
Well, not really.

717
0:58:02.160 --> 0:58:05.160
In cosmic ray, the moment is kind of a bit unmaintained.

718
0:58:05.160 --> 0:58:07.160
And so the same kind of supplies.

719
0:58:07.160 --> 0:58:11.160
I don't want to say names, but there is a very, very large

720
0:58:11.160 --> 0:58:14.160
450 maybe vendor that uses it.

721
0:58:14.160 --> 0:58:16.160
And we asked them, can you fund development?

722
0:58:16.160 --> 0:58:19.160
They said, you know, no.

723
0:58:19.160 --> 0:58:22.160
They have shown this around at large events, like in front of

724
0:58:22.160 --> 0:58:25.160
thousands and thousands of people.

725
0:58:25.160 --> 0:58:28.160
But yeah, they're like, OK, we keep all the changes for itself

726
0:58:28.160 --> 0:58:31.160
and find it as it is.

727
0:58:31.160 --> 0:58:32.160
So for the Python frameworks.

728
0:58:32.160 --> 0:58:35.160
So we talk about time and balance and effort that you

729
0:58:35.160 --> 0:58:39.160
need to put in to develop all these features and functionalities.

730
0:58:39.160 --> 0:58:43.160
So the core team doesn't have this.

731
0:58:43.160 --> 0:58:45.160
Yeah, so for the Python frameworks, there's not really

732
0:58:45.160 --> 0:58:46.160
CI plugin support.

733
0:58:46.160 --> 0:58:49.160
I do know that, for example, PyTest, there is support for

734
0:58:49.160 --> 0:58:51.160
Jenkins and Sonar.

735
0:58:51.160 --> 0:58:53.160
And I'm not sure about Striker, but I know it's there.

736
0:58:53.160 --> 0:58:57.160
And usually these things are relatively easy to build

737
0:58:57.160 --> 0:58:59.160
yourself with here as well, because all you have to do is,

738
0:58:59.160 --> 0:59:02.160
if there is a report in some JSON file, you can quite easily

739
0:59:02.160 --> 0:59:05.160
parse it and make a nice HTML form about this.

740
0:59:05.160 --> 0:59:08.160
Because again, they're all open for contributions.

741
0:59:08.160 --> 0:59:10.160
Do we have time for one last?

742
0:59:10.160 --> 0:59:13.160
I want to just add to that a little bit.

743
0:59:13.160 --> 0:59:16.160
OK, really quickly, first of all, with your question, yeah,

744
0:59:16.160 --> 0:59:19.160
when I originally implemented my movement thing, I did do it

745
0:59:19.160 --> 0:59:22.160
on PR, and in that case I got an action that would comment my

746
0:59:22.160 --> 0:59:23.160
coverage in a nice, metric-y way.

747
0:59:23.160 --> 0:59:25.160
And so you can, it's quite simple to do.

748
0:59:25.160 --> 0:59:28.160
So about Cosmic Query, first of all, that sucks, and I'm

749
0:59:28.160 --> 0:59:31.160
sorry, that's blooming awful.

750
0:59:31.160 --> 0:59:34.160
Yeah, sadly, it does seem that a lot of what we've kind of

751
0:59:34.160 --> 0:59:36.160
been discussing on the side of the room is just like, man,

752
0:59:36.160 --> 0:59:38.160
it would be good if some, you know, we all agree this is

753
0:59:38.160 --> 0:59:40.160
important, right, and it's useful for a lot of things.

754
0:59:40.160 --> 0:59:41.160
It would be great if someone funded it.

755
0:59:41.160 --> 0:59:44.160
So I think, unfortunately, with Python, that is the state of

756
0:59:44.160 --> 0:59:45.160
play, and it does suck.

757
0:59:45.160 --> 0:59:47.160
But yes, I get you.

758
0:59:47.160 --> 0:59:49.160
Any other questions, finally?

759
0:59:49.160 --> 0:59:50.160
Yes, hello.

760
0:59:50.160 --> 0:59:55.160
Can you write custom notation to motivate your code, you know,

761
0:59:55.160 --> 0:59:56.160
custom logic?

762
0:59:56.160 --> 0:59:58.160
That's a really good question.

763
0:59:58.160 --> 1:00:00.160
So, sorry?

764
1:00:00.160 --> 1:00:01.160
Repeat it.

765
1:00:01.160 --> 1:00:03.160
That's, I will now repeat your really good question.

766
1:00:03.160 --> 1:00:07.160
The question was, so the question was, if I have a

767
1:00:07.160 --> 1:00:10.160
certain type of mutant that I want to make, can I do that?

768
1:00:10.160 --> 1:00:14.160
So I would say, with the stuff that I used in Python, the

769
1:00:14.160 --> 1:00:18.160
answer is you need to actually, you know, use the version you've

770
1:00:18.160 --> 1:00:19.160
downloaded, edit it yourself, and add that stuff.

771
1:00:19.160 --> 1:00:21.160
So sadly, there's not an easy customizable way.

772
1:00:21.160 --> 1:00:23.160
That would be an awesome enhancement, though, that I would

773
1:00:23.160 --> 1:00:24.160
like to see.

774
1:00:24.160 --> 1:00:26.160
You know, that would be cool.

775
1:00:26.160 --> 1:00:28.160
In other platforms, Paco, any other?

776
1:00:28.160 --> 1:00:30.160
I do know that I think Python does have some extension points,

777
1:00:30.160 --> 1:00:32.160
so it really depends.

778
1:00:32.160 --> 1:00:35.160
I know that the company I work for currently called Picnic,

779
1:00:35.160 --> 1:00:37.160
they're also working on extending it, for example, for

780
1:00:37.160 --> 1:00:38.160
reactive code.

781
1:00:38.160 --> 1:00:41.160
So there are some extension points often.

782
1:00:41.160 --> 1:00:47.160
So, in short, it depends on the framework and how easy it is.

783
1:00:47.160 --> 1:00:48.160
Are we done?

784
1:00:48.160 --> 1:00:49.160
Okay, we're at time.

785
1:00:49.160 --> 1:00:50.160
Thank you so much.

786
1:00:50.160 --> 1:00:51.160
This has been a really nice discussion as well, so thank you

787
1:00:51.160 --> 1:00:52.160
for sharing yours.

788
1:00:52.160 --> 1:01:18.160
Thank you.

