1
0:00:00.000 --> 0:00:11.000
Okay, so our next talk is by Ivan Sakhka.

2
0:00:11.000 --> 0:00:17.880
Ivan has commercial experience working in 3D graphics and runtime design with Rust,

3
0:00:17.880 --> 0:00:28.680
Nix and Haskell, and he also does design algorithm competitions and children's coding

4
0:00:28.680 --> 0:00:29.680
workshops.

5
0:00:29.680 --> 0:00:34.800
He lives in Belgium, loves biking, hiking, climbing and vegan cooking.

6
0:00:34.800 --> 0:00:40.720
His topic today is on the path of better interoperability with Rust.

7
0:00:40.720 --> 0:00:41.720
Thank you, Ivan.

8
0:00:41.720 --> 0:00:42.720
Thank you.

9
0:00:42.720 --> 0:00:43.720
Hi, everyone.

10
0:00:43.720 --> 0:00:55.440
So, this talk is about a thing I worked the past few months.

11
0:00:55.440 --> 0:01:05.520
There is also a blog article on engineering.iog.io, I guess, which is basically the content of

12
0:01:05.520 --> 0:01:09.440
the slides with links and references and everything.

13
0:01:09.440 --> 0:01:18.320
And so, the IOG issue is there is really large Haskell code base to maintain and some parts

14
0:01:18.320 --> 0:01:25.800
of the code base are C bits mainly for cryptographic library like Kryptonite.

15
0:01:25.800 --> 0:01:33.920
And so, there is a way to more easily integrate Rust library because for cryptography, there

16
0:01:33.920 --> 0:01:39.920
is cool Rust library implementation.

17
0:01:39.920 --> 0:01:44.920
And that's not quite simple right now to interface Haskell and Rust.

18
0:01:44.920 --> 0:01:50.800
And so, this talk is about how to make the experience easier.

19
0:01:50.800 --> 0:01:51.800
And there is a repository.

20
0:01:51.800 --> 0:01:59.760
Yeah, so, it's the links here, the subtitle where you can find the source and everything.

21
0:01:59.760 --> 0:02:08.720
And so, when we try to integrate to runtime for example, Rust and Haskell in our case,

22
0:02:08.720 --> 0:02:16.600
there is a lot of way to interoperate different programming languages.

23
0:02:16.600 --> 0:02:26.360
And one of the solution which is often used is to use, I don't know, sockets or writing

24
0:02:26.360 --> 0:02:28.840
on a file or pipe or something like that.

25
0:02:28.840 --> 0:02:35.120
And to use a protocol, for example, protocol buffer from Google or anything you can use,

26
0:02:35.120 --> 0:02:40.280
Amazon or HTTP API, all this kind of stuff.

27
0:02:40.280 --> 0:02:50.280
But if you do such, you will rely on C skulls like EOs to make interoperability works.

28
0:02:50.280 --> 0:02:58.600
And if the librarian which you rely, you want really little over to call it to rely on what

29
0:02:58.600 --> 0:03:05.080
the librarian does, you prefer to use something which is called FFI, which is a library.

30
0:03:05.080 --> 0:03:09.760
It's more close to system programming, which is foreign function interface, which is basically

31
0:03:09.760 --> 0:03:19.080
jumping the memory of binary code generated by another languages and up it will work the

32
0:03:19.080 --> 0:03:20.080
right way.

33
0:03:20.080 --> 0:03:24.360
And to make it work, it requires special attention.

34
0:03:24.360 --> 0:03:33.440
And the tools needed to underline that is we will take special attention to that right

35
0:03:33.440 --> 0:03:34.440
now.

36
0:03:34.440 --> 0:03:40.600
And if we look at what exists to FFI between Rust and other programming languages, because

37
0:03:40.600 --> 0:03:49.400
there is such a common way to interoperate stuff, we can see that from C to Rust, there

38
0:03:49.400 --> 0:03:36.440
is a thing called Rust

39
0:03:52.440 --> 0:03:54.440
is a thing called C.

40
0:03:54.440 --> 0:04:01.640
I will not name all of them, but there are all of them, which is Bongen, which is generating

41
0:04:01.640 --> 0:04:03.640
bindings.

42
0:04:03.640 --> 0:04:10.120
You already know that, but why we do binding generation?

43
0:04:10.120 --> 0:04:18.120
Because FFI is really something dangerous where if your two foreign function interface

44
0:04:18.120 --> 0:04:21.720
didn't match, you will not know.

45
0:04:21.720 --> 0:04:24.120
Your compiler will not warn you about that.

46
0:04:24.120 --> 0:04:30.840
It will warn you if a symbol is missing, but it will not check the types, the number of

47
0:04:30.840 --> 0:04:35.400
your arguments, if you respect the same calling convention.

48
0:04:35.400 --> 0:04:43.640
It will show you want this interface to be generated so you can ensure it matches something

49
0:04:43.640 --> 0:04:47.960
very common, but it appears it does not exist between Rust and Askel.

50
0:04:47.960 --> 0:04:52.720
So that's basically what this Tolkien project is about.

51
0:04:52.720 --> 0:04:55.840
And so a bit of Rust code.

52
0:04:55.840 --> 0:05:03.000
The way I choose to generate Bongen using a macro, which works like a function decorator,

53
0:05:03.000 --> 0:05:09.800
so it's a function that does something really simple, just print hello name, string interpolation

54
0:05:09.800 --> 0:05:10.800
in Rust.

55
0:05:10.800 --> 0:05:17.440
Here, I import my library, and here I have my custom thing, which is I tell my binding

56
0:05:17.440 --> 0:05:25.120
generation about what will be my Askel wanted function signature.

57
0:05:25.120 --> 0:05:30.440
And so a macro will expand the code.

58
0:05:30.440 --> 0:05:34.520
So it's got generation, macro actually, in most languages.

59
0:05:34.520 --> 0:05:38.640
So here's a code expanded by the macro.

60
0:05:38.640 --> 0:05:43.360
I have numonguel things because maybe you know mongling something that exists in C++2

61
0:05:43.360 --> 0:05:48.840
is a function symbol change, a change in binary, and we want to preserve it.

62
0:05:48.840 --> 0:05:56.080
We want binary to have the same symbol to be culled from the outside from an Askel program.

63
0:05:56.080 --> 0:06:02.920
And all those things I want you to look at is I use external C here, precise C. That's

64
0:06:02.920 --> 0:06:03.960
mean in Rust.

65
0:06:03.960 --> 0:06:08.240
I want to use the C culling convention, C-heavy-i.

66
0:06:08.240 --> 0:06:15.040
So high-be-i is a culling convention and memory type layouts, which is a bit of the same part

67
0:06:15.040 --> 0:06:16.960
of the same definition.

68
0:06:16.960 --> 0:06:25.280
The thing is when you define FFI in Haskell, we'll show you Askel code just after this

69
0:06:25.280 --> 0:06:27.760
slide, you don't have the choice.

70
0:06:27.760 --> 0:06:30.440
You use the C culling convention.

71
0:06:30.440 --> 0:06:37.280
In Rust, you have a bit more choice, but you can't use, just not true what I wanted you

72
0:06:37.280 --> 0:06:40.680
to say, you have the choice in Askel to, never mind.

73
0:06:40.680 --> 0:06:46.880
I want just to point out that Rust, heavy-i, Rust culling convention, the cull convention

74
0:06:46.880 --> 0:06:52.240
I use Rust function inside the binary between the same, is unstable, which is things that

75
0:06:52.240 --> 0:07:02.200
exist in Askel 2, which is a way that Rust internal, the Rust core team, keep to be able

76
0:07:02.200 --> 0:07:10.880
to break the mechanism inside Rust C without changing the module version of the compiler.

77
0:07:10.880 --> 0:07:15.280
So for example, the culling convention changed several times in the stable version of the

78
0:07:15.280 --> 0:07:19.920
language, which is Rust 1.0 something.

79
0:07:19.920 --> 0:07:25.280
So if we build a thing on top of Rust, heavy-i, culling convention, keep memory layout, it

80
0:07:25.280 --> 0:07:27.800
will not be stable, it will be an hack.

81
0:07:27.800 --> 0:07:34.280
And so maintaining it will be really laborious because it's working with internal documentation

82
0:07:34.280 --> 0:07:39.320
which is not made for people to use it as a public API.

83
0:07:39.320 --> 0:07:49.760
And so, why Rust macro? I want also to point out that because there is a lot of way to

84
0:07:49.760 --> 0:07:54.440
do binding generation and often it work as an external tooling.

85
0:07:54.440 --> 0:08:00.200
And the issue with an external tooling, it's really easy to forget to integrate the external

86
0:08:00.200 --> 0:08:03.080
tooling into your build suite.

87
0:08:03.080 --> 0:08:11.120
And if you do that, your binding will be out of sync with your codes, so your program will

88
0:08:11.120 --> 0:08:12.120
not work.

89
0:08:12.120 --> 0:08:16.880
So we want binding generation to be part of the compilation.

90
0:08:16.880 --> 0:08:18.880
Create is a Rust module.

91
0:08:18.880 --> 0:08:22.600
And so I did it that way.

92
0:08:22.600 --> 0:08:28.840
And I also want to point out that there is other programming in Rust space, like C-bindgents

93
0:08:28.840 --> 0:08:34.240
are just try to integrate Rust code like search and replace.

94
0:08:34.240 --> 0:08:40.440
So if you, for example, in the long range, have two identifiers in different namespace,

95
0:08:40.440 --> 0:08:46.200
C-bindgents, that's a way to generate C-bindgents for Rust, will not be able to understand their

96
0:08:46.200 --> 0:08:47.200
meaning.

97
0:08:47.200 --> 0:08:50.920
So when they define the algorithm, it's part of the limitation of that library.

98
0:08:50.920 --> 0:08:56.640
It's not part of the bindgen library we present here that understands Rust semantics because

99
0:08:56.640 --> 0:08:59.840
it's implemented as a macro.

100
0:08:59.840 --> 0:09:06.760
And so it expands Rust code and it also generates as a set effect R-scale code and R-scale modules

101
0:09:06.760 --> 0:09:09.720
that just have the one-tied signature.

102
0:09:09.720 --> 0:09:17.240
So same symbol, same signature, things that's synced together.

103
0:09:17.240 --> 0:09:24.960
So if we relook the Rust code, there's another things I want to talk to you about here.

104
0:09:24.960 --> 0:09:29.960
You see you have the C compatible coding conversion type.

105
0:09:29.960 --> 0:09:38.880
The thing I want you to look at is I use trait, trait, rep C, trait, rep Rust, and that's

106
0:09:38.880 --> 0:09:40.440
trait are Rust type classes.

107
0:09:40.440 --> 0:09:44.120
That's a way to define contracts for data structure.

108
0:09:44.120 --> 0:09:48.440
You mean a data structure should implement this and this method.

109
0:09:48.440 --> 0:09:55.600
So I want every data structure that has this method would implement those internally, implemented

110
0:09:55.600 --> 0:10:01.240
as virtual table, like in C++.

111
0:10:01.240 --> 0:10:02.240
And why I use that?

112
0:10:02.240 --> 0:10:07.600
I use that to be extensive programmable.

113
0:10:07.600 --> 0:10:09.000
So I have nice error.

114
0:10:09.000 --> 0:10:11.360
It's part of Rust type system.

115
0:10:11.360 --> 0:10:15.400
Users can add types to this framework.

116
0:10:15.400 --> 0:10:20.280
And for the types, which is part of the standard library that I implement myself, I take care

117
0:10:20.280 --> 0:10:21.880
of the memory management.

118
0:10:21.880 --> 0:10:25.120
And we talk about it a bit later.

119
0:10:25.120 --> 0:10:32.440
And also the thing is in FFI, in Rust, you can use only what's called FFE safe types.

120
0:10:32.440 --> 0:10:37.680
It means types that have a memory layout in SQL in convention.

121
0:10:37.680 --> 0:10:43.240
And most of Rust type have undefined memory layout for SQL in convention.

122
0:10:43.240 --> 0:10:49.960
So the thing is, for example, if I get Rust strings, I cast it safely to a C string.

123
0:10:49.960 --> 0:10:55.440
So I could represent as C string works, which knows the way that Rust strings are actually

124
0:10:55.440 --> 0:10:58.480
represented.

125
0:10:58.480 --> 0:11:02.320
And so what about GC?

126
0:11:02.320 --> 0:11:09.320
The thing is Rust have a destructor mechanism based on ownership lifetime, a lot of rusty

127
0:11:09.320 --> 0:11:14.400
things, but the idea is more about destructor.

128
0:11:14.400 --> 0:11:20.320
When you go out of a scope, the destructor of the value is called, which is dropped.

129
0:11:20.320 --> 0:11:29.320
And so what I do here is I tell Rust type system does not call drop on Rust value because

130
0:11:29.320 --> 0:11:31.640
it will live on the Haskell side.

131
0:11:31.640 --> 0:11:40.120
So that's the other side of the bindings that need to free the value, which is similar to

132
0:11:40.120 --> 0:11:47.360
what you can do with March, I don't know how to pronounce that library.

133
0:11:47.360 --> 0:11:52.880
And the things is also I learned during this project, the real semantic of safe and then

134
0:11:52.880 --> 0:12:05.480
unsafe for a code definition, because I finally understand that unsafe means you want to play

135
0:12:05.480 --> 0:12:12.880
with any object on the Haskell heap, which is not the default case of what we actually

136
0:12:12.880 --> 0:12:16.280
do when we pass basic data typesets.

137
0:12:16.280 --> 0:12:26.720
It does not need the garbage collector to pause because it doesn't know if we could

138
0:12:26.720 --> 0:12:34.560
get an inconsistent state by something that the foreign code will do.

139
0:12:34.560 --> 0:12:42.120
And so if you use unsafe, you will have a warning that say a cautious, an unsafe code

140
0:12:42.120 --> 0:12:50.760
will slow down your war program or you want to do that or not, anything.

141
0:12:50.760 --> 0:12:57.680
And that's a library, a Rust library, but those are things I did.

142
0:12:57.680 --> 0:13:03.360
And that's also what exists for all of the Rust tooling is a key tool that helps you

143
0:13:03.360 --> 0:13:12.440
to set up a project because you have to tweak your Rust build file, you have to tweak your

144
0:13:12.440 --> 0:13:14.440
Rscale build file.

145
0:13:14.440 --> 0:13:20.440
Actually you have to do a set up that has built customization in Rscale unless you use

146
0:13:20.440 --> 0:13:28.560
Nix, which I could understand a lot of people who want to.

147
0:13:28.560 --> 0:13:35.240
And on Rust.ai I use build.rs if you do a dynamic library because dynamic library that

148
0:13:35.240 --> 0:13:41.760
JC fetch needs a JC version in the name of the dynamic library.

149
0:13:41.760 --> 0:13:47.120
So that's the things that I have to get as a build customization.

150
0:13:47.120 --> 0:13:53.640
This scan of tweak, but overall this library is really small.

151
0:13:53.640 --> 0:14:00.760
I'll put next slide just a few minutes later.

152
0:14:00.760 --> 0:14:07.440
The world library, the world tooling I present here is less than 1000 lines of code.

153
0:14:07.440 --> 0:14:13.020
So it's 1000 lines of code.

154
0:14:13.020 --> 0:14:23.040
So that's really small and minimalist and key.

155
0:14:23.040 --> 0:14:28.960
So actually I forget what I was about to say.

156
0:14:28.960 --> 0:14:39.320
Actually all of that of this plumber is simple and I'm not sure myself I want to make it

157
0:14:39.320 --> 0:14:42.720
more complex because it just works.

158
0:14:42.720 --> 0:14:46.960
And the thing is it works but it is really simple data types.

159
0:14:46.960 --> 0:14:52.720
The C data types that are representable in Rscale and Rust.

160
0:14:52.720 --> 0:14:57.760
And there is a lot of things that are not representable in C. For example, Rust slice.

161
0:14:57.760 --> 0:15:03.640
A slice is a pointer and a size and you have a guarantee that there is memory in it.

162
0:15:03.640 --> 0:15:05.600
You can iterate on it.

163
0:15:05.600 --> 0:15:10.560
You can represent it in C with a struct but it's not really a C type.

164
0:15:10.560 --> 0:15:14.320
You will do a custom struct.

165
0:15:14.320 --> 0:15:22.880
And those things are targeted by the Rust RFC which is an intramarable ABI which is

166
0:15:22.880 --> 0:15:31.640
creating an ABI which is stable which have more Rust things than the C ABI but which

167
0:15:31.640 --> 0:15:38.320
is flagged as stable which is not the case of the Rust internal ABI.

168
0:15:38.320 --> 0:15:44.640
And the other thing is CABAL customization is a bit of a mess.

169
0:15:44.640 --> 0:15:52.040
Doing this is a set up that has to find the library and anything to make it work because

170
0:15:52.040 --> 0:15:53.280
of CABAL bugs.

171
0:15:53.280 --> 0:16:01.160
So I will not have to have a standard way to integrate for example Rust and chain into

172
0:16:01.160 --> 0:16:02.560
CABAL.

173
0:16:02.560 --> 0:16:09.360
Here you have to run the total chain into different type.

174
0:16:09.360 --> 0:16:11.120
And that's it.

175
0:16:11.120 --> 0:16:17.240
I can throw a lot of questions or I can do a demo if I might talk in short hours and

176
0:16:17.240 --> 0:16:20.280
what I was expecting.

177
0:16:20.280 --> 0:16:24.080
So that's the day to ask questions.

178
0:16:24.080 --> 0:16:25.080
Yeah.

179
0:16:25.080 --> 0:16:35.960
Yeah I can do a quick demo.

180
0:16:35.960 --> 0:16:41.560
Sorry.

181
0:16:41.560 --> 0:16:46.760
It's not easy because it's not mirroring so I have to look at the screen YI.

182
0:16:46.760 --> 0:16:51.280
I'm doing this thing.

183
0:16:51.280 --> 0:16:55.320
What I can do.

184
0:16:55.320 --> 0:17:06.240
What I can do.

185
0:17:06.240 --> 0:17:14.560
Yeah.

186
0:17:14.560 --> 0:17:23.920
Did you.

187
0:17:23.920 --> 0:17:24.920
Yeah.

188
0:17:24.920 --> 0:17:34.800
So from what I understand you can pass from from Rust to Haskell the subset of data that

189
0:17:34.800 --> 0:17:37.880
is representable with the Rc.

190
0:17:37.880 --> 0:17:41.000
So you can't really pass functions for example.

191
0:17:41.000 --> 0:17:43.080
Or can you?

192
0:17:43.080 --> 0:17:48.880
It will be unsafe on the Haskell side if you do that for example because you will need

193
0:17:48.880 --> 0:17:50.880
to be.

194
0:17:50.880 --> 0:17:53.440
I is an interesting example.

195
0:17:53.440 --> 0:18:02.280
I didn't try passing a function pointer.

196
0:18:02.280 --> 0:18:09.520
The thing is there is the thing is you if you want to pass complex data types you it's

197
0:18:09.520 --> 0:18:16.920
always more meaningful to use serialization because it's it's it doesn't match the two

198
0:18:16.920 --> 0:18:28.240
language model but function I didn't honestly think about it but I you mean a function pointers

199
0:18:28.240 --> 0:18:30.400
that will cross if I buyer.

200
0:18:30.400 --> 0:18:33.440
So that's the whole question right.

201
0:18:33.440 --> 0:18:34.440
Yeah.

202
0:18:34.440 --> 0:18:35.440
Yeah.

203
0:18:35.440 --> 0:18:36.440
Yeah.

204
0:18:36.440 --> 0:18:41.160
So if you have no concept of sharing pointers you copy the whole data and it's made to the

205
0:18:41.160 --> 0:18:46.800
other node including function which are serialized and then read to present on the other node.

206
0:18:46.800 --> 0:18:58.960
I guess it will not not really be an issue because because in fact there's there's no

207
0:18:58.960 --> 0:19:07.640
really boundary at the end that's one binary so there's only things that I want my model

208
0:19:07.640 --> 0:19:16.160
to have a better grasp around it is all GC Haskell GC will behave in this case but I

209
0:19:16.160 --> 0:19:25.480
think there is no special issue for doing that but I think I should experiment on it

210
0:19:25.480 --> 0:19:30.280
first to to to before saying it's it's completely okay to do that.

211
0:19:30.280 --> 0:19:31.280
Yeah.

212
0:19:31.280 --> 0:19:33.280
Thank you for the question.

213
0:19:33.280 --> 0:19:34.280
Yeah.

214
0:19:34.280 --> 0:19:35.280
I.

215
0:19:35.280 --> 0:19:36.280
Did you see something.

216
0:19:36.280 --> 0:19:37.280
Fuck.

217
0:19:37.280 --> 0:19:58.160
So.

218
0:19:58.160 --> 0:20:07.200
Sorry.

219
0:20:07.200 --> 0:20:16.560
So if I go here for example I have a little rest things.

220
0:20:16.560 --> 0:20:18.560
SRC.

221
0:20:18.560 --> 0:20:21.060
Yeah.

222
0:20:21.060 --> 0:20:29.600
Can show you the lead the rest which do a cryptographic primitive for example and you

223
0:20:29.600 --> 0:20:38.560
what you manipulate is clearly rest types it's not C types and I have a warning and

224
0:20:38.560 --> 0:20:40.560
I don't know why.

225
0:20:40.560 --> 0:20:41.560
Yeah.

226
0:20:41.560 --> 0:20:50.840
Because I don't start first and if I do I guess it will work I hope so.

227
0:20:50.840 --> 0:20:58.800
I can check what's happened with after macro expansion.

228
0:20:58.800 --> 0:21:08.160
Did it work.

229
0:21:08.160 --> 0:21:11.200
Yeah.

230
0:21:11.200 --> 0:21:12.200
Sorry.

231
0:21:12.200 --> 0:21:14.200
demo effect.

232
0:21:14.200 --> 0:21:15.200
Yeah.

233
0:21:15.200 --> 0:21:16.200
Why.

234
0:21:16.200 --> 0:21:17.200
Fuck.

235
0:21:17.200 --> 0:21:27.000
Maybe the other one is locked.

236
0:21:27.000 --> 0:21:32.520
I don't know why you do that maybe I'm no internet connection and that's a so issue

237
0:21:32.520 --> 0:21:33.520
here.

238
0:21:33.520 --> 0:21:34.520
Yeah.

239
0:21:34.520 --> 0:21:36.720
I guess that's the issue.

240
0:21:36.720 --> 0:21:42.320
So never mind I can show you the ask and things generated.

241
0:21:42.320 --> 0:21:46.720
So no that's a cabal file generated by the client.

242
0:21:46.720 --> 0:21:51.400
And so I have.

243
0:21:51.400 --> 0:21:53.000
Looks like that.

244
0:21:53.000 --> 0:22:01.960
I have my my.

245
0:22:01.960 --> 0:22:10.200
What can I show you.

246
0:22:10.200 --> 0:22:14.400
I can show you the bleed customization can see what it looks like.

247
0:22:14.400 --> 0:22:16.240
Look like sit.

248
0:22:16.240 --> 0:22:22.600
It's not really interesting but you do few things.

249
0:22:22.600 --> 0:22:25.720
And what can I show you.

250
0:22:25.720 --> 0:22:31.840
I have a little file that's unsure that's a client you use to generate the wall stuff

251
0:22:31.840 --> 0:22:38.120
is compatible with a version of the library you use to do.

252
0:22:38.120 --> 0:22:41.600
I want to change the world behavior in the future.

253
0:22:41.600 --> 0:22:47.840
And now on the ask inside it looks something like that so I have a project I have a couple

254
0:22:47.840 --> 0:22:50.680
project right.

255
0:22:50.680 --> 0:22:54.800
It looks like that.

256
0:22:54.800 --> 0:23:02.920
And the test scene just work like.

257
0:23:02.920 --> 0:23:11.880
I have a test that couple.

258
0:23:11.880 --> 0:23:13.240
It looks like that.

259
0:23:13.240 --> 0:23:21.480
I can use it like it was normal ascal dependencies and my.

260
0:23:21.480 --> 0:23:23.960
Ask code.

261
0:23:23.960 --> 0:23:25.960
It's quite simple I guess.

262
0:23:25.960 --> 0:23:26.960
Yeah.

263
0:23:26.960 --> 0:23:31.960
Sorry fix me but don't look.

264
0:23:31.960 --> 0:23:32.960
Yeah.

265
0:23:32.960 --> 0:23:33.960
Yeah.

266
0:23:33.960 --> 0:23:36.960
You have something like that.

267
0:23:36.960 --> 0:23:46.040
It's always a bit you manipulate low level data structure but that's that's often what

268
0:23:46.040 --> 0:23:51.800
you want to do when you you you broke something in the system programming language.

269
0:23:51.800 --> 0:23:57.160
That's one reason to use rest over something else.

270
0:23:57.160 --> 0:24:00.240
Otherwise.

271
0:24:00.240 --> 0:24:08.040
I don't know I got the input that's the binding don't really need.

272
0:24:08.040 --> 0:24:10.480
Don't really need.

273
0:24:10.480 --> 0:24:15.520
More advanced data types for example ochamel have an interrupt ochamel interrupt things

274
0:24:15.520 --> 0:24:26.520
with rust that helps to represent a duty bus rust and ochamel and I don't know if we really

275
0:24:26.520 --> 0:24:33.960
need to have a duty conversion between languages for most of use case I don't know.

276
0:24:33.960 --> 0:24:34.960
Yeah.

277
0:24:34.960 --> 0:24:36.960
That's that's many.

278
0:24:36.960 --> 0:24:43.240
I don't know if you have other question or just curious about something.

279
0:24:43.240 --> 0:24:45.240
Or another.

280
0:24:45.240 --> 0:24:47.240
Yeah.

281
0:24:47.240 --> 0:24:52.160
Hey there's a question.

282
0:24:52.160 --> 0:24:59.760
So you said I want one that rest will not drop the value and that's to scale to three

283
0:24:59.760 --> 0:25:03.560
so how does that work?

284
0:25:03.560 --> 0:25:10.560
Is that under by the GVIPE I have a GC or does it need to be done manually?

285
0:25:10.560 --> 0:25:14.920
You mean I tell us to not drop a value?

286
0:25:14.920 --> 0:25:15.920
No.

287
0:25:15.920 --> 0:25:25.400
If we do rest doesn't drop the value who does is it the GVIPE or somewhere we need to add

288
0:25:25.400 --> 0:25:27.520
that in a program?

289
0:25:27.520 --> 0:25:28.520
Yeah.

290
0:25:28.520 --> 0:25:36.600
The idea is because it's part of the marshmold things we have to free it explicitly as I

291
0:25:36.600 --> 0:25:37.600
understand it.

292
0:25:37.600 --> 0:25:47.960
If we do not value with leaf maybe somebody could tell me if I mistaken the spot.

293
0:25:47.960 --> 0:25:54.440
It's really hard to debug what actually GC does.

294
0:25:54.440 --> 0:26:01.680
So far I didn't experiment so mention that but yeah the real thing is really that if

295
0:26:01.680 --> 0:26:09.200
you do not force Rust to not drop things it will because it's part of its type system

296
0:26:09.200 --> 0:26:17.840
it will pull code to free memory to free of the memory allocator you used straight into

297
0:26:17.840 --> 0:26:19.680
the code.

298
0:26:19.680 --> 0:26:25.760
Rust statically decide where to put allocation and release of memory inside the bin and binary

299
0:26:25.760 --> 0:26:33.760
computed statically at compile time so you have to tell the type system to not do it

300
0:26:33.760 --> 0:26:38.040
for specific types if there is an internals for that.

301
0:26:38.040 --> 0:26:48.920
But on the Haskell side I'm not sure I'm pretty sure that the GC will track it as a

302
0:26:48.920 --> 0:26:56.280
garbage collected object I think because you have to do it explicitly.

303
0:26:56.280 --> 0:27:08.400
That's one of the point I'm a bit unconfident so I want to check again this kind of scenario.

304
0:27:08.400 --> 0:27:12.440
Do you have a question?

305
0:27:12.440 --> 0:27:17.640
What do you do if there's an external Rust library that you don't have control over because

306
0:27:17.640 --> 0:27:23.040
they might not want to add HS bindgen macros to their code base?

307
0:27:23.040 --> 0:27:30.480
Is there a way of generating a shim or something?

308
0:27:30.480 --> 0:27:37.120
In fact it's really easy in Rust to do re-export so you can always create a new create, re-export

309
0:27:37.120 --> 0:27:43.040
a create as you say I depend on this create and re-export the thing I want to re-export

310
0:27:43.040 --> 0:27:47.880
and I decorate or not element.

311
0:27:47.880 --> 0:27:50.880
Yes it works.

312
0:27:50.880 --> 0:27:52.880
Sorry?

313
0:27:52.880 --> 0:27:59.520
Can you put those macros on the functions in the other library then?

314
0:27:59.520 --> 0:28:09.800
In fact it's just wrapping function by function so you can do whatever you want.

315
0:28:09.800 --> 0:28:16.240
And you can opt in or opt out some function of a library and some not which is to me is

316
0:28:16.240 --> 0:28:23.480
the advantage of using macro and function decorator over code, work code parsing.

317
0:28:23.480 --> 0:28:27.040
That's not free though is it?

318
0:28:27.040 --> 0:28:28.040
That's not?

319
0:28:28.040 --> 0:28:33.040
So if you're re-exporting functions but are you actually re-exporting the same function

320
0:28:33.040 --> 0:28:37.600
or are you exporting a wrapper around the re-exporation?

321
0:28:37.600 --> 0:28:49.320
Yeah but I, okay, I in Rust there is a clear idea of what symbol I want to expose and what

322
0:28:49.320 --> 0:28:55.520
symbol I don't want to expose so I'm pretty confident that the compiler has the library

323
0:28:55.520 --> 0:28:57.840
to inline or not things.

324
0:28:57.840 --> 0:29:02.840
So for example most of the trait implementation I do which is casting are inline.

325
0:29:02.840 --> 0:29:08.080
I explicitly say I want it to be inline and so yes it's a function that's called a function

326
0:29:08.080 --> 0:29:14.680
but at the end it's just, it's, have no runtime cost.

327
0:29:14.680 --> 0:29:15.680
So yeah.

328
0:29:15.680 --> 0:29:17.680
Okay, we're out of time.

329
0:29:17.680 --> 0:29:18.680
Thank you.

330
0:29:18.680 --> 0:29:19.680
So thanks very much Yvonne.

331
0:29:19.680 --> 0:29:20.680
Let's give him a round of applause.

332
0:29:20.680 --> 0:29:33.880
Thank you very much.

