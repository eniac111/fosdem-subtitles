WEBVTT

00:00.000 --> 00:11.000
Okay, so our next talk is by Ivan Sakhka.

00:11.000 --> 00:17.880
Ivan has commercial experience working in 3D graphics and runtime design with Rust,

00:17.880 --> 00:28.680
Nix and Haskell, and he also does design algorithm competitions and children's coding

00:28.680 --> 00:29.680
workshops.

00:29.680 --> 00:34.800
He lives in Belgium, loves biking, hiking, climbing and vegan cooking.

00:34.800 --> 00:40.720
His topic today is on the path of better interoperability with Rust.

00:40.720 --> 00:41.720
Thank you, Ivan.

00:41.720 --> 00:42.720
Thank you.

00:42.720 --> 00:43.720
Hi, everyone.

00:43.720 --> 00:55.440
So, this talk is about a thing I worked the past few months.

00:55.440 --> 01:05.520
There is also a blog article on engineering.iog.io, I guess, which is basically the content of

01:05.520 --> 01:09.440
the slides with links and references and everything.

01:09.440 --> 01:18.320
And so, the IOG issue is there is really large Haskell code base to maintain and some parts

01:18.320 --> 01:25.800
of the code base are C bits mainly for cryptographic library like Kryptonite.

01:25.800 --> 01:33.920
And so, there is a way to more easily integrate Rust library because for cryptography, there

01:33.920 --> 01:39.920
is cool Rust library implementation.

01:39.920 --> 01:44.920
And that's not quite simple right now to interface Haskell and Rust.

01:44.920 --> 01:50.800
And so, this talk is about how to make the experience easier.

01:50.800 --> 01:51.800
And there is a repository.

01:51.800 --> 01:59.760
Yeah, so, it's the links here, the subtitle where you can find the source and everything.

01:59.760 --> 02:08.720
And so, when we try to integrate to runtime for example, Rust and Haskell in our case,

02:08.720 --> 02:16.600
there is a lot of way to interoperate different programming languages.

02:16.600 --> 02:26.360
And one of the solution which is often used is to use, I don't know, sockets or writing

02:26.360 --> 02:28.840
on a file or pipe or something like that.

02:28.840 --> 02:35.120
And to use a protocol, for example, protocol buffer from Google or anything you can use,

02:35.120 --> 02:40.280
Amazon or HTTP API, all this kind of stuff.

02:40.280 --> 02:50.280
But if you do such, you will rely on C skulls like EOs to make interoperability works.

02:50.280 --> 02:58.600
And if the librarian which you rely, you want really little over to call it to rely on what

02:58.600 --> 03:05.080
the librarian does, you prefer to use something which is called FFI, which is a library.

03:05.080 --> 03:09.760
It's more close to system programming, which is foreign function interface, which is basically

03:09.760 --> 03:19.080
jumping the memory of binary code generated by another languages and up it will work the

03:19.080 --> 03:20.080
right way.

03:20.080 --> 03:24.360
And to make it work, it requires special attention.

03:24.360 --> 03:33.440
And the tools needed to underline that is we will take special attention to that right

03:33.440 --> 03:34.440
now.

03:34.440 --> 03:40.600
And if we look at what exists to FFI between Rust and other programming languages, because

03:40.600 --> 03:49.400
there is such a common way to interoperate stuff, we can see that from C to Rust, there

03:49.400 --> 03:52.440
is a thing called Rust

03:52.440 --> 03:54.440
is a thing called C.

03:54.440 --> 04:01.640
I will not name all of them, but there are all of them, which is Bongen, which is generating

04:01.640 --> 04:03.640
bindings.

04:03.640 --> 04:10.120
You already know that, but why we do binding generation?

04:10.120 --> 04:18.120
Because FFI is really something dangerous where if your two foreign function interface

04:18.120 --> 04:21.720
didn't match, you will not know.

04:21.720 --> 04:24.120
Your compiler will not warn you about that.

04:24.120 --> 04:30.840
It will warn you if a symbol is missing, but it will not check the types, the number of

04:30.840 --> 04:35.400
your arguments, if you respect the same calling convention.

04:35.400 --> 04:43.640
It will show you want this interface to be generated so you can ensure it matches something

04:43.640 --> 04:47.960
very common, but it appears it does not exist between Rust and Askel.

04:47.960 --> 04:52.720
So that's basically what this Tolkien project is about.

04:52.720 --> 04:55.840
And so a bit of Rust code.

04:55.840 --> 05:03.000
The way I choose to generate Bongen using a macro, which works like a function decorator,

05:03.000 --> 05:09.800
so it's a function that does something really simple, just print hello name, string interpolation

05:09.800 --> 05:10.800
in Rust.

05:10.800 --> 05:17.440
Here, I import my library, and here I have my custom thing, which is I tell my binding

05:17.440 --> 05:25.120
generation about what will be my Askel wanted function signature.

05:25.120 --> 05:30.440
And so a macro will expand the code.

05:30.440 --> 05:34.520
So it's got generation, macro actually, in most languages.

05:34.520 --> 05:38.640
So here's a code expanded by the macro.

05:38.640 --> 05:43.360
I have numonguel things because maybe you know mongling something that exists in C++2

05:43.360 --> 05:48.840
is a function symbol change, a change in binary, and we want to preserve it.

05:48.840 --> 05:56.080
We want binary to have the same symbol to be culled from the outside from an Askel program.

05:56.080 --> 06:02.920
And all those things I want you to look at is I use external C here, precise C. That's

06:02.920 --> 06:03.960
mean in Rust.

06:03.960 --> 06:08.240
I want to use the C culling convention, C-heavy-i.

06:08.240 --> 06:15.040
So high-be-i is a culling convention and memory type layouts, which is a bit of the same part

06:15.040 --> 06:16.960
of the same definition.

06:16.960 --> 06:25.280
The thing is when you define FFI in Haskell, we'll show you Askel code just after this

06:25.280 --> 06:27.760
slide, you don't have the choice.

06:27.760 --> 06:30.440
You use the C culling convention.

06:30.440 --> 06:37.280
In Rust, you have a bit more choice, but you can't use, just not true what I wanted you

06:37.280 --> 06:40.680
to say, you have the choice in Askel to, never mind.

06:40.680 --> 06:46.880
I want just to point out that Rust, heavy-i, Rust culling convention, the cull convention

06:46.880 --> 06:52.240
I use Rust function inside the binary between the same, is unstable, which is things that

06:52.240 --> 07:02.200
exist in Askel 2, which is a way that Rust internal, the Rust core team, keep to be able

07:02.200 --> 07:10.880
to break the mechanism inside Rust C without changing the module version of the compiler.

07:10.880 --> 07:15.280
So for example, the culling convention changed several times in the stable version of the

07:15.280 --> 07:19.920
language, which is Rust 1.0 something.

07:19.920 --> 07:25.280
So if we build a thing on top of Rust, heavy-i, culling convention, keep memory layout, it

07:25.280 --> 07:27.800
will not be stable, it will be an hack.

07:27.800 --> 07:34.280
And so maintaining it will be really laborious because it's working with internal documentation

07:34.280 --> 07:39.320
which is not made for people to use it as a public API.

07:39.320 --> 07:49.760
And so, why Rust macro? I want also to point out that because there is a lot of way to

07:49.760 --> 07:54.440
do binding generation and often it work as an external tooling.

07:54.440 --> 08:00.200
And the issue with an external tooling, it's really easy to forget to integrate the external

08:00.200 --> 08:03.080
tooling into your build suite.

08:03.080 --> 08:11.120
And if you do that, your binding will be out of sync with your codes, so your program will

08:11.120 --> 08:12.120
not work.

08:12.120 --> 08:16.880
So we want binding generation to be part of the compilation.

08:16.880 --> 08:18.880
Create is a Rust module.

08:18.880 --> 08:22.600
And so I did it that way.

08:22.600 --> 08:28.840
And I also want to point out that there is other programming in Rust space, like C-bindgents

08:28.840 --> 08:34.240
are just try to integrate Rust code like search and replace.

08:34.240 --> 08:40.440
So if you, for example, in the long range, have two identifiers in different namespace,

08:40.440 --> 08:46.200
C-bindgents, that's a way to generate C-bindgents for Rust, will not be able to understand their

08:46.200 --> 08:47.200
meaning.

08:47.200 --> 08:50.920
So when they define the algorithm, it's part of the limitation of that library.

08:50.920 --> 08:56.640
It's not part of the bindgen library we present here that understands Rust semantics because

08:56.640 --> 08:59.840
it's implemented as a macro.

08:59.840 --> 09:06.760
And so it expands Rust code and it also generates as a set effect R-scale code and R-scale modules

09:06.760 --> 09:09.720
that just have the one-tied signature.

09:09.720 --> 09:17.240
So same symbol, same signature, things that's synced together.

09:17.240 --> 09:24.960
So if we relook the Rust code, there's another things I want to talk to you about here.

09:24.960 --> 09:29.960
You see you have the C compatible coding conversion type.

09:29.960 --> 09:38.880
The thing I want you to look at is I use trait, trait, rep C, trait, rep Rust, and that's

09:38.880 --> 09:40.440
trait are Rust type classes.

09:40.440 --> 09:44.120
That's a way to define contracts for data structure.

09:44.120 --> 09:48.440
You mean a data structure should implement this and this method.

09:48.440 --> 09:55.600
So I want every data structure that has this method would implement those internally, implemented

09:55.600 --> 10:01.240
as virtual table, like in C++.

10:01.240 --> 10:02.240
And why I use that?

10:02.240 --> 10:07.600
I use that to be extensive programmable.

10:07.600 --> 10:09.000
So I have nice error.

10:09.000 --> 10:11.360
It's part of Rust type system.

10:11.360 --> 10:15.400
Users can add types to this framework.

10:15.400 --> 10:20.280
And for the types, which is part of the standard library that I implement myself, I take care

10:20.280 --> 10:21.880
of the memory management.

10:21.880 --> 10:25.120
And we talk about it a bit later.

10:25.120 --> 10:32.440
And also the thing is in FFI, in Rust, you can use only what's called FFE safe types.

10:32.440 --> 10:37.680
It means types that have a memory layout in SQL in convention.

10:37.680 --> 10:43.240
And most of Rust type have undefined memory layout for SQL in convention.

10:43.240 --> 10:49.960
So the thing is, for example, if I get Rust strings, I cast it safely to a C string.

10:49.960 --> 10:55.440
So I could represent as C string works, which knows the way that Rust strings are actually

10:55.440 --> 10:58.480
represented.

10:58.480 --> 11:02.320
And so what about GC?

11:02.320 --> 11:09.320
The thing is Rust have a destructor mechanism based on ownership lifetime, a lot of rusty

11:09.320 --> 11:14.400
things, but the idea is more about destructor.

11:14.400 --> 11:20.320
When you go out of a scope, the destructor of the value is called, which is dropped.

11:20.320 --> 11:29.320
And so what I do here is I tell Rust type system does not call drop on Rust value because

11:29.320 --> 11:31.640
it will live on the Haskell side.

11:31.640 --> 11:40.120
So that's the other side of the bindings that need to free the value, which is similar to

11:40.120 --> 11:47.360
what you can do with March, I don't know how to pronounce that library.

11:47.360 --> 11:52.880
And the things is also I learned during this project, the real semantic of safe and then

11:52.880 --> 12:05.480
unsafe for a code definition, because I finally understand that unsafe means you want to play

12:05.480 --> 12:12.880
with any object on the Haskell heap, which is not the default case of what we actually

12:12.880 --> 12:16.280
do when we pass basic data typesets.

12:16.280 --> 12:26.720
It does not need the garbage collector to pause because it doesn't know if we could

12:26.720 --> 12:34.560
get an inconsistent state by something that the foreign code will do.

12:34.560 --> 12:42.120
And so if you use unsafe, you will have a warning that say a cautious, an unsafe code

12:42.120 --> 12:50.760
will slow down your war program or you want to do that or not, anything.

12:50.760 --> 12:57.680
And that's a library, a Rust library, but those are things I did.

12:57.680 --> 13:03.360
And that's also what exists for all of the Rust tooling is a key tool that helps you

13:03.360 --> 13:12.440
to set up a project because you have to tweak your Rust build file, you have to tweak your

13:12.440 --> 13:14.440
Rscale build file.

13:14.440 --> 13:20.440
Actually you have to do a set up that has built customization in Rscale unless you use

13:20.440 --> 13:28.560
Nix, which I could understand a lot of people who want to.

13:28.560 --> 13:35.240
And on Rust.ai I use build.rs if you do a dynamic library because dynamic library that

13:35.240 --> 13:41.760
JC fetch needs a JC version in the name of the dynamic library.

13:41.760 --> 13:47.120
So that's the things that I have to get as a build customization.

13:47.120 --> 13:53.640
This scan of tweak, but overall this library is really small.

13:53.640 --> 14:00.760
I'll put next slide just a few minutes later.

14:00.760 --> 14:07.440
The world library, the world tooling I present here is less than 1000 lines of code.

14:07.440 --> 14:13.020
So it's 1000 lines of code.

14:13.020 --> 14:23.040
So that's really small and minimalist and key.

14:23.040 --> 14:28.960
So actually I forget what I was about to say.

14:28.960 --> 14:39.320
Actually all of that of this plumber is simple and I'm not sure myself I want to make it

14:39.320 --> 14:42.720
more complex because it just works.

14:42.720 --> 14:46.960
And the thing is it works but it is really simple data types.

14:46.960 --> 14:52.720
The C data types that are representable in Rscale and Rust.

14:52.720 --> 14:57.760
And there is a lot of things that are not representable in C. For example, Rust slice.

14:57.760 --> 15:03.640
A slice is a pointer and a size and you have a guarantee that there is memory in it.

15:03.640 --> 15:05.600
You can iterate on it.

15:05.600 --> 15:10.560
You can represent it in C with a struct but it's not really a C type.

15:10.560 --> 15:14.320
You will do a custom struct.

15:14.320 --> 15:22.880
And those things are targeted by the Rust RFC which is an intramarable ABI which is

15:22.880 --> 15:31.640
creating an ABI which is stable which have more Rust things than the C ABI but which

15:31.640 --> 15:38.320
is flagged as stable which is not the case of the Rust internal ABI.

15:38.320 --> 15:44.640
And the other thing is CABAL customization is a bit of a mess.

15:44.640 --> 15:52.040
Doing this is a set up that has to find the library and anything to make it work because

15:52.040 --> 15:53.280
of CABAL bugs.

15:53.280 --> 16:01.160
So I will not have to have a standard way to integrate for example Rust and chain into

16:01.160 --> 16:02.560
CABAL.

16:02.560 --> 16:09.360
Here you have to run the total chain into different type.

16:09.360 --> 16:11.120
And that's it.

16:11.120 --> 16:17.240
I can throw a lot of questions or I can do a demo if I might talk in short hours and

16:17.240 --> 16:20.280
what I was expecting.

16:20.280 --> 16:24.080
So that's the day to ask questions.

16:24.080 --> 16:25.080
Yeah.

16:25.080 --> 16:35.960
Yeah I can do a quick demo.

16:35.960 --> 16:41.560
Sorry.

16:41.560 --> 16:46.760
It's not easy because it's not mirroring so I have to look at the screen YI.

16:46.760 --> 16:51.280
I'm doing this thing.

16:51.280 --> 16:55.320
What I can do.

16:55.320 --> 17:06.240
What I can do.

17:06.240 --> 17:14.560
Yeah.

17:14.560 --> 17:23.920
Did you.

17:23.920 --> 17:24.920
Yeah.

17:24.920 --> 17:34.800
So from what I understand you can pass from from Rust to Haskell the subset of data that

17:34.800 --> 17:37.880
is representable with the Rc.

17:37.880 --> 17:41.000
So you can't really pass functions for example.

17:41.000 --> 17:43.080
Or can you?

17:43.080 --> 17:48.880
It will be unsafe on the Haskell side if you do that for example because you will need

17:48.880 --> 17:50.880
to be.

17:50.880 --> 17:53.440
I is an interesting example.

17:53.440 --> 18:02.280
I didn't try passing a function pointer.

18:02.280 --> 18:09.520
The thing is there is the thing is you if you want to pass complex data types you it's

18:09.520 --> 18:16.920
always more meaningful to use serialization because it's it's it doesn't match the two

18:16.920 --> 18:28.240
language model but function I didn't honestly think about it but I you mean a function pointers

18:28.240 --> 18:30.400
that will cross if I buyer.

18:30.400 --> 18:33.440
So that's the whole question right.

18:33.440 --> 18:34.440
Yeah.

18:34.440 --> 18:35.440
Yeah.

18:35.440 --> 18:36.440
Yeah.

18:36.440 --> 18:41.160
So if you have no concept of sharing pointers you copy the whole data and it's made to the

18:41.160 --> 18:46.800
other node including function which are serialized and then read to present on the other node.

18:46.800 --> 18:58.960
I guess it will not not really be an issue because because in fact there's there's no

18:58.960 --> 19:07.640
really boundary at the end that's one binary so there's only things that I want my model

19:07.640 --> 19:16.160
to have a better grasp around it is all GC Haskell GC will behave in this case but I

19:16.160 --> 19:25.480
think there is no special issue for doing that but I think I should experiment on it

19:25.480 --> 19:30.280
first to to to before saying it's it's completely okay to do that.

19:30.280 --> 19:31.280
Yeah.

19:31.280 --> 19:33.280
Thank you for the question.

19:33.280 --> 19:34.280
Yeah.

19:34.280 --> 19:35.280
I.

19:35.280 --> 19:36.280
Did you see something.

19:36.280 --> 19:37.280
Fuck.

19:37.280 --> 19:58.160
So.

19:58.160 --> 20:07.200
Sorry.

20:07.200 --> 20:16.560
So if I go here for example I have a little rest things.

20:16.560 --> 20:18.560
SRC.

20:18.560 --> 20:21.060
Yeah.

20:21.060 --> 20:29.600
Can show you the lead the rest which do a cryptographic primitive for example and you

20:29.600 --> 20:38.560
what you manipulate is clearly rest types it's not C types and I have a warning and

20:38.560 --> 20:40.560
I don't know why.

20:40.560 --> 20:41.560
Yeah.

20:41.560 --> 20:50.840
Because I don't start first and if I do I guess it will work I hope so.

20:50.840 --> 20:58.800
I can check what's happened with after macro expansion.

20:58.800 --> 21:08.160
Did it work.

21:08.160 --> 21:11.200
Yeah.

21:11.200 --> 21:12.200
Sorry.

21:12.200 --> 21:14.200
demo effect.

21:14.200 --> 21:15.200
Yeah.

21:15.200 --> 21:16.200
Why.

21:16.200 --> 21:17.200
Fuck.

21:17.200 --> 21:27.000
Maybe the other one is locked.

21:27.000 --> 21:32.520
I don't know why you do that maybe I'm no internet connection and that's a so issue

21:32.520 --> 21:33.520
here.

21:33.520 --> 21:34.520
Yeah.

21:34.520 --> 21:36.720
I guess that's the issue.

21:36.720 --> 21:42.320
So never mind I can show you the ask and things generated.

21:42.320 --> 21:46.720
So no that's a cabal file generated by the client.

21:46.720 --> 21:51.400
And so I have.

21:51.400 --> 21:53.000
Looks like that.

21:53.000 --> 22:01.960
I have my my.

22:01.960 --> 22:10.200
What can I show you.

22:10.200 --> 22:14.400
I can show you the bleed customization can see what it looks like.

22:14.400 --> 22:16.240
Look like sit.

22:16.240 --> 22:22.600
It's not really interesting but you do few things.

22:22.600 --> 22:25.720
And what can I show you.

22:25.720 --> 22:31.840
I have a little file that's unsure that's a client you use to generate the wall stuff

22:31.840 --> 22:38.120
is compatible with a version of the library you use to do.

22:38.120 --> 22:41.600
I want to change the world behavior in the future.

22:41.600 --> 22:47.840
And now on the ask inside it looks something like that so I have a project I have a couple

22:47.840 --> 22:50.680
project right.

22:50.680 --> 22:54.800
It looks like that.

22:54.800 --> 23:02.920
And the test scene just work like.

23:02.920 --> 23:11.880
I have a test that couple.

23:11.880 --> 23:13.240
It looks like that.

23:13.240 --> 23:21.480
I can use it like it was normal ascal dependencies and my.

23:21.480 --> 23:23.960
Ask code.

23:23.960 --> 23:25.960
It's quite simple I guess.

23:25.960 --> 23:26.960
Yeah.

23:26.960 --> 23:31.960
Sorry fix me but don't look.

23:31.960 --> 23:32.960
Yeah.

23:32.960 --> 23:33.960
Yeah.

23:33.960 --> 23:36.960
You have something like that.

23:36.960 --> 23:46.040
It's always a bit you manipulate low level data structure but that's that's often what

23:46.040 --> 23:51.800
you want to do when you you you broke something in the system programming language.

23:51.800 --> 23:57.160
That's one reason to use rest over something else.

23:57.160 --> 24:00.240
Otherwise.

24:00.240 --> 24:08.040
I don't know I got the input that's the binding don't really need.

24:08.040 --> 24:10.480
Don't really need.

24:10.480 --> 24:15.520
More advanced data types for example ochamel have an interrupt ochamel interrupt things

24:15.520 --> 24:26.520
with rust that helps to represent a duty bus rust and ochamel and I don't know if we really

24:26.520 --> 24:33.960
need to have a duty conversion between languages for most of use case I don't know.

24:33.960 --> 24:34.960
Yeah.

24:34.960 --> 24:36.960
That's that's many.

24:36.960 --> 24:43.240
I don't know if you have other question or just curious about something.

24:43.240 --> 24:45.240
Or another.

24:45.240 --> 24:47.240
Yeah.

24:47.240 --> 24:52.160
Hey there's a question.

24:52.160 --> 24:59.760
So you said I want one that rest will not drop the value and that's to scale to three

24:59.760 --> 25:03.560
so how does that work?

25:03.560 --> 25:10.560
Is that under by the GVIPE I have a GC or does it need to be done manually?

25:10.560 --> 25:14.920
You mean I tell us to not drop a value?

25:14.920 --> 25:15.920
No.

25:15.920 --> 25:25.400
If we do rest doesn't drop the value who does is it the GVIPE or somewhere we need to add

25:25.400 --> 25:27.520
that in a program?

25:27.520 --> 25:28.520
Yeah.

25:28.520 --> 25:36.600
The idea is because it's part of the marshmold things we have to free it explicitly as I

25:36.600 --> 25:37.600
understand it.

25:37.600 --> 25:47.960
If we do not value with leaf maybe somebody could tell me if I mistaken the spot.

25:47.960 --> 25:54.440
It's really hard to debug what actually GC does.

25:54.440 --> 26:01.680
So far I didn't experiment so mention that but yeah the real thing is really that if

26:01.680 --> 26:09.200
you do not force Rust to not drop things it will because it's part of its type system

26:09.200 --> 26:17.840
it will pull code to free memory to free of the memory allocator you used straight into

26:17.840 --> 26:19.680
the code.

26:19.680 --> 26:25.760
Rust statically decide where to put allocation and release of memory inside the bin and binary

26:25.760 --> 26:33.760
computed statically at compile time so you have to tell the type system to not do it

26:33.760 --> 26:38.040
for specific types if there is an internals for that.

26:38.040 --> 26:48.920
But on the Haskell side I'm not sure I'm pretty sure that the GC will track it as a

26:48.920 --> 26:56.280
garbage collected object I think because you have to do it explicitly.

26:56.280 --> 27:08.400
That's one of the point I'm a bit unconfident so I want to check again this kind of scenario.

27:08.400 --> 27:12.440
Do you have a question?

27:12.440 --> 27:17.640
What do you do if there's an external Rust library that you don't have control over because

27:17.640 --> 27:23.040
they might not want to add HS bindgen macros to their code base?

27:23.040 --> 27:30.480
Is there a way of generating a shim or something?

27:30.480 --> 27:37.120
In fact it's really easy in Rust to do re-export so you can always create a new create, re-export

27:37.120 --> 27:43.040
a create as you say I depend on this create and re-export the thing I want to re-export

27:43.040 --> 27:47.880
and I decorate or not element.

27:47.880 --> 27:50.880
Yes it works.

27:50.880 --> 27:52.880
Sorry?

27:52.880 --> 27:59.520
Can you put those macros on the functions in the other library then?

27:59.520 --> 28:09.800
In fact it's just wrapping function by function so you can do whatever you want.

28:09.800 --> 28:16.240
And you can opt in or opt out some function of a library and some not which is to me is

28:16.240 --> 28:23.480
the advantage of using macro and function decorator over code, work code parsing.

28:23.480 --> 28:27.040
That's not free though is it?

28:27.040 --> 28:28.040
That's not?

28:28.040 --> 28:33.040
So if you're re-exporting functions but are you actually re-exporting the same function

28:33.040 --> 28:37.600
or are you exporting a wrapper around the re-exporation?

28:37.600 --> 28:49.320
Yeah but I, okay, I in Rust there is a clear idea of what symbol I want to expose and what

28:49.320 --> 28:55.520
symbol I don't want to expose so I'm pretty confident that the compiler has the library

28:55.520 --> 28:57.840
to inline or not things.

28:57.840 --> 29:02.840
So for example most of the trait implementation I do which is casting are inline.

29:02.840 --> 29:08.080
I explicitly say I want it to be inline and so yes it's a function that's called a function

29:08.080 --> 29:14.680
but at the end it's just, it's, have no runtime cost.

29:14.680 --> 29:15.680
So yeah.

29:15.680 --> 29:17.680
Okay, we're out of time.

29:17.680 --> 29:18.680
Thank you.

29:18.680 --> 29:19.680
So thanks very much Yvonne.

29:19.680 --> 29:20.680
Let's give him a round of applause.

29:20.680 --> 29:33.880
Thank you very much.
